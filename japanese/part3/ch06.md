# 圏論から見たモナド {#monads-categorically}

モナドについてプログラマーに話すと、おそらく作用について話すことになるだろう。だが、数学者にとってはモナドは代数に関するものだ。代数については後で話そう――代数はプログラミングにおいて重要な役割を果たす――まずは、代数とモナドとの関係について少し直観を得てもらおうと思う。さしあたっては、やや身振り手振りでの議論になるが、我慢してほしい。

代数とは式を作成・操作・評価することだ。式は演算子を使って組み立てられる。次の単純な式を考えてみよう：

$$x^2 + 2 x + 1$$

この式は$x$のような変数と$1$や$2$のような定数とを加算や乗算のような演算子で組み合わせて構成されている。プログラマーはよく式を木 (tree) と見なす。

`\begin{figure} \centering`{=latex}
![](images/exptree.png){width=30%}
`\end{figure}`{=latex}
\noindent
木はコンテナなので、より一般化すると、式は変数を格納するコンテナだと言える。圏論ではコンテナを自己関手として表す。型$a$を変数$x$に代入すると、式は型$m\ a$を持つことになる。ここで、$m$は式木を構成する自己関手だ。（非自明な分岐式は通常、再帰的に定義された自己関手を使って作成される。）

式に対して実行できる最もありふりた操作は何だろう？
それは置換だ。つまり、変数を式に置き換えることだ。たとえば、この例では$x$を$y-1$に置き換えて次のようにできる：

$$(y - 1)^2 + 2 (y - 1) + 1$$

何が起きたかというと、型$m\ a$の式を取って型$a \to m\ b$への変換を適用した（$b$は$y$の型を表す）。結果は型$m\ b$の式になる。はっきり書いてみよう：

$$m\ a \to (a \to m\ b) \to m\ b$$

そう、これはモナドにおけるbindのシグネチャーだ。

ちょっとしたモチベーションが得られた。さあ、モナドの計算に移ろう。数学者はプログラマーとは異なる表記法を用いる。自己関手には文字$T$を使い、`join`には$\mu$、`return`には$\eta$というギリシャ文字を使うのが好みだ。`join`も`return`も多相関数なので、自然変換に対応すると推測できる。

それゆえ、圏論では、モナドは自然変換$\mu$と$\eta$のペアを伴った自己関手$T$として定義される。

$\mu$は関手の平方$T^2$から$T$へ戻る自然変換だ。この平方は単に関手をそれ自身と$T \circ T$のように合成したものだ（このような平方は自己関手でしか行えない）：

$$\mu \Colon T^2 \to T$$

この自然変換の対象$a$における成分は次の射だ：

$$\mu_a \Colon T (T a) \to T a$$

これは、$\Hask$では、`join`の定義に直接変換される。

$\eta$は恒等関手$I$と$T$の間の自然変換だ：

$$\eta \Colon I \to T$$

対象$a$に対し$I$を作用させると単に$a$になるのを考慮すると、$\eta$の成分は次の射によって与えられる：

$$\eta_a \Colon a \to T a$$

これは`return`の定義に直接変換される。

これらの自然変換にはいくつか追加で満たすべき規則がある。1つの観点としては、これらの規則によって自己関手$T$に対してKleisli圏を定義できる。$a$と$b$の間のKleisli矢は射$a \to T b$として定義されることを思い出そう。2つのそのような矢の合成（ここでは下付き文字$T$を添えた円で記す）は$\mu$を使って実装できる：

$$g \circ_T f = \mu_c \circ (T g) \circ f$$

ただし：

$$
\begin{gathered}
f \Colon a \to T b \\
g \Colon b \to T c
\end{gathered}
$$

ここで$T$は関手であり、射$g$に適用できる。この式はHaskellの記法で理解した方が簡単だろう：

```haskell
f >=> g = join . fmap g . f
```

\noindent
あるいは、成分で表すとこうなる：

```haskell
(f >=> g) a = join (fmap g (f a))
```

\noindent
代数的に解釈すると、単に2つの連続した置換を合成しているだけだ。

Kleisli矢が圏を形成するには、それらの合成が結合性を持っていて、かつ$\eta_a$が$a$における恒等Kleisli矢であってほしい。この要件は$\mu$と$\eta$のモナド則に変換できる。しかし、これらの規則は、別の方法で導出すればもっとモノイド則に似て見えてくる。実際、$\mu$はしばしば*乗算* (multiplication) と呼ばれ、$\eta$は*単位* (unit) と呼ばれる。

大まかに言うと、結合律は、$T$の立方$T^3$を$T$に縮約するための2つの方法が同じ結果を与えなければならない、と述べている。また、左単位律と右単位律は、$\eta$が$T$に適用された後に$\mu$で縮約すると再び$T$が得られる、と述べている。

少しトリッキーなのは自然変換と関手を合成しているからだ。そこで水平合成について少し復習するのがよいだろう。たとえば、$T^3$は$T^2$の後に$T$を合成したものと見なせる。これに、次の2つの自然変換の水平合成を適用できる：

$$I_T \circ \mu$$

`\begin{figure} \centering`{=latex}
![](images/assoc1.png){width=40%}
`\end{figure}`{=latex}
\noindent
すると$T \circ T$が得られ、$\mu$を適用するとさらに$T$に縮約できる。$I_T$は$T$から$T$への恒等自然変換だ。このような水平合成$I_T \circ \mu$はよく$T \circ \mu$と短く表記される。この表記に曖昧さはない。なぜなら、ある関手を自然変換と合成するのは意味がなく、それゆえこの文脈では$T$は必ず$I_T$を意味するからだ。

（自己）関手圏${[}\cat{C}, \cat{C}{]}$に図式を描くこともできる。

`\begin{figure} \centering`{=latex}
![](images/assoc2.png){width=30%}
`\end{figure}`{=latex}
\noindent
あるいは、$T^3$を合成$T^2 \circ T$として扱い、$\mu \circ T$を適用してもよい。その結果も$T \circ T$として扱い、$\mu$をまた使って$T$に戻せる。これら2つの経路は同じ結果を生成する必要がある。

`\begin{figure} \centering`{=latex}
![](images/assoc.png){width=30%}
`\end{figure}`{=latex}
\noindent
同様に、$T$の後に恒等関手$I$を合成したものに対して水平合成$\eta \circ T$を適用して$T^2$が得られ、$\mu$を使って戻せる。その結果は恒等自然変換を$T$に直接適用したかのように同じになるはずだ。そして、同様のことが$T \circ \eta$にもあてはまると類推できる。

`\begin{figure} \centering`{=latex}
![](images/unitlawcomp-1.png){width=40%}
`\end{figure}`{=latex}
\noindent
Kleisli矢の合成が実際に圏の規則を満たすことをこれらの規則が保証するのは納得できるだろう。

モナドとモノイドの類似点は驚くべきものだ。どちらにも乗算$\mu$・単位$\eta$・結合律・単位律が存在する。しかし、我々のモノイドの定義は狭すぎて、モナドをモノイドとしては記述できない。そこで、モノイドの概念を一般化しよう。

## モノイダル圏

モノイドの従来の定義に戻ろう。それは二項演算と単位という特殊な要素を持つ集合だ。Haskellでは、これは型クラスとして表現できる：

```haskell
class Monoid m where
    mappend :: m -> m -> m
    mempty  :: m
```

\noindent
二項演算`mappend`は結合的かつ単位的 (unital) でなければならない（すなわち、単位`mempty`による乗算はno-opだ）。

Haskellでの`mappend`の定義はカリー化されていることに注意してほしい。これは`m`のすべての要素を次の関数に写すと解釈できる：

```haskell
mappend :: m -> (m -> m)
```

\noindent
この解釈こそがモノイドを単一対象圏として定義するもととなる。その単一対象圏の自己準同型 (endomorphism) である`(m -> m)`がモノイドの要素を表す。ただし、Haskellにはカリー化が組み込まれているので、乗算の別の定義から始めてもよい：

```haskell
mu :: (m, m) -> m
```

\noindent
ここで、カルテシアン積`(m, m)`は乗算されるペアの始域になる。

この定義は一般化への別の道を示唆する：カルテシアン積を圏論的な積に置き換えるというものだ。積が大域的に定義されている圏から始め、対象`m`を選択し、乗算を射として定義できる：

$$\mu \Colon m\times{}m \to m$$

ただし、問題が1つある：任意の圏では対象の内部を覗き見られないのに、どうすれば単位元を選択できるだろう？
そのためのトリックがある。要素選択が単集合からの関数と等価になる仕組みを覚えているだろうか？
Haskellでは、`mempty`の定義を次の関数に置き換えられた：

```haskell
eta :: () -> m
```

\noindent
単集合は$\Set$の終対象なので、終対象$t$を持つすべての圏にこの定義を一般化するのは自然だ：

$$\eta \Colon t \to m$$

これにより、要素について述べることなく単位「要素」を選べる。

以前モノイドを単一対象圏として定義したときとは違って、ここではモノイド則が自動的に満たされるわけではなく、それらを課す必要がある。しかし、それらを定式化するには、基礎となる圏論的な積そのもののモノイダル構造を確立しなければならない。まずはHaskellでモノイダル構造がどう機能するか思い出そう。

結合性から始める。Haskellでは、対応する等式的規則 (equational law) はこうなる：

```haskell
mu x (mu y z) = mu (mu x y) z
```

\noindent
これを他の圏に一般化する前に、関数（射）の等価性として書き直す必要がある。個々の変数に対する作用から離れた抽象化が必要だ――言い換えれば、ポイントフリー記法を使う必要がある。カルテシアン積は双関手だと分かっているので、左辺はこう書ける：

```haskell
(mu . bimap id mu)(x, (y, z))
```

\noindent
そして右辺はこうなる：

```haskell
(mu . bimap mu id)((x, y), z)
```

\noindent
これはほぼ希望どおりだ。残念ながら、厳密に言うとカルテシアン積には結合性がない――`(x, (y, z))`と`((x, y), z)`は異なる――ので、ポイントフリーでは書けない：

```haskell
mu . bimap id mu = mu . bimap mu id
```

\noindent
一方、ペアのネスト2つは同型だ。それらの間を変換する結合子 (associator) と呼ばれる可逆関数がある：

```haskell
alpha :: ((a, b), c) -> (a, (b, c))
alpha ((x, y), z) = (x, (y, z))
```

\noindent
結合子の助けを借りれば`mu`についての結合律をポイントフリーで書ける：

```haskell
mu . bimap id mu . alpha = mu . bimap mu id
```

\noindent
単位律にも同様のトリックを適用できる。新しい記法では次のような形式になる：

```haskell
mu (eta (), x) = x
mu (x, eta ()) = x
```

\noindent
これらは次のように書き直せる：

```haskell
(mu . bimap eta id) ((), x) = lambda ((), x)
(mu . bimap id eta) (x, ()) = rho (x, ())
```

\noindent
2つの同型射のうち`lambda`は左単位子 (left unitor) と呼ばれ、`rho`は右単位子 (right unitor) と呼ばれる。これらが示すのは、単位 `()` は同型を除いてカルテシアン積の恒等射であるという事実だ：

```haskell
lambda :: ((), a) -> a
lambda ((), x) = x
```

```haskell
rho :: (a, ()) -> a
rho (x, ()) = x
```

\noindent
したがって、ポイントフリー版の単位律は次のようになる：

```haskell
mu . bimap id eta = lambda
mu . bimap eta id = rho
```

\noindent
ここまでで、`mu`と`eta`についてのポイントフリーなモノイド則の定式化を、基礎となるカルテシアン積自体が型の圏におけるモノイダル乗算のように作用するという事実を用いて行った。ただし、留意すべき点として、カルテシアン積の結合律と単位律は同型を除いてのみ有効だ。

これらの規則は積と終対象を持つすべての圏に一般化できると分かった。圏論的な積は確かに同型を除いて結合的であり、同様に、同型を除いて終対象は単位だ。結合子と2つの単位子は自然同型だ。規則は可換図式で表せる。

`\begin{figure} \centering`{=latex}
![](images/assocmon.png){width=50%}
`\end{figure}`{=latex}
\noindent
積は双関手なので射のペアをリフトできることに注意してほしい――Haskellではそのために`bimap`が使われる。

ここで立ち止まって、圏論的な積と終対象を持つあらゆる圏においてモノイドを定義できる、と述べてよい。モノイド則を満たすような対象$m$と2つの射$\mu$と$\eta$を選択できるなら、モノイドが存在する。しかし、もっとうまくやれる。$\mu$と$\eta$について規則を定式化するために完全な圏論的な積は必要ない。積の定義は射影を使う普遍的構成によって行われるのを思い出してほしい。モノイド則の定式化では射影を一切使わなかった。

積ではないのに積のように振る舞う双関手は[テンソル積]{.keyword #tensor_product} (tensor product) と呼ばれ、中置演算子$\otimes$で表されることが多い。テンソル積の一般的な定義は少しトリッキーだが、気にしないでよい。ここでは単にその特性を列挙する――最も重要なのは同型を除いた結合性だ。

同様に、対象$t$が終対象である必要はない。それが終対象であるという特性――つまり、どの対象からも一意な射が存在すること――を使ったことはない。必要なのは、それがテンソル積とうまく協調して働くことだ。つまり、同型を除いてテンソル積の単位であってほしい。以上をまとめてみよう：

モノイダル圏$\cat{C}$はテンソル積と呼ばれる双関手を伴う：

$$\otimes \Colon \cat{C}\times{}\cat{C} \to \cat{C}$$

そして、単位対象と呼ばれる特定の対象$i$と、それぞれ結合子・左単位子・右単位子と呼ばれる3つの自然同型写像も伴う：

$$
\begin{aligned}
\alpha_{a b c} &\Colon (a \otimes b) \otimes c \to a \otimes (b \otimes c) \\
\lambda_a &\Colon i \otimes a \to a \\
\rho_a &\Colon a \otimes i \to a
\end{aligned}
$$

(テンソル四重積を単純化するためのコヒーレンス条件 (coherence condition) も存在する。)

重要なのは、よく知られた多くの双関手がテンソル積で記述できることだ。それは特に、積、余積、そしてすぐ後でみるように自己関手の合成（そしてDay convolutionのようなより深遠な積）に対して機能する。モノイダル圏は豊穣圏の定式化において不可欠な役割を果たすことになる。

## モノイダル圏におけるモノイド

モノイダル圏という、より一般的な設定を使ってモノイドを定義する準備が整った。対象$m$を選択することから始めよう。テンソル積を使えば$m$の冪を形成できる。$m$の平方は$m \otimes m$だ。$m$の立方を形成する方法は2つあるが、それらは結合子を通じて同型だ。より高次の$m$の冪についても同様だ（そこではコヒーレンス条件が必要になる）。モノイドを形成するには2つの射を選ぶ必要がある：

$$
\begin{aligned}
\mu &\Colon m \otimes m \to m \\
\eta &\Colon i \to m
\end{aligned}
$$

ここで、$i$はテンソル積の単位対象だ。

`\begin{figure} \centering`{=latex}
![](images/monoid-1.jpg){width=40%}
`\end{figure}`{=latex}
\noindent
これらの射は結合律および単位律を満たさなければならない。それらは以下の可換図式で表せる：

`\begin{figure} \centering`{=latex}
![](images/assoctensor.jpg){width=50%}
`\end{figure}`{=latex}
\noindent
`\begin{figure} \centering`{=latex}
![](images/unitmon.jpg){width=50%}
`\end{figure}`{=latex}
\noindent
テンソル積は必然的に双関手であることに注意してほしい。これは、$\mu \otimes \id$や$\eta \otimes \id$のような積を形成するには射のペアをリフトする必要があるからだ。これらの図式は、圏論的な積に関するこれまでの結果を直接的に一般化しているにすぎない。

## モノイドとしてのモナド

モノイダル構造は思いがけないところに現れる。その1つが関手圏だ。少し目を細めれば、関手の合成が積の生成に見えてくるだろう。問題は、2つの関手は合成できるとは限らないことだ――一方の終域圏が他方の始域圏でなければならない。これは射の合成の一般的な規則に他ならない――そして、すでに知っているとおり、関手はまさに圏$\Cat$内の射だ。ただし、自己射（同じ対象にループバックする射）と同様に自己関手も常に合成可能だ。任意の圏$\cat{C}$について、$\cat{C}$から$\cat{C}$への自己関手は関手圏${[}\cat{C}, \cat{C}{]}$を形成する。その対象は自己関手であり、射はそれらの間の自然変換だ。この圏から任意の2つの対象、たとえば自己関手$F$と$G$を取って、3番目の対象$F \circ G$――それらを合成した自己関手――を生成できる。

自己関手の合成はテンソル積の良い候補だろうか？
まず、それが双関手だと示さなければならない。それを使って射――ここでは自然変換――のペアをリフトできるだろうか？
テンソル積で`bimap`に相当するもののシグネチャーは次のようになるだろう：

$$\mathit{bimap} \Colon (a \to b) \to (c \to d) \to (a \otimes c \to b \otimes d)$$

対象を自己関手で、矢印を自然変換で、テンソル積を合成で置き換えると：

$$(F \to F') \to (G \to G') \to (F \circ G \to F' \circ G')$$

となり、水平合成の特殊なケースだと認識してよい。

`\begin{figure} \centering`{=latex}
![](images/horizcomp.png){width=40%}
`\end{figure}`{=latex}
\noindent
また、恒等自己関手$I$も存在し、自由に使える。これは自己関手の合成――新しいテンソル積――の恒等射として機能する。そのうえ、関手の合成は結合的だ。事実、結合律と単位律は厳密だ――結合子や2つの単位子は必要ない。したがって、自己関手は関手合成をテンソル積として伴う厳密なモノイダル圏を形成する。

この圏でのモノイドとは何だろう？
それは対象――自己関手$T$と、2つの射――自然変換だ：

$$
\begin{gathered}
\mu \Colon T \circ T \to T \\
\eta \Colon I \to T
\end{gathered}
$$

それだけでなく、モノイド則もある：

`\begin{figure} \centering`{=latex}
![](images/assoc.png){width=40%}
`\end{figure}`{=latex}
\noindent
`\begin{figure} \centering`{=latex}
![](images/unitlawcomp.png){width=50%}
`\end{figure}`{=latex}
\noindent
これらはいままで見てきたモナド則そのものだ。これでソーンダーズ・マックレーンの有名な引用が理解できるだろう：

> 端的に言えば、モナドは自己関手からなる圏におけるモノイドに他ならない。

これが関数プログラミングのカンファレンスのTシャツにプリントされているのを見たことがあるかもしれない。

## 随伴に基づくモナド

[随伴](#adjunctions)$L \dashv R$は2つの圏$\cat{C}$と$\cat{D}$の間を行き来する一対の関手だ。それらを合成する方法は2つあり、2つの自己関手$R \circ L$と$L \circ R$が生じる。随伴によると、これらの自己関手は単位と余単位と呼ばれる2つの自然変換を通じて恒等関手と関係している：

$$
\begin{gathered}
\eta \Colon I_{\cat{D}} \to R \circ L \\
\varepsilon \Colon L \circ R \to I_{\cat{C}}
\end{gathered}
$$

すぐ分かるとおり、随伴の単位はモナドの単位にそっくりだ。自己関手$R \circ L$は実際にモナドなのが分かる。必要なのは、$\eta$に対応する適切な$\mu$を定義することだけだ。これは自己関手の正方図式と自己関手自体との間の自然変換であり、随伴関手では次のように表される：

$$R \circ L \circ R \circ L \to R \circ L$$

そして、実際、余単位を使えば真ん中の$L \circ R$を潰せる。$\mu$の実際の式は水平合成で与えられる：

$$\mu = R \circ \varepsilon \circ L$$

モナド則は、随伴の単位と余単位によって満たされた恒等律 (identity law) と、交換律から導かれる。

随伴から派生したモナドをHaskellであまり見かけないのは、随伴には通常2つの圏が関わるからだ。ただし、冪すなわち関数対象の定義は例外だ。この随伴は次の2つの自己関手から形成される：

$$
\begin{gathered}
L z = z\times{}s \\
R b = s \Rightarrow b
\end{gathered}
$$

これらを合成するとお馴染みのstateモナドになるのが分かるだろう：

$$R (L z) = s \Rightarrow (z\times{}s)$$

このモナドは以前Haskellで見たことがある：

```haskell
newtype State s a = State (s -> (a, s))
```

\noindent
もとの随伴もHaskellに翻訳してみよう。左関手は積関手だ：

```haskell
newtype Prod s a = Prod (a, s)
```

\noindent
そして右関手はreader関手だ：

```haskell
newtype Reader s a = Reader (s -> a)
```

\noindent
これらは随伴を形成する：

```haskell
instance Adjunction (Prod s) (Reader s) where
  counit (Prod (Reader f, s)) = f s
  unit a = Reader (\s -> Prod (a, s))
```

\noindent
積関手の後にreader関手を合成したものが実際にstate関手と等価なのは簡単に納得できる：

```haskell
newtype State s a = State (s -> (a, s))
```

\noindent
予想どおり、随伴の`unit`はstateモナドの`return`関数と等価だ。`counit`は、引数に作用する関数を評価することによって作用する。これは`runState`関数の非カリー化版と見なせる。

```haskell
runState :: State s a -> s -> (a, s)
runState (State f) s = f s
```

\noindent
（非カリー化する理由は、`counit`でペアに作用するからだ）。

ここでstateモナドの`join`を自然変換$\mu$の成分として定義できる。そのためには3つの自然変換を水平合成したものが必要だ：

$$\mu = R \circ \varepsilon \circ L$$

言い換えると、余単位$\varepsilon$をreader関手の1つのレベルに忍び込ませる必要がある。単に`fmap`を直接呼び出すことはできない。なぜなら、コンパイラーが`Reader`関手のものではなく`State`関手のものを選択するだろうからだ。だが、reader関手の`fmap`は左関数合成にすぎないことを思い出してほしい。そのため、関数合成を直接使うことにする。

まず、データコンストラクター`State`を切り離すことで`State`関手内の関数を公開する必要がある。これは`runState`を使って行われる。

```haskell
ssa :: State s (State s a)
runState ssa :: s -> (State s a, s)
```

\noindent
次に、`uncurry runState`によって定義される余単位に左合成する。最後に、`State`データコンストラクターに戻す：

```haskell
join :: State s (State s a) -> State s a
join ssa = State (uncurry runState . runState ssa)
```

\noindent
これはまさに`State`モナドのための`join`の実装だ。

あらゆる随伴からモナドが生じるだけでなく、逆もまた真だと分かる：あらゆるモナドは随伴関手2つの合成に分解できる。ただし、そのような分解は一意ではない。

もう1つの自己関手$L \circ R$については次章で述べる。
