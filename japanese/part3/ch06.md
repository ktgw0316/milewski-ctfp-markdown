# 圏論から見たモナド {#monads-categorically}

モナドについてプログラマーに話すなら、おそらく計算効果について話すことになるだろう。だが、数学者にとってはモナドは代数に関するものだ。代数については後で話そう――代数はプログラミングにおいて重要な役割を果たす――まずは、代数とモナドとの関係について少し直観を得てもらおうと思う。さしあたっては、やや大雑把な議論になるが、ご容赦願いたい。

代数とは式を作成・操作・評価することだ。式は演算子を使って組み立てられる。次の単純な式を考えてみよう：
$$x^2 + 2 x + 1$$
この式は$x$のような変数と$1$や$2$のような定数とを加算や乗算のような演算子で組み合わせて構成されている。プログラマーはよく式を木と見なす。

`\begin{figure}[H] \centering`{=latex}
![](images/exptree.png){width=30%}
`\end{figure}`{=latex}

\noindent
木はコンテナーなので、より一般化すると、式は変数を格納するコンテナーだと言える。圏論ではコンテナーを自己関手として表す。型$a$を変数$x$に割り振ると、式は型$m\ a$を持つことになる。ここで、$m$は式木を構成する自己関手だ。（非自明な枝分かれした式は通常、再帰的に定義された自己関手を使って作成される。）

式に対して実行できる最も共通した操作は何だろう？　それは代入だ。つまり、変数を式に置き換えることだ。たとえば、この例では$x$を$y-1$に置き換えて次のようにできる：
$$(y - 1)^2 + 2 (y - 1) + 1$$
何が起きたかというと、型$m\ a$の式を取って型$a \to m\ b$への変換を適用した（$b$は$y$の型を表す）。結果は型$m\ b$の式になる。はっきり書いてみよう：
$$m\ a \to (a \to m\ b) \to m\ b$$
そう、これはモナドにおけるbindのシグネチャーだ。

ちょっとしたモチベーションが得られた。では、モナドについての数学に取り掛かろう。数学者はプログラマーとは異なる表記法を用いる。自己関手には文字$T$を、自然変換にはギリシャ文字を使うのが好みだ。ここでは、`join`には$\mu$、`return`には$\eta$を使う。
`join`も`return`も多相関数なので、自然変換に対応していると見当がつく。

それゆえ、圏論では、モナドは自然変換$\mu$と$\eta$のペアを伴った自己関手$T$として定義される。

$\mu$は関手の二乗$T^2$から$T$へ戻る自然変換だ。この二乗は単に関手をそれ自身と合成したもの、つまり$T \circ T$だ（このような二乗は自己関手でしか行えない）：
$$\mu \Colon T^2 \to T$$
この自然変換の対象$a$における成分は次の射だ：
$$\mu_a \Colon T (T a) \to T a$$
これは、$\Hask$では、`join`の定義に直接対応する。

$\eta$は恒等関手$I$と自己関手$T$の間の自然変換だ：
$$\eta \Colon I \to T$$
対象$a$に対し$I$を作用させると単に$a$になるのを考慮すると、$\eta$の成分は次の射によって与えられる：
$$\eta_a \Colon a \to T a$$
これは`return`の定義に直接対応する。

これらの自然変換にはいくつか追加で満たすべき規則がある。1つの観点としては、そうした追加の規則は自己関手$T$についてのクライスリ圏を定義するのに十分なものだ、ということだ。$a$と$b$の間のクライスリ射は射$a \to T b$として定義されたことを思い出そう。そのような2つの射の合成（ここでは下付き文字$T$を添えた円で記す）は$\mu$を使って実装できる：
$$g \circ_T f = \mu_c \circ (T g) \circ f$$
ただし：
$$
\begin{gathered}
f \Colon a \to T b \\
g \Colon b \to T c
\end{gathered}
$$
ここで$T$は関手であるため、射$g$に適用できる。この式はHaskellの記法で理解した方が簡単かもしれない：

```haskell
f >=> g = join . fmap g . f
```

\noindent
あるいは、成分で表すとこうなる：

```haskell
(f >=> g) a = join (fmap g (f a))
```

\noindent
代数的に解釈すると、単に2つの連続した代入を合成しているだけだ。

クライスリ射が圏をなすために、それらの合成が結合性を持っていて、かつ$\eta_a$が$a$における恒等クライスリ射であってほしい。$\mu$と$\eta$に対するモナド則は、この要件を翻訳することで得られる。しかし、これらの規則は別の方法で導出することでもっとモノイド則に似て見えてくるのだ。実際、$\mu$はしばしば*乗算* (multiplication) と呼ばれ、$\eta$は*単位* (unit) と呼ばれる。

大まかに言うと、結合律は、$T$の三乗$T^3$を$T$に簡約するための2つの方法が同じ結果を与えなければならないことを述べている。また、左単位律と右単位律は、$\eta$が$T$に適用された後に$\mu$で簡約すると再び$T$が得られることを述べている。

少しトリッキーなのは自然変換と関手を合成しているからだ。そこで水平合成について少し復習するのがよいだろう。たとえば、$T^3$は$T$を$T^2$の後に合成したものと見なせる。これに、次の2つの自然変換の水平合成を適用できる：
$$I_T \circ \mu$$

`\begin{figure}[H] \centering`{=latex}
![](images/assoc1.png){width=40%}
`\end{figure}`{=latex}

\noindent
すると$T \circ T$が得られ、$\mu$を適用するとさらに$T$に簡約できる。ここで$I_T$は$T$から$T$への恒等自然変換だ。このような水平合成$I_T \circ \mu$はよく$T \circ \mu$と短く表記される。この表記に曖昧さはない。なぜなら、関手を自然変換と合成するのは意味がなく、それゆえこの文脈では$T$は$I_T$を意味するに違いないからだ。

（自己）関手圏${[}\cat{C}, \cat{C}{]}$における図式を描くこともできる：

`\begin{figure}[H] \centering`{=latex}
![](images/assoc2.png){width=30%}
`\end{figure}`{=latex}

\noindent
また別の簡約法として、$T^3$を合成$T^2 \circ T$として扱い、$\mu \circ T$を適用してもよい。その結果も$T \circ T$となるので、今回も$\mu$を使って$T$に戻せる。これら2つの経路のどちらにおいても同じ結果が得られるようになっていてほしい。

`\begin{figure}[H] \centering`{=latex}
![](images/assoc.png){width=30%}
`\end{figure}`{=latex}

\noindent
同様に、恒等関手$I$を$T$の後に合成したものに対して水平合成$\eta \circ T$を適用して$T^2$が得られ、その後で$\mu$を使って簡約できる。その結果は恒等自然変換を$T$に直接適用したのと同じになってほしい。そして、類推から、同様のことが$T \circ \eta$にも当てはまってほしい。

`\begin{figure}[H] \centering`{=latex}
![](images/unitlawcomp-1.png){width=40%}
`\end{figure}`{=latex}

\noindent
これらの規則から、クライスリ射の合成が実際に圏の規則を満たすことを確かめてみるとよい。

モナドとモノイドの類似点は驚異的だ。どちらにも乗算$\mu$・単位$\eta$・結合律・単位律が存在する。しかし、我々のモノイドの定義は狭すぎて、モナドをモノイドとしては記述できない。そこで、モノイドの概念を一般化しよう。

## モノイダル圏

モノイドの従来の定義に戻ろう。それは二項演算および、単位という特別な要素を持つ集合だった。Haskellでは、このことを型クラスとして表現できる：

```haskell
class Monoid m where
    mappend :: m -> m -> m
    mempty  :: m
```

\noindent
二項演算`mappend`は結合的かつ単位的 (unital) でなければならない（すなわち、単位`mempty`を乗算することはno-opとなる）。

Haskellでの`mappend`の定義はカリー化されていることに注意してほしい。つまり、`mappend`は`m`のどの要素も関数に写せると解釈できる。すなわち：

```haskell
mappend :: m -> (m -> m)
```

\noindent
この解釈こそが、モノイドを、自己射 (endomorphism) `(m -> m)` がモノイドの要素を表すような単一対象圏として定義するもととなるものだった。ただし、Haskellにはカリー化が組み込まれているので、乗算の別の定義から始めてもよかったはずだ：

```haskell
mu :: (m, m) -> m
```

\noindent
ここで、デカルト積`(m, m)`は乗算されるペアの域になる。

この定義は一般化への別の道を示唆する：デカルト積を圏論的な積に置き換えるというものだ。積が大域的に定義されている圏から始め、対象`m`を選択し、乗算を射として定義できるかもしれない：
$$\mu \Colon m\times{}m \to m$$
ただし、問題が1つある：任意の圏で対象の内部を覗き見られるわけではないのに、どうすれば単位元を選び取れるだろう？　そのためのトリックがある。要素の選択が単元集合からの関数と等価であったことを覚えているだろうか？　Haskellで言うと、`mempty`の定義を次の関数に置き換えられてもよかったはずだ：

```haskell
eta :: () -> m
```

\noindent
単元集合は$\Set$の終対象なので、終対象$t$を持つすべての圏にこの定義を一般化するのは自然だ：
$$\eta \Colon t \to m$$
これにより、要素について述べることなく単位「要素」を選べる。

以前モノイドを単一対象圏として定義したときとは違って、ここではモノイド則が自動的に満たされるわけではなく、それらを課す必要がある。しかし、それらを定式化するには、基礎となる圏論的な積そのもののモノイドの構造を確立しなければならない。まずはHaskellでモノイドの構造がどのようになっていたか思い出していこう。

まずは結合性から見ていこう。Haskellでは、対応する等式規則 (equational law) は次のように書ける：

```haskell
mu x (mu y z) = mu (mu x y) z
```

\noindent
この等式を他の圏に一般化する前に、関数（射）の等しさの形で書き直す必要がある。抽象化により個々の変数に対する作用から離れる必要がある――言い換えれば、ポイントフリー記法を使う必要がある。デカルト積は双関手だと分かっているので、左辺は次のように書き直せる：

```haskell
(mu . bimap id mu)(x, (y, z))
```

\noindent
そして右辺は次のように書ける：

```haskell
(mu . bimap mu id)((x, y), z)
```

\noindent
これはほぼ希望どおりだ。残念ながら、デカルト積には厳密 (strict) な結合性がない――`(x, (y, z))`と`((x, y), z)`は異なる――ので、次のようにポイントフリーでは書けない：

```haskell
mu . bimap id mu = mu . bimap mu id
```

\noindent
一方、この2つのペアのネストの仕方同士は同型だ。それらの間を変換する結合律子 (associator) と呼ばれる可逆関数がある：

```haskell
alpha :: ((a, b), c) -> (a, (b, c))
alpha ((x, y), z) = (x, (y, z))
```

\noindent
結合律子の助けを借りれば`mu`についての結合律をポイントフリーで書ける：

```haskell
mu . bimap id mu . alpha = mu . bimap mu id
```

\noindent
単位律にも同様のトリックを適用できる。新しい記法では次のような形式になる：

```haskell
mu (eta (), x) = x
mu (x, eta ()) = x
```

\noindent
これらは次のように書き直せる：

```haskell
(mu . bimap eta id) ((), x) = lambda ((), x)
(mu . bimap id eta) (x, ()) = rho (x, ())
```

\noindent
2つの同型射のうち`lambda`は左単位律子 (left unitor) と呼ばれ、`rho`は右単位律子 (right unitor) と呼ばれる。これらが示すのは、単位 `()` は同型を除いてデカルト積の単位元であるという事実だ：

```haskell
lambda :: ((), a) -> a
lambda ((), x) = x
```

```haskell
rho :: (a, ()) -> a
rho (x, ()) = x
```

\noindent
したがって、ポイントフリー版の単位律は次のようになる：

```haskell
mu . bimap id eta = lambda
mu . bimap eta id = rho
```

\noindent
ここまでで、`mu`と`eta`についてのポイントフリーなモノイド則の定式化を、基礎となるデカルト積自体が型の圏におけるモノイド的な乗算のように作用するという事実を用いて行った。ただし、留意すべき点として、デカルト積の結合律と単位律は同型を除いてのみ成り立つ。

実は、これらの規則は積と終対象を持つすべての圏に一般化できる。圏論的な積は確かに同型を除いて結合的であり、同様に、同型を除いて終対象は単位だ。結合律子と2つの単位律子は自然同型だ。それらについての規則は可換図式で表せる。

`\begin{figure}[H] \centering`{=latex}
![](images/assocmon.png){width=50%}
`\end{figure}`{=latex}

\noindent
積は双関手なので射のペアを持ち上げられることに注意してほしい――Haskellではそのために`bimap`が使われる。

ここで議論を打ち切って、圏論的な積と終対象を持つあらゆる圏においてモノイドを定義できると述べることもできるかもしれない。つまり、モノイド則を満たすような対象$m$と2つの射$\mu$と$\eta$を選択できるなら、モノイドが存在する、と。しかし、もっとうまくやれる。$\mu$と$\eta$について規則を定式化するために完全な圏論的な積は必要ない。積の定義は射影を使った普遍的構成によって行われていたのを思い出してほしい。その一方でモノイド則の定式化では射影を一切使わなかった。

積ではないものの積のように振る舞う双関手は[*テンソル積*]{.keyword #tensor_product}\index{テンソル積} (tensor product) と呼ばれ^[訳注：モノイダル圏に伴うテンソル積はモノイダル積 (monoidal product) とも呼ばれる。]、中置演算子$\otimes$で表されることが多い。テンソル積の一般的な定義は少しトリッキーだが、気にしないでよい。ここでは単にその性質を列挙する――最も重要なのは同型を除いた結合性だ。

同様に、対象$t$が終対象である必要はない。それが終対象であるという性質――つまり、どの対象からも一意な射が存在すること――を使いはしなかった。必要なのは、それがテンソル積とうまく協調して働くことだ。つまり、同型を除いてテンソル積の単位であってほしい。以上をまとめてみよう：

モノイダル圏$\cat{C}$はテンソル積と呼ばれる双関手：
$$\otimes \Colon \cat{C}\times{}\cat{C} \to \cat{C}$$
および、単位対象と呼ばれる特定の対象$i$と、それぞれ結合律子・左単位律子・右単位律子と呼ばれる3つの自然同型写像：
$$
\begin{aligned}
\alpha_{a b c} &\Colon (a \otimes b) \otimes c \to a \otimes (b \otimes c) \\
\lambda_a &\Colon i \otimes a \to a \\
\rho_a &\Colon a \otimes i \to a
\end{aligned}
$$
を備えた圏だ（上記に加えて四項のテンソル積を単純化するためのコヒーレンス条件 (coherence condition) も存在する^[訳注：第28章2節の五角図式を参照。]。）

重要なのは、よく知られた多くの双関手がテンソル積として記述できることだ。特に、積、余積、そしてすぐ後でみるように自己関手の合成（そしてDay convolutionのようなより深遠な積）がそのような例だ。そして、モノイダル圏は豊穣圏の定式化において不可欠な役割を果たすことになる。

## モノイダル圏におけるモノイド

さて、モノイダル圏という、より一般的な設定においてモノイドを定義する準備が整った。対象$m$を選択することから始める。ここで、テンソル積を使えば$m$の冪を形成できる。$m$の二乗は$m \otimes m$だ。$m$の三乗を形成する方法は2つあるが、それらは結合律子を通じて同型だ。より高次の$m$の冪についても同様だ（そこではコヒーレンス条件が必要になる）。モノイドをなすには2つの射を選ぶ必要がある：
$$
\begin{aligned}
\mu &\Colon m \otimes m \to m \\
\eta &\Colon i \to m
\end{aligned}
$$
ここで、$i$はテンソル積の単位対象だ。

`\begin{figure}[H] \centering`{=latex}
![](images/monoid-1.jpg){width=40%}
`\end{figure}`{=latex}

\noindent
これらの射は結合律および単位律を満たさなければならない。それらは以下の可換図式で表せる：

`\begin{figure}[H] \centering`{=latex}
![](images/assoctensor.jpg){width=50%}
`\end{figure}`{=latex}

`\begin{figure}[H] \centering`{=latex}
![](images/unitmon.jpg){width=50%}
`\end{figure}`{=latex}

\noindent
ここではテンソル積が双関手であることが極めて重要だ。それは、積を作るには$\mu \otimes \id$や$\eta \otimes \id$のように射のペアを持ち上げる必要があるからだ。これらの図式は、圏論的な積に関するこれまでの結果の直截の一般化にすぎない。

## モノイドとしてのモナド

モノイドの構造は思いがけないところに現れる。その1つが関手圏だ。少し目を細めれば、関手の合成が積の一種に見えてくるだろう。問題は、2つの関手は合成できるとは限らないことだ――一方にとっての行き先となる圏が他方にとってのもととなる圏でなければならない。これは射の合成についてのいつもの規則に他ならない――そして、すでに知っているとおり、関手はまさに圏$\Cat$内の射だった。ただし、自己射（同じ対象にループバックする射）と同様に自己関手も常に合成可能だ。任意の圏$\cat{C}$について、$\cat{C}$から$\cat{C}$への自己関手は関手圏${[}\cat{C}, \cat{C}{]}$をなす。その対象は自己関手であり、射はそれらの間の自然変換だ。この圏から任意の2つの対象（自己関手$F$と$G$とする）を選び、もうひとつの対象$F \circ G$――それらを合成した自己関手――を得られる。

自己関手の合成はテンソル積の良い候補だろうか？　まず、それが双関手だと示さなければならない。それを使って射――ここでは自然変換――のペアを持ち上げられるだろうか？　テンソル積について`bimap`に相当するもののシグネチャーは次のようになるだろう：
$$\mathit{bimap} \Colon (a \to b) \to (c \to d) \to (a \otimes c \to b \otimes d)$$
対象を自己関手で、矢印を自然変換で、テンソル積を合成で置き換えると次が得られる：
$$(F \to F') \to (G \to G') \to (F \circ G \to F' \circ G')$$
これは、水平合成の特殊なケースだと見なせる。

`\begin{figure}[H] \centering`{=latex}
![](images/horizcomp.png){width=40%}
`\end{figure}`{=latex}

\noindent
また、恒等自己関手$I$も自由に使える。これは自己関手の合成――新しいテンソル積――の単位として機能する。そのうえ、関手の合成は結合的だ。事実、結合律と単位律は厳密だ――結合律子や2つの単位律子は必要ない。したがって、自己関手は関手合成をテンソル積として伴う厳密モノイダル圏をなす。

この圏でのモノイドとは何だろう？　それは対象――自己関手$T$と、次のような2つの射――自然変換だ：
$$
\begin{gathered}
\mu \Colon T \circ T \to T \\
\eta \Colon I \to T
\end{gathered}
$$
それだけでなく、モノイド則もある：

`\begin{figure}[H] \centering`{=latex}
![](images/assoc.png){width=40%}
`\end{figure}`{=latex}

`\begin{figure}[H] \centering`{=latex}
![](images/unitlawcomp.png){width=50%}
`\end{figure}`{=latex}

\noindent
これらはいままで見てきたモナド則そのものだ。これでソーンダーズ・マックレーンの有名な言葉^[訳注：『圏論の基礎』第VI章1節から一部を略して引用。]が理解できるだろう：

> 端的に言えば、モナドは自己関手からなる圏におけるモノイドに他ならない。

これが関数プログラミングのカンファレンスでTシャツにプリントされているのを見たことがあるかもしれない。

## 随伴に基づくモナド

[随伴](#adjunctions)$L \dashv R$（第18章を参照）は2つの圏$\cat{C}$と$\cat{D}$の間を行き来する一対の関手だ。それらを合成する方法は2つあり、それぞれ2つの自己関手$R \circ L$と$L \circ R$が得られる。随伴の定義によると、これらの自己関手は単位と余単位と呼ばれる2つの自然変換を通じて恒等関手と関係している：
$$
\begin{gathered}
\eta \Colon I_{\cat{D}} \to R \circ L \\
\varepsilon \Colon L \circ R \to I_{\cat{C}}
\end{gathered}
$$
すぐに、随伴の単位はモナドの単位にそっくりだということが見て取れる。実は、自己関手$R \circ L$は本当にモナドなのだ。必要なのは、あとは$\eta$に対応する適切な$\mu$を定義することだけだ。これは自己関手の二乗と自己関手自体との間の自然変換であり、随伴関手の言葉で書くと次のように表される：
$$R \circ L \circ R \circ L \to R \circ L$$
そして、実際、余単位を使えば真ん中の$L \circ R$を潰せる。正確には$\mu$は水平合成で与えられる：
$$\mu = R \circ \varepsilon \circ L$$
モナド則は、随伴の単位と余単位が満たす恒等図式^[訳注：第18章1節の三角恒等式を参照。]と、
相互交換法則^[訳注：第10章4節の後半を参照。]から導かれる。

随伴から派生したモナドをHaskellであまり見かけないのは、随伴には通常2つの圏が関わるからだ。ただし、冪すなわち関数対象の定義は例外だ。この随伴は次の2つの自己関手から形成される：
$$
\begin{gathered}
L z = z\times{}s \\
R b = s \Rightarrow b
\end{gathered}
$$
これらを合成するとお馴染みのstateモナドになるのが分かるだろう：
$$R (L z) = s \Rightarrow (z\times{}s)$$
このモナドは以前Haskellで見たことがある：

```haskell
newtype State s a = State (s -> (a, s))
```

\noindent
もとの随伴もHaskellに翻訳してみよう。左関手は積関手だ：

```haskell
newtype Prod s a = Prod (a, s)
```

\noindent
そして右関手はreader関手だ：

```haskell
newtype Reader s a = Reader (s -> a)
```

\noindent
これらは随伴をなす：

```haskell
instance Adjunction (Prod s) (Reader s) where
  counit (Prod (Reader f, s)) = f s
  unit a = Reader (\s -> Prod (a, s))
```

\noindent
ここで、reader関手を積関手の後に合成したものが実際にstate関手と等価なのは簡単に確認できる：

```haskell
newtype State s a = State (s -> (a, s))
```

\noindent
予想どおり、随伴の`unit`はstateモナドの`return`関数と等価だ。また、`counit`は、その引数に作用する関数を評価することによって作用する^[訳注：`f`は`counit`の引数`s`に作用する関数であり、それを評価することで`a`の値を得る、というのが`counit`の作用。]。これは、`runState`関数：

```haskell
runState :: State s a -> s -> (a, s)
runState (State f) s = f s
```

\noindent
の非カリー化版として認識可能だ[^runstate]（非カリー化する理由は、`counit`はペアに作用するからだ）。

[^runstate]: 訳注：型構成子を取り払うと`counit :: (s -> a, s) -> a`と`uncurry runState :: (s -> (a, s), s) -> (a, s)`となり、`uncurry runstate`は`counit`のインスタンスだと見なせる。このインスタンスは後述の$\varepsilon \circ L$に対応しているので、$\mu$の構成についての議論にはこちらを用いるので十分である。

ここでstateモナドの`join`を自然変換$\mu$の成分として定義できる。そのためには3つの自然変換を水平合成したものが必要だ：
$$\mu = R \circ \varepsilon \circ L$$
言い換えると、余単位$\varepsilon$をreader関手を1レベル超えて忍び込ませる必要がある。単に`fmap`を直接呼び出すことはできない。なぜなら、コンパイラーが`Reader`関手のものではなく`State`関手のものを選択するだろうからだ。だが、reader関手の`fmap`は左関数合成にすぎないことを思い出してほしい。そのため、関数合成を直接使うことにする。

まず、データ構成子`State`を一皮剥くことで`State`関手内の関数をあらわにする必要がある。これは`runState`を使えばできる。

```haskell
ssa :: State s (State s a)
runState ssa :: s -> (State s a, s)
```

\noindent
次に、`uncurry runState`によって定義される余単位に左合成する。最後に、`State`データ構成子で包み直す：

```haskell
join :: State s (State s a) -> State s a
join ssa = State (uncurry runState . runState ssa)
```

\noindent
これはまさに`State`モナドのための`join`の実装だ[^state-join]。

[^state-join]:
    訳注：$\mu = R \circ \varepsilon \circ L$とは以下のように対応している。

    - `runState ssa`は左関手$L$が`T(T x)` の内側の`T`を適用する部分
    - `uncurry runState`は随伴の余単位$\varepsilon$
    - `State (...)` は右関手$R$が最終結果を`T x`の形に整える部分

実は、あらゆる随伴からモナドが生じるだけでなく、逆もまた真だ：あらゆるモナドは随伴関手2つの合成に分解できる。ただし、そのような分解は一意ではない。

もう一方の自己関手$L \circ R$については次章で述べる。
