# Lawvere理論

最近では、モナドに言及せずに関数型プログラミングについて語ることはできない。しかし、Eugenio MoggiがモナドではなくLawvere理論に着目した並行宇宙も、可能性としては存在する。その宇宙を探検しよう。

## 普遍代数

代数を様々な抽象レベルで記述する方法はたくさんある。モノイド・群・環などを記述するための汎用言語を見つけたい。最も単純なレベルでは、これらのすべての構造は、集合の要素に対する*演算*と、これらの演算によって満たされなければならないいくつかの*規則*を定義する。たとえば、モノイドは結合則を満たす二項演算によって定義できる。さらに、単位元と単位元則もある。しかし、少し想像力を働かせれば、単位元は零項演算――引数を取らず集合の特別な要素を返す操作――に変えられる。群について述べるには、受け取った要素の逆を返す単項演算子を追加する。それに対応する左逆元則と右逆元則がある。環では2つの二項演算子といくつかの規則が定義される。以下同様だ。

大枠としては、代数はさまざまな値の$n$に対する$n$項演算の集合と、等式の恒等射の集合によって定義される。これらの恒等射はすべて普遍的に定量化されている。たとえば、結合性の等式はすべての可能な3要素の組み合わせについて満たされる必要がある、などだ。

ちなみに、これは0 (加算についての単位) が乗算について逆を持たないという単純な理由から、フィールドを考慮から除外する。フィールドの逆元則は普遍的に定量化できない。

この普遍代数の定義は、演算 (関数) を射に置き換えると、$\Set$以外の圏にも拡張できる。集合の代わりに、(総称対象と呼ばれる) 対象$a$を選ぶ。単項演算は$a$の準同型にすぎない。しかし、それ以外の[アリティ]{.keyword #arity} (arity, 演算の引数の数) についてはどうだろう？
二項演算 (アリティ2) は、積$a \times{}a$から$a$へ戻る射として定義できる。一般の$n$項演算は、$a$の$n$乗から$a$への射だ:

$$\alpha_n \Colon a^n \to a$$

零項演算は、終対象 ($a$の0乗) からの射だ。したがって、あらゆる代数を定義するために必要なのはある圏だけで、その圏の対象は1つの特別な対象$a$の冪乗だ。特定の代数は、この圏のhom集合として符号化されている。これがLawvere理論の概略だ。

Lawvere理論の導出は多くのステップを経るため、道順を示しておく:

1. 有限集合の圏$\cat{FinSet}$。
2. そのスケルトン$\cat{F}$。
3. その反対$\Fop$。
4. Lawvere理論$\cat{L}$:
   圏$\cat{Law}$内のある対象。
5. Lawvere圏のモデル$M$:
   圏
   $\cat{Mod}(\cat{Law},\Set)$ 内のある対象。

![](images/lawvere1.png){width=80%}

## Lawvere理論

複数あるLawvere理論はすべて共通のバックボーンを共有している。Lawvere理論におけるすべての対象は、ただ1つの対象から積を使って生成される (実際に、ただの冪乗だ)。しかし、一般の圏では、これらの積をどのように定義するのだろうか？
より単純な圏からの写像を使って積を定義できることが知られている。事実として、このより単純な圏は積ではなく余積を定義する可能性があり、その場合は*反変*関手を使ってそれらを終域圏に埋め込む。反変関手は、余積を積に変換し、単射を射影に変換する。

Lawvere圏のバックボーンとして自然な選択肢は、有限集合の圏$\cat{FinSet}$だ。これは空集合$\varnothing$、単集合$1$、2要素集合$2$などを含む。この圏の対象はすべて、余積を使って単集合から生成できる (空集合は零項余積の特殊なケースとして扱う)。たとえば、2要素集合は2つの単集合の和$2 = 1 + 1$だ。Haskellでも次のように表現される:

```haskell
    type Two = Either () ()
```

しかし、空集合は1つしかないと考えるのが自然であっても、単集合は異なるものが多数存在してよい。特に、すべて同型であるにもかかわらず、集合$1 + \varnothing$と集合$\varnothing + 1$と$1$はそれぞれ異なる。集合の圏の余積は結合則を満たさない。この状況を解決するには、すべての同型集合を識別する圏を構成すればよい。そのような圏は[スケルトン]{.keyword #skeleton} (skeleton) と呼ばれる。言い換えれば、すべてのLawvere理論のバックボーンは$\cat{FinSet}$のスケルトン$\cat{F}$だ。この圏の対象は、$\cat{FinSet}$の要素数に対応した (0を含む) 自然数を使って識別できる。余積は加算の役目を果たす。$\cat{F}$内の射は有限集合間の関数に対応する。例として、$\varnothing$から$n$への (空集合を始対象とする) 一意な射があり、$n$から$\varnothing$への射は ($\varnothing \to \varnothing$を除いて) なく、$1$から$n$への射 (単射) は$n$あり、$n$から$1$への射は1つある、などが挙げられる。ここで、$n$は$\cat{F}$内のある対象を表し、同型射によって識別された$\cat{FinSet}$内のすべての$n$要素集合に対応する。

圏$\cat{F}$を使うと、[Lawvere理論]{.keyword #Lawvere_theory}を、次の特別な関手を伴う圏$\cat{L}$として形式的に定義できる:

$$I_{\cat{L}} \Colon \Fop \to \cat{L}$$

この関手は対象の全単射である必要があり、有限積を保存する必要がある ($\Fop$内の積と$\cat{F}$内の余積は同じだ):

$$I_{\cat{L}}\ (m\times{}n) = I_{\cat{L}}\ m\times{}I_{\cat{L}}\ n$$

この関手は対象上の恒等関手として特徴付けられることがある。つまり、$\cat{F}$内と$\cat{L}$内とで対象が同じであることを表す。そこで、これらに同じ名前を使うことにし、自然数で表そう。ただし、$\cat{F}$内の対象は集合と同じではないことに注意してほしい (これらは同型集合のクラスだ)。

一般に、$\cat{L}$内のhom集合は、$\Fop$内のhom集合よりも豊穣だ。これらは$\cat{FinSet}$内の関数に対応する射以外の射も含むことがある (後者は[基本的な積操作]{.keyword #basic_product_operation} (basic product operation) とも呼ばれる)。Lawvere理論の等式的規則は、これらの射に符号化される。

鍵となる観察は、$\cat{F}$内の単集合$1$が、$\cat{L}$内で同じく$1$と呼ばれる対象に写され、$\cat{L}$内の他のすべての対象が自動的にこの対象の冪乗になることだ。たとえば、$\cat{F}$内の2要素集合$2$は余積$1+1$であるため、$\cat{L}$内の積$1 \times 1$ (または$1^2$) に写される必要がある。この意味で、圏$\cat{F}$は$\cat{L}$の対数のように振る舞う。

$\cat{L}$内の射の中には、関手$I_{\cat{L}}$によって$\cat{F}$から転送されたものがある。それらは$\cat{L}$で構造としての役目を果たす。特に、余積単射$i_k$は積射影$p_k$になる。直観として有用なのは、射影:

$$p_k \Colon 1^n \to 1$$

を、$n$個の変数のうち第$k$番目以外のすべてを無視するような関数のプロトタイプとして想像することだ。逆に、$\cat{F}$内の定常射$n \to 1$は、$\cat{L}$内では対角射$1 \to 1^n$になる。これらは変数の複製に相当する。

$\cat{L}$内の射のうちで興味深いのは、射影以外の$n$項演算を定義するものだ。それらの射によって、Lawvere理論は他の理論とは別物になっている。それらは乗算・加算・単位元の選択などで、代数を定義する。しかし、$\cat{L}$を完全な圏にするためには、複合操作$n \to m$ (あるいは、等価なものとして、$1^n \to 1^m$) も必要だ。圏の構造が単純なため、これらは型$n \to 1$のより単純な射の積だとわかる。これは、積を返す関数は関数の積である (あるいは、前に見たように、hom関手は連続である) という言明を一般化したものだ。

![](images/lawvere1.png){width=80%}

Lawvere理論$\cat{L}$は$\Fop$に基づいており、積を定義する「退屈な」射はそこから継承されている。「興味深い」射も追加され、$n$項操作 (点線の矢印) を記述する。

Lawvere理論は圏$\cat{Law}$を形成する。この圏の射は関手であり、有限積を保存し関手$I$と可換だ。このような2つの理論 $(\cat{L}, I_{\cat{L}})$ と $(\cat{L'}, I'_{\cat{L'}})$ が与えられた場合、それらの間の射は関手$F \Colon \cat{L} \to \cat{L'}$となり、次のようになる:

$$
\begin{gathered}
F\ (m \times n) = F\ m \times F\ n \\
F \circ I_{\cat{L}} = I'_{\cat{L'}}
\end{gathered}
$$

Lawvere理論の間の射は、ある理論を別の理論の中で解釈するという考え方をカプセル化したものだ。たとえば、群の乗算は、逆を無視すれば、モノイドの乗算と解釈できる。

Lawvere圏の最も単純で自明な例は、$\Fop$自体だ (これは$I_{\cat{L}}$についての恒等関手の選択に対応する)。演算や規則を持たないこのLawvere理論は、たまたま$\cat{Law}$の始対象でもある。

この時点でLawvere理論の自明でない例を示せば非常に有益だろうが、モデルとは何かを先に理解しておかなければ、説明が困難だ。

## Lawvere理論におけるモデル

Lawvere理論を理解するための鍵は、それらの理論のうちの1つは、同じ構造を共有する多くの個別の代数を一般化したものだ、と理解することだ。たとえば、モノイドのLawvere理論は、モノイドであることの本質を説明している。それはすべてのモノイドで有効である必要がある。特定のモノイドはそのような理論のモデルとなる。あるモデルは、Lawvere理論$\cat{L}$から集合の圏$\Set$への関手として定義される。(モデルに他の圏を使う一般化されたLawvere理論もあるが、ここでは$\Set$のみ説明する。)
$\cat{L}$の構造は積に大きく依存するため、そのような関手は有限積を保存する必要がある。$\cat{L}$のモデルは、Lawvere理論$\cat{L}$の上の代数とも呼ばれ、次の関手によって定義される:

$$
\begin{gathered}
M \Colon \cat{L} \to \Set \\
M\ (a \times b) \cong M\ a \times M\ b
\end{gathered}
$$

積の保存は*同型を除いて*のみ必要であることに注意してほしい。これは非常に重要だ。なぜなら、積を厳密に保存すると、ほとんどの興味深い理論が棄却されるからだ。

モデルによる積の保存とは、$\Set$内の$M$の像が、集合$M\ 1$――$\cat{L}$からの対象$1$の像――の累乗によって生成された一連の集合であることを意味する。この集合を$a$と呼ぼう。(この集合は*ソート* (sort) と呼ばれることがあり、このような代数は[シングルソート]{.keyword #single-sorted} (single-sorted) と呼ばれる。Lawvere理論のマルチソート代数への一般化も存在する。)特に、$\cat{L}$からの二項演算は次の関数に写される:

$$a \times a \to a$$

あらゆる関手と同じく、$\cat{L}$内の複数の射が$\Set$内の同じ関数に潰されることがある。

ちなみに、すべての規則は全称量化された等価性であるという事実は、すべてのLawvere理論が自明なモデルを持つことを意味する:
恒等射は、すべての対象を単集合に写し、すべての射をその上の定関数に写す。

$m \to n$という形式の$\cat{L}$内の一般の射は、次の関数に写される:

$$a^m \to a^n$$

$M$と$N$という2つの異なるモデルがある場合、それらの間の自然変換は、添字$n$が付けられた関数の族になる:

$$\mu_n \Colon M\ n \to N\ n$$

or, equivalently:

$$\mu_n \Colon a^n \to b^n$$

ここで、$b = N\ 1$だ。

自然条件によって$n$項演算の保存が保証されることに注意してほしい:

$$N\ f \circ \mu_n = \mu_1 \circ M\ f$$

ここで、$f \Colon n \to 1$は$\cat{L}$における$n$項演算だ。

モデルを定義する関数は、モデルの圏である$\cat{Mod}(\cat{L}, \Set)$ を、射としての自然変換を伴って形成する。

自明なLawvere圏$\Fop$のモデルを考えてみよう。そのようなモデルは、$1$での値$M\ 1$によって完全に決定される。$M\ 1$は任意の集合でよいため、$\Set$が含む集合と同じ数のモデルがある。さらに、$\cat{Mod}(\Fop, \Set)$ 内のすべての射 (関数$M$と$N$の間の自然変換) は、$M\ 1$におけるコンポーネントによって一意に決定される。逆に、すべての関数$M\ 1 \to N\ 1$は、2つのモデル$M$と$N$の間に自然変換を引き起こす。したがって、$\cat{Mod}(\Fop, \Set)$ は$\Set$と同値だ。

## モノイドの理論

Lawvere理論の最も単純で重要な例は、モノイドの構造を記述することだ。それは、すべての可能なモノイドの構造を抽出した単一の理論だ。つまり、そのモデルはモノイドの圏$\cat{Mon}$全体に及ぶ。すでに述べた[普遍的構成](#free-monoids)は、射の部分集合を同一視すれば、すべてのモノイドが適切な自由モノイドから得られることを示していた。したがって、1つの自由モノイドですべてのモノイドがすでに一般化されている。しかし、自由モノイドは無数に存在する。モノイドに対するLawvere理論$\cat{L}_{\cat{Mon}}$は、それらすべてを1つのエレガントな構成にまとめる。

すべてのモノイドには単位が必要なので、$\cat{L}_{\cat{Mon}}$内には$0$から$1$への特別な射$\eta$が必要だ。これに対応する射は$\cat{F}$内にはないことに注意してほしい。そのような射の存在を仮定すると、逆向きの$1$から$0$への射になるので、$\cat{FinSet}$内では、単集合から空集合への関数になるだろう。そのような関数は存在しない。

次に、射$2 \to 1$を考える。これは、すべての二項演算のプロトタイプを含む$\cat{L}_{\cat{Mon}}(2, 1)$ のメンバーだ。$\cat{Mod}(\cat{L}_{\cat{Mon}}, \Set)$ のモデルを構成するとき、これらの射はカルテシアン積$M\ 1 \times M\ 1$から$M\ 1$への関数に写される。言い換えると、引数2つを取る関数だ。

問題は、モノイダル演算子のみを使って何種類の2引数関数を実装できるかだ。2つの引数を$a$と$b$と呼ぼう。両方の引数を無視してモノイダル単位を返す関数が1つある。それから、それぞれ$a$と$b$を返す2つの射影がある。さらに、$ab, ba, aa, bb, aab, \ldots$などを返す関数が続く。実際には、このような2引数関数は、生成元$a$と$b$を伴う自由モノイドの要素と同じ数だけ存在する。$\cat{L}_{\cat{Mon}}(2, 1)$ は、モデルの1つが自由モノイドであるため、これらすべての射を含む必要があることに注意してほしい。自由モノイドでは、これらは別々の関数に対応する。他のモデルでは$\cat{L}_{\cat{Mon}}(2, 1)$ の複数の射が1つの関数へと潰される場合があるが、自由モノイドではそうならない。

$n$個の生成元$n^*$を使って自由モノイドを表せば、hom集合$\cat{L}(2, 1)$ を、モノイドの圏$\cat{Mon}$内のhom集合$\cat{Mon}(1^*, 2^*)$ と同一視できる。一般に、$\cat{L}_{\cat{Mon}}(m, n)$ を$\cat{Mon}(n^*, m^*)$ にする。言い換えると、圏$\cat{L}_{\cat{Mon}}$は自由モノイドの圏の逆だ。

モノイドに関するLawvere理論の*モデル*の圏$\cat{Mod}(\cat{L}_{\cat{Mon}}, \Set)$ は、すべてのモノイドの圏$\cat{Mon}$と等価だ。

## Lawvere理論とモナド

覚えていると思うが、代数の理論はモナドを使って――特に[モナドの代数](#algebras-for-monads)で――記述できる。Lawvere理論とモナドがつながっているのは驚くべきことではない。

まず、Lawvere理論からモナドがどのように導出されるかを見てみよう。導出は忘却関手と自由関手の間の[随伴](#freeforgetful-adjunctions)を経る。忘却関手$U$は、ある集合を各モデルに割り当てる。その集合は、$\cat{Mod}(\cat{L}, \Set)$ からの関手$M$を、$\cat{L}$内の対象$1$において評価することで得られる。

$U$を導出するもう1つの方法は、$\Fop$が$\cat{Law}$の始対象であるという事実を利用することだ。これは、すべてのLawvere理論$\cat{L}$に対し、一意な関手$\Fop \to \cat{L}$があることを意味する。この関手は、モデル上に逆向きの関手を引き起こす (モデルは理論*から*集合への関手であるため):

$$\cat{Mod}(\cat{L}, \Set) \to \cat{Mod}(\Fop, \Set)$$

ただし、すでに議論したように、$\Fop$のモデルの圏は$\Set$と同値だ。したがって、次の忘却関手が得られる:

$$U \Colon \cat{Mod}(\cat{L}, \Set) \to \Set$$

このように定義された$U$は左随伴としての自由関手$F$を常に持つことが示せる。

このことは有限集合の場合には容易に分かる。自由関手$F$は自由代数を生成する。自由代数は、$\cat{Mod}(\cat{L}, \Set)$ 内の特定のモデルであり、生成元の有限集合$n$から生成される。$F$は表現可能関手として実装できる:

$$\cat{L}(n, -) \Colon \cat{L} \to \Set$$

これが本当に自由であることを示すには、忘却関手への左随伴であることさえ証明すればよい:

$$\cat{Mod}(\cat{L}(n, -), M) \cong \Set(n, U(M))$$

右辺を単純化しよう:

$$\Set(n, U(M)) \cong \Set(n, M\ 1) \cong (M\ 1)^n \cong M\ n$$

(射の集合が冪乗と同型であり、ここでは単に積の反復であるという事実を使った。)随伴は米田の補題の結果だ:

$$[\cat{L}, \Set](\cat{L}(n, -), M) \cong M\ n$$

まとめると、忘却関手と自由関手によって$\Set$上の[モナド](#monads-categorically)$T = U \circ F$が定義される。したがって、すべてのLawvere理論はモナドを生成する。

モデルに対する[モナドの代数](#algebras-for-monads)の圏はモデルの圏と同値であることが分かる。

モナドを使って形成された式を評価する方法がモナド代数によって定義されたことを思い出すだろう。Lawvere理論は、式を生成するために使えるn項演算を定義する。モデルは、それらの式を評価する手段を提供する。

しかし、モナドとLawvere理論の関係は、両方向に向かうわけではない。有限的モナド (finitary monad) からのみLawvere理論が導出される。有限的モナドは有限的関手に基づく。$\Set$上のある有限的関手は、有限集合への作用によって完全に決定される。任意の集合$a$への作用は、次のコエンドを使って評価できる:

$$F\ a = \int^n a^n \times (F\ n)$$

コエンドは余積すなわち和の一般化なので、この式は冪級数展開の一般化になる。あるいは、関手は一般化されたコンテナだ、という直観に頼ってもよい。その場合、$a$の有限的コンテナは、形と内容の和として記述できる。ここで、$F\ n$は$n$個の要素を格納するための形の集合だ。また、内容は要素の$n$タプルであり、それ自体が$a^n$の要素だ。たとえば、(関手としての) リストは有限的であり、アリティごとに1つの形を持つ。木はアリティごとにより多くの形を持つ、なども挙げられる。

まず第一に、Lawvere理論から生成されたすべてのモナドは有限的であり、コエンドとして表せる:

$$T_{\cat{L}}\ a = \int^n a^n \times \cat{L}(n, 1)$$

逆に、$\Set$上の任意の有限的モナド$T$に対してLawvere理論を構築できる。まず、$T$についてのKleisli圏を構築する。覚えていると思うが、$a$から$b$へのKleisli圏内の射は、台となる圏内の射によって与えられる:

$$a \to T\ b$$

有限集合に限定すると、これは次のようになる:

$$m \to T\ n$$

このKleisli圏の有限集合に限定された反対圏$\cat{Kl}^{op}_{T}$こそ、求めていたLawvere理論だ。特に、$\cat{L}$内のn項演算を記述するhom集合$\cat{L}(n, 1)$ は、hom集合$\cat{Kl}_{T}(1, n)$ によって与えられる。

プログラミングで遭遇するほとんどのモナドは有限的モナドであることが知られている。ただし、継続モナドという注目すべき例外は除く。Lawvere理論の概念は、有限的演算を超えて拡張することも可能だ。

## コエンドとしてのモナド

コエンドの式について詳しく見ていこう。

$$T_{\cat{L}}\ a = \int^n a^n \times \cat{L}(n, 1)$$

まず、このco-endは、次のように定義された$\cat{F}$内のプロ関手$P$に対して使われる:

$$P\ n\ m = a^n \times \cat{L}(m, 1)$$

このプロ関手は最初の引数$n$について反変だ。これが射をどうリフトするかを考えよう。$\cat{FinSet}$内の射は有限集合の間の写像$f \Colon m \to n$だ。このような写像は、$n$要素の集合から$m$要素を (重複は許容して) 選ぶことを表している。次のように、$a$の冪乗の写像へリフトできる (方向に注意してほしい):

$$a^n \to a^m$$

このリフトでは、単純に$n$要素タプル $(a_1, a_2, ...a_n)$ から$m$要素が (重複を許容して) 選択される。

![](images/liftpower.png){width=50%}

たとえば、$f_k \Colon 1 \to n$を考えよう。これは$n$要素集合から第$k$番目の要素を選択したものだ。これをリフトしたものは、$a$の要素を$n$個含むタプルを取って第$k$番目の要素を返す関数となる。

あるいは、$f \Colon m \to 1$を考えよう。これは$m$要素すべてを1つに写す定関数だ。リフトすると、$a$の要素を1つ取って$m$回複製する関数となる:

$$\lambda{}x \to (\underbrace{x, x,\ ...\ , x}_{m})$$

2番目の引数である問題のプロ関手が共変であることは、必ずしも自明ではないことに気付いただろう。hom関手$\cat{L}(m, 1)$ は、実際には$m$について反変だ。しかし、いま扱っているコエンドは圏$\cat{L}$ではなく圏$\cat{F}$のものだ。このコエンドの変数$n$は有限集合 (あるいはそのスケルトン) を経由する。圏$\cat{L}$は$\cat{F}$の逆を含む。したがって、$\cat{F}$内の射$m \to n$は$\cat{L}$内の$\cat{L}(n, m)$ のメンバーだ (埋め込みは関手$I_{\cat{L}}$から得られる)。

$\cat{F}$から$\Set$への関手としての$\cat{L}(m, 1)$ について、関手性を確認しよう。関数$f \Colon m \to n$をリフトしたいので、$\cat{L}(m, 1)$ から$\cat{L}(n, 1)$ への関数を実装するのが目標になる。関数$f$に対応して、$\cat{L}$内に$n$から$m$への射が存在する (方向に注意してほしい)。この射を$\cat{L}(m, 1)$ に前置合成すると$\cat{L}(n, 1)$ の部分集合が得られる。

![](images/liftl.png)

関数$1 \to n$をリフトすれば$\cat{L}(1, 1)$ から$\cat{L}(n, 1)$ に移動できることに注目してほしい。この事実は後で使う。

反変関手$a^n$と共変関手$\cat{L}(m, 1)$ の積はプロ関手$\Fop \times \cat{F} \to \Set$だ。コエンドをプロ関手の対角要素すべての余積 (非交和)として定義できることを思い出してほしい。それらの対角要素のうちいくつかは識別できる。この識別は余くさび条件に対応している。

ここで、コエンドは、すべての$n$に渡る集合$a^n \times \cat{L}(n, 1)$ の非交和として始まる。識別は[コエンドをコイコライザとして](#ends-and-coends)表現することで生成できる。ある非対角項$a^n \times \cat{L}(m, 1)$ から始めよう。対角項を得るには、射$f \Colon m \to n$を積の1番目か2番目のコンポーネントに適用すればよい。それによって2つの結果が識別される。

![](images/equalize1.png)

前に示したように、$f \Colon 1 \to n$をリフトすると2つの変換が得られる:

$$a^n \to a$$

および:

$$\cat{L}(1, 1) \to \cat{L}(n, 1)$$

したがって、$a^n \times \cat{L}(1, 1)$ から始めて、以下の両方に到達できる:

$$a \times \cat{L}(1, 1)$$

は$\langle f, \id \rangle$をリフトして得られ、また:

$$a^n \times \cat{L}(n, 1)$$

は$\langle \id, f \rangle$をリフトして得られる。This doesn't mean, however, that all elements of $a^n \times \cat{L}(n, 1)$ can be identified with $a \times \cat{L}(1, 1)$. なぜなら、$\cat{L}(n, 1)$ の要素すべてが$\cat{L}(1, 1)$ から到達できるわけではないからだ。リフトできるのは$\cat{F}$からの射だけなのを思い出してほしい。$\cat{L}$内の非自明な$n$項演算は、射$f \Colon 1 \to n$をリフトしても構築できない。

言い換えると、識別できるのは、基本射 (basic morphism) を適用することによって$\cat{L}(1, 1)$ から$\cat{L}(n, 1)$ に到達できるようなコエンド式の、すべての加数のみだ。これらはすべて$a \times \cat{L}(1, 1)$ と同値だ。基本射は$\cat{F}$内の射の像だ。

Lawvere理論の最も単純なケースである$\Fop$自体で、これがどのように機能するかを見てみよう。そのような理論では、すべての$\cat{L}(n, 1)$ が$\cat{L}(1, 1)$ から到達できる。なぜなら、$\cat{L}(1, 1)$ は恒等射だけを含む単元圏であり、$\cat{L}(n, 1)$ は$\cat{F}$内の単射$1 \to n$に対応する*基本射*だけを含むからだ。したがって、余積に含まれる加数はすべて同値なので次が得られる:

$$T\ a = a \times \cat{L}(1, 1) = a$$

これは恒等モナドだ。

## 副作用のLawvere理論

モナドとLawvere理論は非常に強く関連しているので、プログラミングでLawvere理論をモナドの代わりとして使えるかを問うのは自然なことだ。モナドの大きな問題は合成しにくいことだ。モナドトランスフォーマーを作るための汎用のレシピはない。Lawvere理論はこの場面で有利であり、余積とテンソル積を使って合成できる。一方、有限的モナド以外はLawvere理論に容易に変換できない。ここでの例外は継続モナドだ。この分野での研究が進んでいる (参考文献を参照のこと)。

Lawvere理論が副作用を記述するためにどのように使えるかを説明するために、単純な例として、例外について説明する。例外は伝統的には`Maybe`モナドで実装される。

`Maybe`モナドは零項演算$0 \to 1$だけを伴うLawvere理論によって生成される。この理論のモデルは、$1$をある集合$a$に写し、零項演算を次の関数に写す関手だ:

```haskell
    raise :: () -> a
```

`Maybe`モナドはコエンド式を使って復元できる。零項操作を追加すると、hom集合$\cat{L}(n, 1)$ にどんな影響があるか検討してみよう。新しく ($\Fop$にはない) $\cat{L}(0, 1)$ が作られる以外にも、$\cat{L}(n, 1)$ に新しい射が追加される。これらは、$n \to 0$の型の射を$0 \to 1$と合成した結果だ。このような寄与はすべて、コエンド式では$a^0 \times \cat{L}(0, 1)$ で識別される。なぜなら、それらを得るには:

$$a^n \times \cat{L}(0, 1)$$

をもとに$0 \to n$を2種類の方法でリフトすればよいからだ。

![](images/equalize2.png)

このコエンドの縮約は:

$$T_{\cat{L}}\ a = a^0 + a^1$$

あるいは、Haskellの記法では:

```haskell
    type Maybe a = Either () a
```

となり、次と等価だ:

```haskell
    data Maybe a = Nothing | Just a
```

このLawvere理論は例外の送出のみをサポートしており、例外の処理はサポートしていないことに注意してほしい。

## 課題

1. $\cat{F}$ ($\cat{FinSet}$のスケルトン) 内の$2$から$3$へのすべての射を列挙せよ。
2. モノイドのLawvere理論についてのモデルの圏が、リストモナドについてのモナド代数の圏と同値であることを示せ。
3. モノイドのLawvere理論はリストモナドを生成する。その二項演算は、対応するKleisli矢を使って生成できることを示せ。
4. $\textbf{FinSet}$は$\Set$の部分圏であり、それを$\Set$に埋め込む関手が存在する。$\Set$の関手はすべて$\cat{FinSet}$に制限できる。有限的関手がそれ自身の制限の左Kan拡張であることを示せ。

## 参考文献

1. [Functorial Semantics of Algebraic Theories](http://www.tac.mta.ca/tac/reprints/articles/5/tr5.pdf), F. William Lawvere
2. [Notions of computation determine monads](http://homepages.inf.ed.ac.uk/gdp/publications/Comp_Eff_Monads.pdf), Gordon Plotkin and John Power
