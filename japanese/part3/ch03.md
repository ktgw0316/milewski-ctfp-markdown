# 自由/忘却随伴

## 随伴に基づく自由モノイド

自由構造は随伴の強力な応用例だ。[自由関手]{.keyword #free_functor}は[忘却関手]{.keyword #forgetful_functor2}への左随伴として定義される。忘却関手は構造を忘れた関手で、通常は非常に単純だ。たとえば、多くの興味深い圏は集合の上に構築されている。しかし、それらの集合を抽象化した圏論的対象は内部構造をもたず、要素をもたない。それでも、これらの対象はある意味で集合の記憶を保っていることがよくある。つまり、ある圏$\cat{C}$から$\Set$への写像――関手――が存在する。$\cat{C}$内のある対象に対応する集合は、その対象の[台集合]{.keyword #underlying_set} (underlying set) と呼ばれる。

モノイドは、台集合――要素の集合――を持つ対象だ。モノイドの圏$\cat{Mon}$から集合の圏へは忘却関手`U`が存在し、モノイドをその台集合に写す。それはさらにモノイド射 (準同型) を集合間の関数に写す。

私は、$\cat{Mon}$が分裂した性格を持っていると見なすのが好きだ。一方では、それは乗算と単位元を持つたくさんの集合だ。もう一方では、それは特徴のない対象を持つ圏であり、その唯一の構造は対象間の射にエンコードされている。乗算と単位を保存するすべての集合関数は、$\cat{Mon}$に射を呼び起こす。

注意事項:

* 同じ集合に写されるモノイドは多数存在する可能性があり、
* モノイド射は、それらの台集合の間に存在する関数よりも少ない (または、多くても同数だ)。

忘却関手`U`の左随伴である関手`F`は、生成元集合から自由モノイドを構築する自由関手だ。随伴は、前に議論した[自由モノイドの普遍的構成](#free-monoids)に従う。

![モノイド$m_1$と$m_2$は同じ台集合を持つ。$m_2$と$m_3$の台集合の間の関数は、その間の射よりも多い。](images/forgetful.jpg){width=60%}

Hom集合を使って、この随伴を次のように書ける:

$$\cat{Mon}(F x, m) \cong \Set(x, U m)$$

この ($x$と$m$についての自然) 同型によって以下のことが分かる:

* $x$によって生成された自由モノイド$F x$と任意のモノイド$m$との間のモノイド準同型に対し、生成元$x$の集合を$m$の台集合に埋め込む一意な関数が存在する。これは$\Set(x, U m)$ 内の関数だ。
* ある$m$の台集合に$x$を埋め込むすべての関数に対し、$x$によって生成された自由モノイドとモノイド$m$の間に一意なモノイド射が存在する。(これは普遍的構成で$h$と呼んでいた射だ。)


![](images/freemonadjunction.jpg){width=80%}

直観では、$F x$は$x$に基づいて構築できる「最大の」モノイドだ。もしモノイドの内部を見られたら、$\cat{Mon}(F x, m)$ に属するすべての射がこの自由モノイドを他のモノイド$m$に*埋め込む*ことがわかるだろう。それは、おそらくいくつかの要素を同一視することで行われる。具体的には、$F x$の生成元 (例えば$x$の要素) を$m$に埋め込む。この随伴は、$\Set(x, U m)$ からの関数で与えられる右辺の$x$の埋め込みが、左辺のモノイドの埋め込みを一意に決定し、またその逆も成り立つことを示している。

Haskellでは、リストのデータ構造は自由モノイドだ (ただし、注意点がいくつかある: [Dan Doelのブログ記事](http://comonad.com/reader/2015/free-monoids-in-haskell/)を参照)。リスト型`[a]`は自由モノイドであり、型`a`は生成元の集合を表す。たとえば、型`[Char]`には、単位要素――空リスト`[]`――と、`['a']`、`['b']`のような単要素リスト――自由モノイドの生成元が含まれている。残りは「積」を適用して生成される。ここでは、2つのリストの積は単に片方をもう片方に連結するだけだ。連結は結合的で単位的 (unital) だ (つまり、中立元が存在する――ここでは空リストだ)。`Char`によって生成される自由モノイドは、`Char`からなるすべての文字列の集合に他ならない。これはHaskellでは`String`と呼ばれる:

```haskell
type String = [Char]
```

(`type`は型シノニムを定義する――既存の型に別の名前を付ける。)


もう1つの興味深い例として、単一の生成元から作られた自由モノイドが挙げられる。これはunitのリスト`[()]`の型だ。その要素は`[]`、`[()]`、`[(), ()]`などだ。そのようなリストはすべて、1つの自然数――長さで記述できる。それ以外にunitのリストにエンコードされた情報はない。このようなリスト2つを連結すると、長さが構成要素の長さの合計である新しいリストが生成される。型`[()]`が、(0を含む) 自然数の加算モノイドと同型であることは容易に理解できる。以下の2つの関数は互いに逆であり、この同型を表している:

```haskell
toNat :: [()] -> Int
toNat = length

toLst :: Int -> [()]
toLst n = replicate n ()
```

簡単のため`Natural`型ではなく`Int`型を使ったが、考え方は同じだ。関数`replicate`は、与えられた値――ここでは単位――で埋められた長さ`n`のリストを作成する。

## いくつかの直観

以下では、身振り手振りの議論をいくつか挙げる。この種の議論は厳密ではないが、直観を形成するのに役立つ。

自由/忘却随伴についての直観を得るには、関手や関数が本質的に情報を損失することを心に留めておくのがよい。関数は複数の対象や射を潰すことがあり、関数は集合の複数の要素をまとめることがある。また、像が終域の一部しかカバーしていないこともある。

$\Set$内の「平均的な」hom集合は関数の全スペクトルを含み、最も損失の少ないもの (たとえば、単射、または、おそらく同型) に始まり、始域全体を単一要素 (もしあれば) に潰す定数関数で終わる。

私はよく、任意の圏における射も損失があると見なす。これは単なるメンタルモデルだが、特に随伴について考えるときには有用だ――典型的には、圏の1つが$\Set$である随伴の場合だ。

形式的には、反転可能な射 (同型射) または反転不可能な射についてのみ語れる。損失があると見なせるのは後者だ。また、単射関数 (潰さない関数) と全射関数 (終域全体をカバーする関数) という概念を一般化した、モノ (mono-) 射とエピ (epi-) 射という概念もある。ただし、モノとエピの両方でありながら非可逆な射も存在可能だ。

自由$\dashv$忘却随伴では、左側に制約の多い圏$\cat{C}$があり、右側に制約の少ない圏$\cat{D}$がある。$\cat{C}$の射が「より少ない」のは、何らかの追加構造を保存しなければならないからだ。$\cat{Mon}$の場合は乗算と単位を保存しなければならない。$\cat{D}$の射はそれほど多くの構造を保存しなくてよいので、「より多くの」射がある。

忘却関手$U$を$\cat{C}$内の対象$c$に適用するとき、$c$の「内部構造」を暴いていると見なせる。実際、$\cat{D}$が$\Set$なら、$U$は$c$の内部構造――台集合――を*定義*していると見なせる。(任意の圏では、対象の内部については他の対象との接続を通じてしか述べられないが、ここでは単に身振り手振りで議論しているだけだ。)


$U$を使って2つの対象$c'$と$c$を写す場合、一般に、hom集合$\cat{C}(c', c)$ の写像は$\cat{D}(U c', U c)$ の部分集合のみをカバーすると予想される。$\cat{C}(c', c)$ 内の射が追加構造を保存しなければならないのに対して、$\cat{D}(U c', U c)$ の射はそうではないからだ。

![](images/forgettingmorphisms.jpg){width=45%}

しかし、随伴は特定のhom集合の[同型]{.keyword #isomorphism}として定義されるので、$c'$は非常に慎重に選択しなければならない。随伴では、$c'$は$\cat{C}$内のどこから選択してもよいわけではなく、自由関手$F$の (より小さいと推察される) 像から選択される:

$$\cat{C}(F d, c) \cong \cat{D}(d, U c)$$

したがって、$F$の像は任意の$c$に向かう多くの射を持つ対象で構成されていなければならない。実際、構造を保存する$F d$から$c$への射は、構造を保存しない$d$から$U c$への射と同数存在する必要がある。これは、$F$の像が本質的に構造のない対象で構成されている必要がある (射が保存すべき構造がない) ことを意味する。そのような「構造のない」対象は自由対象 (free object) と呼ばれる。

![](images/freeimage.jpg){width=45%}

モノイドの例では、自由モノイドは単位元則と結合則によって生成される構造以外には何の構造も持たない。それ以外では、すべての乗算はまったく新しい要素を生成する。

自由モノイドでは、$2 * 3$は$6$ではない――新しい要素${[}2, 3{]}$だ。${[}2, 3{]}$と$6$は同一視されないので、この自由モノイドから他の任意のモノイド$m$への射は、それらを別々に写すことが許される。ただし、${[}2, 3{]}$と$6$ (それらの積) の両方を$m$の同じ要素に写しても構わない。また、加算モノイドで${[}2, 3{]}$と$5$ (それらの和) を同一視することなども同様だ。同一視が異なれば、得られるモノイドも異なる。

これは別の興味深い直観を導く: 自由モノイドは、モノイダル演算を実行する代わりに、渡された引数を累積 (accumulate) する。例えば、$2$と$3$を掛ける代わりに、$2$と$3$をリストに記憶する。この手法の利点は、どんなモノイダル操作を使うか指定する必要がないことだ。引数を累積し続けて、最後だけその結果に演算子を適用すればよい。そしてその最後の時点で、どんな演算子を適用するか選択できる。数値を加算したり、乗算したり、モジュロ2加算したりできる。つまり、自由モノイドは式の作成と評価を分離する。この考え方は代数について話すときにもう一度見ることになる。

この直観は他のもっと複雑な自由構造にも一般化できる。たとえば、評価する前に式木 (expression tree) 全体を累積できる。このアプローチの利点は、そのような木を変換して、評価を高速にしたり、メモリ消費を減らしたりできることだ。これはたとえば、行列計算の実装に使われる。先行評価 (eager evaluation) で行列計算を行うと、中間結果を保存するための一時的な配列が大量に割り当てられてしまうからだ。

## 課題

1. 単集合から構築された自由モノイドを、その生成元と見なす。その自由モノイドから任意のモノイド$m$への射と、その単集合から$m$の台集合への関数との間に1対1の対応があることを示せ。
