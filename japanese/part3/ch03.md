# 自由/忘却随伴 {#freeforgetful-adjunctions}

<!-- ## 随伴に基づく自由モノイド -->

自由構成は随伴の強力な応用例だ。[*自由関手*]{.keyword #free_functor}\index{自由関手}は[*忘却関手*]{.keyword #forgetful_functor2}\index{忘却関手}への左随伴として定義される。忘却関手は構造を忘れる関手で、通常は非常に単純だ。たとえば、多くの興味深い圏は集合の上に構築されている。しかし、それらの集合を抽象化した圏論的な対象は、内部構造
すなわち要素を持たない。それでも、これらの対象が、その圏$\cat{C}$から$\Set$への写像――つまり、関手――が存在するという意味で集合の記憶を保っていることはよくある。$\cat{C}$内のある対象に対応する集合は、その対象の[*台集合*]{.keyword #underlying_set}\index{台集合}と呼ばれる。

モノイドはそのような台集合――要素の集合――を持つような対象である。モノイドの圏$\cat{Mon}$から集合の圏への忘却関手$U$が存在し、モノイドをその台集合に写す。また、モノイド射（準同型）を集合間の関数に写す。

私は$\cat{Mon}$を二重人格だと見なすのが好きだ。一方では、それは乗算と単位元を持つたくさんの集合からなる。他方では、それは特徴のない対象たちからなる圏であり、その唯一の構造は対象間の射として表されている。乗算と単位元を保存するすべての集合関数は$\cat{Mon}$の射となる。\
\
注意事項：

* 同じ集合に写されるモノイドは多数存在し得る。
* モノイド射は、それらの台集合の間に存在する関数より少ない（あるいは、高々同数）。

この忘却関手$U$の左随伴である関手$F$は、生成元の集合から自由モノイドを構築するような自由関手となる。この随伴は、前に議論した[自由モノイドの普遍的構成](#free-monoids)（第13章2節）から導かれる。

![モノイド$m_1$と$m_2$は同じ台集合を持つ。$m_2$と$m_3$の台集合の間の関数は、それらの間の射よりも多い。](images/forgetful.jpg "モノイド$m_1$と$m_2$は同じ台集合を持つ。$m_2$と$m_3$の台集合の間の関数は、それらの間の射よりも多い。"){width=60%}

\noindent
Hom集合による定義では、この随伴は次のように書ける。
$$\cat{Mon}(F x, m) \cong \Set(x, U m)$$
この（$x$と$m$について自然な）同型によって以下のことが分かる。

* $x$によって生成された自由モノイド$F x$と任意のモノイド$m$との間のどのモノイド準同型についても、生成元の集合$x$を$m$の台集合に埋め込む関数が一意に存在する。これは$\Set(x, U m)$ 内の関数である。
* ある$m$の台集合に$x$を埋め込むどの関数についても、$x$によって生成された自由モノイドとそのモノイド$m$の間に一意なモノイド射が存在する。（これは普遍的構成で$h$と呼んでいた射だ。）

`\begin{figure}[H] \centering`{=latex}
![](images/freemonadjunction.jpg){width=80%}
`\end{figure}`{=latex}

\noindent
直観的には、$F x$は$x$に基づいて構築できる「最大の」モノイドとなる。もしモノイドの内部を見られたなら、$\cat{Mon}(F x, m)$ に属するどの射もこの自由モノイドを別のモノイド$m$に*埋め込む*ことが分かるだろう。その際、いくつかの要素は同一視され得る。特に、その射は$F x$の生成元（すなわち$x$の要素）を$m$に埋め込む。この随伴は、$x$の埋め込み（図の右側の$\Set(x, U m)$ から取ってきた関数によって与えられる）が、左側のモノイドの埋め込みを一意に決定し、またその逆も成り立つことを表している。

Haskellにおいては、リストデータ構造は自由モノイドである（ただし、注意点がいくつかある。[Dan Doelのブログ記事](http://comonad.com/reader/2015/free-monoids-in-haskell/)[^doel]を参照）。リスト型`[a]`は型`a`が生成元の集合を表しているような自由モノイドである。たとえば、型`[Char]`は、単位元――空リスト`[]`――と、`['a']`、`['b']`などのような単要素リスト――自由モノイドの生成元を含む。残りの要素は「積」を適用することにより生成される。ここでは、2つのリストの積は単に片方をもう片方に連接するだけだ。連接は結合的で単位元的 (unital) だ（つまり、中立元が存在する――ここでは空リストだ）。`Char`によって生成される自由モノイドは、`Char`の文字からなるすべての文字列の集合に他ならない。これはHaskellでは`String`と呼ばれる。

[^doel]: <http://comonad.com/reader/2015/free-monoids-in-haskell/>

    訳注：要は$\bot$や無限リストを無視すればということ。

```haskell
type String = [Char]
```

\noindent
（`type`は型シノニム――既存の型に対する別名――を定義する。）

もう1つの興味深い例として、単一の生成元から作られた自由モノイドが挙げられる。これはunitのリストの型`[()]`だ。その要素は`[]`、`[()]`、`[(), ()]`などだ。そのようなリストはすべて、1つの自然数――長さによって表せる。それ以外にunitのリストが含む情報はない。このようなリストを2つ連接すると、もとのリストの長さを合計した長さの新しいリストが生成される。型`[()]`が（0を含む）自然数の加算モノイドと同型であることは容易に理解できる。以下の2つの関数は互いに逆であり、この同型の証拠となっている。

```haskell
toNat :: [()] -> Int
toNat = length

toLst :: Int -> [()]
toLst n = replicate n ()
```

\noindent
簡単のため`Natural`型ではなく`Int`型を使ったが、考え方は同じだ^[訳注：`Int`型は固定幅かつ負数も表現可能。`Natural`を使う場合は`length`と`replicate`の代わりに`genericLength`と`genericReplicate`を使う。]。関数`replicate`は、任意の値――ここではunit――で埋められた長さ`n`のリストを作成する。

## いくつかの直観

以下では、大雑把な議論をいくつか挙げる。この種の議論はまったく厳密ではないが、直観を形成するのには役立つ。

自由／忘却随伴について何らかの直観を得るには、関手や関数は本質的に情報を損失するものだということを心に留めておくのがよい。関手は複数の対象や射を潰すことがあり、関数は集合の複数の要素をまとめることがある。また、関手や関数の像は余域の一部しかカバーしていないこともある。

$\Set$内の「平均的な」hom集合は、最も損失の少ない関数（たとえば単射、または場合によっては同型）から、域全体を単一要素（もしあれば）に潰す定数関数まで、一連の関数すべてを含む。

私はよく、任意の圏における射も損失があると見なす。これはメンタルモデルにすぎないが、有用な考え方であり、随伴――特に、圏の1つが$\Set$である場合――について考えるとき役に立つ。

形式的には、我々が語れるのは可逆な射（同型射）または非可逆な射についてだけだ。損失があると見なせるのは後者だ。また、単射関数（潰さない関数）と全射関数（余域全体をカバーする関数）という概念を一般化した、モノ (mono-) 射とエピ (epi-) 射という概念もある。ただし、モノかつエピでありながら非可逆な射も存在する場合がある。

自由$\dashv$忘却随伴では、左側に制約の多い圏$\cat{C}$があり、右側に制約の少ない圏$\cat{D}$がある。$\cat{C}$の射が「より少ない」のは、何らかの追加構造を保存しなければならないからだ。$\cat{Mon}$の場合は乗算と単位元を保存しなければならない。$\cat{D}$の射はそれほど多くの構造を保存しなくてよいので、「より多くの」射がある。

忘却関手$U$を$\cat{C}$内の対象$c$に適用するとき、$c$の「内部構造」を暴いていると見なせる。実際、$\cat{D}$が$\Set$なら、$U$は$c$の内部構造――台集合――を*定義*していると見なせる。（任意の圏においては、対象の内部については他の対象との接続を通じてしか述べられないが、ここでは単に大雑把に議論しているだけだ。）

$U$を使って2つの対象$c'$と$c$を写す場合、一般に、hom集合$\cat{C}(c', c)$ の写像は$\cat{D}(U c', U c)$ の部分集合のみをカバーすると予想される。$\cat{C}(c', c)$ 内の射が追加構造を保存しなければならないのに対して、$\cat{D}(U c', U c)$ の射はそうではないからだ。

`\begin{figure}[H] \centering`{=latex}
![](images/forgettingmorphisms.jpg){width=45%}
`\end{figure}`{=latex}

\noindent
しかし、随伴は特定のhom集合間の[*同型*]{.keyword #isomorphism}\index{同型}として定義されるので、$c'$は非常に慎重に選択しなければならない。随伴では、$c'$は$\cat{C}$内のどこから選択してもよいわけではなく、自由関手$F$の（より小さいと推察される）像から選択される。
$$\cat{C}(F d, c) \cong \cat{D}(d, U c)$$
したがって、$F$の像は任意の$c$に向かう多くの射を持つ対象たちのみからなっていなければならない。実際、構造を保存する$F d$から$c$への射は、構造を保存しない$d$から$U c$への射と同数存在する必要がある。これは、$F$の像が（射が保存すべき構造がなくなる程度に）本質的に構造のない対象たちからなっている必要があることを意味する。そのような「構造のない」対象は自由対象 (free object) と呼ばれる。

`\begin{figure}[H] \centering`{=latex}
![](images/freeimage.jpg){width=45%}
`\end{figure}`{=latex}

\noindent
モノイドの例では、自由モノイドは単位律と結合律によって生成される構造以外には何の構造も持たない。それ以外では、すべての乗算は全く新しい要素を生成する。

自由モノイドでは、$2 * 3$は$6$ではない――新しい要素${[}2, 3{]}$だ。${[}2, 3{]}$と$6$は同一視されないので、この自由モノイドから他の任意のモノイド$m$への射は、それらを別々に写すことが許される。もちろん、${[}2, 3{]}$と$6$（それらの積）の両方を$m$の同じ要素に写しても構わない。また、加算モノイドで${[}2, 3{]}$と$5$（それらの和）を同一視することなども同様だ。同一視が異なれば、得られるモノイドも異なる。

これは別の興味深い直観を導く。すなわち、自由モノイドは、モノイドの演算を実行する代わりに、渡された引数を累積 (accumulate) する。たとえば、$2$と$3$を掛ける代わりに、$2$と$3$をリストに記憶する。この手法の利点は、どんなモノイドの演算を使うか指定する必要がないことだ。引数を累積し続けて、最後にだけ演算子を累積結果に適用すればよい。しかも、どんな演算子を適用するかはその最後の時点で選択できる。数値を加算したり、乗算したり、モジュロ2加算したりできる。つまり、自由モノイドは式の作成と評価を分離する。この考え方は代数について述べるときにもう一度見ることになるだろう。

この直観は他のもっと複雑な自由構成にも一般化できる。たとえば、式木 (expression tree) を評価する前にその全体を累積できる。このアプローチの利点は、そのような木を変換して、評価を高速にしたり、メモリー消費を減らしたりできることだ。これは、たとえば行列計算の実装に使われる。愚直に前から計算すると、中間結果を保存するための一時的な配列が大量に割り当てられる場合があるからだ^[監訳注：Bird & Gibbons: Algorithm Design with Haskell, Cambridge University Press, 2020.
<https://www.cambridge.org/core/books/algorithm-design-with-haskell/824BE0319E3762CE8BA5B1D91EEA3F52>
の第14章 "Optimum Bracketing" を参照。]。

## 課題

1. ある単元集合から生成された自由モノイドを考える。その自由モノイドから任意のモノイド$m$への射と、その単元集合から$m$の台集合への関数との間に1対1の対応があることを示せ。
