# 自由/忘却随伴 {#freeforgetful-adjunctions}

<!-- ## 随伴に基づく自由モノイド -->

自由構成は随伴の強力な応用例だ。[*自由関手*]{.keyword #free_functor}\index{自由関手}は[*忘却関手*]{.keyword #forgetful_functor2}\index{忘却関手}への左随伴として定義される。忘却関手は構造を忘れた関手で、通常は非常に単純だ。たとえば、多くの興味深い圏は集合の上に構築されている。しかし、それらの集合を抽象化した圏論的な対象は、内部構造
すなわち要素を持たない。それでも、これらの対象がある意味で集合の記憶を保ち、ある圏$\cat{C}$から$\Set$への写像――関手――が存在することはよくある。$\cat{C}$内のある対象に対応する集合は、その対象の[*台集合*]{.keyword #underlying_set}\index{台集合}と呼ばれる。

モノイドは、台集合――要素の集合――を持つ対象だ。モノイドの圏$\cat{Mon}$から集合の圏へは忘却関手$U$が存在し、モノイドをその台集合に写す。また、モノイド射（準同型）を集合間の関数に写す。

私は$\cat{Mon}$が分裂した性格を持っていると見なすのが好きだ。一方では、それは乗算と単位元を持つたくさんの集合からなる。他方では、それは特徴のない対象たちからなる圏であり、その唯一の構造は対象間の射として表されている。乗算と単位元を保存するすべての集合関数は$\cat{Mon}$に射を呼び起こす。

注意事項：

* 同じ集合に写されるモノイドは多数存在する可能性がある。
* モノイド射は、それらの台集合の間に存在する関数より少ない（多くても同数だ）。

忘却関手$U$の左随伴である関手$F$は、生成元の集合から自由モノイドを構築する自由関手だ。この随伴は、前に議論した[自由モノイドの普遍的構成](#free-monoids)（第13章2節）から導かれる。

`\begin{figure}[H] \centering`{=latex}
![モノイド$m_1$と$m_2$は同じ台集合を持つ。$m_2$と$m_3$の台集合の間の関数は、その間の射よりも多い。](images/forgetful.jpg){width=60%}
`\end{figure}`{=latex}

\noindent
Hom集合を使って、この随伴を次のように書ける：
$$\cat{Mon}(F x, m) \cong \Set(x, U m)$$
この（$x$と$m$について自然な）同型によって以下のことが分かる：

* $x$によって生成された自由モノイド$F x$と任意のモノイド$m$との間のどのモノイド準同型についても、生成元$x$の集合を$m$の台集合に埋め込む一意な関数が存在する。これは$\Set(x, U m)$ 内の関数である。
* ある$m$の台集合に$x$を埋め込むどの関数についても、$x$によって生成された自由モノイドとモノイド$m$の間に一意なモノイド射が存在する。（これは普遍的構成で$h$と呼んでいた射だ。）

`\begin{figure}[H] \centering`{=latex}
![](images/freemonadjunction.jpg){width=80%}
`\end{figure}`{=latex}

\noindent
直観的には、$F x$は$x$に基づいて構築できる「最大の」モノイドとなる。もしモノイドの内部を見られたら、$\cat{Mon}(F x, m)$ に属するどの射もこの自由モノイドを別のモノイド$m$に*埋め込む*ことが分かるだろう。それは、いくつかの要素を同一視することで行われる。特に、$F x$の生成元（すなわち$x$の要素）を$m$に埋め込む。この随伴は、図の右側で$\Set(x, U m)$ からの関数によって与えられる$x$の埋め込みが、左側のモノイドの埋め込みを一意に決定し、またその逆も成り立つことを示している。

Haskellにおいては、リストのデータ構造は自由モノイドだ (ただし、注意点がいくつかある：[Dan Doelのブログ記事](http://comonad.com/reader/2015/free-monoids-in-haskell/)^[<http://comonad.com/reader/2015/free-monoids-in-haskell/>]を参照)。リスト型`[a]`は自由モノイドであり、型`a`が生成元の集合を表す。たとえば、型`[Char]`は、単位元――空リスト`[]`――と、`['a']`、`['b']`のような単要素リスト――自由モノイドの生成元を含む。残りの要素は「積」を適用して生成される。ここでは、2つのリストの積は単に片方をもう片方に連接するだけだ。連接は結合的で単位元的 (unital) だ（つまり、中立元が存在する――ここでは空リストだ）。`Char`によって生成される自由モノイドは、`Char`からなるすべての文字列の集合に他ならない。これはHaskellでは`String`と呼ばれる：

```haskell
type String = [Char]
```

\noindent
（`type`は型シノニム――既存の型に対する別名――を定義する。）

もう1つの興味深い例として、単一の生成元から作られた自由モノイドが挙げられる。これはunitのリスト`[()]`の型だ。その要素は`[]`、`[()]`、`[(), ()]`などだ。そのようなリストはすべて、1つの自然数――長さで記述できる。それ以外にunitのリストが表す情報はない。このようなリストを2つ連接すると、もとのリストの長さを合計した長さの新しいリストが生成される。型`[()]`が（0を含む）自然数の加算モノイドと同型であることは容易に理解できる。以下の2つの関数は互いに逆であり、この同型を表している：

```haskell
toNat :: [()] -> Int
toNat = length

toLst :: Int -> [()]
toLst n = replicate n ()
```

\noindent
簡単のため`Natural`型ではなく`Int`型を使ったが、考え方は同じだ。関数`replicate`は、任意の値――ここでは単位元――で埋められた長さ`n`のリストを作成する。

## いくつかの直観

以下では、身振り手振りの議論をいくつか挙げる。この種の議論は厳密ではないが、直観を形成するのに役立つ。

自由／忘却随伴について何らかの直観を得るには、関手や関数は情報を損失するものだということを心に留めておくのがよい。関数は複数の対象や射を潰すことがあり、関数は集合の複数の要素をまとめることがある。また、像が終域の一部しかカバーしていないこともある。

$\Set$内の「平均的な」hom集合は、最も損失の少ない関数（たとえば、単射または、おそらく同型）に始まり、始域全体を単一要素（もしあれば）に潰す定数関数に終わるような、一連の関数すべてを含む。

私はよく、任意の圏における射も損失があると見なす。これはメンタルモデルにすぎないが、特に随伴について考えるときは役に立つ――典型的には、圏の1つが$\Set$である随伴の場合だ。

形式的には、我々が語れるのは可逆な射（同型射）または反転不可能な射についてだけだ。損失があると見なされるのは後者だ。また、単射関数（潰さない関数）と全射関数（終域全体をカバーする関数）という概念を一般化した、モノ (mono-) 射とエピ (epi-) 射という概念もある。ただし、モノとエピの両方でありながら非可逆な射も存在可能だ。

自由$\dashv$忘却随伴では、左側に制約の多い圏$\cat{C}$があり、右側に制約の少ない圏$\cat{D}$がある。$\cat{C}$の射が「より少ない」のは、何らかの追加構造を保存しなければならないからだ。$\cat{Mon}$の場合は乗算と単位元を保存しなければならない。$\cat{D}$の射はそれほど多くの構造を保存しなくてよいので、「より多くの」射がある。

忘却関手$U$を$\cat{C}$内の対象$c$に適用するとき、$c$の「内部構造」を暴いていると見なせる。実際、$\cat{D}$が$\Set$なら、$U$は$c$の内部構造――台集合――を*定義*していると見なせる。（任意の圏においては、対象の内部については他の対象との接続を通じてしか述べられないが、ここでは単に身振り手振りで議論しているだけだ。）

$U$を使って2つの対象$c'$と$c$を写す場合、一般に、hom集合$\cat{C}(c', c)$ の写像は$\cat{D}(U c', U c)$ の部分集合のみをカバーすると予想される。$\cat{C}(c', c)$ 内の射が追加構造を保存しなければならないのに対して、$\cat{D}(U c', U c)$ の射はそうではないからだ。

`\begin{figure}[H] \centering`{=latex}
![](images/forgettingmorphisms.jpg){width=45%}
`\end{figure}`{=latex}

\noindent
しかし、随伴は特定のhom集合の[*同型*]{.keyword #isomorphism}\index{同型}として定義されるので、$c'$は非常に慎重に選択しなければならない。随伴では、$c'$は$\cat{C}$内のどこから選択してもよいわけではなく、自由関手$F$の（より小さいと推察される）像から選択される：
$$\cat{C}(F d, c) \cong \cat{D}(d, U c)$$
したがって、$F$の像は任意の$c$に向かう多くの射を持つ対象で構成されていなければならない。実際、構造を保存する$F d$から$c$への射は、構造を保存しない$d$から$U c$への射と同数存在する必要がある。これは、$F$の像が本質的に構造のない対象で構成されている必要がある（射が保存すべき構造がない）ことを意味する。そのような「構造のない」対象は自由対象 (free object) と呼ばれる。

`\begin{figure}[H] \centering`{=latex}
![](images/freeimage.jpg){width=45%}
`\end{figure}`{=latex}

\noindent
モノイドの例では、自由モノイドは単位律と結合律によって生成される構造以外には何の構造も持たない。それ以外では、すべての乗算は全く新しい要素を生成する。

自由モノイドでは、$2 * 3$は$6$ではない――新しい要素${[}2, 3{]}$だ。${[}2, 3{]}$と$6$は同一視されないので、この自由モノイドから他の任意のモノイド$m$への射は、それらを別々に写すことが許される。ただし、${[}2, 3{]}$と$6$（それらの積）の両方を$m$の同じ要素に写しても構わない。また、加算モノイドで${[}2, 3{]}$と$5$（それらの和）を同一視することなども同様だ。同一視が異なれば、得られるモノイドも異なる。

これは別の興味深い直観を導く。すなわち、自由モノイドは、モノイダル演算を実行する代わりに、渡された引数を累積 (accumulate) する。たとえば、$2$と$3$を掛ける代わりに、$2$と$3$をリストに記憶する。この手法の利点は、どんなモノイダル操作を使うか指定する必要がないことだ。引数を累積し続けて、その結果に演算子を最後だけ適用すればよい。そしてその最後の時点で、どんな演算子を適用するか選択できる。数値を加算したり、乗算したり、モジュロ2加算したりできる。つまり、自由モノイドは式の作成と評価を分離する。この考え方は代数について述べるときにもう一度見ることになるだろう。

この直観は他のもっと複雑な自由構成にも一般化できる。たとえば、式木 (expression tree) を評価する前にその全体を累積できる。このアプローチの利点は、そのような木を変換して、評価を高速にしたり、メモリー消費を減らしたりできることだ。これはたとえば、行列計算の実装に使われる。行列計算を先行評価 (eager evaluation) で行うと、中間結果を保存するための一時的な配列が大量に割り当てられてしまうからだ。

## 課題

#. ある単元集合を生成元として構築された自由モノイドを考える。その自由モノイドから任意のモノイド$m$への射と、その単元集合から$m$の台集合への関数との間に1対1の対応があることを示せ。
