# トポイ

プログラミングから離れてハードコアな数学に飛び込んでしまったかもしれないのは分かっている。しかし、プログラミングにおける次の大きな革命が何をもたらすのか、理解のためにどんな数学が必要となるのかは、誰にも分からない。すでにいくつか非常に興味深いアイデアがある。連続時間^[訳註：離散時間（飛び飛びの時刻値のみを扱う）ではないという意味。]での関数型リアクティブプログラミング、Haskellの型システムの依存型による拡張、ホモトピー型理論のプログラミングにおける探究などだ。

ここまでは、値の*集合*を使って気楽に型を区別してきた。これは厳密には正しくない。なぜなら、このようなアプローチはある事実を考慮していないからだ。それは、プログラミングでは値を*計算*し、そして計算は時間のかかるプロセスであり、極端な場合には停止しない可能性がある、という事実だ。すべてのチューリング完全な言語は発散計算 (divergent computation) を含む。

また、集合論には、計算機科学の基礎として、そして数学自体の基礎としても、最適とは言い難い根本的な理由がある。良い比喩としては、集合論は特定のアーキテクチャに結び付けられたアセンブリ言語だと言える。別のアーキテクチャで計算を実行したいなら、より一般的なツールを使う必要がある。

可能性の1つは、集合の代わりに空間 (space) を使うことだ。空間は構造がより豊かで、集合を使わずに定義できる。通常、空間に関連付けられるものの1つは位相 (topology) で、連続性などを定義するために必要だ。位相への従来のアプローチは、ご想像のとおり、集合論によるものだ。特に、部分集合は位相の中心的な概念だ。驚くまでもなく、圏論の研究者たちはこの概念を$\Set$以外の圏に一般化した。集合論に代わるものとしてふさわしい性質を持つ圏の型は[トポス]{.keyword #topos}（topos, 複数形：トポイtopoi）と呼ばれ、部分集合を一般化した概念などを提供する。

## 部分対象分類子

要素ではなく関数を使って部分集合の概念を表現することから始めよう。$a$から$b$への任意の関数$f$は、$b$の部分集合――$f$の下にある$a$の像――を定義する。しかし、同一の部分集合を定義する関数はたくさんある。もっと具体的にする必要がある。まず初めに、単射関数 (injective function) ――複数の要素を1つに潰さない関数に焦点を当てよう。単射関数はある集合を別の集合に「注入」する。有限集合における単射関数は、ある集合の要素を別の集合の要素に接続する平行な矢として視覚化できる。当然、最初の集合を2つ目の集合より大きくすることはできない。そうでないと矢は必然的に収束する。まだ曖昧さは残っている：別の集合$a'$と、その集合から$b$への別の単射関数$f'$があって、同じ部分集合が選ばれる可能性がある。しかし、そのような集合が$a$と同型でなければならないことは簡単に納得できる。この事実を利用して、部分集合を、終域の同型によって関連付けられた単射関数の族として定義できる。より正確には、2つの単射関数：
$$
\begin{aligned}
f &\Colon a \to b \\
f' &\Colon a' \to b
\end{aligned}
$$
が等価になるのは、同型射：
$$h \Colon a \to a'$$
が存在する場合だ。ただし：
$$f = f'\ .\ h$$
このような等価な単射の族は、$b$の部分集合を定義する。

`\begin{figure} \centering`{=latex}
![](images/subsetinjection.jpg){width=40%}
`\end{figure}`{=latex}
\noindent
この定義は、単射関数をモノ射 (monomorphism) に置き換えることで任意の圏にリフトできる。$a$から$b$へのモノ射$m$は普遍性によって定義されることを思い出してほしい。任意の対象$c$および任意の射のペア：
$$
\begin{aligned}
g &\Colon c \to a \\
g' &\Colon c \to a
\end{aligned}
$$
のうち次を満たすもの：
$$m\ .\ g = m\ .\ g'$$
については$g = g'$である必要がある。

`\begin{figure} \centering`{=latex}
![](images/monomorphism.jpg){width=40%}
`\end{figure}`{=latex}
\noindent
集合においてこの定義をより理解しやすくするには、関数$m$がモノ射で*ない*ことが何を意味するかを考えるとよい。その場合は$a$の2つの異なる要素が$b$の1つの要素に写されるだろう。そして、それら2つの要素についてのみ違いがある2つの関数$g$と$g'$を見つけられる。$m$を後合成すると、その違いは見えなくなる。

`\begin{figure} \centering`{=latex}
![](images/notmono.jpg){width=40%}
`\end{figure}`{=latex}
\noindent
部分集合を定義する別の方法もある：特性関数 (characteristic function) と呼ばれる単一の関数を使う方法だ。これは、集合$b$から2要素集合$\Omega$への関数$\chi$だ。2要素集合の片方の要素には "true" が、もう片方には “false” が指定されている。この関数は、$b$の要素のうち部分集合の元である要素に "true" を割り当て、そうでない要素に "false" を割り当てる。

$\Omega$の要素を "true" に指定することの意味を明確にする必要が残る。ここで標準的なトリックが使える：単集合から$\Omega$への関数を使えばよい。この関数を$\mathit{true}$と呼ぼう：
$$\mathit{true} \Colon 1 \to \Omega$$

`\begin{figure} \centering`{=latex}
![](images/true.jpg){width=40%}
`\end{figure}`{=latex}
\noindent
これらの定義の組み合わせ方によっては、部分対象 (subobject) が何であるかだけでなく、特別な対象$\Omega$についても要素に触れずに定義できる。ここでのアイデアは、射$\mathit{true}$が「総称」部分対象を表すようにしたい、というものだ。$\Set$では、これは2要素の集合$\Omega$から1要素の部分集合を選ぶ。これは最大限に総称的だ。ここで選ばれたものがれっきとした部分集合なのは明らかだ。なぜなら、この部分集合には*ない*要素が$\Omega$にはもう1つあるからだ。

より一般的な条件では、$\mathit{true}$を終対象から*分類対象* (classifying object) $\Omega$へのモノ射として定義する。ただし、分類対象の定義が必要になる。つまり、この対象を特性関数に結びつける普遍性が必要だ。$\Set$では、特性関数$\chi$に沿った$\mathit{true}$の引き戻しが、部分集合$a$とそれを$b$に埋め込む単射関数の両方を定義することが知られている。その引き戻し図式を以下に示す：

`\begin{figure} \centering`{=latex}
![](images/pullback.jpg){width=40%}
`\end{figure}`{=latex}
\noindent
この図式を分析してみよう。引き戻しの式は次のとおりだ：
$$\mathit{true}\ .\ \mathit{unit} = \chi\ .\ f$$
関数$\mathit{true}\ .\ \mathit{unit}$は$a$のすべての要素を "true" に写す。したがって、$f$は$a$のすべての要素を、$b$の要素のうち$\chi$が "true" であるものに写す必要がある。定義より、これらは特性関数$\chi$によって指定される部分集合の要素だ。つまり、$f$の像はまさに求めていた部分集合だ。引き戻しの普遍性によって$f$は単射だと保証される。

この引き戻し図式は$\Set$以外の圏の分類対象を定義するのに使える。そのような圏には終対象が必要で、それによってモノ射$\mathit{true}$を定義できる。また、引き戻しも必要だ――実際の要件は、すべての有限の極限を持つことだ（引き戻しは有限の極限の一例だ）。これらの仮定の下で、分類対象$\Omega$を、すべてのモノ射$f$について引き戻し図式を完成させる一意な射$\chi$が存在する、という特性によって定義する。

この特性を分析しよう。引き戻しを構築するとき、3つの対象$\Omega$、$b$、$1$と、2つの射$\mathit{true}$、$\chi$が与えられる。引き戻しの存在は、図式を可換にするような2つの射$f$と$\mathit{unit}$（後者は終対象の定義によって一意に決定される）を伴った最適な対象$a$を見つけられることを意味する。

ここでは連立微分方程式を解いていることになる。つまり、$a$*と*$b$の両方を変化させることで$\Omega$と$\mathit{true}$について解いている。与えられた$a$および$b$について、モノ射$f \Colon a \to b$がある場合とない場合がある。だが、もしあるなら、何らかの$\chi$の引き戻しにしたい。さらに、この$\chi$が$f$によって一意に決定されるようにしたい。

モノ射$f$と特性関数$\chi$の間に1対1の対応関係があるとは言えない。なぜなら、引き戻しは同型を除いて一意なだけだからだ。しかし、部分集合を等価な単射の族として以前定義したのを思い出してほしい。これを一般化するには、$b$の部分対象を、$b$への等価なモノ射の族として定義すればよい。このモノ射の族は、先ほどの図式における等価な引き戻しの族と1対1で対応している。

したがって、$b$の部分対象の集合$\mathit{Sub}(b)$ をモノ射の族として定義でき、それが$b$から$\Omega$への射の集合と同型だと分かる：
$$\mathit{Sub}(b) \cong \cat{C}(b, \Omega)$$
偶然にも、これは2つの関手の自然同型だ。言い換えれば、$\mathit{Sub}(-)$ は表現可能（反変）関手であり、その表現は対象$\Omega$だ。

## トポス

トポスは次のような圏だ：

1. カルテシアン閉である：積・終対象・（積の右随伴として定義される）冪のすべてを持つ。
2. すべての有限図式について極限を持つ。
3. 部分対象分類子$\Omega$がある。

これらの特性によって、トポスはほとんどの用途で$\Set$の代わりになる。さらに、定義から導かれる追加の特性もある。たとえば、トポスは始対象も含めてすべての有限の余極限を持つ。

部分対象分類子を終対象2つの余積（和）として――$\Set$におけるのと同様に――定義するのは魅力的だが、もっと一般化したい。これが当てはまるトポイはブーリアンと呼ばれる。

## トポイと論理

集合論では、特性関数は、集合の要素の特性――[述語]{.keyword #predicate2} (predicate) を定義するものと解釈されうる。述語は、一部の要素に対しては真となり、他の要素に対しては偽となる。述語$\mathit{isEven}$は自然数の集合から偶数の部分集合を選択する。トポスでは、述語の概念を対象$a$から$\Omega$への射に一般化できる。$\Omega$が真偽対象 (truth object) と呼ばれることがあるのはこのためだ。

述語は論理の構成要素だ。トポスには、論理を研究するのに必要な全装備が揃っている。積は論理積（*and*）に対応し、余積は論理和（*or*）に対応し、冪は論理包含に対応する。排中律（または、等価なものとして、二重否定除去）を除く論理学の標準的な公理すべてがトポスに含まれている。これが、トポスの論理が構成的論理 (constructive logic) あるいは直観主義論理 (intuitionistic logic) に対応する理由だ。

直観主義論理は計算機科学から予想外に支持され、着実に定着していっている。排中律という古典的な概念は、絶対的な真実があるという信念に基づいている。つまり、すべての記述は真か偽のいずれかであり、古代ローマ人が言ったように、*tertium non datur*（第3の道はない）ということだ。しかし、何かの真偽を知るための方法は、それを証明または反証できるかどうかだけだ。証明とはプロセスであり、計算だ――そして、知ってのとおり、計算には時間とリソースがかかる。場合によっては、停止しないこともある。有限の時間で証明できない命題を真だと主張するのは無意味だ。トポスにはより繊細な真偽対象があるので、より一般的な枠組みを提供して興味深い論理をモデル化できる。

## 課題

1. 特性関数に沿った$\mathit{true}$の引き戻しである関数$f$は単射でなければならないことを示せ。
