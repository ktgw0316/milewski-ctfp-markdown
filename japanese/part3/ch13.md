# トポイ

プログラミングから離れてハードコアな数学に飛び込んでしまったかもしれないのは分かっている。しかし、プログラミングにおける次の大きな革命が何をもたらすのか、理解のためにどんな数学が必要となるのかは、誰にも分からない。すでにいくつか非常に興味深いアイデアがある。連続時間での関数型リアクティブプログラミング、Haskellの型システムの依存型による拡張、ホモトピー型理論のプログラミングにおける探究などだ。

ここまでは、値の*集合*を使って何気なく型を区別してきた。これは厳密には正しくない。なぜなら、このようなアプローチはある事実を考慮していないからだ。それは、プログラミングでは値を*計算*し、そして計算は時間のかかるプロセスであり、極端な場合には停止しない可能性がある、という事実だ。分岐計算は、すべてのチューリング完全な言語の一部だ。

また、集合論には、計算機科学の基礎として、そして数学自体の基礎としても、最適とは言い難い根本的な理由がある。良い比喩としては、集合論は特定のアーキテクチャに結び付けられたアセンブリ言語だといえる。別のアーキテクチャで計算を実行したいなら、より一般的なツールを使う必要がある。

可能性の1つは、集合の代わりに空間 (space) を使うことだ。空間は構造がより豊かで、集合を使わずに定義できる。通常、空間に関連付けられるものの1つは位相幾何学 (topology) で、連続性などを定義するために必要だ。位相幾何学への従来のアプローチは、ご想像のとおり、集合論によるものだ。特に、部分集合は位相幾何学の中心的な概念だ。驚くまでもないが、圏論の研究者たちはこの概念を$\Set$以外の圏に一般化した。集合論に代わるものとしてふさわしい性質を持つ圏の型は[トポス]{.keyword #topos} (topos, 複数形: トポイtopoi) と呼ばれ、部分集合を一般化した概念などを提供する。

## Subobject Classifier

要素ではなく関数を使って部分集合の概念を表現することから始めよう。$a$から$b$への任意の関数$f$は、$b$の部分集合――$f$の下にある$a$の像――を定義する。しかし、同一の部分集合を定義する関数はたくさんある。もっと具体的にする必要がある。まず初めに、単射関数――複数の要素を1つに潰さない関数に焦点を当てよう。単射関数 (injective function) はある集合を別の集合に「注入」する。有限集合における単射関数は、ある集合の要素を別の集合の要素に接続する平行な矢として視覚化できる。当然、最初の集合を2つ目の集合より大きくすることはできない。そうでないと矢は必然的に収束する。まだ曖昧さが残っている: 別の集合$a'$と、その集合から$b$への別の単射関数$f'$があって、同じ部分集合が選ばれる可能性がある。しかし、そのような集合が$a$と同型でなければならないことは容易に納得できる。この事実を利用して、部分集合を、終域の同型によって関連付けられた単射関数の族として定義できる。より正確には、2つの単射関数:

$$
\begin{align*}
f &\Colon a \to b \\
f' &\Colon a' \to b
\end{align*}
$$

が等価になるのは、同型射:

$$h \Colon a \to a'$$

次が満たされる場合:

$$f = f'\ .\ h$$

このような等価な単射の族は、$b$の部分集合を定義する。

![](images/subsetinjection.jpg){width=40%}

この定義は、単射関数をモノ射に置き換えることで任意の圏にリフトできる。$a$から$b$へのモノ射$m$は普遍性によって定義されることを思い出してほしい。任意の対象$c$および任意の射のペア:

$$
\begin{align*}
g &\Colon c \to a \\
g' &\Colon c \to a
\end{align*}
$$

次が満たされる場合:

$$m\ .\ g = m\ .\ g'$$

については$g = g'$である必要がある。

![](images/monomorphism.jpg){width=40%}

集合においてこの定義をより理解しやすくするには、関数$m$がモノ射で*ない*ことが何を意味するかを考えるとよい。その場合は$a$の2つの異なる要素が$b$の1つの要素に写されるだろう。そして、それら2つの要素についてのみ違いがある2つの関数$g$と$g'$を見つけられる。$m$を後置合成すると、その違いは見えなくなる。

![](images/notmono.jpg){width=40%}

部分集合を定義する別の方法もある: 特性関数と呼ばれる単一の関数を使う方法だ。これは、集合$b$から2要素集合$\Omega$への関数$\chi$だ。この関数は、$b$の要素のうち部分集合のメンバーである要素に "true" を割り当て、メンバーではない要素に "false" を割り当てる。

$\Omega$の要素を "true" に指定することが何を意味するかを特定する必要が残る。ここで標準的なトリックが使える: 単集合から$\Omega$への関数を使えばよい。この関数を$true$と呼ぼう:

$$true \Colon 1 \to \Omega$$

![](images/true.jpg){width=40%}

これらの定義の組み合わせ方によっては、サブ対象が何であるかだけでなく、特別な対象$\Omega$についても要素に触れずに定義できる。ここでのアイデアは、射$true$が「総称」サブ対象を表すようにしたい、というものだ。$\Set$では、これは2要素の集合$\Omega$から1要素の部分集合を選ぶ。これは可能な限り総称的だ。ここで選ばれたものがれっきとした部分集合なのは明らかだ。なぜなら、この部分集合には*ない*要素が$\Omega$にはもう1つあるからだ。

より一般的な条件では、$true$を終対象から*分類対象* (classifying object) $\Omega$へのモノ射として定義する。ただし、分類対象の定義が必要になる。つまり、この対象を特性関数に結びつける普遍性が必要だ。$\Set$では、特性関数$\chi$に沿った$true$の引き戻しが、部分集合$a$とそれを$b$に埋め込む単射関数の両方を定義することが知られている。その引き戻し図式を以下に示す:

![](images/pullback.jpg){width=40%}

この図式を分析してみよう。引き戻しの式は次のとおりだ:

$$true\ .\ unit = \chi\ .\ f$$

関数$true\ .\ unit$は$a$のすべての要素を "true" に写す。したがって、$f$は$a$のすべての要素を$b$の要素のうち$\chi$が "true" であるものに写す必要がある。これらは、定義より、特性関数$\chi$によって指定される部分集合の要素だ。したがって、$f$の像はまさに求めていた部分集合だ。引き戻しの普遍性によって$f$が単射であることが保証される。

この引き戻し図式は、$\Set$以外の圏の分類対象を定義するのに使える。そのような圏には終対象が必要で、それによってモノ射$true$を定義できる。また、引き戻しも必要だ――実際の要件は、すべて有限の極限を持つことだ (引き戻しは有限の極限の一例だ)。これらの仮定の下で、分類対象$\Omega$を、すべてのモノ射$f$について引き戻し図式を完成させる一意な射$\chi$が存在する、という特性によって定義する。

この特性を分析しよう。引き戻しを構築するとき、3つの対象$\Omega$・$b$・$1$と、2つの射$true$・$\chi$が与えられる。引き戻しの存在は、図式を可換にするような、2つの射$f$と$unit$ (後者は終対象の定義によって一意に決定される) を伴った最適な対象$a$を見つけられることを意味する。

ここでは、別の方程式の系を解いている。つまり、$a$*と*$b$の両方を変化させることで$\Omega$と$true$について解いている。与えられた$a$および$b$について、モノ射$f \Colon a \to b$がある場合とない場合がある。しかし、もしあるなら、何らかの$\chi$の引き戻しにしたい。さらに、この$\chi$が$f$によって一意に決定されるようにしたい。

モノ射$f$と特性関数$\chi$の間に1対1の対応関係があるとは言えない。なぜなら、引き戻しは同型を除いて一意なだけだからだ。しかし、部分集合を等価な注入の族として以前定義したのを思い出してほしい。これを一般化するには、$b$のサブ対象を、$b$への等価なモノ射の族として定義すればよい。このモノ射の族は、先ほどの図式における等価な引き戻しの族と1対1で対応している。

したがって、$b$のサブ対象の集合$Sub(b)$ をモノ射の族として定義でき、それが$b$から$\Omega$への射の集合と同型であることがわかる。

$$Sub(b) \cong \cat{C}(b, \Omega)$$

偶然にも、これは2つの関手の自然同型だ。言い換えれば、$Sub(-)$ は表現可能 (反変) 関手であり、その表現は対象$\Omega$だ。

## トポス

トポスは次のような圏だ:

1. カルテシアン閉である: 積・終対象・(積の右随伴として定義される) 冪乗のすべてを持つ。
2. すべての有限図式について極限を持つ。
3. サブ対象分類子$\Omega$がある。

この特性の集合によって、ほとんどの用途では、トポスが$\Set$の代わりになる。さらに、定義から導かれる追加の特性もある。たとえば、トポスは有限の余極限を、始対象も含めてすべて持つ。

サブ対象分類子を終対象2つの余積 (和) として――$\Set$におけるのと同様に――定義するのは魅力的だが、もっと一般化したい。これが当てはまるトポイはブーリアンと呼ばれる。

## トポイと論理

集合論では、特性関数は、ある集合の要素の特性――[述語]{.keyword #predicate} (predicate) を定義するものと解釈されうる。述語は、一部の要素に対しては真となり、他の要素に対しては偽となる。述語$isEven$は自然数の集合から偶数の部分集合を選択する。トポスでは、述語の概念を対象$a$から$\Omega$への射に一般化できる。$\Omega$が真偽対象 (truth object) と呼ばれることがあるのはこのためだ。

述語は論理の構成要素だ。トポスには、論理を研究するのに必要な全装備が揃っている。It has products that correspond to logical conjunctions (logical *and*), coproducts for disjunctions (logical *or*), and exponentials for implications. 排中律 (または、等価なものとして、二重否定除去) 以外のすべての標準的な論理学の公理がトポスに含まれる。これが、トポスの論理が構成的論理 (constructive logic) あるいは直観主義論理 (intuitionistic logic) に対応する理由だ。

直観主義論理は計算機科学から予想外に支持され、着実に定着していっている。排中律という古典的な概念は、絶対的な真実があるという信念に基づいている。つまり、すべての記述は真か偽のいずれかであり、古代ローマ人が言ったように、*tertium non datur* (第3の道はない) ということだ。しかし、何かの真偽を知るための方法は、それを証明または反証できるかどうかだけだ。証明とはプロセスであり、計算だ――そして、知ってのとおり、計算には時間とリソースがかかる。場合によっては、停止しないこともある。有限の時間で証明できない命題を真実であると主張するのは無意味だ。トポスは、より繊細な真実の対象を持ち、興味深い論理をモデル化するためのより一般的な枠組みを提供する。

### 課題

1. 特性関数に沿った$true$の引き戻しである関数$f$は単射でなければならないことを示せ。
