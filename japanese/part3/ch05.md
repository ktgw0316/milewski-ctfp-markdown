# モナドと作用

モナドが何のためにあるのかは理解できた。モナドは装飾された関数を合成できる。本当に興味深い疑問は、なぜ装飾された関数が関数プログラミングにおいてそんなに重要なのかということだ。すでに見た例として、`Writer`モナドでは、装飾によって複数の関数呼び出しにわたってログを作成し累積できた。通常は非純粋関数 (impure function) を使って（たとえば、何らかのグローバルな状態にアクセスし変更することで）解決するような問題を、純粋関数を使って解決した。

## 問題

よく似た問題を集めた短いリストを、[エウジニオ・モッジの独創的な論文](https://core.ac.uk/download/pdf/21173011.pdf)から転載して以下に示した。どれも伝統的には関数の純粋さを放棄することで解決される：

* 部分性：停止しない可能性のある計算
* 非決定性：何種類もの結果を返す可能性のある計算
* 副作用：状態にアクセス・変更する計算
   * 読み取り専用の状態、あるいは環境
   * 書き込み専用の状態、あるいはログ
   * 読み取り・書き込みの状態
* 例外：失敗する可能性のある部分関数
* 継続：プログラムの状態を保存でき、要求に応じて復元できること
* インタラクティブな入力
* インタラクティブな出力

本当に驚くべきことに、これらすべての問題は1つの巧妙なトリックで解決できる。装飾された関数にするというトリックだ。もちろん、装飾は各ケースで全く違うものになる。

装飾がモナディックだという条件は、この段階では必要ないことを認識しておかなくてはならない。合成――1つの装飾された関数をより小さな装飾された関数に分解できること――を主張するとき、初めてモナドが必要になる。また、それぞれの装飾が違うため、モナディック合成の実装方法もやはり違うものになるが、全体的なパターンは同じだ。非常に単純な、恒等射を伴った結合的な合成というパターンだ。

次節では、Haskellでの例について詳しく説明する。圏論に戻りたい人や、Haskellによるモナドの実装にすでに慣れている人は、遠慮なく斜め読みしたり飛ばしたりして構わない。

## 解決策

まず、`Writer`モナドの使用方法を分析してみよう。あるタスクを実行する純粋関数――引数を与えると、ある決まった出力が生成される関数――から始めた。この関数を、もとの出力を文字列とペアにすることで装飾する別の関数に置き換えた。これがログ生成の問題に対する解決策だった。

それで終わりにできなかったのは、一般に、モノリシックな解決策は扱いたくないからだ。1つのログ生成関数をより小さなログ生成関数に分解できる必要があった。こうした小さな関数の合成こそがモナドという概念への道標となった。

本当に驚くべきことは、関数の戻り値の型を装飾するという同一のパターンが、通常は純粋性を放棄する必要がある多種多様な問題に対して機能することだ。リストを見て、それぞれの問題に適用される装飾を順番に突き止めよう。

### 部分性

停止しない可能性のあるすべての関数について、戻り値の型を「リフトされた」型に変更する。その型はもとの型のすべての値および特別な「ボトム」値$\bot$を含む。たとえば、集合としての`Bool`型は`True`と`False`の2つの要素を含む。リフトされた`Bool`は3つの要素を含む。リフトされた`Bool`を返す関数は、`True`または`False`を生成するか、永久に実行され続ける。

面白いのは、Haskellのような遅延評価言語では、終わりのない関数が実際に値を返すことがあり、その値が次の関数に渡されうるということだ。この特別な値をボトムと呼ぶ。この値が（たとえば、パターンマッチングに使うため、あるいは出力として生成したため）明示的に必要とされているのでない限り、プログラムの実行を遅らせることなくこの値を渡せる。すべてのHaskellの関数は潜在的に非停止であり得るため、Haskellのすべての型はリフトされることが想定されている。これが、単純な$\Set$ではなく、Haskellの（リフトされた）型と関数の圏$\Hask$について頻繁に議論する理由だ。もっとも、$\Hask$が本物の圏かどうかは議論がある ([Andrej Bauerによる記事](http://math.andrej.com/2016/08/06/hask-is-not-a-category/)を参照)。

### 非決定性

関数が多くの異なる結果を返すことがあるなら、一度にすべての結果を返す方がよいだろう。意味論的には、非決定論的関数は結果のリストを返す関数と等価だ。これはガベージコレクションのある遅延評価言語では実に理に適っている。たとえば、必要な値が1つだけの場合はリストの頭部だけを取得すればよく、尾部が評価されることはない。ランダムな値が必要な場合は乱数ジェネレーターを使ってリストのn番目の要素を選択する。遅延評価では結果の無限リストを返すことさえ可能になる。

リストモナド――Haskellでの非決定論的計算の実装――では`join`は`concat`として実装されている。`join`の役割はコンテナのコンテナをフラット化することなのを思い出してほしい――`concat`はリストのリストを連結して1つのリストにする。また、`return`は単要素リストを作成する：

```haskell
instance Monad [] where
    join = concat
    return x = [x]
```

リストモナドのbind演算子は、`fmap`の後に`join`が続くという一般式で与えられ、ここでは次のようになる：

```haskell
as >>= k = concat (fmap k as)
```

ここで、関数`k`はそれ自体がリストを生成する関数で、リスト`as`のすべての要素に適用される。結果はリストのリストとなり、`concat`を使ってフラット化される。

プログラマーの観点では、リストの操作は比較的簡単であり、たとえば、非決定論的関数をループ内で呼び出したり、イテレーターを返す関数を実装したりする方が難しい (ただし、[近年のC++](http://ericniebler.com/2014/04/27/range-comprehensions/)では、遅延評価するrangeを返すのはHaskellでリストを返すのとほぼ等価だ)。

非決定性が創造的に使われる好例はゲームプログラミングだ。たとえば、コンピューターが人間を相手にチェスをするとき、相手の次の動きは予測できない。しかし、すべての可能な移動のリストを生成して1つずつ分析できる。同様に、非決定論的な構文解析器は、与えられた式に対して可能なすべての構文解析のリストを生成できる。

リストを返す関数は非決定論的だと解釈してもよいものの、リストモナドの応用範囲はもっと広い。リストを生成する計算をつなぎ合わせることは、命令型プログラミングで使われる反復構文――ループ――を関数プログラミングで完全に代替する手段だからだ。単一のループは、多くの場合`fmap`を使って書き直せる。fmapはループの本体をリストの各要素に適用する。リストモナドで`do`記法を使えば、複雑な多重ループを置き換えられる。

私のお気に入りの例は、ピタゴラス数 (Pythagorean triple) ――直角三角形の辺を形成できる3つの正の整数の組――を生成するプログラムだ。

```haskell
triples = do
    z <- [1..]
    x <- [1..z]
    y <- [x..z]
    guard (x^2 + y^2 == z^2)
    return (x, y, z)
```

最初の行は、`z`が正の整数の無限リスト`[1..]`から要素を取得することを示している。次に`x`は、1から`z`までの整数の（有限）リスト`[1..z]`から要素を取得する。最後に`y`は、`x`から`z`までの整数のリストから要素を取得する。これで$1 \leqslant x \leqslant y \leqslant z$の3つの整数を自由に使える。関数`guard`は、`Bool`式を取り、unitのリストを返す。

```haskell
guard :: Bool -> [()]
guard True  = [()]
guard False = []
```

この関数（`MonadPlus`というより大きなクラスのメンバー）は、ここでは非ピタゴラス数を除外するために使われる。実際、bind（または関連する演算子`>>`）の実装を見ると、空リストが与えられると空リストが生成されることに気付くだろう。一方、空でないリスト（ここではunitを含む単リスト`[()]`）が与えられた場合、bindは継続を呼ぶ。ここでは`return(x, y, z)`だ。これは検証済みのピタゴラス数を持つ単リストを生成する。これらの単リストはすべて、内包するbindによって連結され、最終的な（無限の）結果を生成する。当然、`triple`の呼び出し側はリスト全体を消費できないが、Haskellは遅延評価言語なので問題ない。

通常は3重にネストされたループを必要とする問題が、リストモナドと`do`記法のおかげで劇的に単純化された。それだけでは不十分と言わんばかりに、Haskellではこのコードをリスト内包表記を使ってさらに単純化する：

```haskell
triples = [(x, y, z) | z <- [1..]
                     , x <- [1..z]
                     , y <- [x..z]
                     , x^2 + y^2 == z^2]
```

これはリストモナド（厳密に言えば、`MonadPlus`）のためのさらなる糖衣構文だ。

他の関数型言語や命令型言語でも、ジェネレーターやコルーチンという名のもとに同様の構造が見られることがある。

### 読み取り専用の状態

外部の状態すなわち環境に対して読み取り専用でアクセスする関数は、その環境を追加の引数として取る関数に常に置き換え可能だ。純粋な関数`(a, e) -> b`（ここで、`e`は環境の型）は、一見したところ、Kleisli矢のようには見えない。しかし、それを`a -> (e -> b)`にカリー化すれば、その装飾がお馴染みのreader関手なのがすぐ分かる：

```haskell
newtype Reader e a = Reader (e -> a)
```

`Reader`を返す関数は、ある環境を与えると望んだ結果を生成するような作用を持つ小さな実行可能コードを生成する、と解釈できる。ヘルパー関数`runReader`はそのような作用を実行する：

```haskell
runReader :: Reader e a -> e -> a
runReader (Reader f) e = f e
```

環境の値が異なれば生成される結果も異なりうる。

`Reader`を返す関数も`Reader`の作用自体も純粋であることに注意してほしい。

`Reader`モナド用にbindを実装するには、まず、環境`e`を取得して`b`を生成する関数を生成する必要がある：

```haskell
ra >>= k = Reader (\e -> ...)
```

ラムダ内では、作用`ra`を実行して`a`を生成できる：

```haskell
ra >>= k = Reader (\e -> let a = runReader ra e
                         in ...)
```

次に、`a`を継続`k`に渡せば新しい作用`rb`が得られる：

```haskell
ra >>= k = Reader (\e -> let a  = runReader ra e
                             rb = k a
                         in ...)
```

最後に、環境`e`で作用`rb`を実行できる：

```haskell
ra >>= k = Reader (\e -> let a  = runReader ra e
                             rb = k a
                         in runReader rb e)
```

`return`を実装するには、環境を無視して値をそのまま返す作用を作成すればよい。

いくつかの簡略化を経てまとめると、次の定義が得られる：

```haskell
instance Monad (Reader e) where
    ra >>= k = Reader (\e -> runReader (k (runReader ra e)) e)
    return x = Reader (\e -> x)
```

### 書き込み専用の状態

これは最初に例にしたログ生成と同じだ。装飾は`Writer`関手によって与えられる：

```haskell
newtype Writer w a = Writer (a, w)
```

完全を期すため、データコンストラクターをアンパックする小さなヘルパー関数`runWriter`も示そう：

```haskell
runWriter :: Writer w a -> (a, w)
runWriter (Writer (a, w)) = (a, w)
```

すでに見たとおり、`Writer`を合成可能にするには、`w`はモノイドでなければならない。bind演算子で書かれた`Writer`の`Monad`インスタンスを以下に示す：

```haskell
instance (Monoid w) => Monad (Writer w) where
    (Writer (a, w)) >>= k = let (a', w') = runWriter (k a)
                            in Writer (a', w `mappend` w')
    return a = Writer (a, mempty)
```

### 状態

状態へ読み取り/書き込みアクセスする関数は、`Reader`と`Writer`の装飾を組み合わせる。それらは、追加の引数として状態を受け取り、結果として値/状態のペアを生成する純粋関数 `(a, s) -> (b, s)` と見なせる。カリー化すると、それらはKleisli矢`a -> (s -> (b, s))`の形になり、装飾は`State`関手へと抽象化される：

```haskell
newtype State s a = State (s -> (a, s))
```

ここでも、Kleisli矢は作用を返すものと見なせて、ヘルパー関数を使って実行できる：

```haskell
runState :: State s a -> s -> (a, s)
runState (State f) s = f s
```

初期状態が異なると、結果が異なりうるだけでなく、最終状態も異なりうる。

`State`モナドに対するbindの実装は`Reader`モナドの実装と非常によく似ている。ただし、各ステップで正しい状態を渡すように注意する必要がある：

```haskell
sa >>= k = State (\s -> let (a, s') = runState sa s
                            sb = k a
                        in runState sb s')
```

インスタンス全体は次のとおりだ：

```haskell
instance Monad (State s) where
    sa >>= k = State (\s -> let (a, s') = runState sa s
                            in runState (k a) s')
    return a = State (\s -> (a, s))
```

ヘルパーとしてのKleisli矢も2つあり、状態を操作するために使える。そのうちの1つは状態を調べるために取得する：

```haskell
get :: State s s
get = State (\s -> (s, s))
```

もう1つは状態を全く新しいものに置き換える：

```haskell
put :: s -> State s ()
put s' = State (\s -> ((), s'))
```

### 例外

例外をスローする命令型関数は、実際には部分関数――引数の値のいくつかに対して定義されていない関数だ。例外を最もシンプルに純粋全域関数として実装するには`Maybe`関手を使う。部分関数を全域関数へと拡張すればよい。つまり、意味があるなら`Just a`を、そうでないなら`Nothing`を返すように拡張する。失敗の原因に関する何らかの情報も返したい場合は、代わりに`Either`関手を使える（第1の型は固定され、たとえば`String`とされる）。

以下は`Maybe`の`Monad`インスタンスだ：

```haskell
instance Monad Maybe where
    Nothing >>= k = Nothing
    Just a  >>= k = k a
    return a = Just a
```

`Maybe`についてのモナディック合成では、エラーが検出されたときは計算がきちんと短絡評価される（継続`k`が決して呼ばれない）ことに注意してほしい。これは例外に期待される振る舞いだ。

### 継続

これは「電話はしないでください、こちらから電話しますので！」という、採用面接のあとで経験しそうな状況を表す。回答を直接得る代わりに、ある関数をハンドラーとして提供することになっており、そのハンドラーが呼ばれると結果が得られる。このスタイルのプログラミングが特に役立つのは、呼び出し時点で結果がわからない場合だ。たとえば、別のスレッドで評価される場合や、リモートのウェブサイトから配信される場合などだ。この場合のKleisli矢が返す関数は「残りの計算」を表すハンドラーを受け取る：

```haskell
data Cont r a = Cont ((a -> r) -> r)
```

このハンドラー`a -> r`は、最終的に呼び出されると型`r`の結果を生成し、その結果が最後に返される。継続は結果の型によってパラメーター化される。（実用上は、これはある種のステータスインジケーターである場合が多い。）

Kleisli矢から返された作用を実行するためのヘルパー関数もある。それはハンドラーを取得して継続に渡す：

```haskell
runCont :: Cont r a -> (a -> r) -> r
runCont (Cont k) h = k h
```

継続の合成は非常に難しいことで知られており、それゆえモナドや、特に`do`記法による処理は非常に有利だ。

bindの実装について説明しよう。まず、本質だけに絞ったシグネチャーに注目する：

```haskell
(>>=) :: ((a -> r) -> r) ->
         (a -> (b -> r) -> r) ->
         ((b -> r) -> r)
```

目標は、ハンドラー`(b -> r)`を受け取って結果`r`を生成する関数を作成することだ。そこで出発点はこうなる：

```haskell
ka >>= kab = Cont (\hb -> ...)
```

このラムダの内部で、`ka`関数を、残りの計算を表す適切なハンドラーを添えて呼び出したい。そのハンドラーをラムダとして実装する：

```haskell
runCont ka (\a -> ...)
```

この場合、残りの計算は、まず`kab`を`a`で呼び出し、次に`hb`を結果の作用`kb`に渡すことを含む：

```haskell
runCont ka (\a -> let kb = kab a
                  in runCont kb hb)
```

ご覧のとおり、継続は裏返しに合成されている。最終的なハンドラー`hb`は、計算の最も内側の層から呼び出される。インスタンス全体は次のとおりだ：

```haskell
instance Monad (Cont r) where
    ka >>= kab = Cont (\hb -> runCont ka (\a -> runCont (kab a) hb))
    return a = Cont (\ha -> ha a)
```

### インタラクティブな入力

これは最も厄介な問題であり、多くの混乱の源だ。明らかに、`getChar`のような関数は、キーボードから入力された文字を返すとしたら、純粋ではあり得ない。しかし、コンテナ内の文字を返すとしたらどうだろう？
そのコンテナから文字を除去する方法がない限り、この関数は純粋であると主張できる。`getChar`を呼び出すたびに、全く同じコンテナが返される。概念としては、このコンテナには可能な文字すべての重ね合わせが含まれる。

量子力学に馴染みがあれば、この比喩を問題なく理解できるだろう。これはシュレーディンガーの猫が入った箱のようなものだ――ただし、箱を開けたり中を覗いたりする方法はない。この箱は、組み込みの特別な`IO`関手を使って定義される。この例では`getChar`をKleisli矢として宣言できる：

```haskell
getChar :: () -> IO Char
```

（実際には、unit型を取る関数は戻り値の型の値を選択するのと等価なので、`getChar`の宣言は単純に`getChar :: IO Char`となる。）

`IO`は関手なので`fmap`を使って内容を操作できる。また、関手として、文字だけでなく任意の型を内容として保持できる。このアプローチの真の有用性が明らかになるのは、Haskellでの`IO`がモナドなのを考慮したときだ。これは`IO`オブジェクトを生成するKleisli矢を合成できることを意味する。

Kleisli合成を使えば、`IO`オブジェクトの内容を覗き見できると思うかもしれない（またも量子力学で比喩すると「波動関数を収縮させる」ことにあたる）。実際、`getChar`は、文字を受け取る別のKleisli矢と合成できる。たとえば、受け取った文字を整数に変換するようなものと合成できる。注意点として、そのような2番目のKleisli矢は整数を`(IO Int)`としてしか返せない。ここでも、すべての可能な整数を重ね合わせることになる。以下同様だ。シュレーディンガーの猫は決して外に出ない。`IO`モナドに入ると、抜け出す方法はない。`IO`モナドについて`runState`や`runReader`と同等のものはない。`runIO`はないのだ！


では、Kleisli矢の結果である`IO`オブジェクトを、他のKleisli矢と合成する以外に何ができるだろう？
そう、`main`から返せる。Haskellでは`main`は次のシグネチャーを持つ：

```haskell
main :: IO ()
```

そしてこれはKleisli矢と見なして構わない：

```haskell
main :: () -> IO ()
```

この観点からは、Haskellのプログラムは`IO`モナドを使った1つの大きなKleisli矢にすぎない。モナディック合成を使えば複数の小さなKleisli矢から合成できる。生成された`IO`オブジェクト（`IO`アクションとも呼ばれる）で何を行うかはランタイムシステム次第だ。

矢自体が純粋関数であることに注目してほしい――それは一貫して純粋関数だ。純粋でない仕事はシステムへと追いやられている。`main`から返された`IO`アクションを最終的に実行するとき、あらゆる種類の汚れ仕事が行われる。たとえば、ユーザー入力の読み取り、ファイルの変更、不愉快なメッセージの表示、ディスクのフォーマット、などなどだ。Haskellのプログラムは決して手を汚すことはない（ただし、`unsafePerformIO`を呼び出す場合は除くが、それは別の話だ）。

当然、Haskellは遅延評価なので`main`はほとんど即座に戻り、純粋でない仕事はすぐに始まる。`IO`アクションの実行中に、純粋な計算の結果が要求され評価される。そのため、実際には、プログラムの実行では純粋な（Haskellの）コードと純粋でない（システムの）コードが折り重なっている。

`IO`モナドには別の解釈がある。さらに奇妙な解釈だが、数学モデルとしては完全な意味をなす。それは宇宙全体をプログラム中のオブジェクトとして扱う。概念として、命令型モデルは宇宙を外部のグローバルオブジェクトとして扱うため、入出力を実行する手続きにはそのオブジェクトとの相互作用による副作用が伴うことに着目してほしい。それらは宇宙の状態を読み取ることも変更することもできる。

関数プログラミングで状態を扱う方法はすでに知っている――Stateモナドを使えばよい。だが、宇宙の状態は単純ではないので、標準的なデータ構造では簡単に記述できない。しかし、直接扱わない限り、その必要はない。型`RealWorld`が存在し、宇宙工学の奇跡によってランタイムがこの型のオブジェクトを提供できる、と仮定すれば十分だ。`IO`作用はただの関数だ：

```haskell
type IO a  =  RealWorld -> (a, RealWorld)
```

あるいは、`State`モナドとしてはこうなる：

```haskell
type IO = State RealWorld
```

ただし、`IO`モナドの`>=>`と`return`は言語に組み込まれている必要がある。

### インタラクティブな出力

同じ`IO`モナドが、インタラクティブな出力をカプセル化するのにも使われる。`RealWorld`はすべての出力デバイスを含むと見なされる。なぜ単にHaskellから出力関数を呼び出して、何もしないふりをすることができないのか疑問に思うだろう。たとえば、なぜ次のように書くのだろう：

```haskell
putStr :: String -> IO ()
```

単純に次のように書くのではいけないのだろうか：

```haskell
putStr :: String -> ()
```

理由は2つある：Haskellは遅延評価なので、出力――ここではunitオブジェクト――が全く使われない関数は呼び出されない。また、遅延評価でなかったとしても、そのような呼び出しの順序は自由に変更でき、出力を混乱させうる。Haskellで2つの関数を強制的に逐次実行する唯一の方法はデータ依存性を使うことだ。ある関数の入力を別の関数の出力に依存させる必要がある。`IO`アクション間で`RealWorld`を受け渡せば逐次処理を強制できる。

概念としては、以下のプログラム：

```haskell
main :: IO ()
main = do
    putStr "Hello "
    putStr "World!"
```

では、「World!」と表示するアクションは「Hello」がすでに画面に表示されている宇宙を入力として受け取る。そして画面に「Hello World!」と表示された新しい宇宙を出力する。

## 結論

当然ながらここではモナドを使うプログラミングのほんの表面を撫でたにすぎない。モナドは、命令型プログラミングで副作用を使って通常行われることを純粋関数で行うだけでなく、高度な制御と型安全性を備えて実現している。だが、欠点がないわけではない。モナドへのよくある不満は、互いに簡単に合成できないことだ。だとしても、基本的なモナドのほとんどはモナドトランスフォーマーライブラリを使って結合できる。たとえば状態と例外を組み合わせたモナドスタックを作成するのは比較的簡単だ。ただし、任意のモナドをスタックするためのレシピはない。
