# モナドと計算効果

モナドが何のためにあるのかは理解できた。モナドによって、装飾された関数を合成できるようになる。本当に興味深い疑問は、なぜ装飾された関数が関数プログラミングにおいてそんなに重要なのかということだ。すでに1つの例については見た。`Writer`モナドだ。そこでは、装飾によって複数の関数呼び出しにわたってログを作成し累積できた。そうでもなければ非純粋関数 (impure function) を使って（たとえば、何らかのグローバルな状態にアクセスし変更することで）解決するような問題を、純粋関数を使って解決できたことになる。

## 問題

よく似た問題を集めた短いリストを、[エウジニオ・モッジの先駆的な論文](https://doi.org/10.1016/0890-5401(91)90052-4)^[*Notions of Computation and Monads*. Inf. Comput. 93(1): 55-92 (1991). <https://doi.org/10.1016/0890-5401(91)90052-4>]から転載して以下に示した。どれも伝統的には関数の純粋さを放棄することで解決される。

* 部分性：停止しない可能性のある計算
* 非決定性：複数の結果を返す可能性のある計算
* 副作用：状態にアクセス・変更する計算
   * 読み取り専用の状態、すなわち環境
   * 書き込み専用の状態、すなわちログ
   * 読み取り・書き込みの両方が可能な状態
* 例外：失敗する可能性があるような部分関数
* 継続：プログラムの状態を保存でき、要求に応じて復元できること
* インタラクティブな入力
* インタラクティブな出力

本当に驚くべきことに、これらすべての問題は1つの巧妙なトリックで解決できる。装飾された関数にするというトリックだ。もちろん、装飾は各ケースで全く違うものになる。

装飾がモナド的だという条件は、この段階では必要ないことを認識しておかなくてはならない。合成――1つの装飾された関数をより小さな装飾された関数に分解できること――を主張するとき、初めてモナドが必要になる。また、それぞれの装飾が違うため、モナド的な合成の実装方法もやはり違うものになるが、全体的なパターンは同じだ。非常に単純な、恒等射を伴った結合的な合成というパターンだ。

次節はHaskellでの例でいっぱいだ。圏論に戻りたい人や、Haskellによるモナドの実装にすでに慣れている人は、遠慮なく斜め読みしたり飛ばしたりして構わない。

## 解決策

まず、`Writer`モナドをどう使ったか分析してみよう。我々はまず、何らかのタスクを実行するような純粋関数――つまり、引数が与えられると何らかの結果を返す関数――から始めた。そして、この関数を、もとの出力を文字列とペアにすることで装飾する別の関数に置き換えた。これがログ生成の問題に対する我々の解決策だった。

それで終わりにできなかったのは、一般に、モノリシックな解決策は扱いたくないからだ。1つのログ生成関数をより小さなログ生成関数に分解できる必要があった。そして、こうした小さな関数の合成こそがモナドという概念への道標となった。

本当に驚くべきことは、関数の戻り値の型を装飾するという同一のパターンが、通常は純粋性を放棄する必要がある多種多様な問題に対して機能することだ。前述のリストのそれぞれの問題について、どのような装飾が適用されるかを順に確認していこう。

### 部分性

停止しない可能性のあるすべての関数について、戻り値の型を「持ち上げられた」型に変更する。その型はもとの型のすべての値および特別な「ボトム」値$\bot$を含む^[訳注：ボトムは停止しない計算結果を表す。]。
たとえば、集合としての`Bool`型は`True`と`False`の2つの要素を含む。持ち上げられた`Bool`は3つの要素^[訳注：`True`と`False`と$\bot$。]を含む。それに対し、持ち上げられた`Bool`を返す関数は、`True`または`False`を生成するか、永久に実行され続ける。

奇妙なのは、Haskellのような遅延評価言語では、終わりのない関数が実際に値を返す^[訳注：正確には、ボトムは終わりのない関数の結果を表す (denote) ものであり、少なくとも操作的な感覚では値 (value) ではない。]ことがあり、その値が次の関数に渡されうるということだ。
この特別な値をボトムと呼ぶ。この値が（たとえば、パターンマッチングに使うため、あるいは出力に使用されるため）明示的に必要とされているのでない限り、プログラムの実行を止めることなくこの値を渡せる。すべてのHaskellの関数は潜在的に停止しない関数であり得るため、Haskellのすべての型は持ち上げられているものであると仮定される。これが、単純な$\Set$ではなく、Haskellの（持ち上げられた）型と関数の圏$\Hask$について頻繁に議論する理由だ。もっとも、$\Hask$が本物の圏かどうかは明らかでない ([Andrej Bauerによる記事](http://math.andrej.com/2016/08/06/hask-is-not-a-category/)^[<http://math.andrej.com/2016/08/06/hask-is-not-a-category/>]を参照)。

### 非決定性

関数が複数の異なる結果を返すことがあるなら、一度にすべての結果を返す方がよいだろう。意味論的には、非決定的関数は結果のリストを返す関数と等価だ。これはガベージコレクションのある遅延評価言語では実に理に適っている。たとえば、必要な値が1つだけの場合はリストのheadだけを取得すればよく、このときtailが評価されることはない。ランダムな値が必要な場合は乱数ジェネレーターを使ってリストのn番目の要素を選択する。遅延評価では結果の無限リストを返すことさえ可能になる。

リストモナド――Haskellでの非決定的計算の実装[^non-deterministic]――では`join`は`concat`として実装されている。`join`の役割はコンテナーのコンテナーをフラット化することなのを思い出してほしい――`concat`はリストのリストを連接して1つのリストにする。また、`return`は単要素リストを作成する。

```haskell
instance Monad [] where
    join = concat
    return x = [x]
```

[^non-deterministic]: 監訳注：実装のひとつ。非決定的計算をリストモナドで表現するのは結果が無限である場合（より正確には有限であると確定できない場合）にうまく扱えない。たとえば、`xs`が無限リストのときに`concat [xs, ...] = xs`であり、先頭要素以降の情報が失われる。より具体的な例としては、後述の`triples`において最初の2行を`x <- [1..]`と`z <- [x..]`のように入れかえると期待どおりに動作しない（`x = 1`のケースのみ試みられることになる）。

    解決方法のひとつはSebastian FischerらのICFP 09論文 "Purely functional lazy non-deterministic programming" (<https://doi.org/10.1145/1596550.1596556>) で議論されている。

\noindent
リストモナドのbind演算子は、`fmap`の後に`join`が続くという一般的な解法により与えられる。より具体的には、今回のケースでは次のようになる。

```haskell
as >>= k = concat (fmap k as)
```

\noindent
ここで、関数`k`はそれ自体がリストを生成する関数で、リスト`as`のすべての要素に適用される。結果はリストのリストとなり、`concat`を使ってフラット化される。

プログラマーの観点では、リストの操作は比較的簡単であり、たとえば、非決定的関数をループの中で呼び出す、つまりイテレーターを返す関数を実装することの方が難しい (ただし、[近年のC++](http://ericniebler.com/2014/04/27/range-comprehensions/)^[<http://ericniebler.com/2014/04/27/range-comprehensions/>]では、遅延rangeを返すことがHaskellでリストを返すこととほぼ等価となる)。

非決定性が創造的に使われる好例はゲームプログラミングだ。たとえば、コンピューターが人間を相手にチェスをするとき、相手の次の手は予測できない。しかし、すべての可能な手のリストを生成して1つずつ分析はできる。同様に、非決定的な構文解析器は、与えられた式に対して可能なすべての構文解析結果のリストを生成できる。

リストを返す関数は非決定的だと解釈してもよいものの、リストモナドの応用範囲はもっと広い。リストを生成する計算をつなぎ合わせることは、命令型プログラミングで使われる反復構文――ループ――を関数プログラミングで完全に代替する手段だからだ。単一のループは、多くの場合`fmap`を使って書き直せる。fmapはループの本体をリストの各要素に適用する。リストモナドで`do`記法を使えば、複雑な多重ループを置き換えられる。

私のお気に入りの例は、ピタゴラス数 (Pythagorean triple) ――直角三角形の辺を形成できる3つの正の整数の組――を生成するプログラムだ。

```haskell
triples = do
    z <- [1..]
    x <- [1..z]
    y <- [x..z]
    guard (x^2 + y^2 == z^2)
    return (x, y, z)
```

\noindent
最初の行は、`z`が正の整数の無限リスト`[1..]`から要素を取得することを示している。次に`x`は、1から`z`までの整数の（有限）リスト`[1..z]`から要素を取得する。最後に`y`は、`x`から`z`までの整数のリストから要素を取得する。これで$1 \leqslant x \leqslant y \leqslant z$の3つの整数を自由に使える。関数`guard`は、`Bool`式を取り、unitのリストを返す。

```haskell
guard :: Bool -> [()]
guard True  = [()]
guard False = []
```

\noindent
この関数（`MonadPlus`というより大きなクラスのメンバー）は、ここでは非ピタゴラス数を除外するために使われる。実際、bind（または関連する演算子`>>`）の実装を見ると、空リストが与えられると空リストが生成されることに気付くだろう。一方、空でないリスト（ここではunitを含む単リスト`[()]`）が与えられた場合、bindは継続を呼ぶ。ここでは`return(x, y, z)`だ。これは検証済みのピタゴラス数を持つ単リストを生成する。これらの単リストはすべて、内包するbindによって連接され、最終的な（無限の）結果を生成する。当然、`triple`の呼び出し側はリスト全体を消費できないが、Haskellは遅延評価言語なので問題ない。

通常は3重にネストされたループを必要とする問題が、リストモナドと`do`記法のおかげで劇的に単純化された。それだけでは不十分と言わんばかりに、Haskellではこのコードをリスト内包表記を使ってさらに単純化する。

```haskell
triples = [(x, y, z) | z <- [1..]
                     , x <- [1..z]
                     , y <- [x..z]
                     , x^2 + y^2 == z^2]
```

\noindent
これはリストモナド（厳密に言えば、`MonadPlus`^[訳注：MonadComprehensions拡張を有効にしている場合。]）のためのさらなる糖衣構文だ。

他の関数型言語や命令型言語でも、ジェネレーターやコルーチンという名のもとに同様の構造が見られることがある。

### 読み取り専用の状態

外部の状態に対して読み取り専用でアクセス、すなわち環境にアクセスする関数は、その環境を追加の引数として取る関数に常に置き換え可能だ。純粋な関数`(a, e) -> b`（ここで、`e`は環境の型）は、一見したところ、クライスリ射のようには見えない。しかし、それを`a -> (e -> b)`にカリー化すれば、その装飾がお馴染みのreader関手なのがすぐ分かる。

```haskell
newtype Reader e a = Reader (e -> a)
```

\noindent
`Reader`を返す関数は、小さな実行可能なものを生成する関数である、と解釈できる。ここで、その実行可能なものは、環境が与えられると望んだ結果を生成するようなアクションだ。ヘルパー関数`runReader`はそのようなアクションを実行する。

```haskell
runReader :: Reader e a -> e -> a
runReader (Reader f) e = f e
```

\noindent
環境の値が異なれば得られる結果も異なりうる。

`Reader`を返す関数も`Reader`のアクションの実行自体も純粋であることに注意してほしい。

`Reader`モナド用のbind^[訳注：`bind :: (e -> a) -> (a -> e -> b) -> e -> b`]を実装するには、まず、環境`e`を取得して`b`を生成する関数を作る必要がある。

```haskell
ra >>= k = Reader (\e -> ...)
```

\noindent
ラムダ内では、アクション`ra`を実行して`a`を生成できる。

```haskell
ra >>= k = Reader (\e -> let a = runReader ra e
                         in ...)
```

\noindent
次に、`a`を継続`k`に渡せば新しいアクション`rb`が得られる。

```haskell
ra >>= k = Reader (\e -> let a  = runReader ra e
                             rb = k a
                         in ...)
```

\noindent
最後に、環境`e`を用いてアクション`rb`を実行できる。

```haskell
ra >>= k = Reader (\e -> let a  = runReader ra e
                             rb = k a
                         in runReader rb e)
```

\noindent
`return`を実装するには、環境を無視して値をそのまま返すアクションを作成すればよい。

いくつかの簡略化を経てまとめると、次の定義が得られる。

```haskell
instance Monad (Reader e) where
    ra >>= k = Reader (\e -> runReader (k (runReader ra e)) e)
    return x = Reader (\e -> x)
```

### 書き込み専用の状態

これは最初に例にしたログ生成と同じだ。装飾は`Writer`関手によって与えられる。

```haskell
newtype Writer w a = Writer (a, w)
```

\noindent
完全を期すため、データ構成子をアンパックする小さなヘルパー関数`runWriter`も示そう。

```haskell
runWriter :: Writer w a -> (a, w)
runWriter (Writer (a, w)) = (a, w)
```

\noindent
すでに見たとおり、`Writer`を合成可能にするには、`w`はモノイドでなければならない。bind演算子版の`Writer`の`Monad`インスタンスを以下に示す。

```haskell
instance (Monoid w) => Monad (Writer w) where
    (Writer (a, w)) >>= k = let (a', w') = runWriter (k a)
                            in Writer (a', w `mappend` w')
    return a = Writer (a, mempty)
```

### 状態

状態へ読み取り/書き込みアクセスする関数は、`Reader`と`Writer`の装飾を組み合わせる。それらは、追加の引数として状態を受け取り、結果として値/状態のペアを生成する純粋関数 `(a, s) -> (b, s)` と見なせる。カリー化すると、それらはクライスリ射`a -> (s -> (b, s))`の形になり、装飾は`State`関手へと抽象化される。

```haskell
newtype State s a = State (s -> (a, s))
```

\noindent
ここでも、クライスリ射は作用を返すものと見なせて、次のヘルパー関数を使って実行できる。

```haskell
runState :: State s a -> s -> (a, s)
runState (State f) s = f s
```

\noindent
初期状態が異なると、結果が異なりうるだけでなく、最終状態も異なりうる。

`State`モナドに対するbindの実装は`Reader`モナドの実装と非常によく似ている。ただし、各ステップで正しい状態を渡すように注意する必要がある。

```haskell
sa >>= k = State (\s -> let (a, s') = runState sa s
                            sb = k a
                        in runState sb s')
```

\noindent
インスタンス全体は次のとおりだ。

```haskell
instance Monad (State s) where
    sa >>= k = State (\s -> let (a, s') = runState sa s
                            in runState (k a) s')
    return a = State (\s -> (a, s))
```

\noindent
状態を操作するために使えるクライスリ射が2つある。そのうちの1つは状態を調べるために取得する。

```haskell
get :: State s s
get = State (\s -> (s, s))
```

\noindent
もう1つは状態を全く新しいものに置き換える。

```haskell
put :: s -> State s ()
put s' = State (\s -> ((), s'))
```

### 例外

例外をスローする命令型関数は、実際には部分関数――引数の値のいくつかに対して定義されていない関数だ。例外を純粋全域関数として実装する最も単純なやり方は`Maybe`関手を使うものだ。これによって部分関数を、定義されているときは`Just a`、そうでないときは`Nothing`を返すような全域関数へと拡張できる。失敗の原因に関する何らかの情報も返したい場合は、`Maybe`の代わりに`Either`関手を使える（ただし、第1の型はたとえば`String`などに固定する）。

以下は`Maybe`の`Monad`インスタンスだ。

```haskell
instance Monad Maybe where
    Nothing >>= k = Nothing
    Just a  >>= k = k a
    return a = Just a
```

\noindent
`Maybe`についてのモナド的な合成では、エラーが検出されたときは計算がきちんと短絡評価される（継続`k`が決して呼ばれない）ことに注意してほしい。これは例外に期待される振る舞いだ。

### 継続

これは「電話はしないでください、こちらから電話しますので！」という、採用面接の後に経験しそうな状況を表す^[訳注：プログラミングの文脈では、この台詞には「ハリウッドの原則」という名前が付いている。電話することと関数を呼び出すことが同じcallという動詞で表されることに基づく駄洒落。]。回答を直接得る代わりに、ユーザーはハンドラー（計算結果を引数として呼ばれる関数）を渡す。このスタイルのプログラミングが特に役立つのは、呼び出し時点ではすぐに結果が分からない場合だ。たとえば、別のスレッドで評価される場合や、リモートのウェブサイトから配信される場合などだ。この場合のクライスリ射はハンドラーを受け取るような関数を返し、そのハンドラーは「残りの計算」［訳注：つまり、継続］を表す。

```haskell
data Cont r a = Cont ((a -> r) -> r)
```

\noindent
このハンドラー`a -> r`は、いずれ呼び出されると型`r`の結果を生成し、その結果が［訳注：クライスリ射が返す関数から］最終的に返されることになる。継続は結果の型によってパラメーター化される。（実用上は、この結果の型はある種のステータスインジケーターを表す場合が多い。）

クライスリ射から返されたアクションを実行するためのヘルパー関数もある。それはハンドラーを取得して継続に渡す。

```haskell
runCont :: Cont r a -> (a -> r) -> r
runCont (Cont k) h = k h
```

\noindent
継続の合成は非常に難しいことで知られており、それゆえモナドや、特に`do`記法による処理は非常に有利だ。

bindの実装について説明しよう。まず、余計なものを取り払ったシグネチャーに注目する。

```haskell
(>>=) :: ((a -> r) -> r) ->
         (a -> (b -> r) -> r) ->
         ((b -> r) -> r)
```

\noindent
目標は、ハンドラー`(b -> r)`を受け取って結果`r`を生成する関数を作成することだ。そこで出発点はこうなる。

```haskell
ka >>= kab = Cont (\hb -> ...)
```

\noindent
このラムダの内部で、`ka`関数を、残りの計算を表す適切なハンドラーを添えて呼び出したい。そのハンドラーはラムダとして実装することにする。

```haskell
runCont ka (\a -> ...)
```

\noindent
この場合において、残りの計算は、まず`kab`を`a`で呼び出し、次に`hb`を結果の作用`kb`に渡すことを伴う。

```haskell
runCont ka (\a -> let kb = kab a
                  in runCont kb hb)
```

\noindent
ご覧のとおり、継続は裏返しに合成されている。最終的なハンドラー`hb`は、計算の最も内側の層から呼び出される。インスタンス全体は次のとおりだ。

```haskell
instance Monad (Cont r) where
    ka >>= kab = Cont (\hb -> runCont ka (\a -> runCont (kab a) hb))
    return a = Cont (\ha -> ha a)
```

### インタラクティブな入力

これは最も厄介な問題であり、多くの混乱の源だ。明らかに、`getChar`のような関数は、キーボードから入力された文字を返すとしたら、純粋ではあり得ない。しかし、その関数が文字をコンテナーで包んで返すとしたらどうだろう？　そのコンテナーから文字を取り出す方法がない限り、この関数は純粋であると主張できる。`getChar`を呼び出すたびに、全く同じコンテナーが返される。概念としては、このコンテナーには可能な文字すべての重ね合わせが含まれる。

量子力学に馴染みがあれば、この比喩を問題なく理解できるだろう。これはシュレーディンガーの猫が入った箱のようなものだ――ただし、箱を開けたり中を覗いたりする方法はない。この箱は、組み込みの特別な`IO`関手を使って定義される。この例では`getChar`をクライスリ射として宣言できる。

```haskell
getChar :: () -> IO Char
```

\noindent
（実際には、unit型を取る関数は戻り値の型の値を選択するのと等価なので、`getChar`の宣言は単純に`getChar :: IO Char`となる。）

`IO`は関手なので`fmap`を使って中身を操作できる。また、関手として、文字だけでなく任意の型の中身を保持できる。このアプローチの真の有用性が明らかになるのは、Haskellでの`IO`がモナドなのを考慮したときだ。これは`IO`オブジェクトを生成するクライスリ射を合成できることを意味する。

クライスリ合成を使えば、`IO`オブジェクトの内容を覗き見できると思うかもしれない（またも量子力学で比喩すると「波動関数を収縮させる」ことにあたる）。実際、`getChar`は、文字を受け取る別のクライスリ射と合成できる。たとえば、受け取った文字を整数に変換するようなものと合成できる。問題は、そのような2番目のクライスリ射は整数を`(IO Int)`としてしか返せないということだ。ここでも、最終的に得られるのはすべての可能な整数の重ね合わせとなる。以下同様だ。シュレーディンガーの猫は決して外に出ない。`IO`モナドに入ると、抜け出す方法はない。`IO`モナドについて`runState`や`runReader`と同等のものはない。`runIO`はないのだ！

では、クライスリ射の結果である`IO`オブジェクトを、他のクライスリ射と合成する以外に何ができるだろう？　ええと、`main`から返せる。Haskellでは`main`は次のシグネチャーを持つ。

```haskell
main :: IO ()
```

\noindent
そしてこれはクライスリ射と見なして構わない。

```haskell
main :: () -> IO ()
```

\noindent
この観点からは、Haskellのプログラムは`IO`モナドにおける1つの大きなクライスリ射にすぎない。そうした射はモナド的な合成を使えば複数の小さなクライスリ射から合成できる。生成された`IO`オブジェクト（`IO`アクションとも呼ばれる）で何を行うかはランタイムシステム次第だ。

射自体が純粋関数であることに注目してほしい――それは一貫して純粋関数だ。純粋でない仕事は処理系へと追いやられている。`main`から返された`IO`アクションを最終的に実行するとき、あらゆる種類の汚れ仕事が行われる。たとえば、ユーザー入力の読み取り、ファイルの変更、不愉快なメッセージの表示、ディスクのフォーマット、などなどだ。Haskellのプログラムは決して手を汚すことはない（ただし、`unsafePerformIO`を呼び出す場合は除くが、それは別の話だ）。

当然、Haskellは遅延評価なので`main`はほとんど即座に戻り、純粋でない仕事は即座に始まる。純粋な計算の結果が要求され評価されるのは`IO`アクションの実行中なのだ。そのため、実際には、プログラムの実行では純粋な（Haskellの）コードと純粋でない（処理系の）コードが折り重なっている。

`IO`モナドには別の解釈がある。さらに奇妙な解釈だが、数学モデルとしては完全な意味をなす。それは宇宙全体をプログラム中のオブジェクトとして扱う。概念として、命令型モデルは宇宙を外部のグローバルオブジェクトとして扱うため、I/Oを実行する手続きにはそのオブジェクトとの相互作用によるところの副作用が伴うことに着目してほしい。それらの手続きは宇宙の状態を読み取りも変更もしうる。

関数プログラミングで状態を扱う方法はすでに知っている――Stateモナドを使えばよい。だが、単純な状態とは違って、宇宙の状態は標準的なデータ構造では簡単に記述できない。しかし、直接扱わない限り、その必要はない。型`RealWorld`が存在し、宇宙工学の奇跡によってランタイムがこの型のオブジェクトを提供できる、と仮定すれば十分だ。`IO`作用はただの関数だ。

```haskell
type IO a  =  RealWorld -> (a, RealWorld)
```

\noindent
あるいは、`State`モナドとしてはこうなる。

```haskell
type IO = State RealWorld
```

\noindent
ただし、`IO`モナドの`>=>`と`return`は言語に組み込まれている必要がある。

### インタラクティブな出力

同じ`IO`モナドが、インタラクティブな出力をカプセル化するのにも使われる。`RealWorld`はすべての出力デバイスを含むと見なされる。なぜ単にHaskellから出力関数を呼び出して、それが何もしないものであるかのようなふりをできないのか疑問に思うだろう。たとえば、なぜ次のように書くのだろう。

```haskell
putStr :: String -> IO ()
```

\noindent
単純に次のように書くのではいけないのだろうか。

```haskell
putStr :: String -> ()
```

\noindent
理由は2つある：Haskellは遅延評価なので、出力――ここではunitオブジェクト――が全く使われない関数は呼び出されない。また、遅延評価でなかったとしても、そのような呼び出しの順序は自由に変更でき、出力を混乱させうる。Haskellで2つの関数を強制的に逐次実行する唯一の方法はデータ依存性を使うことだ。ある関数の入力を別の関数の出力に依存させる必要がある。`IO`アクション間で`RealWorld`を受け渡せば逐次処理を強制できる。

概念としては、以下のプログラム：

```haskell
main :: IO ()
main = do
    putStr "Hello "
    putStr "World!"
```

\noindent
では、「World!」と表示するアクションは「Hello」がすでに画面に表示されている宇宙を入力として受け取る。そして画面に「Hello World!」と表示された新しい宇宙を出力する。

## 結論

当然ながらここではモナドを使うプログラミングのほんの表面を撫でたにすぎない。モナドは、命令型プログラミングで副作用を使って通常行われることを純粋関数で単に実現するのではなく、高度な制御と型安全性を備えて実現している。だが、欠点がないわけではない。モナドへのよくある不満は、モナド同士を簡単に合成できないことだ。だとしても、基本的なモナドのほとんどはモナド変換子ライブラリー (Monad transformer library) ^[訳注：<https://hackage.haskell.org/package/mtl>]を使って結合できる。たとえば状態と例外を組み合わせたモナドスタックを作成するのは比較的簡単だ。ただし、任意のモナドをスタックするためのレシピはない。
