# モナドの代数 {#algebras-for-monads}

もし自己関手を式の定義方法だと解釈するなら、代数は式の評価、モナドは式の形成と操作だということになる。代数とモナドを組み合わせることで、多くの機能が得られるだけでなく、いくつかの興味深い質問にも答えられる。そのような疑問の1つはモナドと随伴の関係に関するものだ。これまで見てきたように、すべての随伴はモナド（およびコモナド）を[定義する](#monads-categorically)。問題は、すべてのモナド（コモナド）は随伴から導出できるのかということだ。できる、というのが答えだ。任意のモナドを生成する随伴の族が存在する。そのような随伴を2つ紹介する。

![](images/pigalg.png){width=25%}

定義を確認しよう。モナドは、あるコヒーレンス条件を満たす2つの自然変換を伴う自己関手$m$だ。それらの変換の$a$におけるコンポーネントは次のとおりだ：

$$
\begin{aligned}
\eta_a &\Colon a \to m\ a \\
\mu_a &\Colon m\ (m\ a) \to m\ a
\end{aligned}
$$

同じ自己関手についての代数は、ある特定の対象の選択――台$a$――であり、次の射を伴う：

$$\mathit{alg} \Colon m\ a \to a$$

まず注目すべきは、代数が$\eta_aa$とは逆向きに進んでいることだ。直観では、$\eta_a$は型$a$の値から自明な式を作る。第1のコヒーレンス条件は、代数をモナドと互換性のあるものにするものであり、台が$a$であるその代数でこの式を評価するともとの値が返されることを保証する：

$$\mathit{alg} \circ \eta_a = \id_a$$

第2の条件は、2重にネストされた式$m\ (m\ a)$ を評価する方法は2つある、という事実に基づく。まず$\mu_a$を適用して式をフラット化してから、次に代数の評価子を使えばよい。あるいは、リフトされた評価子を適用して内側の式を評価してから、その結果に評価子を適用してもよい。これら2つの戦略を等価にしたい：

$$\mathit{alg} \circ \mu_a = \mathit{alg} \circ m\ \mathit{alg}$$

ここで、射`m alg`は関手$m$を使って$\mathit{alg}$をリフトした結果だ。次の可換図式はこれら2つの条件を示している（後のことを想定して$m$を$T$に置き換えた）：

![](images/talg1.png)

![](images/talg2.png)

これらの条件はHaskellでも表現できる：

```haskell
alg . return = id
alg . join = alg . fmap alg
```

簡単な例を見てみよう。リスト自己関手の代数は、ある型`a`と、`a`のリストから`a`を生成する関数とで構成される。この関数は`foldr`を使って表せる。そのためには、要素の型とアキュムレータの型を、両方とも同じ`a`になるように選ぶ：

```haskell
foldr :: (a -> a -> a) -> a -> [a] -> a
```

この特定の代数は、引数が2つの関数`f`と値`z`によって指定される。list関手はモナドでもあり、`return`は値を単要素リストに変換する。代数の合成は、ここでは`foldr f z`であり、`return`の後で`x`を取る：

```haskell
foldr f z [x] = x `f` z
```

ただし、`f`の作用を中置記法で表した。代数がモナドと互換性があるのは、すべての`x`に対して次のコヒーレンス条件が満たされる場合だ：

```haskell
x `f` z = x
```

`f`を二項演算子と見なすと、この条件は`z`が右単位元であることを示している。

第2のコヒーレンス条件は、リストのリストに対して作用する。`join`の作用は個々のリストを連結する。その後で結果のリストを畳み込めばよい。一方で、まず個々のリストを畳み込み、次に結果のリストを畳み込んでもよい。ここでも、`f`を二項演算子と見なすと、この条件はその二項演算の結合性を示している。これらの条件は`(a, f, z)`がモノイドである場合には確実に満たされる。

## T-代数

数学者はモナドを$T$と呼ぶのを好むので、それらと互換性のある代数をT-代数と呼ぶ。圏$\cat{C}$における任意のモナド$T$についてのT-代数は圏を形成する。この圏はEilenberg-Moore圏と呼ばれ、$\cat{C}^T$と表記されることが多い。この圏の射は代数の準同型だ。それらはF-代数について定義されているのを見たのと同じ準同型だ。

T-代数は台対象と評価子からなるペア $(a, f)$ だ。$\cat{C}^T$から$\cat{C}$への自明な忘却関手$U^T$が存在し、$(a, f)$ を$a$に写す。また、T-代数の準同型を、$\cat{C}$内の台対象間の射のうち対応するものに写す。随伴について議論したとき、忘却関手への左随伴は自由関手と呼ばれると述べたのを覚えているだろう。

$U^T$への左随伴は$F^T$と呼ばれる。それは$\cat{C}$内の対象$a$を$\cat{C}^T$内の自由代数に写す。この自由代数の台は$T\ a$だ。その評価子は$T\ (T\ a)$ から$T\ a$へ戻る射だ。$T$はモナドなので、モナディックな$\mu_a$（Haskellでの`join`）を評価子として使える。

さらに、これがT-代数であることも示す必要がある。そのためには、次の2つのコヒーレンス条件が満たされなければならない：

$$
\begin{aligned}
\mathit{alg} &\circ \eta_{Ta} = \id_{Ta} \\
\mathit{alg} &\circ \mu_a = \mathit{alg} \circ T\ \mathit{alg}
\end{aligned}
$$

しかし、$\mu$を代数に代入すれば、これらはモナド則にすぎない。

ご存知のように、すべての随伴はモナドを定義する。$F^T$と$U^T$の間の随伴は、Eilenberg-Moore圏の構成で使われたモナド$T$そのものを定義することが分かる。この構成はすべてのモナドに対して行えるので、すべてのモナドは随伴から生成できる、と結論できる。後ほど、同じモナドを生成する別の随伴が存在することを示す。

計画はこうだ：まず、$F^T$が実際に$U^T$の左随伴であることを示す。そのために、この随伴の単位と余単位を定義し、対応する三角恒等式が満たされているのを証明する。次に、この随伴によって生成されるモナドが、実際にもとのモナドであることを示す。

随伴の単位は次の自然変換だ：

$$\eta \Colon I \to U^T \circ F^T$$

この変換の$a$におけるコンポーネントを計算してみよう。恒等関手によって$a$が得られる。自由関手は自由代数 $(T\ a, \mu_a)$ を生成し、忘却関手はそれを$T\ a$に縮約する。以上により、$a$から$T\ a$への写像が得られる。単にモナド$T$の単位をこの随伴の単位として使うことにする。

余単位を見てみよう：

$$\varepsilon \Colon F^T \circ U^T \to I$$

あるT-代数 $(a, f)$ におけるコンポーネントを計算してみよう。忘却関手は$f$を忘れており、自由関手はペア $(T\ a, \mu_a)$ を生成する。したがって、$(a, f)$ における余単位$\varepsilon$を定義するには、Eilenberg-Moore圏内の正しい射、すなわち次のようなT-代数の準同型が必要だ：

$$(T\ a, \mu_a) \to (a, f)$$

このような準同型は台$T\ a$を$a$に写す必要がある。忘れられた評価子$f$を復活させよう。今度はそれをT-代数の準同型として使う。実際、$f$をT-代数にしたのと同じ可換図式は、それがT-代数の準同型だと示すものとも見なせる：

![](images/talg31.png)

したがって、$(a, f)$（T-代数の圏の対象）における余単位の自然変換のコンポーネント$\varepsilon$を$f$と定義した。

随伴を完成させるには、単位と余単位が三角恒等式を満たすことも示す必要がある。それらの三角形はこう描ける：

![](images/talg4.png)

最初のものはモナド$T$の単位則より成り立つ。2つ目のものはT-代数の規則 $(a, f)$ だ。

以上より、これら2つの関手が随伴を形成することが示せた：

$$F^T \dashv U^T$$

すべての随伴はモナドを生成する。往復旅行

$$U^T \circ F^T$$

は、対応するモナドを生成する$\cat{C}$内の自己関手だ。対象$a$に対する作用を見てみよう。$F^T$によって作られる自由代数は $(T\ a, \mu_a)$ だ。忘却関手$U^T$は評価子を削除する。したがって、確かに次が得られる：

$$U^T \circ F^T = T$$

予想どおり、随伴の単位はモナド$T$の単位だ。

随伴の余単位では次の式からモナディックな乗算が生成されるのを覚えているだろう：

$$\mu = R \circ \varepsilon \circ L$$

これは3つの自然変換の水平合成であり、そのうち2つは恒等自然変換で、$L$を$L$に写すものと$R$を$R$に写すものだ。真ん中のものは余単位で、ある代数 $(a, f)$ におけるコンポーネントが$f$であるような自然変換だ。

コンポーネント$\mu_a$を計算してみよう。まず、$\varepsilon$を$F^T$の後に水平合成すると、$F^T\ a$における$\varepsilon$のコンポーネントが得られる。$F^T$は$a$を代数 $(T\ a, \mu_a)$ に渡し、$\varepsilon$は評価子を選択するので、結果は$\mu_a$になる。$U^T$による左側の水平合成は何も変更しない。なぜなら、射に対する$U^T$の作用は自明だからだ。したがって、実際に、随伴から得られる$\mu$はもとのモナド$T$の$\mu$と同じだ。

## Kleisli圏

Kleisli圏についてはすでに見た。別の圏$\cat{C}$とモナド$T$で構成された圏だ。これを圏$\cat{C}_T$と呼ぼう。Kleisli圏$\cat{C}_T$の対象は$\cat{C}$の対象だが、射については違う。Kleisli圏での$a$から$b$への射$f_{\cat{K}}$は、もとの圏での$a$から$T\ b$への射$f$に対応する。この射$f$を$a$から$b$へのKleisli矢と呼ぶ。

Kleisli圏における射の合成はKleisli矢のモナディック合成によって定義される。例として、$g_{\cat{K}}$を$f_{\cat{K}}$の後に合成するとする。Kleisli圏において：

$$
\begin{gathered}
f_{\cat{K}} \Colon a \to b \\
g_{\cat{K}} \Colon b \to c
\end{gathered}
$$

のとき、圏$\cat{C}$において対応するものは、次のとおりだ：

$$
\begin{gathered}
f \Colon a \to T\ b \\
g \Colon b \to T\ c
\end{gathered}
$$

次のような合成：

$$h_{\cat{K}} = g_{\cat{K}} \circ f_{\cat{K}}$$

を$\cat{C}$でのKleisli矢として定義する。

$$
\begin{aligned}
h &\Colon a \to T\ c \\
h &= \mu \circ (T\ g) \circ f
\end{aligned}
$$

Haskellでは次のように記述できる：

```haskell
h = join . fmap g . f
```

$\cat{C}$から$\cat{C}_T$への関手$F$があり、対象に対しては自明な働きをする。射に対しては、$f$の戻り値を装飾するKleisli射を作成することによって、$\cat{C}$の$f$を$\cat{C}_T$の射に写す。次のような射が与えられたとき：

$$f \Colon a \to b$$

$\cat{C}_T$には、次の対応するKleisli矢を持つ射ができる：

$$\eta \circ f$$

Haskellでは次のように記述できる：

```haskell
return . f
```

また、$\cat{C}_T$から$\cat{C}$へ戻る関手$G$も定義できる。それはKleisli圏から対象$a$を取り、$\cat{C}$の対象$T\ a$に写す。次のKleisli矢に対応する射$f_{\cat{K}}$に対する作用：

$$f \Colon a \to T\ b$$

は$\cat{C}$内の射：

$$T\ a \to T\ b$$

であり、まず$f$をリフトしてから$\mu$を適用することで得られる：

$$\mu_{T b} \circ T\ f$$

Haskellの記法だと次のようになる：

<div class="sourceCode"><pre
class="sourceCode haskell"><code class="sourceCode haskell">G f<sub>T</sub> = join . fmap f</code></pre></div>

これはモナディックなバインドの`join`に基づく定義に見えるだろう。

2つの関手が随伴を形成しているのは容易に理解できる：

$$F \dashv G$$

そして、それらの合成$G \circ F$はもとのモナド$T$を再現する。

したがって、これは同じモナドを生成する2番目の随伴だ。実際、$\cat{Adj}(\cat{C}, T)$ という随伴全体の圏が存在し、その結果、$\cat{C}$において同じモナド$T$が生成される。その圏では、いま見たKleisli随伴が始対象で、Eilenberg-Moore随伴が終対象だ。

## コモナドの余代数

同様の構成は任意の[コモナド](#comonads)$W$に対して行える。コモナドが成立する余代数の圏を定義できる。それらの余代数は次の図式を可換にする：

![](images/talg5.png)

ここで、$\mathit{coa}$は台が$a$である余代数の余評価射 (coevaluation morphism) だ：

$$\mathit{coa} \Colon a \to W\ a$$

そして、$\varepsilon$と$\delta$はコモナドを定義する2つの自然変換だ（Haskellでは、これらのコンポーネントは`extract`および`duplicate`と呼ばれる）。

これらの余代数の圏から$\cat{C}$へは自明な忘却関手$U^W$が存在する。それはただ余評価を忘れている。その右随伴$F^W$について考えよう。

$$U^W \dashv F^W$$

忘却関手のこの右随伴は余自由関手 (cofree functor) と呼ばれる。$F^W$は余自由余代数 (cofree coalgebra) を生成する。それは$\cat{C}$内の対象$a$に余代数 $(W\ a, \delta_a)$ を割り当てる。随伴はもとのコモナドを合成$F^W \circ U^W$として再生成する。

同様に、余Kleisli矢から余Kleisli圏を構築し、対応する随伴からコモナドを再生成できる。

## レンズ

レンズの話に戻ろう。レンズは余代数を使って書ける：

$$\mathit{coalg_s} \Colon a \to \mathit{Store}\ s\ a$$

ここで関手$\mathit{Store}\ s$は次のとおりだ：

```haskell
data Store s a = Store (s -> a) s
```

この余代数は、以下の関数のペアとしても表せる：

$$
\begin{aligned}
set &\Colon a \to s \to a \\
get &\Colon a \to s
\end{aligned}
$$

($a$は「すべて」(all) を表し、$s$はその「小さな」(small) 一部だと考えてほしい)。このペアに関して、次が成り立つ：

$$\mathit{coalg_s}\ a = \mathit{Store}\ (\mathit{set}\ a)\ (\mathit{get}\ a)$$

ここで、$a$は型$a$の値だ。部分適用された`set`は関数$s \to a$であることに注意してほしい。

また、$\mathit{Store}\ s$がコモナドなのも分かっている。

```haskell
instance Comonad (Store s) where
  extract (Store f s) = f s
  duplicate (Store f s) = Store (Store f) s
```

問題は、あるレンズがこのコモナドの余代数になる条件は何かということだ。第1のコヒーレンス条件：

$$\varepsilon_a \circ \mathit{coalg} = \idarrow[a]$$

は、次のように解釈できる：

$$set\ a\ (get\ a) = a$$

このレンズ則は、構造体$a$のフィールドを以前の値に設定しても何も変わらないという事実を表す。

第2の条件：

$$\mathit{fmap}\ \mathit{coalg} \circ \mathit{coalg} = \delta_a \circ \mathit{coalg}$$

は、もう少し手間がかかる。まず、`store`関手の`fmap`の定義を思い出してほしい：

```haskell
fmap g (Store f s) = Store (g . f) s
```

`fmap coalg`を`coalg`の結果に適用すると、次のようになる：

```haskell
Store (coalg . set a) (get a)
```

一方、`duplicate`を`coalg`の結果に適用すると、次のようになる：

```haskell
Store (Store (set a)) (get a)
```

これら2つの式が等しくなるには、`Store`の下の2つの関数はどのような`s`に作用しても等しくなければならない。

```haskell
coalg (set a s) = Store (set a) s
```

`coalg`を展開すると、次が得られる：

```haskell
Store (set (set a s)) (get (set a s)) = Store (set a) s
```

これは残り2つのレンズ則と等価だ。1つ目：

```haskell
set (set a s) = set a
```

は、フィールドの値を2回設定するのは1回設定するのと同じだと示している。2つ目：

```haskell
get (set a s) = s
```

は、$s$に設定されたフィールドの値を取得すると$s$が返されることを示す。

言い換えれば、行儀の良いレンズはまさに`store`関手のコモナド余代数だ。

## 課題

1. 自由関手$F \Colon C \to C^T$の射に対する作用は何か。ヒント：モナディックな$\mu$について自然性条件を使う。
2. 次の随伴を定義せよ：

   $$U^W \dashv F^W$$

3. 上記の随伴がもとのコモナドを再現するのを証明せよ。
