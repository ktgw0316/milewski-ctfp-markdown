# モナド：プログラマーの定義

プログラマーたちは、モナドにまつわる神話を発展させてきた。これはプログラミングにおける極めて抽象的で難しい概念の1つだと考えられている。「わかっている」人とそうでない人がいる。多くの人にとって、モナドの概念を理解した瞬間はあたかも神秘的な体験のようだ。モナドは非常に多様な構成の本質を抽象化しているので、日常生活でうまく比喩できるものがない。そして我々は暗闇の中で手探りするようになった。まるで盲人たちが象の様々な部分に触れて「ロープだ」「木の幹だ」「ブリトーだ！」と勝ち誇って叫ぶように。

はっきり言っておこう。モナドを取り巻く神秘主義はすべて誤解に基づいている。モナドはとてもシンプルな概念だ。混乱を引き起こしているのは、モナドの応用先の多様さだ。

この記事のための調査の一環として、私はダクトテープ（別名ダックテープ）とその応用先について調べた。それを使ってできることのほんの一例を紹介しよう：

* ダクトをシーリングする
* アポロ13号に搭載された二酸化炭素除去装置を修理する
* いぼを治療する
* アップルのiPhone 4の通話切断問題を修正する
* プロムで着るドレスを作る
* 吊り橋を建設する

ダクトテープが何か知らずに、このリストに基づいて理解しようとしているのを想像してほしい。幸運を祈る！


そういうわけで、「モナドは……のようなものだ」という常套句のコレクションにもう1つ追加しようと思う：モナドはダクトテープのようなものだ。応用は幅広く多様だが、原理はごく単純だ：モナドは物同士をくっつける。より正確には、物同士を合成する。

このことは、多くのプログラマー、特に命令型言語をバックグラウンドに持つプログラマーがモナドを理解するのに困難が伴う理由の一部を説明している。問題は、プログラミングを関数合成の観点から考えるのに慣れていないことにある。これは理解できる。関数から関数へ値を直接渡さずに、中間値に名前を付けるのはよくあることだ。グルーコードの短い断片を、ヘルパー関数に抽象化せず、インライン化することもよくある。以下は、ベクトルの長さを求める関数をC言語で命令型スタイルで実装したものだ：

```c
double vlen(double *v) {
    double d = 0.0;
    int n;
    for (n = 0; n < 3; ++n)
        d += v[n]* v[n];
    return sqrt(d);
}
```

これを、明示的な関数合成を用いた（様式化された）Haskell版と比較してほしい：

```haskell
vlen = sqrt . sum . fmap  (flip (^) 2)
```

(ここでは、より謎めかせるために、指数演算子`(^)`の2番目の引数を`2`に設定して部分適用した。)

Haskellのポイントフリースタイルが常に優れていると主張しているのではなく、プログラミングで行うことのすべての基礎に関数合成があると主張しているだけだ。そして実質的には関数を合成しているにもかかわらず、Haskellでは多大な労力を費やして`do`記法と呼ばれる命令型構文をモナディック合成のために提供している。その使い方については後で説明する。まずは、なぜモナディック合成が必要なのか説明しよう。

## Kleisli圏

以前、通常の関数を装飾することで[Writerモナド](#writer_monad)に到達した。装飾するために、典型的には、戻り値を文字列とペアにした。あるいはもっと一般には、モノイドの要素とペアにした。いまではそのような装飾が関手だと気付ける：

```haskell
newtype Writer w a = Writer (a, w)

instance Functor (Writer w) where
    fmap f (Writer (a, w)) = Writer (f a, w)
```

続いて、以下の形式の装飾された関数すなわちKleisli矢 (Kleisli arrow) を合成する方法を発見した：

```haskell
a -> Writer w b
```

ログの累積は合成の内部で実装した。

これでKleisli圏をより一般的に定義する準備ができた。まずは圏$\cat{C}$と自己関手$m$から始める。対応するKleisli圏$\cat{K}$は$\cat{C}$と同じ対象を持つが、射は異なる。$\cat{K}$内の2つの対象$a$と$b$の間の射は次のように実装される：

$$a \to m\ b$$

これはもとの圏$\cat{C}$内の射だ。$\cat{K}$内のKleisli矢は$a$と$b$の間の射として扱い、$a$と$m\ b$の間の射としては扱わないことを覚えておくのが重要だ。

この例では、$m$は`Writer w`に特化されており、ある決まったモノイド`w`に対応している。

Kleisli矢は、それに適した合成を定義できるときだけ圏を形成する。すべての対象に対して恒等射を持ち結合的な合成がある場合、関手$m$は[モナド]{.keyword #monad} (monad) と呼ばれ、その結果形成される圏はKleisli圏と呼ばれる。

Haskellでは、Kleisli合成はfish演算子`>=>`を用いて定義され、その恒等射は`return`と呼ばれる多相関数だ。Kleisli合成を使ったモナドの定義は次のとおりだ：

```haskell
class Monad m where
    (>=>) :: (a -> m b) -> (b -> m c) -> (a -> m c)
    return :: a -> m a
```

モナドを定義する方法には同等のものがいくつもあり、これがHaskellエコシステムでの主要な方法ではないことを覚えておいてほしい。この方法の概念の簡潔さと得られる直観は気に入っているが、プログラミングの際に便利な定義は他にもある。それらについて少し話そう。

この定式化ではモナド則を非常に簡単に表現できる。Haskellではモナド則を強制できないが、等式推論には使える。それらは単にKleisli圏の標準的な合成則だ：

```haskell
(f >=> g) >=> h = f >=> (g >=> h) -- 結合性
return >=> f = f                  -- 左単位元
f >=> return = f                  -- 右単位元
```

この種の定義はモナドが本当は何なのかも表している。つまり、モナドは装飾された関数を合成する方法なのだ。副作用や状態は関係ない。関係あるのは合成だ。後で見るように、装飾された関数はさまざまな作用や状態を表現するために使われることがあるが、モナドはそのためのものではない。モナドは粘着力のあるダクトテープで、装飾された関数の一端を別の装飾された関数の一端につなぐ。

`Writer`の例に戻ろう：ログ生成関数（`Writer`関手でのKleisli矢）は圏を形成する。なぜなら、`Writer`はモナドだからだ。

```haskell
instance Monoid w => Monad (Writer w) where
    f >=> g = \a ->
        let Writer (b, s)  = f a
            Writer (c, s') = g b
        in Writer (c, s `mappend` s')
    return a = Writer (a, mempty)
```

`Writer w`のモナド則は、`w`のモノイド則が満たされている限り満たされる（これらもHaskellでは強制できない）。

`Writer`モナド用に便利なKleisli矢が定義されており、`tell`と呼ばれる。その唯一の目的は引数をログに追加することだ：

```haskell
tell :: w -> Writer w ()
tell s = Writer ((), s)
```

これは後で他のモナディック関数の構成要素として使うことになる。

## Fishの解剖

さまざまなモナドに対してfish演算子を実装するとすぐ、コードに重複がたくさんあり、簡単に括り出せることに気付くだろう。まず、2つの関数のKleisli合成は1つの関数を返す必要があるので、その実装も型`a`の引数を1つ取るラムダから始められる：

```haskell
(>=>) :: (a -> m b) -> (b -> m c) -> (a -> m c)
f >=> g = \a -> ...
```

この引数は`f`に渡す以外のことはできない：

```haskell
f >=> g = \a -> let mb = f a
                in ...
```

この時点で、型`m c`の結果を生成し、型`m b`の対象と関数`g :: b -> m c`を自由に使える必要がある。それを行う関数を定義しよう。この関数は*bind*と呼ばれ、通常は中置演算子の形式で記される：

```haskell
(>>=) :: m a -> (a -> m b) -> m b
```

モナドごとに、fish演算子の代わりにbindを定義できる。実際、標準的なHaskellのモナドの定義ではbindが使われている：

```haskell
class Monad m where
    (>>=) :: m a -> (a -> m b) -> m b
    return :: a -> m a
```

以下に`Writer`モナドのバインドの定義を示す：

```haskell
(Writer (a, w)) >>= f = let Writer (b, w') = f a
                        in  Writer (b, w `mappend` w')
```

これは確かにfish演算子の定義より短い。

`m`が関手であるという事実を利用すればbindをさらに詳しく分析できる。`fmap`を使えば`m a`の内容に関数`a -> m b`を適用できる。それによって`a`は`m b`に変換される。したがって、適用結果は型`m (m b)`となる。これは必要な結果の型`m b`そのものではない。しかし、近付いてはいる。`m`の2重適用を潰す、つまりフラット化する関数さえあればよい。そのような関数は`join`と呼ばれる。

```haskell
join :: m (m a) -> m a
```

`join`を使ってbindを次のように書き直せる：

```haskell
ma >>= f = join (fmap f ma)
```

これはモナドの定義の3番目の選択肢につながる：

```haskell
class Functor m => Monad m where
    join :: m (m a) -> m a
    return :: a -> m a
```

ここでは`m`が`Functor`であることを明示的に要求した。これまでの2つのモナドの定義ではその必要はなかった。型コンストラクター`m`は、fish演算子とbind演算子のどちらかをサポートするなら自動的に関手になるからだ。たとえば、`fmap`はbindと`return`で定義できる：

```haskell
fmap f ma = ma >>= \a -> return (f a)
```

完全を期すため、`Writer`モナドの`join`を以下に示す：

```haskell
join :: Monoid w => Writer w (Writer w a) -> Writer w a
join (Writer ((Writer (a, w')), w)) = Writer (a, w `mappend` w')
```

## `do`記法

モナドを使ってコードを書く方法の1つは、Kleisli矢の使用――fish演算子によるそれらの合成だ。このプログラミング手法はポイントフリースタイルを一般化したものだ。ポイントフリーのコードはコンパクトで、実にエレガントなことが多い。しかし、一般には、理解するのが難しく暗号すれすれだ。だから、ほとんどのプログラマーは関数の引数や中間値に名前を付ける方を好む。

それはつまり、モナドを扱う場合にはfish演算子よりもbind演算子を優先するのを意味する。Bindはモナディックな値を取ってモナディックな値を返す。プログラマーはそれらの値に名前を付けても構わない。しかし、これは改善とは言えない。本当は、あたかも通常の値を扱っているかのようなふりがしたい。値をカプセル化するモナディックなコンテナが欲しいのではない。命令型コードのように、グローバルなログの更新などの副作用のほとんどが視界から隠れていてほしい。そしてそれこそHaskellが`do`記法でエミュレートするものだ。

ここで疑問に思うだろう。一体なぜモナドを使うのか？
副作用を見えなくしたいなら、命令型言語に留まればいいのではないか？
その答えは、モナドなら副作用をはるかにうまくコントロールできる、というものだ。たとえば、`Writer`モナドのログは関数から関数へ渡され、グローバルに公開されることはない。ログを改竄したりデータ競合を引き起したりする可能性はない。また、モナディックなコードはプログラムの他の部分から明確に区分され隔離される。

`do`記法はモナディック合成のための単なる糖衣構文だ。表面上は命令型コードによく似ているが、bindとラムダ式のシーケンスに直接変換できる。

一例として、前に`Writer`モナドでのKleisli矢の合成を説明するために使った例を取り上げる。現在の定義を使うと、それは次のように書き直せる：

```haskell
process :: String -> Writer String [String]
process = upCase >=> toWords
```

この関数は、動作ログを生成しつつ、入力文字列内のすべての文字を大文字に変換して単語に分割する。

`do`記法ならこうなる：

```haskell
process s = do
    upStr <- upCase s
    toWords upStr
```

ここで、`upCase`は`Writer`を生成するのに、`upStr`は単なる`String`だ：

```haskell
upCase :: String -> Writer String String
upCase s = Writer (map toUpper s, "upCase ")
```

これは`do`ブロックがコンパイラーによって次のように脱糖されるためだ：

```haskell
process s =
    upCase s >>= \upStr ->
        toWords upStr
```

`upCase`のモナディックな結果は`String`を引数とするラムダに束縛されている。その引数の名前は`do`ブロックに書かれていたものと同じだ。次の行：

```haskell
upStr <- upCase s
```

は、`upStr`が*得る*のは`upCase s`の結果だ、と読める。

擬似的な命令型スタイルは`toWords`をインライン化するとさらに顕著になる。2つの関数呼び出しに置き換えてインライン化しよう。まず`tell`を呼び出して、文字列`"toWords"`をログに記録する。続いて`return`を呼び出して、文字列`upStr`を`words`によって分割した結果を返す。`words`は文字列を扱う通常の関数であることに注意してほしい。

```haskell
process s = do
    upStr <- upCase s
    tell "toWords "
    return (words upStr)
```

ここで、doブロックの各行を脱糖すると、ネストされた新たなbindが導入される：

```haskell
process s =
    upCase s >>= \upStr ->
      tell "toWords " >>= \() ->
        return (words upStr)
```

`tell`はunit値を生成するので、後続のラムダに渡す必要はないことに注意してほしい。モナディックな結果の内容を無視するのはよくあることだ（ただし、その作用――ここではログへの寄与――は無視しない）。そのため、そのような場合にbindを置き換える特別な演算子がある：

```haskell
(>>) :: m a -> m b -> m b
m >> k = m >>= (\_ -> k)
```

実際に脱糖されたコードは次のようになる：

```haskell
process s =
    upCase s >>= \upStr ->
      tell "toWords " >>
        return (words upStr)
```

一般に、`do`ブロックは行（またはサブブロック）で構成され、左矢印によって新しい名前を導入してコードの残りの部分で使えるようにするか、あるいは純粋に副作用を目的として実行される。Bind演算子はコード行間で暗黙的に使われる。ちなみに、Haskellでは`do`ブロックの書式を波括弧とセミコロンで置き換えられる。これが、モナドはセミコロンをオーバーロードする方法だ、と表現される理由になっている。

`do`記法を脱糖する際にラムダとbind演算子がネストされると、`do`ブロックの残りを各行の結果に基づいて実行するのに影響を与えることに注目してほしい。この特性を使えば、例外をシミュレートするなど、複雑な制御構造を導入できる。

興味深いことに、`do`記法と同等のものが命令型言語に、典型的にはC++に応用されている。再開可能な関数 (re- sumable function) やコルーチン (coroutine) のことだ。C++の[futureがモナドを形成する](https://bartoszmilewski.com/2014/02/26/c17-i-see-a-monad-in-your-future/)ことは秘密ではない。それは継続モナドの一例だ。継続モナドについてはすぐ後で議論する。継続の問題点は、合成するのが非常に難しいことだ。Haskellでは`do`という表記法を使うことで、「こっちのハンドラーがそっちのハンドラーを呼ぶ」というスパゲッティを、逐次コードに非常によく似たものに変換している。再開可能な関数によって、同じ変換がC++でも可能になる。また、同じメカニズムを適用すれば、[ネストされたループのスパゲッティ](https://bartoszmilewski.com/2014/04/21/getting-lazy-with-c/)をリスト内包表記または「ジェネレーター」に変えられる。これは本質的にリストモナドの`do`記法だ。モナドによる統一的な抽象化がなければ、これらの個々の問題は通常、言語にカスタム拡張を提供して対処されることになる。Haskellでは、すべてライブラリを通じて対処される。
