# 関手性 {#functoriality}

関手とは何かを学び、いくつかの例を見てきたのに続いて、小さい関手から大きい関手を作る方法を見てみよう。特に興味深いのは、（圏内の対象間の写像に対応する）どの型コンストラクターを、（射の間の写像を含む）関手に拡張できるのかという点だ。

## 双関手

関手は$\Cat$（圏の圏）の射であるため、射――典型的には関数――に関する直観の多くは関手にも当てはまる。たとえば、2つの引数を取る関数と同じように、2つの引数を取る関手、すなわち[双関手]{.keyword #bifunctor} (bifunctor) が存在しうる。対象について、双関手は対象のすべてのペアを写す。1つは圏$\cat{C}$から、もう1つは圏$\cat{D}$から、圏$\cat{E}$の対象に写す。これは単に、圏の[カルテシアン積]{.keyword #Cartesian_product} (Cartesian product) $\cat{C} \times{} \cat{D}$から$\cat{E}$への写像だと言っているだけであることに注意してほしい。

`\begin{figure} \centering`{=latex}
![](images/bifunctor.jpg){width=30%}
`\end{figure}`{=latex}
\noindent
実に簡単だ。しかし、関手性によると、双関手は射も写さなければならない。ただし、今回は$\cat{C}$と$\cat{D}$の射のペアを$\cat{E}$の射に写す必要がある。

ここでも、射のペアは直積圏$\cat{C} \times{} \cat{D}$内の1つの射に相当する。圏のカルテシアン積における射を、ある対象のペアから別の対象のペアへ向かう射のペアと定義した。これらの射のペアは、自明な方法で合成できる：

$$(f, g) \circ (f', g') = (f \circ f', g \circ g')$$

合成は結合的であり、恒等射の対 $(\id, \id)$ を恒等射として持つ。圏のカルテシアン積は確かに圏だ。

双関手についてもっと簡単に考えたいなら、両方の引数を取る関手だと見なせばよい。そうすれば、関手の規則――結合性と恒等射の保存――を関手から双関手へ翻訳するのではなく、引数ごとに個別にチェックすれば十分だろう。ただし、一般には、個別の関手性は結合した関手性の証明としては不十分だ。結合した関手性が成り立たない圏は*前モノイダル圏* (premonoidal category) と呼ばれる。

Haskellで双関手を定義しよう。この場合の3つの圏はすべて同じで、Haskellの型の圏だ。双関手は2つの型引数を取る型コンストラクターだ。型クラス`Bifunctor`の定義をライブラリ`Control.Bifunctor`から採ると、次のとおりだ：

```haskell
class Bifunctor f where
    bimap :: (a -> c) -> (b -> d) -> f a b -> f c d
    bimap g h = first g . second h
    first :: (a -> c) -> f a b -> f c b
    first g = bimap g id
    second :: (b -> d) -> f a b -> f a d
    second = bimap id
```

![bimap](images/bimap.jpg){width=30%}
\noindent
型変数`f`は双関手を表す。これは、どの型シグネチャーにおいても常に2つの型引数に適用されているのが分かる。最初の型シグネチャーは、2つの関数を同時に写す`bimap`を定義している。その結果はリフトされた関数`(f a b -> f c d)`であり、双関手の型コンストラクターが生成する型に対して作用する。`bimap`には`first`と`second`の観点でのデフォルト実装がある（前述のとおり、これは常に機能するわけではなく、2つの写像が可換でない場合には`first g . second h`と`second h . first g`は同じではない）。

他の2つの型シグネチャー`first`と`second`は、2つの`fmap`であり、それぞれ最初と2番目の引数について`f`の関手性を示す。

--------------------------------------- -----------------------------------------
![first](images/first.jpg){width=65%}   ![second](images/second.jpg){width=60%}
--------------------------------------- -----------------------------------------

型クラス定義は、この両方のデフォルト実装を`bimap`に基づいて提供する。

`Bifunctor`のインスタンスを宣言するときには、`bimap`を実装してデフォルトの`first`と`second`を受け入れるか、`first`と`second`の両方を実装してデフォルトの`bimap`を受け入れるか、どちらかを選べる（もちろん3つすべてを実装してもよいが、それらが相互に正しく関連付けられているのを確認するのはプログラマーの責任になる）。

## 積と余積の双関手

双関手の重要な例として、圏論的な積がある。それは[普遍的構成](#products-and-coproducts)によって定義される2つの対象の積だ。対象の任意のペアに対して積が存在する場合、これらの対象から積への写像は双関手的だ。これは一般に真であり、Haskellに特によく当てはまる。最も単純な直積型であるペアでは、コンストラクターの`Bifunctor`インスタンスはこうなる：

```haskell
instance Bifunctor (,) where
    bimap f g (x, y) = (f x, g y)
```

選択の余地はあまりない。`bimap`では単に、最初の関数をペアの最初の成分に適用し、2番目の関数を2番目の成分に適用するだけだ。次のような型を想定すれば、コード自体がほぼ説明になっている：

```haskell
bimap :: (a -> c) -> (b -> d) -> (a, b) -> (c, d)
```

ここでの双関手の役割は、たとえば次のような型のペアを作ることだ：

```haskell
(,) a b = (a, b)
```

双対性より、余積は、圏内の対象のすべてのペアに対して定義されているなら双関手でもある。Haskellでは、`Either`の型コンストラクターが`Bifunctor`のインスタンスであることが良い例だ：

```haskell
instance Bifunctor Either where
    bimap f _ (Left x)  = Left (f x)
    bimap _ g (Right y) = Right (g y)
```

これもコード自体が説明になっている。

モノイダル圏について述べたときのことを覚えているだろうか？
モノイダル圏は、対象に作用する二項演算子と単位対象とを定義する。$\Set$について、カルテシアン積に関して単集合を単位とするモノイダル圏だと述べた。また、非交和に関しても空集合を単位とするモノイダル圏だ。しかし、モノイダル圏の要件の1つとして、二項演算子が双関手でなければならないことは述べていなかった。これは非常に重要な要件だ。射によって定義される圏の構造とモノイダル積とを両立させたいからだ。我々はいま、モノイダル圏の完全な定義に一歩近づいている（そこに到達するまでに、まだ自然性について学ぶ必要がある）。

## 関手的代数的データ型

これまでに、パラメーター化されたデータ型が関手であるような例をいくつか見て、それらについて`fmap`を定義できた。複雑なデータ型は単純なデータ型から構成される。特に、代数的データ型 (ADT) は、和と積を使って作成される。和と積が関手的なのは先ほど見た。関手が合成するのも知っている。したがって、ADTの基本的な構成要素が関手的であると示せれば、パラメーター化されたADTも関手的だと分かる。

では、パラメーター化された代数的データ型の構成要素は何だろうか？
まず、`Maybe`における`Nothing`や`List`における`Nil`のように、関手の型パラメーターに依存しない要素がある。それらは`Const`関手と等価だ。`Const`関手は型パラメーターを無視することを忘れないでほしい（いま述べているのは*2番目の*型パラメーターのことで、最初のパラメーターはそのままにされる）。

次に、`Maybe`における`Just`のように、単に型パラメーター自体をカプセル化する要素がある。これらは恒等関手と等価だ。以前、恒等関手について$\Cat$の恒等射として言及したが、Haskellでの定義は説明しなかった。それをここに示す：

```haskell
data Identity a = Identity a
```

```haskell
instance Functor Identity where
    fmap f (Identity x) = Identity (f x)
```

`Identity`は、型`a`の（不変な）値を常に1つだけ格納する、最も単純なコンテナと見なせる。

代数的データ構造の他のすべては、これら2つのプリミティブから積と和を使って構成される。

この新しい知識に基づいて、`Maybe`型コンストラクターを改めて見てみよう。

```haskell
data Maybe a = Nothing | Just a
```

これは2つの型の和だ。和が関手的なのは知っている。1つ目の部分である`Nothing`は、`a`に作用する`Const ()`として表せる（`Const`の最初の型パラメーターはunit型に設定されている――後で`Const`のさらに興味深い使い方を説明する）。2つ目の部分は、恒等関手の別名だ。`Maybe`は、同型を除いて、次のようにも定義できる：

```haskell
type Maybe a = Either (Const () a) (Identity a)
```

したがって、`Maybe`は双関手`Either`を2つの関手`Const ()`と`Identity`に合成したものだ。（`Const`は実際には双関手だが、ここでは常に部分適用で使う。）

関手の合成が関手であることはすでに見た。同じことが双関手にも当てはまるのは簡単に納得できる。必要なのは、2つの関手を持つ双関手の合成が、射にどのように作用するかを理解することだけだ。2つの射が与えられた場合、片方の関手で片方の射を、もう1つの関手でもう1つの射をそれぞれリフトするだけでよい。次に、そのようにして得られるリフトされた射のペアを、双関手でリフトする。

この合成はHaskellで表現できる。双関手`bf`（2つの型を引数に取る双関手コンストラクターである型変数）と、2つの関手`fu`と`gu`（それぞれ1つの型変数を取る型コンストラクター）と、2つの通常の型`a`と`b`とによってパラメーター化されるデータ型を定義しよう。`fu`を`a`に適用し、`gu`を`b`に適用し、それから`bf`を結果の2つの型に適用する：

```haskell
newtype BiComp bf fu gu a b = BiComp (bf (fu a) (gu b))
```

これが対象の合成であり、型の合成だ。Haskellで型コンストラクターを型に適用する方法が、関数を引数に適用するのと同じであることに注目してほしい。それらは同じ構文だ。

少し迷ったなら、`BiComp`を、`Either`、`Const ()`、`Identity`、`a`、`b`の順に適用してみてほしい。`Maybe b`の必要最小限のバージョンを復元できるだろう（`a`は無視する）。

新しいデータ型`BiComp`は、`a`および`b`内の双関手だが、`bf`自体が`Bifunctor`であり、`fu`および`gu`が`Functor`である場合に限る。コンパイラーは、`bf`に対する`bimap`の定義と、`fu`と`gu`に対する`fmap`の定義とが存在することを認識している必要がある。Haskellでは、これはインスタンス宣言の前提条件として表現される。つまり、クラス制約のセットが二重矢印の前に書かれる：

```haskell
instance (Bifunctor bf, Functor fu, Functor gu) =>
  Bifunctor (BiComp bf fu gu) where
    bimap f1 f2 (BiComp x) = BiComp (bimap (fmap f1) (fmap f2) x)
```

`BiComp`に対する`bimap`の実装は、`bf`に対する`bimap`と、`fu`および`gu`に対する2つの`fmap`とで与えられる。コンパイラーは、`BiComp`が使われるたびに、すべての型を自動的に推測し、適切なオーバーロード関数を選択する。

`bimap`の定義内の`x`は次のような型だ：

```haskell
bf (fu a) (gu b)
```

これについて述べると長くなる。外側の`bimap`は外側の`bf`の層を貫通しており、2つの`fmap`はそれぞれ`fu`と`gu`の下まで掘り下げている。`f1`と`f2`の型が次の場合：

```haskell
f1 :: a -> a'
f2 :: b -> b'
```

最終結果の型は`bf (fu a') (gu b')`となる：

```haskell
bimap ::(fu a -> fu a') -> (gu b -> gu b')
  -> bf (fu a) (gu b) -> bf (fu a') (gu b')
```

ジグソーパズルが好きな人なら、この種の型操作で何時間も楽しめるだろう。

`Maybe`が関手だと証明する必要はなかったと分かった。この事実は、2つの関手的プリミティブの和という構築方法から導かれたものだ。

鋭い読者ならこう尋ねるだろう：代数的データ型に対する`Functor`インスタンスをそれほど機械的に導出できるのなら、コンパイラーによって自動化して実行できないのか？
実際、可能であり、行われている。ただし、ソースファイルの先頭に次の行を含めることで、特定のHaskell拡張を有効にする必要がある：

```haskell
{-# LANGUAGE DeriveFunctor #-}
```

そして、データ構造体に`deriving Functor`を追加する：

```haskell
data Maybe a = Nothing | Just a
  deriving Functor
```

すると、対応する`fmap`が自動的に実装される。

代数的データ構造の正則性 (regularity) により、`Functor`だけでなく、前に述べた`Eq`型クラスを含む、いくつかの型クラスのインスタンスを派生させられる。コンパイラーに独自の型クラスのインスタンスを派生させるように教えるという選択肢もあるが、それはもう少し高度だ。もっとも、基本的な構成要素に対する動作と和と積とを提供し、残りの部分はコンパイラーに計算させるという考え方は変わらない。

## C++での関手

C++プログラマーなら、関手の実装に関しては、明らかに自分でやることになる。しかし、C++でもある種の代数的データ構造は見つかるはずだ。そのようなデータ構造を総称テンプレートにすれば、`fmap`を素早く実装できるだろう。

データ木構造を見てみよう。Haskellでは再帰的な直和型として定義される：

```haskell
data Tree a = Leaf a | Node (Tree a) (Tree a)
    deriving Functor
```

前にも述べたように、C++で直和型を実装する方法の1つは、クラス階層を使うことだ。オブジェクト指向言語では、`fmap`を基底クラス`Functor`の仮想関数として実装し、それをすべてのサブクラスでオーバーライドするのが自然だ。残念ながらこれは不可能だ。なぜなら、`fmap`はテンプレートであり、それが作用する対象の型（`this`ポインタ）だけでなく、それに適用された関数の戻り型によってもパラメーター化されているからだ。C++では仮想関数はテンプレート化できない。`fmap`を総称フリー関数として実装し、パターンマッチングを`dynamic_cast`に置き換えよう。

基底クラスでは、動的キャストをサポートするために少なくとも1つの仮想関数を定義する必要があるため、デストラクターを仮想関数にする（いずれにしても良い考えだ）：

```cpp
template<class T>
struct Tree {
    virtual ~Tree() {}
};
```

`Leaf`は、`Identity`関手を偽装したものだ：

```cpp
template<class T>
struct Leaf : public Tree<T> {
    T _label;
    Leaf(T l) : _label(l) {}
};
```

`Node`は直積型だ：

```cpp
template<class T>
struct Node : public Tree<T> {
    Tree<T> * _left;
    Tree<T> * _right;
    Node(Tree<T> * l, Tree<T> * r) : _left(l), _right(r) {}
};
```

`fmap`を実装するときには、`Tree`の型で動的ディスパッチを利用する。`Leaf`の場合は`Identity`版の`fmap`を適用し、`Node`の場合は2つの`Tree`関手で構成された双関手のように扱う。C++プログラマーとしては、これらの用語を使ってコードを分析することに慣れていないかもしれないが、圏論的な考え方を実践するには適している。

```cpp
template<class A, class B>
Tree<B> * fmap(std::function<B(A)> f, Tree<A> * t)
{
    Leaf<A> * pl = dynamic_cast <Leaf<A>*>(t);
    if (pl)
        return new Leaf<B>(f (pl->_label));
    Node<A> * pn = dynamic_cast<Node<A>*>(t);
    if (pn)
        return new Node<B>( fmap<A>(f, pn->_left)
                          , fmap<A>(f, pn->_right));
    return nullptr;
}
```

簡単のため、メモリとリソース管理の問題は無視することにしたが、本番コードではおそらくスマートポインター（uniqueかsharedかはポリシーによる）を使うことになるだろう。

`fmap`のHaskell実装と比較してほしい：

```haskell
instance Functor Tree where
    fmap f (Leaf a) = Leaf (f a)
    fmap f (Node t t') = Node (fmap f t) (fmap f t')
```

この実装は、コンパイラーによって自動的に導出することもできる。

## Writer関手

前に[Kleisli圏](#kleisli-categories)を説明したとき、戻ってくることを約束した。Kleisli圏の射は、`Writer`データ構造体を返す「装飾された」関数として表現されていた。

```haskell
type Writer a = (a, String)
```

すでに述べたように、装飾は自己関手と何らかの関係にある。そして実際、`Writer`の型コンストラクターは、`a`について関手的だ。単純な直積型なので、`fmap`を実装する必要すらない。

しかし、Kleisli圏と関手の間には、どのような一般的な関係があるのだろうか？
Kleisli圏は圏なので、合成と恒等射が定義されている。合成はfish演算子によって与えられるのを思い出してほしい：

```haskell
(>=>) :: (a -> Writer b) -> (b -> Writer c) -> (a -> Writer c)
m1 >=> m2 = \x ->
    let (y, s1) = m1 x
        (z, s2) = m2 y
    in (z, s1 ++ s2)
```

また、恒等射は`return`という関数によって計算される：

```haskell
return :: a -> Writer a
return x = (x, "")
```

この2つの関数の型を十分に長く見れば（つまり、十分に*長く*見れば）、それらを組み合わせて、`fmap`として機能する適切な型シグネチャーを持つ関数を作成する方法が見つかる。それは次のようになる：

```haskell
fmap f = id >=> (\x -> return (f x))
```

この例では、fish演算子は2つの関数を組み合わせている。1つはおなじみの`id`であり、もう1つは、引数に`f`を適用した結果に`return`を適用するラムダ関数だ。理解するのが最も難しいのは`id`を使うところだろう。Fish演算子の引数となる関数は、「通常の」型を受け取って装飾された型を返す関数ではないのだろうか？
実は、そんなことはない。`a -> Writer b`の`a`が「普通の」型でなければならないとは誰も言っていない。これは型変数なので何でも良く、特に、`Writer b`のような装飾された型でも構わない。

したがって、`id`は`Writer a`を受け取り、`Writer a`に変換する。Fish演算子は`a`の値を取り出し、`x`としてラムダに渡す。ここで、`f`はそれを`b`に変換し、`return`はそれを装飾して`Writer b`にする。これらすべてをまとめると、`Writer a`を受け取り、`Writer b`を返す関数が完成する。これは、`fmap`が生成するはずのものと全く同じだ。

注目してほしいのは、この引数が非常に汎用的であることだ。つまり、`Writer`は任意の型コンストラクターで置き換えられる。Fish演算子と`return`をサポートしていれば、`fmap`も定義できる。したがってKleisli圏での装飾は常に関手となる。（ただし、すべての関手がKleisli圏に由来するわけではない。）

先ほど定義した`fmap`は、`derivating Functor`を使ってコンパイラーによって導出された`fmap`と同じではないかと思うかもしれない。とても興味深いことに、そのとおりだ。そうなっているのは、Haskellが多相関数を実装する方法に由来する。それは[パラメトリック多相]{.keyword #parametric_polymorphism}と呼ばれ、いわゆる[theorems for free]{.keyword #theorems_for_free}の根源となっている。それらの定理の1つは、ある型コンストラクターに対して恒等射を保存するような`fmap`の実装があるなら、それは一意である、と述べている。

## 共変関手と反変関手

Writer関手を振り返り終えたのでReader関手に戻ろう。それは部分適用された関数、すなわちアロー型コンストラクターに基づいていた：

```haskell
(->) r
```

これは型シノニム^[訳註：型に付けた別名のこと。]で書き直せる：

```haskell
type Reader r a = r -> a
```

これに対する`Functor`インスタンスは、これまで見てきたように、次のようになる：

```haskell
instance Functor (Reader r) where
    fmap f g = f . g
```

だが、ペア型コンストラクターや`Either`型コンストラクターと同じく、この関数型コンストラクターは2つの型引数を取る。ペアや`Either`は両方の引数について関手的であり、すなわち双関手だった。この関数のコンストラクターも双関手だろうか？

最初の引数で関手的にしてみよう。`Reader`とは引数が反転している、よく似た型シノニムから始めることにする：

```haskell
type Op r a = a -> r
```

今回は、戻り値の型`r`を固定し、引数の型`a`を変化させる。次のような型シグネチャーを持つ`fmap`を実装するために、何らかの方法で型を一致させられるか見てみよう：

```haskell
fmap :: (a -> b) -> (a -> r) -> (b -> r)
```

`a`を取りそれぞれ`b`と`r`を返す2つの関数だけでは、`b`を取り`r`を返す関数を作成する方法が全くない。代わりに1つ目の関数を逆にして、`b`を受け取り`a`を返すようにできれば、状況は違ってくるだろう。任意の関数を逆にはできないが、反対圏に行くことはできる。

要約すると、圏$\cat{C}$ごとに双対圏$\cat{C}^\mathit{op}$が存在する。これは$\cat{C}$と同じ対象を持つ圏だが、すべての矢が逆になっている。

$\cat{C}^\mathit{op}$から他の圏$\cat{D}$への関手を考えてみよう：

$$F \Colon \cat{C}^\mathit{op} \to \cat{D}$$

このような関手は$\cat{C}^\mathit{op}$の射$f^\mathit{op} \Colon a \to b$を$\cat{D}$の射$F f^\mathit{op} \Colon F a \to F b$に写す。しかし、射$f^\mathit{op}$は、もとの圏$\cat{C}$のある射$f \Colon b \to a$と密かに対応している。反転に注意してほしい。

さて、$F$は正則関手 (regular functor) だが、$F$に基づいて定義できる別の写像があり、それは関手ではない。それを$G$と呼ぼう。これは$\cat{C}$から$\cat{D}$への写像だ。対象は$F$と同じ方法で写されるが、射は逆に写される。$\cat{C}$の射$f \Colon b \to a$を取り、それをまず反対の射$f^\mathit{op} \Colon a \to b$に写し、次に関手$F$を使って$F f^\mathit{op} \Colon F a \to F b$を取得する。

$F a$が$G a$と同じで、$F b$が$G b$と同じであることを考慮すると、この旅の全体は次のように記述できる：

$G f \Colon (b \to a) \to (G a \to G b)$

これは「ひねりのある関手」だ。このように射の方向を反転させる圏の写像は、*反変* (contravariant) 関手と呼ばれる。反変関手は、反対圏からの正則関手にすぎないことに注意してほしい。その一方で、正則関手――これまでに学んだ関手――は*共変* (covariant) 関手と呼ばれる。

![反変](images/contravariant.jpg){width=30%}
\noindent
以下の型クラスは、Haskellにおける反変関手（実際には反変*自己*関手）を定義している：

```haskell
class Contravariant f where
    contramap :: (b -> a) -> (f a -> f b)
```

前述の型コンストラクター`Op`はこのインスタンスだ：

```haskell
instance Contravariant (Op r) where
    -- (b -> a) -> Op r a -> Op r b
    contramap f g = g . f
```

関数`f`が、`Op`の内容――関数`g`より*先*（つまり右側）に挿入されることに注意してほしい。

`Op`に対する`contramap`の定義は、単に引数を反転した関数合成演算子であることに注意すれば、さらに簡潔にできるだろう。引数を反転するためには`flip`という特別な関数がある：

```haskell
flip :: (a -> b -> c) -> (b -> a -> c)
flip f y x = f x y
```

これを使うと次のようになる：

```haskell
contramap = flip (.)
```

## プロ関手

これまで見てきたように、関数アロー演算子は、最初の引数では反変、2番目の引数では共変だ。このような怪物に名前はあるのだろうか？
終域圏が$\Set$の場合、この怪物は[プロ関手]{.keyword #profunctor} (profunctor) と呼ばれる。反変関手は反対圏の共変関手と等価なので、プロ関手は次のように定義される：

$$\cat{C}^\mathit{op} \times \cat{D} \to \Set$$

Haskellの型は一次近似としては集合と見なせるので、引数が2つの型コンストラクター`p`に`Profunctor`という名前を適用する。1番目の引数は反関手的で、2番目は関手的だ。`Data.Profunctor`ライブラリから適切な型クラスを引用しよう：

```haskell
class Profunctor p where
  dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
  dimap f g = lmap f . rmap g
  lmap :: (a -> b) -> p b c -> p a c
  lmap f = dimap f id
  rmap :: (b -> c) -> p a b -> p a c
  rmap = dimap id
```

これら3つの関数すべてにデフォルト実装がある。`Bifunctor`と同じように、`Profunctor`のインスタンスを宣言するとき、`dimap`を実装してデフォルトの`lmap`と`rmap`を受け入れるか、`lmap`と`rmap`の両方を実装してデフォルトの`dimap`を受け入れるか、どちらかを選択できる。

![dimap](images/dimap.jpg){width=40%}
\noindent
ここで、関数アロー演算子は`Profunctor`のインスタンスだと断定してよい：

```haskell
instance Profunctor (->) where
  dimap ab cd bc = cd . bc . ab
  lmap = flip (.)
  rmap = (.)
```

プロ関手の応用としてはHaskellのlensライブラリがある。エンドとコエンドについて述べるときに再び見ることになるだろう。

## Hom関手

上記の例は、対象$a$と$b$のペアを取ってそれらの間の射の集合を割り当てる写像、すなわちhom集合$\cat{C}(a, b)$ が関手であるという、より一般的な命題を反映している。それは直積圏$\cat{C}^\mathit{op}\times{}\cat{C}$から集合の圏$\Set$への関手だ。

射に対する作用を定義してみよう。$\cat{C}^\mathit{op}\times{}\cat{C}$の射は、$\cat{C}$からの射のペアだ：

$$f \Colon a' \to a$$
$$g \Colon b \to b'$$

このペアをリフトしたものは集合$\cat{C}(a, b)$ から集合$\cat{C}(a', b')$ への射（関数）になる必要がある。$\cat{C}(a, b)$ の任意の要素$h$（$a$から$b$への射）を選んでそれに適用すると：

$$g \circ h \circ f$$

という$\cat{C}(a', b')$ の要素となる。

ご覧のとおり、hom関手はプロ関手の特殊なケースだ。

## 課題

1. データ型：

   ```haskell
   data Pair a b = Pair a b
   ```

   が双関手であることを示せ。追加の課題として、`Bifunctor`を3つの方法すべてで実装し、それらの定義が、適用できる場合は常にデフォルトの実装と互換性があることを等式推論によって示せ。

2. `Maybe`の標準的な定義と次の脱糖との同型を示せ：

   ```haskell
   type Maybe' a = Either (Const () a) (Identity a)
   ```

   ヒント：2つの実装の間に2つの写像を定義する。追加の課題として、等式推論を使って、それらが互いに逆であることを示せ。

3. 別のデータ構造を試してみよう。私はこれを`PreList`と呼んでいる。`List`の前身だからだ。これは再帰を型パラメーター`b`で置き換える。

   ```haskell
   data PreList a b = Nil | Cons a b
   ```

   `PreList`をそれ自体に再帰的に適用すれば、`List`の以前の定義を復元できる（どうなるかは、不動点について述べるときに説明する）。

   `PreList`が`Bifunctor`のインスタンスであることを示せ。

4. 次のデータ型が`a`および`b`の双関手を定義していることを示せ：

   ```haskell
   data K2 c a b = K2 c
   ```

   ```haskell
   data Fst a b = Fst a
   ```

   ```haskell
   data Snd a b = Snd b
   ```

   追加の課題として、Conor McBrideの論文[Clowns to the Left of me, Jokers to the Right](http://strictlypositive.org/CJ.pdf)と照らし合わせて解答を確認せよ。

5. Haskell以外の言語で双関手を定義せよ。その言語で`bimap`を総称ペア用に実装せよ。

6. `std::map`は、2つのテンプレート引数`Key`と`T`について双関手またはプロ関手と見なすべきか？
   そう見なせるようにするには、このデータ型をどう再設計すればよいだろう？
