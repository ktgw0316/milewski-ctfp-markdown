# 関手性 {#functoriality}

関手とは何かを学び、いくつかの例を見てきたのに続いて、小さな関手から大きな関手を作る方法を見てみよう。特に興味深いのは、どの型コンストラクター (圏内の対象間の写像に対応する) を関手 (射の間の写像を含む) に拡張できるのかという点だ。

## 双関手

関手は$\Cat$ (圏の圏) の射であるため、射 (特に関数) に関する多くの直観は関手にも当てはまる。たとえば、2つの引数を持つ関数と同じように、2つの引数を持つ関手、すなわち[双関手]{.keyword #bifunctor} (bifunctor) が存在しうる。対象について、双関手は対象のすべてのペアを写す。1つは圏$\cat{C}$から、もう1つは圏$\cat{D}$から、圏$\cat{E}$の対象に写す。これは単に、圏の[カルテシアン積]{.keyword #Cartesian_product} (Cartesian product) $\cat{C} \times{} \cat{D}$から$\cat{E}$への写像だと言っているだけであることに注意してほしい。

![](images/bifunctor.jpg){width=30%}

とても簡単だ。しかし、関手性は、双関手が射を写さなければならないのを意味する。ただし、今回は$\cat{C}$と$\cat{D}$の射のペアを$\cat{E}$の射に写す必要がある。

ここでも、一対の射は、直積圏$\cat{C} \times{} \cat{D}$から$\cat{E}$への一つの射にあたる。圏のカルテシアン積における射を、ある対象のペアから別の対象のペアへ進む射のペアと定義した。これらの射のペアは、自明な方法で合成できる:

$$(f, g) \circ (f', g') = (f \circ f', g \circ g')$$

合成は結合的であり、恒等射として、恒等射の対 $(\id, \id)$ を持つ。圏のカルテシアン積はまさに圏だ。

しかし、双関手について考える更に簡単な方法は、両方の引数をとる関手だと考えることだ。したがって、関手の規則――結合性と恒等射の保存――を関手から双関手へ翻訳するのではなく、引数ごとに別々にチェックすれば十分だろう。圏のペアから第3の圏への写像があり、それが関手的であることを各引数で別々に (たとえば、もう一方の引数を定数にするなどして) 証明すれば、写像は自動的に双関手になる。_関手的_とは、正直な関手 (honest functor) のように射に作用するという意味で用いている。

Haskellで双関手を定義しよう。この場合、3つの圏はすべて同じであり、Haskellの型の圏だ。双関手は、2つの型引数を取る型コンストラクタだ。型クラス`Bifunctor`の定義をライブラリ`Control.Bifunctor`から採ると、次のとおりだ:

```haskell
class Bifunctor f where
    bimap :: (a -> c) -> (b -> d) -> f a b -> f c d
    bimap g h = first g . second h
    first :: (a -> c) -> f a b -> f c b
    first g = bimap g id
    second :: (b -> d) -> f a b -> f a d
    second = bimap id
```

![bimap](images/bimap.jpg){width=30%}

型変数`f`は双関手を表す。これは、どの型シグネチャにおいても常に2つの型引数に適用されているのがわかる。最初の型シグニチャは、2つの関数を同時に写す`bimap`を定義している。その結果はリフトされた関数`(f a b -> f c d)`であり、双関手の型コンストラクターが生成する型に対して作用する。`bimap`には`first`と`second`の観点でのデフォルト実装があり、双関手を定義するにはそれぞれの引数に個別に関手性があれば十分なことを示している。

他の2つの型シグニチャ、`first`と`second`は、2つの`fmap`であり、それぞれ最初と2番目の引数について`f`の関手性を示す。

--------------------------------------- -----------------------------------------
![first](images/first.jpg){width=65%}   ![second](images/second.jpg){width=60%}
--------------------------------------- -----------------------------------------

この型クラス定義では、両方のデフォルト実装を`bimap`として提供している。

`Bifunctor`のインスタンスを宣言するときには、`bimap`を実装して`first`と`second`のデフォルト値を受け入れるか、`first`と`second`の両方を実装して`bimap`のデフォルト値を受け入れるか、どちらかを選択できる (もちろん、3つすべてを実装することもできるが、それらが相互に正しく関連付けられているのを確認するのはあなたの責任になる)。

## 積と余積の双関手

双関手の重要な例として、圏論的な積がある。それは[普遍構成](#products-and-coproducts)によって定義される2つの対象の積だ。対象の任意のペアに対して積が存在する場合、これらの対象から積への写像は双関手的だ。これは一般に真であり、Haskellに特によく当てはまる。以下に、ペアのコンストラクタについての`Bifunctor`インスタンスを示す。最も単純な直積型だ:

```haskell
instance Bifunctor (,) where
    bimap f g (x, y) = (f x, g y)
```

選択肢はあまりない: `bimap`は単に最初の関数をペアの最初のコンポーネントに適用し、2番目の関数を2番目のコンポーネントに適用するだけだ。次のような型を想定すれば、ほとんどコード自体が説明になっている:

```haskell
bimap :: (a -> c) -> (b -> d) -> (a, b) -> (c, d)
```

ここでの双関手の働きは、たとえば次のような型の対を作ることだ:

```haskell
(,) a b = (a, b)
```

双対性によって、余積は、圏内の対象のすべてのペアに対して定義されている場合、双関手でもある。Haskellでは、`Either`の型コンストラクタが`Bifunctor`のインスタンスであることが良い例だ。

```haskell
instance Bifunctor Either where
    bimap f _ (Left x)  = Left (f x)
    bimap _ g (Right y) = Right (g y)
```

これもコード自体が説明になっている。

モノイダル圏について話したときのことを覚えているだろうか？
モノイダル圏は、単位対象とともに対象に作用する二項演算子を定義する。$\Set$はカルテシアン積に関して単集合を単位とするモノイダル圏である、と述べた。また、非交和に関しても空集合を単位とするモノイダル圏である。述べていなかったのは、モノイダル圏の要件の1つは二項演算子が双関手であることだ、ということだ。これは非常に重要な要件だ。我々は、モノイダル積を、射によって定義される圏の構造と両立させたい。我々は今、モノイダル圏の完全な定義に一歩近づいている (そこに到達する前に、まだ自然性について学ぶ必要がある)。

## 関手的代数的データ型

これまで何例か見てきたパラメータ化されたデータ型に対して、`fmap`を定義でき、それらが関手であることがわかった。複雑なデータ型は単純なデータ型から構成される。特に、代数的データ型 (ADT) は、直和と直積を使って作成される。先ほど、直和と直積が関手的であるのを見た。関手が合成するのも知っている。したがって、ADTの基本的な構成要素が関手的であると示せれば、パラメータ化されたADTも関手的だとわかる。

では、パラメータ化された代数的データ型の構成要素は何だろうか？
まず、`Maybe`における`Nothing`や、`List`における`Nil`のように、関手の型パラメータに依存しない項目がある。それらは`Const`関手と等価だ。`Const`関手は型パラメータを無視することを覚えておいてほしい (実際には、興味があるのは_2番目_の型パラメータであり、最初のパラメータは一定に保たれる)。

次に、`Maybe`における`Just`のように、単に型パラメータ自体をカプセル化する要素がある。これらは恒等関手と等価だ。以前、恒等関手について_Cat_の恒等射として言及したが、Haskellでの定義は説明しなかった。それはこうだ:

```haskell
data Identity a = Identity a
```

```haskell
instance Functor Identity where
    fmap f (Identity x) = Identity (f x)
```

`Identity`は、型`a`の (不変な) 値を常に1つだけ格納する、最も単純なコンテナと見なせる。

代数的データ構造の他のすべては、これら2つのプリミティブから直積と直和を使って構成される。

この新しい知識に基づいて、型の`Maybe`コンストラクタを改めて見てみよう。

```haskell
data Maybe a = Nothing | Just a
```

これは2つの型の直和で、直和が関手的なのは知っている。最初の部分である`Nothing`は、`a`に作用する`Const ()`として表せる (`Const`の最初の型パラメータはunitに設定されている――後で`Const`のさらに興味深い使い方を説明する)。2番目の部分は、恒等関手の別名だ。`Maybe`は、同型を除いて、次のようにも定義できる:

```haskell
type Maybe a = Either (Const () a) (Identity a)
```

したがって`Maybe`は、双関手`Either`を、2つの関手`Const ()`と`Identity`に合成したものだ。(`Const`は実際には双関手だが、ここでは常に部分適用で使う)。

関手の合成が関手であることはすでに見た。同じことが双関手にも当てはまるのは容易に納得できる。必要なのは、2つの関手を持つ双関手の合成が、射にどのように作用するかを理解することだけだ。2つの射が与えられた場合、片方の関手で片方の射を、もう1つの関手でもう1つの射をそれぞれリフトするだけでよい。次に、そのようにして得られるリフトされた射のペアを、双関手でリフトする。

この合成はHaskellで表現できる。双関手`bf`  (引数として2つの型を取る双関手コンストラクタである型変数)、2つの関手`fu`と`gu`  (それぞれ1つの型変数を取る型コンストラクタ)、および2つの通常の型`a`と`b`によってパラメータ化されるデータ型を定義しよう。`fu`を`a`に適用し、`gu`を`b`に適用し、それから`bf`を結果の2つの型に適用する:

```haskell
newtype BiComp bf fu gu a b = BiComp (bf (fu a) (gu b))
```

これが対象の合成であり、型の合成だ。Haskellで型コンストラクターを型に適用する方法が、関数を引数に適用するのと同じであるのに注目してほしい。構文は同じだ。

少し迷ったなら、`BiComp`の適用を、`Either`、`Const ()`、`Identity`、`a`、`b`の順に試してみてほしい。`Maybe b`の必要最小限のバージョンを復元できるだろう (`a`は無視する)。

新しいデータ型`BiComp`は、`a`および`b`内の双関手だが、`bf`自体が`Bifunctor`であり、`fu`および`gu`が`Functor`である場合に限る。コンパイラは、`bf`で利用可能な`bimap`の定義、および`fu`と`gu`で利用可能な`fmap`の定義が存在すると認識している必要がある。Haskellでは、これはインスタンス宣言の前提条件として表現されている: クラス制約のセットが二重矢印の前に書かれる:

```haskell
instance (Bifunctor bf, Functor fu, Functor gu) =>
  Bifunctor (BiComp bf fu gu) where
    bimap f1 f2 (BiComp x) = BiComp ((bimap (fmap f1) (fmap f2)) x)

```

`BiComp`に対する`bimap`の実装は、`bf`に対する`bimap`と、`fu`および`gu`に対する2つの`fmap`とで与えられる。コンパイラは、`BiComp`が使われるたびに、すべての型を自動的に推測し、適切なオーバーロード関数を選択する。

`bimap`の定義内の`x`の型は次のとおりだ:

```haskell
bf (fu a) (gu b)
```

これはかなりの分量だ。外側の`bimap`は外側の`bf`の層を貫通しており、2つの`fmap`はそれぞれ`fu`と`gu`の下まで掘り下げている。`f1`と`f2`の型が次の場合:

```haskell
f1 :: a -> a'
f2 :: b -> b'
```

最終結果の型は`bf (fu a') (gu b')`となる:

```haskell
bimap ::(fu a -> fu a') -> (gu b -> gu b')
  -> bf (fu a) (gu b) -> bf (fu a') (gu b')
```

ジグソーパズルが好きな人なら、この種の型操作で何時間も楽しめるだろう。

`Maybe`が関手だと証明する必要はなかったとわかった。この事実は、2つの関手的プリミティブの直和という構築方法から導かれたものだ。

鋭い読者ならこう尋ねるだろう: 代数的データ型に対する`Functor`インスタンスの導出がそれほど機械的なのなら、コンパイラによって自動化して実行できないのか？
実際、可能であり、行われている。ソースファイルの先頭に次の行を含めることで、特定のHaskell拡張を有効にする必要がある:

```haskell
{-# LANGUAGE DeriveFunctor #-}
```

次に、データ構造体に`derivating Functor`を追加する:

```haskell
data Maybe a = Nothing | Just a
  deriving Functor
```

すると、対応する`fmap`が自動的に実装される。

代数的データ構造の正則性により、<g>関手</g>だけでなく、前に述べた<g>Eq</g>型クラスを含む、いくつかの型クラスのインスタンスを派生させられる。コンパイラーに独自の型クラスのインスタンスを派生させるように教えるという選択肢もあるが、それはもう少し高度だ。基本的なビルディング・ブロックと直和と直積の動作を提供し、残りの部分はコンパイラーに計算させるという考え方は同じだ。

## C++での関手

C++プログラマーなら、関手の実装に関しては、明らかに自分でやることになる。しかし、C++でもある種の代数的データ構造を見つけられるはずだ。そのようなデータ構造を総称テンプレートにすれば、`fmap`を素早く実装できるはずだ。

データ木構造を見てみよう。Haskellなら再帰的な直和型として定義される。

```haskell
data Tree a = Leaf a | Node (Tree a) (Tree a)
    deriving Functor
```

前にも述べたように、C++で直和型を実装する方法の1つは、クラス階層を使うことだ。オブジェクト指向言語では、`fmap`を基本クラス`Functor`の仮想関数として実装し、それをすべてのサブクラスでオーバーライドするのが自然だ。残念ながらこれは不可能だ。なぜなら、`fmap`はテンプレートであり、それが作用する対象の型 (`this`ポインタ) だけでなく、それに適用された関数の戻り型によってもパラメータ化されているからだ。仮想関数はC++ではテンプレート化できない。`fmap`を自由な総称関数として実装し、パターンマッチングを`dynamic_cast`に置き換えよう。

基本クラスは、動的キャストをサポートするために少なくとも1つの仮想関数を定義する必要があるため、デストラクタを仮想関数にする (いずれにしても良い考えだ)。

```cpp
template<class T>
struct Tree {
    virtual ~Tree() {};
};
```

`Leaf`は、`Identity`関手を偽装したものだ。

```cpp
template<class T>
struct Leaf : public Tree<T> {
    T _label;
    Leaf(T l) : _label(l) {}
};
```

`Node`は直積型だ。

```cpp
template<class T>
struct Node : public Tree<T> {
    Tree<T> * _left;
    Tree<T> * _right;
    Node(Tree<T> * l, Tree<T> * r) : _left(l), _right(r) {}
};
```

`fmap`を実装するときには、`Tree`の型で動的ディスパッチを利用する。`Leaf`の場合は`Identity`版の`fmap`を適用し、`Node`の場合は2つの`Tree`関手で構成された双関手のように扱われる。C++プログラマーとしては、これらの用語を使ってコードを分析することに慣れていないかもしれないが、圏的な考え方を実践するには適している。

```cpp
template<class A, class B>
Tree<B> * fmap(std::function<B(A)> f, Tree<A> * t)
{
    Leaf<A> * pl = dynamic_cast <Leaf<A>*>(t);
    if (pl)
        return new Leaf<B>(f (pl->_label));
    Node<A> * pn = dynamic_cast<Node<A>*>(t);
    if (pn)
        return new Node<B>( fmap<A>(f, pn->_left)
                          , fmap<A>(f, pn->_right));
    return nullptr;
}
```

簡単のため、メモリとリソース管理の問題は無視することにしたが、本番コードではおそらくスマート・ポインター (uniqueかsharedかはポリシーによる) を使うことになるだろう。

`fmap`のHaskell実装と比較してほしい。

```haskell
instance Functor Tree where
    fmap f (Leaf a) = Leaf (f a)
    fmap f (Node t t') = Node (fmap f t) (fmap f t')
```

この実装は、コンパイラによって自動的に導出することもできる。

## Writer関手

前に[Kleisli圏](#kleisli-categories)を説明したとき、戻ってくると約束した。この圏の射は、`Writer`データ構造体を返す「装飾された」関数として表現されていた。

```haskell
type Writer a = (a, String)
```

装飾は自己関手と何らかの関係があると述べた。そして実際、`Writer`型のコンストラクターは、`a`内で関手的だ。単純な直積型なので、`fmap`を実装する必要すらない。

しかし、Kleisli圏と関手の間には、どのような一般的な関係があるのだろうか？
Kleisli圏は圏であり、合成と恒等射を定義する。思い出してほしい。合成はfishオペレータによって与えられる:

```haskell
(>=>) :: (a -> Writer b) -> (b -> Writer c) -> (a -> Writer c)
m1 >=> m2 = \x ->
    let (y, s1) = m1 x
        (z, s2) = m2 y
    in (z, s1 ++ s2)
```

また、恒等射は`return`という関数によって計算される:

```haskell
return :: a -> Writer a
return x = (x, "")
```

この2つの関数の型を十分に長く見れば (つまり、十分に_長く_見れば)、それらを組み合わせて、`fmap`として機能する適切な型シグネチャを持つ関数を作成する方法を見つけられる。次のように:

```haskell
fmap f = id >=> (\x -> return (f x))
```

この例では、fish演算子は2つの関数を組み合わせている。1つはおなじみの`id`であり、もう1つは、引数に`f`を適用した結果に`return`を適用するラムダ関数だ。理解するのが最も難しいのは、おそらく`id`を使うことだ。Fish演算子の引数となる関数は、「通常の」型を受け取って装飾された型を返す関数ではないのだろうか？
実は、そんなことはない。`a -> Writer b`の`a`が「普通の」型でなければならないとは誰も言っていない。これは型変数なので、何でも構わない。特に、`Writer b`のように装飾された型にできる。

したがって、`id`は`Writer a`を受け取り、`Writer a`に変換する。Fish演算子は`a`の値を取り出し、`x`としてラムダに渡す。ここで、`f`はそれを`b`に変換し、`return`はそれを装飾して`Writer b`にする。これらすべてをまとめると、`Writer a`を受け取り、`Writer b`を返す関数が完成する。これは、`fmap`が生成するはずのものとまったく同じだ。

この引数は非常に汎用的であることに注意してほしい。`Writer`は、任意の型コンストラクタで置き換えられる。Fish演算子と`return`をサポートしていれば、`fmap`も定義できる。したがってKleisli圏の装飾は常に関手だ。(ただし、すべての関手がKleisli圏に由来するわけではない。)


先ほど定義した`fmap`は、コンパイラが`derivating Functor`を使って導出した`fmap`と同じではないかと思うかもしれない。とても興味深いことに、その通りだ。これは、Haskellが多相関数を実装する方法によるものだ。これは[パラメトリック多相]{.keyword #parametric_polymorphism}と呼ばれ、いわゆる[theorems for free]{.keyword #theorem_for_free}の根源となっている。これらの定理の1つは、与えられた型コンストラクタに対して`fmap`の実装があって、それが恒等射を保存するなら、それは一意である、と述べている。

## 共変関手と反変関手

Writer関手のレビューが終わったので、Reader関手に戻ろう。これは部分適用された関数-矢印の型コンストラクタに基づく:

```haskell
(->) r
```

これは型シノニムとして書き直せる:

```haskell
type Reader r a = r -> a
```

これに対する`Functor`インスタンスは、これまで見てきたように、次のようになる:

```haskell
instance Functor (Reader r) where
    fmap f g = f . g
```

しかし、型コンストラクターのペアあるいは`Either`型コンストラクターと同じく、この関数型コンストラクターは2つの型引数を取る。ペアと`Either`は両方の引数で関手的であり、双関手だった。この関数のコンストラクタも双関手だろうか？


最初の引数で関手的にしてみよう。型シノニムから始めよう――`Reader`と似ているが、引数が反転している:

```haskell
type Op r a = a -> r
```

今回は、戻り値の型`r`を修正し、引数の型`a`を変更する。次のような型シグニチャを持つ`fmap`を実装するために、何らかの方法で型を一致させられるか見てみよう:

```haskell
fmap :: (a -> b) -> (a -> r) -> (b -> r)
```

`a`を取りそれぞれ`b`と`r`を返す2つの関数だけでは、`b`を取り`r`を返す関数を作成する方法がまったくない。代わりに1つ目の関数を逆にして、`b`を受け取り`a`を返すようにできれば、状況は違ってくるだろう。任意の関数を逆にはできないが、反対圏に行くことはできる。

簡単に要約すると、圏$\cat{C}$ごとに、双対圏$\cat{C}^{op}$が存在する。これは$\cat{C}$と同じ対象を持つ圏だが、すべての矢印が逆になっている。

$\cat{C}^{op}$から他の圏$\cat{D}$への関手を考えてみよう:

$$F \Colon \cat{C}^{op} \to \cat{D}$$

このような関手は$\cat{C}^{op}$の射$f^{op} \Colon a \to b$を$\cat{D}$の射$F f^{op} \Colon F a \to F b$に写す。しかし、射$f^{op}$は、元の圏$\cat{C}$のある射$f \Colon b \to a$と密かに対応している。反転に注意してほしい。

さて、$F$は正則関手だが、$F$に基づいて定義できる別の写像があり、それは関手ではない。それを$G$と呼ぼう。これは$\cat{C}$から$\cat{D}$への写像だ。対象は$F$と同じ方法で写されるが、射は逆に写される。$\cat{C}$の射$f \Colon b \to a$を取り、それをまず反対の射$f^{op} \Colon a \to b$に写し、次に関手$F$を使って$F f^{op} \Colon F\ a \to F\ b$を取得する。

$F a$が$G a$と同じで、$F b$が$G b$と同じであることを考えると、この旅の全体を次のように記述できる:

$G f \Colon (b \to a) \to (G a \to G b)$

これは「ひねりのある関手」だ。このように射の方向を反転させる圏の写像は、_反変_ (contravariant) 関手と呼ばれる。反変関手は、反対圏からの正則関手 (regular functor) にすぎないことに注意してほしい。ところで、正則関手――これまでに学んだ関手――は_共変_ (covariant) 関手と呼ばれる。

![Contravariant](images/contravariant.jpg){width=30%}

以下の型クラスは、Haskellにおける反変関手 (実際には反変_自己_関手) を定義している:

```haskell
class Contravariant f where
    contramap :: (b -> a) -> (f a -> f b)
```

型コンストラクタ`Op`はそのインスタンスだ:

```haskell
instance Contravariant (Op r) where
    -- (b -> a) -> Op r a -> Op r b
    contramap f g = g . f
```

関数`f`は、`Op`の内容――関数`g`の_前_ (つまり右側) に、自身を挿入することに注意してほしい。

`Op`に対する`contramap`の定義は、単に引数を反転した関数合成演算子であることに注意すれば、さらに簡潔になるかもしれない。引数を反転するための`flip`という特別な関数がある:

```haskell
flip :: (a -> b -> c) -> (b -> a -> c)
flip f y x = f x y
```

これにより、次の結果が得られる:

```haskell
contramap = flip (.)
```

## プロ関手

これまで見てきたように、関手-矢印演算子は、最初の引数では反変、2番目の引数では共変だ。このような野獣に名前はあるのだろうか？
終域圏が$\Set$の場合、このような野獣は[プロ関手]{.keyword #profunctor} (profunctor) と呼ばれる。反変関手は反対圏の共変関手と等価なので、プロ関手は次のように定義される:

$$\cat{C}^{op} \times \cat{D} \to \Set$$

最初の近似ではHaskellの型は集合であるため、2つの引数の型コンストラクタ`p`に`Profunctor`という名前を適用する。1番目の引数は反-関手的で、2番目は関手的だ。`Data.Profunctor`ライブラリから取得した適切な型クラスは次のとおりだ:

```haskell
class Profunctor p where
  dimap :: (a -> b) -> (c -> d) -> p b c -> p a d
  dimap f g = lmap f . rmap g
  lmap :: (a -> b) -> p b c -> p a c
  lmap f = dimap f id
  rmap :: (b -> c) -> p a b -> p a c
  rmap = dimap id
```

これら3つの関数すべてにデフォルト実装がある。`Bifunctor`と同じように、`Profunctor`のインスタンスを宣言するとき、`dimap`を実装してデフォルトの`lmap`と`rmap`を受け入れるか、`lmap`と`rmap`の両方を実装してデフォルトの`dimap`を受け入れるか、どちらかを選択できる。

![dimap](images/dimap.jpg){width=40%}

ここで、関数-矢印演算子は`Profunctor`のインスタンスであると断言できる。

```haskell
instance Profunctor (->) where
  dimap ab cd bc = cd . bc . ab
  lmap = flip (.)
  rmap = (.)
```

プロ関手の応用としてはHaskellのlensライブラリがある。エンドとコエンドについて話すときに、また見ることになるだろう。

## Hom関手

上記の例は、対象$a$と$b$のペアを取り、それらの間の射の集合を割り当てる写像、hom集合$\cat{C}(a, b)$ が関手であるという、より一般的な命題を反映している。それは直積圏$\cat{C}^{op}\times{}\cat{C}$から集合の圏$\Set$への関手だ。

射に対する作用を定義してみよう。$\cat{C}^{op}\times{}\cat{C}$の射は、$\cat{C}$からの射のペアだ。

$$f \Colon a' \to a$$
$$g \Colon b \to b'$$

このペアのリフトは、集合$\cat{C}(a, b)$ から集合$\cat{C}(a', b')$ への射 (関数) でなければならない。$\cat{C}(a, b)$ の任意の要素$h$ ($a$から$b$への射) を選択し、次を割り当てるだけでよい:

$$g \circ h \circ f$$

これは$\cat{C}(a', b')$ の要素だ。

ご覧のとおり、hom関手はプロ関手の特殊なケースだ。

## 課題

1. データ型:

   ```haskell
   data Pair a b = Pair a b
   ```

   が双関手であることを示せ。追加の課題として、`Bifunctor`を3つの方法すべてで実装し、等式推論を使って、それらの定義が適用できる場合は常にデフォルトの実装と互換性があることを示せ。

2. `Maybe`の標準的な定義と次の脱糖との同型を示せ:

   ```haskell
   type Maybe' a = Either (Const () a) (Identity a)
   ```

   ヒント: 2つの実装の間に2つの写像を定義する。追加の課題として、等式推論を使って、それらが互いに逆であることを示せ。

3. 別のデータ構造を試してみよう。私はこれを`PreList`と呼んでいる。なぜなら、これは`List`の前身だからだ。これは再帰を型パラメータ`b`で置き換える。

   ```haskell
   data PreList a b = Nil | Cons a b
   ```

   `PreList`をそれ自体に再帰的に適用すれば、`List`の以前の定義を復元できる (どうなるかは、不動点について述べるときに説明する)。

   `PreList`が`Bifunctor`のインスタンスであることを示せ。

4. 次のデータ型が`a`および`b`の双関手を定義していることを示せ:

   ```haskell
   data K2 c a b = K2 c
   ```

   ```haskell
   data Fst a b = Fst a
   ```

   ```haskell
   data Snd a b = Snd b
   ```

   追加の課題として、Conor McBrideの論文[Clowns to the Left of me, Jokers to the Right](http://strictlypositive.org/CJ.pdf)と照らし合わせて解答を確認せよ。

5. Haskell以外の言語で双関手を定義せよ。その言語で`bimap`を総称ペア用に実装せよ。

6. `std::map`は、2つのテンプレート引数`Key`および`T`で双関手またはプロ関手と見なすべきか?そう見なせるようにするには、このデータ型をどう再設計すればよいか?
