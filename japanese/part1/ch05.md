# 積と余積 {#products-and-coproducts}

古代ギリシアの劇作家のエウリーピデースは「人間は、喜んで交際している仲間たちと異なるところがない」と言った^[訳注：『ポイニクス』812番の台詞に基づく。英訳の “Every man is like the company he is wont to keep.” が格言として広まったものと考えられる。この日本語訳は『ギリシア悲劇全集 (12) エウリーピデース断片』（岩波書店、1993）に従った。]。我々は人間関係によって定義される。これほど圏論に当てはまる言葉はない。圏の中の特定の対象を選び出すには、他の対象（およびそれ自身）との関係性のパターンを記述するしかない。それらの関係性は射によって定義される。

圏論では、[*普遍的構成*]{.keyword #universal_construction}\index{普遍的構成} (universal construction) と呼ばれる、対象をその関係性によって定義するための構成法がよく現れる。そのための方法の1つとしては、対象と射から構成された特定の形のパターンを選び、圏に出現するそのパターンをすべて探すことが挙げられる。そのパターンが十分に一般的で、圏が大きい場合、該当するものが山ほど出てくるだろう。秘訣は、該当したものに対するある種の順位付けを確立し、最適と考えられるものを選択することだ。

このプロセスはウェブ検索のやり方を思い起こさせる。クエリはパターンのようなものだ。非常に一般的なクエリなら、*再現率* (recall) が高く、すなわちヒットする数が多い。関連性があるものもあれば、そうでないものもあるだろう。無関係なヒットを削除するには、クエリを絞り込む。これにより*精度* (precision) が向上する。最終的に、検索エンジンは検索結果を順位付けして、うまくいけば、あなたが興味のある結果がリストの一番上に表示される。

## 始対象

最も単純な形は単一の対象だ。明らかに、この形の実例は、特定の圏にある対象と同じ数だけ存在する。それでは候補が多すぎる。ある種の順位付けを確立し、この階層のトップにある対象を見つける必要がある。我々が自由に使える唯一の手段は射だ。射を矢印として捉えるなら、矢印の全体的な総フローが、圏の一方の端から他方の端へと存在しうる。これは半順序などの順序付けられた圏に当てはまる。$a$から$b$へ向かう矢印（射）が存在するなら、対象$a$は対象$b$よりも「始め」だとして、対象の優先順位の概念を一般化できる。次に、*唯一の*始対象を、他のすべての対象に向かう射を持つものとして定義する。もちろん、そのような対象が存在する保証はない。だが、それについては大丈夫だ。より大きな問題は、そのような対象が多すぎるかもしれないことだ。再現率は高いが、精度を欠いている。解決策は、順序圏からヒントを得ることだ。それらの圏では、任意の2つの対象の間に高々1つの射しかない。そのため、別の対象以下となる方法は1つしかない。これは始対象の次のような定義につながる：

> **始対象** (the initial object) とは、圏内の任意の対象に対し、そこへ向かう射をちょうど1つだけ持つ対象である。

`\begin{figure}[H] \centering`{=latex}
![](images/initial.jpg){width=40%}
`\end{figure}`{=latex}

\noindent
それでも、始対象が（存在するにしても）一意だとは保証されない。しかし、それは次善のものを保証する。[*同型を除いて*]{.keyword #up_to_isomorphism}\index{同型を除いて}一意 (uniqueness up to isomorphism) という性質だ。同型は圏論では非常に重要なので、すぐに説明する。差し当たっては、同型を除いて一意という性質が始対象の定義における "the" の使用を正当化するのを認めることにしよう。

以下にいくつかの例を示す。半順序集合（partially ordered set、しばしばposetとも）では最小元が始対象となる。始対象を持たない半順序集合もある。たとえば、すべての整数の集合（正の数も負の数も含む）で、小なりイコール関係を射とするものだ。

集合と関数の圏では、始対象は空集合だ。空集合はHaskellの型`Void`に対応し（C++には対応する型は存在しない）、`Void`から他の型への一意な多相関数は`absurd`と呼ばれていたのを思い出してほしい。

```haskell
absurd :: Void -> a
```

\noindent
`Void`を型の圏における始対象にしているのは、この射の族なのだ。

## 終対象

引き続き単一対象パターンを扱うが、対象の順位付け方法を変更しよう。$b$から$a$への射がある場合、対象$a$は対象$b$よりも「終わりの側」と言える（方向が逆になっていることに注意してほしい）。探したいのは、圏のどの対象よりも終わりの側となる対象だ。再び、一意性を主張することになる：

> **終対象** (the terminal object) とは、圏内のどの対象からもちょうど1つの射しか来ない対象である。

`\begin{figure}[H] \centering`{=latex}
![](images/final.jpg){width=40%}
`\end{figure}`{=latex}

\noindent
繰り返しになるが、終対象は同型を除いて一意だ。これについてはすぐ後で説明する。まずは、いくつかの例を見てみよう。半順序集合では、終対象があれば、それが最大元だ。集合の圏では、終対象は単元集合だ。単元集合についてはすでに説明した。単元集合は、C++では`void`型に対応し、Haskellではunit型`()`に対応する。この型が持つ唯一の値は、C++では暗黙的だが、Haskellでは明示的に`()`で表される。また、任意の型からunit型へのちょうど1つの純粋関数が存在することも確認した：

```haskell
unit :: a -> ()
unit _ = ()
```

\noindent
これで、終対象のすべての条件が満たされた。

この例では、射の一意性という条件が決定的に重要であることに注意してほしい。なぜなら、すべての集合から入ってくる射を持つ他の集合（実際には、空集合を除くすべての集合）が存在するからだ。たとえば、すべての型に対して定義されたブール値関数（述語）がある：

```haskell
yes :: a -> Bool
yes _ = True
```

\noindent
しかし、`Bool`は終対象ではない。すべての型に対して、少なくとももう1つの`Bool`値関数がある（`Void`に対してはどちらの関数も`absurd`と等しくなるので除く）：

```haskell
no :: a -> Bool
no _ = False
```

\noindent
一意性を主張することで、終対象の定義を1つの型だけに絞り込むのにちょうど良い精度が得られる。

## 双対性

始対象と終対象の定義の対称性には注目せずにいられないだろう。両者の唯一の違いは、射の方向だった。どの圏$\cat{C}$に対しても、すべての射を反転させるだけで[*反対圏*]{.keyword #opposite_category}\index{反対圏} (opposite category) $\cat{C}^\mathit{op}$を定義できると分かる。
反対圏は、同時に合成を再定義しさえすれば、圏としての要件をすべて自動的に満たす。もとの射$f \Colon a \to b$と$g \Colon b \to c$が$h=g \circ f$によって$h \Colon a \to c$へと合成される場合、逆の射$f^\mathit{op} \Colon b \to a$と$g^\mathit{op} \Colon c \to b$は$h^\mathit{op} = f^\mathit{op} \circ g^\mathit{op}$によって$h^\mathit{op} \Colon c \to a$へと合成される^[訳注：本書ではHaskellの記法にならってか、射についても$\colon$でなく$\Colon$が用いられている。]。
そして、恒等射を反転させることは、（駄洒落に注意！）no-opだ。

双対性は圏の非常に重要な特性だ。圏論を扱うすべての数学者の生産性を倍増させるからだ。思いつくすべての構成にはその反対があり、そして、証明するすべての定理について無料でもう1つ付いてくる。反対圏の構成にはしばしば「余」(co) が前置され、積と余積、モナドとコモナド、錐と余錐、極限と余極限などがある。ただし、射を2回反転させればもとの状態に戻るので、ココモナドはない。

そのため、終対象は反対圏の始対象だと言える。

## 同型

プログラマーである我々は、等しさを定義することが簡単な作業ではないことをよく知っている。2つのオブジェクトが等しいとはどういう意味だろう？　メモリー内の同じ場所を占有する必要があるだろうか（ポインターの等しさ）。あるいは、すべての要素の値が同じであれば十分だろうか？　2つの複素数の一方を実部と虚部で表し、もう一方を絶対値と偏角で表すしたとき、それらは等しいだろうか？　数学者たちが等しさの意味を解明済みだろう、と思うかもしれないが、そうではない。数学においても、等しさには複数の競合する定義があるという、同じ問題がある。命題として表される等しさ (propositional equality)、内包的な
等しさ (intensional equality)、外延的な等しさ (extensional equality)、ホモトピー型理論における道 (path) としての等しさがある。そして同型 (isomorphism) のより弱い概念、さらには等価性 (equivalence) のより弱い概念もある。

直観としては、同型の対象は同じように見える。つまり、同じ形をしている。これは、1対1写像により、ある対象のどの一部も別の対象のどこか一部に対応することを意味する。我々の道具で調べうる限り、2つの対象はお互いの完全なコピーだ。数学的には、対象$a$から対象$b$への写像があり、対象$b$から対象$a$への写像があり、それらが互いの逆であることを意味する。圏論では、写像を射に置き換える。同型射は可逆な射、つまり一方が他方の逆になっているような射のペアだ。

逆であるということは合成と恒等射によって理解できる。射$g$が射$f$の逆であるのは、それらの合成が恒等射となる場合だ。それら2つの射は、合成する方法が2つあるので、実際には2つの等式で表される：

```haskell
f . g = id
g . f = id
```

\noindent
始（終）対象が同型を除いて一意だと言ったとき、2つの始（終）対象は同型だということを意味していた。これは簡単に理解できる。2つの始対象$i_{1}$と$i_{2}$があるとしよう。$i_{1}$が始対象であるため、$i_{1}$から$i_{2}$への一意な射$f$が存在する。同様に、$i_{2}$が始対象であるため、$i_{2}$から$i_{1}$への一意な射$g$が存在する。これらの2つの射を合成すると何になるだろう？

![この図中のすべての射は一意だ](images/uniqueness.jpg "この図中のすべての射は一意だ"){width=40%}

\noindent
合成$g \circ f$は、$i_{1}$から$i_{1}$への射でなければならない。しかし、$i_{1}$は始対象なので、$i_{1}$から$i_{1}$へ向かう射は1つだけだ。圏の中なので、$i_{1}$から$i_{1}$への恒等射があるのは分かっている。候補は1つだけなので、$g \circ f$はそれでなければならない。したがって、$g \circ f$は恒等射と等しくなる。同様に、$f \circ g$は恒等射と等しくなければならない。$i_{2}$から$i_{2}$に戻る射は1つしかないからだ。これは、$f$と$g$が互いの逆でなければならないことを証明している。したがって、任意の2つの始対象は同型だ。

この証明では、始対象からそれ自体への射の一意性を用いたことに注意してほしい。そうしなければ「同型を除いて」の部分は証明できない。しかし、なぜ$f$と$g$の一意性が必要なのだろうか。始対象は同型を除いて一意なだけでなく、*一意な*同型を除いて一意だからだ。原則として、2つの対象間には複数の同型が存在する可能性があるが、ここではそうではない。この「一意な同型を除いて一意という性質」は、すべての普遍的構成の重要な特性だ。

## 積

次の普遍的構成は積 (product) に関するものだ。2つの集合のデカルト積 (Cartesian product) が何なのかは知っている。ペアからなる集合だ。しかし、集合の積とそれを構成する集合を結びつけるパターンは何だろう？　それが分かれば、他の圏にも一般化できるはずだ。

唯一言えるのは、積から各構成要素への射影 (projection) という関数が2つある、ということだ。Haskellでは、これら2つの関数は`fst`と`snd`と呼ばれ、それぞれペアの第一要素と第二要素を抜き出す：

```haskell
fst :: (a, b) -> a
fst (x, y) = x
```

```haskell
snd :: (a, b) -> b
snd (x, y) = y
```

\noindent
ここで、関数は引数に対するパターンマッチングによって定義されている。パターン`(x, y)`は任意のペアにマッチし、要素を変数`x`と`y`に抽出する。

これらの定義はワイルドカードを使ってさらに単純化できる：

```haskell
fst (x, _) = x
snd (_, y) = y
```

\noindent
C++では、たとえば次のようなテンプレート関数が使われるだろう：

```cpp
template<class A, class B>
A fst(pair<A, B> const & p) {
    return p.first;
}
```

\noindent
この非常に限られているように一見思える知識をもって、2つの集合（$a$と$b$）の積の構成につながる、集合の圏における対象と射のパターンを定義してみよう。このパターンは対象$c$と、それぞれ$a$と$b$に接続される2つの射$p$と$q$とで構成される：

```haskell
p :: c -> a
q :: c -> b
```

`\begin{figure}[H] \centering`{=latex}
![](images/productpattern.jpg){width=30%}
`\end{figure}`{=latex}

\noindent
このパターンに一致するすべての$c$が積の候補となる。それは大量にあるかもしれない。

`\begin{figure}[H] \centering`{=latex}
![](images/productcandidates.jpg){width=40%}
`\end{figure}`{=latex}

\noindent
たとえば、構成要素として、2つのHaskellの型`Int`と`Bool`を選択してみて、それらの積の候補を挙げてみよう。

1番目の候補は`Int`だ。`Int`は`Int`と`Bool`の積の候補となるだろうか？　そう、候補となる――その射影はこうなる：

```haskell
p :: Int -> Int
p x = x

q :: Int -> Bool
q _ = True
```

\noindent
これはかなり酷いが、基準を満たしている。

2番目の候補は`(Int, Int, Bool)`だ。要素が3つの組、すなわち3つ組だ。これを正当な候補にする2つの射を以下に示す（ここでは3つ組に対してパターンマッチングを使っている）：

```haskell
p :: (Int, Int, Bool) -> Int
p (x, _, _) = x

q :: (Int, Int, Bool) -> Bool
q (_, _, b) = b
```

\noindent
1番目の候補は狭すぎ、積の`Int`の次元だけをカバーしている。一方で、2番目の候補は大きすぎ、`Int`の次元が重複してしまっている。

しかし、この普遍的構成の別の部分である順位付けについてはまだ調べていない。そこで、パターンの2つの例を比較できるようにしたい。つまり、対象の1つの候補$c$とその2つの射影$p$および$q$を、別の対象の候補$c'$とその2つの射影$p'$および$q'$と比較したい。$c'$から$c$への射$m$がある場合に、$c$は$c'$よりも「優れている」と言いたいのだが、それではあまりにも弱い。それに加えて、$c$の射影たちが$c'$の射影たちよりも「優れている」、すなわち「より普遍的」であってほしい。つまり、射影$p'$と$q'$は、$p$と$q$から$m$を使って再構成できるということだ：

```haskell
p' = p . m
q' = q . m
```

`\begin{figure}[H] \centering`{=latex}
![](images/productranking.jpg){width=40%}
`\end{figure}`{=latex}

\noindent
別の観点でこれらの等式を見ると、$m$は$p'$と$q'$を*分解* (factorize) している。これらの等式が自然数について成り立ち、ドットが乗算であると仮定すると、$m$は$p'$と$q'$に共通な因数だ。

ある種の直観を築くために、ペア型`(Int, Bool)`およびその正統な射影`fst`と`snd`が、前に提示した2つの候補より本当に*優れている*ことを示そう。

`\begin{figure}[H] \centering`{=latex}
![](images/not-a-product.jpg){width=40%}
`\end{figure}`{=latex}

\noindent
1番目の候補に対する写像`m`は次のようになる：

```haskell
m :: Int -> (Int, Bool)
m x = (x, True)
```

\noindent
実際、2つの射影`p`と`q`は次のように再構成できる：

```haskell
p x = fst (m x) = x
q x = snd (m x) = True
```

\noindent
2番目の例の`m`も同様に一意に定まる：

```haskell
m (x, _, b) = (x, b)
```

\noindent
`(Int, Bool)`が2つの候補のどちらよりも優れていることを示せた。その逆がなぜ真ではないのかを見てみよう。`p`と`q`から`fst`と`snd`を再構築するのに役立つ`m'`を見つけられるだろうか？

```haskell
fst = p . m'
snd = q . m'
```

\noindent
1番目の例では、`q`は常に`True`を返す。しかし、第2要素が`False`であるペアが存在するのは分かっている。したがって、`q`からは`snd`を再構築できない。

2番目の例は別物だ。`p`または`q`を経た後でも十分な情報が保持される。しかし、`fst`と`snd`を分解する方法が複数ある。`p`と`q`はどちらも3つ組の第2要素を無視するので、`m'`はそこに何でも入れられる。たとえば：

```haskell
m' (x, b) = (x, x, b)
```

\noindent
あるいは：

```haskell
m' (x, b) = (x, 42, b)
```

\noindent
などを定義できる。

以上すべてをまとめると、2つの射影`p`と`q`を持つ任意の型`c`について、それらの射影を分解する一意な`m`が`c`からデカルト積`(a, b)`へと存在する。実際には、`p`と`q`を組み合わせてペアにしているだけだ：

```haskell
m :: c -> (a, b)
m x = (p x, q x)
```

\noindent
これによってデカルト積`(a, b)`がベストマッチとなり、すなわち、この普遍的構成が集合の圏で機能することを意味する。この構成は任意の2つの集合の積を選ぶ。

さて、集合のことは忘れて、同じ普遍的構成を使って任意の圏にある2つの対象の積を定義しよう。そのような積が必ず存在するわけではないが、存在する場合は、一意な同型を除いて一意だ。

> 2つの対象$a$と$b$の**積**とは、2つの射影を伴う対象$c$であり、別の任意の対象$c'$が伴う2つの射影について、それらを分解する$c'$から$c$への一意な射$m$が存在するものを言う。

2つの候補から分解関数`m`を生成する（高階）関数は、[*factorizer*]{.keyword #factorizer}\index{factorizer}と呼ばれることもある。この例では、次の関数になる：

```haskell
factorizer :: (c -> a) -> (c -> b) -> (c -> (a, b))
factorizer p q = \x -> (p x, q x)
```

## 余積

圏論のすべての構成と同じく、積にも双対があり、余積 (coproduct) と呼ばれる。積のパターンの射を反転させると、2つの*入射* (injection) `i`と`j`を伴う対象*c*になる^[訳注：関数としての単射もinjectionだが、混乱を避けるために別の訳語をあてた。]。すなわち、$a$と$b$から$c$への射だ。

```haskell
i :: a -> c
j :: b -> c
```

`\begin{figure}[H] \centering`{=latex}
![](images/coproductpattern.jpg){width=40%}
`\end{figure}`{=latex}

\noindent
順位付けも逆転している：対象$c$は、もし$c$から$c'$への射$m$が単射を分解するなら、$i'$と$j'$の単射を伴う対象$c'$よりも「優れて」いる。

```haskell
i' = m . i
j' = m . j
```

`\begin{figure}[H] \centering`{=latex}
![](images/coproductranking.jpg){width=40%}
`\end{figure}`{=latex}

\noindent
「最も優れた」対象は、そこから他のどのパターンへも一意な射を持つもので、余積と呼ばれ、存在する場合は、一意な同型を除いて一意だ。

> 2つの対象$a$と$b$の**余積**とは、2つの単射を伴う対象$c$であり、別の任意の対象$c'$が伴う2つの単射について、それらを分解する$c$から$c'$への一意な射$m$が存在するものを言う。

集合の圏では、余積は2つの集合の*非交和* (disjoint union) だ。$a$と$b$の非交和の要素は、$a$の要素か$b$の要素のどちらかだ。2つの集合が重なる場合、非交和には共通部分のコピーが2つ含まれる。非交和の要素は起源を示す識別子でタグ付けされていると見なせる。

プログラマーにとっては、型の観点から余積を理解する方が簡単だ。それは2つの型からなるタグ付き和 (tagged union) だ。C++がサポートしている共用体 (union) はタグ付けされていない。つまり、プログラム内では共用体のどのメンバーが有効であるかを何らかの方法で追跡しなければならないということだ。タグ付き共用体を作成するには、タグ――列挙型――を定義して共用体と結びつける必要がある。たとえば、`int`と`char const*`のタグ付き共用体は次のように実装できる：

```cpp
struct Contact {
    enum { isPhone, isEmail } tag;
    union { int phoneNum; char const * emailAddr; };
};
```

\noindent
これに対する2つの入射は、コンストラクターとしても、関数としても実装できる。たとえば、最初の単射を関数`PhoneNum`として実装するとこうなる：

```cpp
Contact PhoneNum(int n) {
    Contact c;
    c.tag = isPhone;
    c.phoneNum = n;
    return c;
}
```

\noindent
これは`Contact`に整数を注入 (inject) する。

タグ付き共用体は[*variant*]{.keyword #variant}\index{variant}とも呼ばれ、boostライブラリーに非常に汎用的な`boost::variant`という実装がある^[訳注：C++17以降では`std::variant`が利用できる。<https://cpprefjp.github.io/reference/variant/variant.html>を参照。]。

Haskellでは、データ構成子を縦棒で区切ることで、任意のデータ型をタグ付き和にまとめられる。`Contact`の例だと次のような宣言になる：

```haskell
data Contact = PhoneNum Int | EmailAddr String
```

\noindent
ここで、`PhoneNum`と`EmailAddr`は、構成子（入射）としても、パターンマッチングのタグとしても機能する（これについては後で詳しく説明する）。たとえば、電話番号を使って連絡先を構成する方法はこうなる：

```haskell
helpdesk :: Contact
helpdesk = PhoneNum 2222222
```

\noindent
正統な実装では、積がプリミティブなペアとしてHaskellに組み込まれているのに対し、余積は`Either`と呼ばれるデータ型であり、標準のPreludeで次のように定義されている：

```haskell
data Either a b = Left a | Right b
```

\noindent
これは`a`と`b`の2つの型によってパラメーター化され、2つの構成子を持つ。すなわち、型`a`の値を取る`Left`と、型`b`の値を取る`Right`だ。

積についてfactorizerを定義したのと同様に、余積についても定義できる。余積の型の候補`c`と2つの入射の候補`i`と`j`について、`Either`に対するfactorizerは次の分解関数を生成する：

```haskell
factorizer :: (a -> c) -> (b -> c) -> Either a b -> c
factorizer i j (Left a)  = i a
factorizer i j (Right b) = j b
```

## 非対称性

これまでに2組の双対の定義を見てきた。終対象の定義は、始対象の定義から射の方向を反転させることで得られ、余積の定義は積の定義から得られる。しかし、集合の圏では、始対象と終対象は大きく異なり、余積と積は大きく異なる。後述するように、積は乗算のように振る舞い、終対象は1の役割を果たし、余積は和のように振る舞い、始対象は0の役割を果たす。特に、有限集合の場合、積のサイズは個々の集合のサイズの積であり、余積のサイズはサイズの合計だ。

これは集合の圏が射の反転に関して対称でないことを示している。

空集合については、どの集合に対しても一意な射（`absurd`関数）がある一方で、戻ってくる射はないことに注意してほしい^[訳注：ただし、空集合自身から戻ってくる恒等射（これも`absurd`関数）は存在する。]。単元集合では、どの集合からも一意な射が来るうえに、（空集合を除く）すべての集合へ向かう外向きの射*も*ある。これまで見てきたように、終対象から発するこれらの射^[訳注：終対象の定義では終対象へ向かう射についてしか述べていないので、終対象から他の対象へ向かう射が存在するのは何の問題もない。]は、他の集合の要素を選択するのに非常に重要な役割を果たしている（空集合には要素がないので、選択するものは何もない）。

単元集合と積の関係は、余積とは全く違う。unit型`()`で表される単元集合を、積パターンのもう1つの――非常に劣った――候補として使うことを考えてみてほしい。それを2つの射影`p`と`q`、すなわち単元集合から各構成要素の集合への関数として実装してみよう。それらは具体的な要素をそれぞれの集合から選択する。積は普遍的なので、ここでの候補の単元集合から積への（一意な）射`m`も存在する。この射は積の集合から要素を選択する。つまり、具体的なペアを選択する。さらに、次の2つの射影を分解する：

```haskell
p = fst . m
q = snd . m
```

\noindent
単元集合の唯一の要素である値`()`に作用させると、これら2つの式は次のようになる：

```haskell
p () = fst (m ())
q () = snd (m ())
```

\noindent
`m ()`は`m`によって選択された積の要素なので、これらの式は、第1の集合から`p`によって選択された要素`p ()`が、`m`によって選択されたペアの第1要素であることを示す。同様に、`q ()`は第2要素に等しい。これは、積の要素は構成要素の集合からの要素のペアであるという理解と完全に一致している。

余積にはそのような単純な解釈はない。単元集合を余積での候補として要素を抽出しようと試みることもできるが、2つの射影がそこから出てくるのではなく、2つの入射がそこに入ることになる。それらはその起源について何も教えてくれないだろう（実際、入力パラメーターが無視されるのを見てきた）。また、余積から単元集合への一意な射についても同様だろう。集合の圏は、始対象の向きから見たときと終対象から見たときとでは全く違って見える。

これは集合の固有の特性ではなく、$\Set$で射として使う関数の特性だ。関数は（一般に）非対称だ。説明しよう。

関数は、その始域 (domain) のすべての要素に対して定義する必要がある（プログラミングでは[*全*]{.keyword #total}\index{全}関数 (total function) と呼ぶ）。しかし、終域 (codomain) 全体を網羅する必要はない。すでにその極端な例をいくつか見てきた。単元集合からの関数たち――終域内の1つの要素だけを選択する関数たちのことだ。（実際に、空集合からの関数は本当に極端だ。）
始域のサイズが終域のサイズよりもずっと小さい場合、我々はよく、始域を終域に埋め込むような関数を思い浮かべる。たとえば、単元集合からの関数は、その1つの要素を終域に埋め込むものだと考えられる。私はそれらを[*埋め込み*]{.keyword #embedding}\index{埋め込み} (embedding) 関数と呼んでいるが、数学者は反対のものに名前を付ける方を好む。つまり、終域をきっちり満たす関数を[*全射*]{.keyword #surjective}\index{全射} (surjective) または[*上への*]{.keyword #onto}\index{上への} (onto) 関数と呼ぶ。

非対称性のもう1つの原因は、関数が始域の複数の要素を終域の1つの要素に写せることだ。そういった関数はそれらの要素を潰す (collapse) ことができる。極端な例としては、集合全体を単元集合に写す関数が挙げられる。これまでに、まさにそれを行う多相`unit`関数を見てきた。合成すると、より酷く潰すことにしかならない。潰す関数2つの合成は、個々の関数よりもさらに潰すことになる。数学者は潰さない関数を[*単射*]{.keyword #injective}\index{単射} (injective) または[*1対1*]{.keyword #one-to-one}\index{1対1} (one-to-one) という名前で呼ぶ。

当然、埋め込みも潰しもしない関数もある。それらは[*全単射*]{.keyword #bijections}\index{全単射} (bijection) と呼ばれ、可逆なので真に対称だ。集合の圏では、同型は全単射と同じだ。

## 課題

#. 終対象が一意な同型を除いて一意であることを示せ。

#. 半順序集合において2つの対象の積は何か？　ヒント：積の普遍的構成を使う。

#. 半順序集合において2つの対象の余積は何か？

#. Haskellの`Either`に相当するものを、（Haskell以外の）好きな言語で総称型として実装せよ。

#. `Either`が、次の2つの単射を伴う`int`よりも「優れた」余積であることを示せ。

   ```cpp
   int i(int n) { return n; }
   int j(bool b) { return b? 0: 1; }
   ```

   \noindent
   ヒント：関数

   ```cpp
   int m(Either const & e);
   ```

   \noindent
   を、`i`と`j`を分解するように定義する。

#. 前の問題の続き：`i`と`j`という2つの単射を伴う`int`が`Either`よりも「優れている」ことはあり得ないと主張するにはどうすればよいか？

#. さらに続き：次の単射についてはどうか？

   ```cpp
   int i(int n) {
       if (n < 0) return n;
       return n + 2;
   }
   int j(bool b) { return b? 0: 1; }
   ```

\noindent
#. `int`と`bool`の余積の候補として、`Either`への射を複数許容するという理由で`Either`より劣るものを挙げよ。

## 参考文献

#. Catstersの[Products and Coproducts](https://www.youtube.com/watch?v=upCSDIO9pjc)^[<https://www.youtube.com/watch?v=upCSDIO9pjc>]の動画
