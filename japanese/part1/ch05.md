# 積と余積 {#products-and-coproducts}

## 矢に従え

古代ギリシアの劇作家のエウリピデスはかつてこう言った。「すべての人は、いつも一緒にいる仲間のようなものだ。」我々は人間関係によって定義される。これほど圏論に当てはまる言葉はない。圏の中の特定の対象を選び出すには、他の対象 (およびそれ自身) との関係のパターンを記述するしかない。これらの関係は射によって定義される。

圏論には[普遍構成]>{.keyword #universal_construction} (universal construction) と呼ばれる共通の構成があり、対象をその関係の観点から定義する。これを行う1つの方法は、対象と射から構成された特定の形のパターンを選び、圏に出現するすべてのパターンを探すことである。それが十分に一般的なパターンであり、圏が大きい場合、多くのヒットを得る可能性がある。秘訣は、これらのヒットの中からある種の順位付けを確立し、最適と考えられるものを選択することだ。

このプロセスは、ウェブ検索のやり方を思い起こさせる。クエリはパターンのようなものだ。非常に一般的なクエリでは、大きな_呼び出し_、つまり多数のヒットが返される。関連性のあるものとそうでないものがある。無関係なヒットを削除するには、クエリを絞り込む。これにより_精度_が向上する。最終的に、検索エンジンは検索結果をランク付けして、うまくいけば、あなたが興味のある結果がリストの一番上に表示される。

## 始対象

最も単純な形は単一の対象だ。明らかに、この形のインスタンスは、特定の圏にある対象と同じ数だけ存在する。それでは候補が多すぎる。ある種の順位付けを確立し、この階層のトップにある対象を見つける必要がある。利用できる唯一の手段は射だ。射を矢として捉えるなら、圏の一方の端から他方の端への矢の全体的な総フローが存在する可能性がある。これは、半順序など、順序付けられた圏に当てはまる。$a$から$b$へ向かう矢 (射) が存在するなら、対象$a$は対象$b$よりも「始め」だとして、対象の優先順位の概念を一般化できる。次に、_その_始対象を、他のすべての対象に向かう矢を持つものとして定義する。もちろんそのような対象が存在する保証はないが、大丈夫だ。より大きな問題は、そのような対象が多すぎる可能性があることだ。recallは良好であるが、精度に欠けている。この問題を解決するには、順序付けられた圏からヒントを得る必要がある。これらの圏では、任意の2つの対象の間に最大で1つの矢を許す。別の対象以下となる方法は1つしかない。これは始対象の次のような定義につながる:

> **始対象** (the initial object) は、圏内の任意の対象に向かう射がただ1つだけある対象だ。

![](images/initial.jpg){width=40%}

ただし、それでも始対象が (存在するにしても) 一意だとは保証されない。しかし、それは次善のものを保証する: [同型を除いて]{.keyword #up_to_isomorphism}一意 (unique up to isomorphism) という性質だ。同型は圏論では非常に重要なので、すぐに述べる。差し当たっては、同型を除いて一意という性質が始対象の定義における「the」の使用を正当化することに同意しよう。

以下にいくつかの例を示す。部分的に順序付けられた集合 (しばしば[ポセット]{.keyword #poset} (poset) と呼ばれる) 内の始対象は、その最小要素だ。ポセットの中には、始対象を持たないものもある。たとえば、正と負のすべての整数の集合のように、射に対して等号付き大小関係を持つものだ。

集合と関数の圏では、始対象は空集合だ。空集合はHaskellの型`Void`に対応し (C++には対応する型は存在せず)、`Void`から他の型への一意な多相関数は`absurd`と呼ばれることを覚えてほしい。

```haskell
absurd :: Void -> a
```

`Void`を型の圏における始対象にしているのは、この射の族なのだ。

## 終対象

単一対象パターンを続けるが、対象のランク付け方法を変更しよう。$b$から$a$への射がある場合、対象$a$は対象$b$よりも「終わりの側」と言える (方向が逆になっていることに注意してほしい)。探したいのは、圏のどの対象よりも終わりの側となる対象だ。再び、一意性を主張することになる:

> **終対象**は、圏内のどの対象からも1つの射しか来ない対象だ。

![](images/final.jpg){width=40%}

繰り返すが、終対象は同型を除いて一意だ。これについては後でお見せする。まずは、いくつかの例を見てみよう。ポセットでは、終対象があれば、それが最大の対象だ。集合の圏では、終対象は単集合だ。単集合についてはすでに説明した。単集合は、C++では`void`型に対応し、Haskellではunit型`()`に対応する。これは1つの値しか持たない型で、C++では暗黙的に、Haskellでは明示的に、`()`で表される。我々はまた、あらゆる型からunit型への、唯一の純粋関数が存在することを確立した。

```haskell
unit :: a -> ()
unit _ = ()
```

それゆえ、終対象のすべての条件が満たされる。

この例では、一意性条件が決定的に重要であることに注意してほしい。なぜなら、すべての集合から入ってくる射を持つ他の集合 (実際には、空集合を除くすべての集合) が存在するからだ。たとえば、すべての型に対して定義されたブール値関数 (述語) がある。

```haskell
yes :: a -> Bool
yes _ = True
```

しかし`Bool`は終対象ではない。すべての型で少なくとももう1つの`Bool`値関数がある (`Void`については、どちらの関数も`absurd`と等しくなるので除く):

```haskell
no :: a -> Bool
no _ = False
```

一意性を主張することで、終対象の定義を1つの型だけに絞り込むのにちょうど良い精度が得られる。

## 双対性

我々が定義した始対象と終対象の間の対称性に気付かずにはいられない。両者の唯一の違いは、射の方向だった。どの圏$\cat{C}$に対しても、すべての矢を逆にするだけで[反対圏]{.keyword #opposite_category} (opposite category) $\cat{C}^{op}$を定義できるとわかる。反対圏は、同時に圏を再定義する限り、合成のすべての要件を自動的に満たす。元の射$f \Colon a \to b$と$g \Colon b \to c$が$h=g \circ f$によって$h \Colon a \to c$へと合成される場合、逆の射$f^{op} \Colon b \to a$と$g^{op} \Colon c \to b$は$h^{op} = f^{op} \circ g^{op}$によって$h^{op} \Colon c \to a$へと合成される。そして、恒等射の矢を逆にすることは、(駄洒落に注意！)
no-opだ。

双対性は、圏論を扱うすべての数学者の生産力を倍増させるため、圏の非常に重要な特性だ。思いつくすべての構成には反対圏があり、証明するすべての定理について無料で手に入る。反対圏の構成にはしばしば「余」(co) が前置され、積と余積、モナドとコモナド、錐と余錐、極限と余極限などがある。しかし、矢を2回反転させると元の状態に戻るので、ココモナドはない。

したがって、終対象は反対圏の始対象だ。

## 同型

プログラマーである我々は、等値性を定義することが簡単な作業ではないことをよく知っている。2つの物体が等しいとはどういう意味だろう？
メモリ内の同じ場所を占有する必要があるだろうか (ポインタの等価性)。あるいは、すべてのコンポーネントの値が同じであれば十分だろうか？
2つの複素数のうち、一方を実部と虚部で表し、もう一方を絶対値と角度で表すと、2つの複素数は等しいだろうか。あなたは数学者が等値性の意味を解明したと思うだろうが、そうではない。彼らも、等値性に複数の競合する定義があるという、同じ問題を抱えている。命題的等値性、内包的等値性、外延的等値性、ホモトピー型理論の経路としての等値性がある。And then there are the weaker notions of isomorphism, and even weaker of equivalence.

直観では、同型の対象は同じように見える――同じ形をしている。これは、1対1の写像において、ある対象のすべての各部分が別の対象の一部に対応することを意味する。調べ得る限り、2つの物体はお互いの完全なコピーだ。数学的には、対象$a$から対象$b$への写像があり、対象$b$から対象$a$への写像があり、それらは互いに逆であることを意味する。圏論では、写像を射に置き換える。同型は可逆な射だ。つまり、一方が他方の逆である射の対だ。

逆については合成と恒等射の観点で理解している。射$g$は、合成が恒等射の場合、射$f$の逆になる。2つの射を構成する2つの方法があるため、これらは実際には2つの等式だ。

```haskell
f . g = id
g . f = id
```

始 (終) 対象が同型を除いて一意だと言ったとき、2つの始 (終) 対象は同型だということを意味していた。それは確かに理解しやすい。2つの始対象$i_{1}$と$i_{2}$があるとする。$i_{1}$が始対象であるため、$i_{1}$から$i_{2}$への一意な射$f$が存在する。同様に、$i_{2}$が始対象であるため、$i_{2}$から$i_{1}$への一意な射$g$が存在する。この2つの射の合成は何か？


![この図中のすべての射は一意だ](images/uniqueness.jpg){width=40%}

合成$g\circ f$は、$i_{1}$から$i_{1}$への射でなければならない。しかし、$i_{1}$は始対象なので、$i_{1}$から$i_{1}$へ向かう射は1つだけだ。圏の中なので、$i_{1}$から$i_{1}$への恒等射があるのは分かっている。そして、候補は1つだけなので、それで間違いない。したがって、$g\circ f$は恒等射と等しくなる。同様に、$f\circ g$は恒等射と等しくなければならない。なぜなら、$i_{2}$から$i_{2}$に戻る射は1つしかないからだ。これは、$f$と$g$が互いに逆でなければならないことを証明している。したがって、任意の2つの始対象は同型だ。

この証明では、始対象からそれ自体への射の一意性を用いたことに注意してほしい。そうしなければ「同型を除いて」の部分は証明できない。しかし、なぜ$f$と$g$の一意性が必要なのだろうか。始対象は同型を除いて一意なだけでなく、_一意な_同型を除いて一意だ。原則として、2つの対象間に複数の同型が存在する可能性があるが、ここではそうではない。この「一意な同型を除いて一意という性質」は、すべての普遍的な構造の重要な特性だ。

## 積

次の普遍構成は積の構成だ。我々は2つの集合のカルテシアン積が何かを知っている: それはペアからなる集合だ。しかし、積の集合とそれを構成する集合を結びつけるパターンは何だろうか。それがわかれば、他の圏にも一般化できるだろう。

我々が言えるのは、積から各構成要素への射影という2つの関数があるということだけだ。Haskellでは、これら2つの関数は`fst`と`snd`と呼ばれ、それぞれペアの最初と2番目の要素を選択する。

```haskell
fst :: (a, b) -> a
fst (x, y) = x
```

```haskell
snd :: (a, b) -> b
snd (x, y) = y
```

ここで、関数は引数のパターンマッチングによって定義される。任意のペアにマッチするパターンは`(x, y)`であり、その要素を変数`x`と`y`に抽出する。

これらの定義は、ワイルドカードを使ってさらに単純化できる。

```haskell
fst (x, _) = x
snd (_, y) = y
```

C++では、次のようなテンプレート関数を使う。

```cpp
template<class A, class B>
A fst(pair<A, B> const & p) {
    return p.first;
}
```

この一見非常に限られた知識をもって、集合の圏における対象と射のパターンを定義してみよう。このパターンは、2つの集合 ($a$と$b$) からなる積の構成につながる。このパターンは、対象$c$と2つの射$p$と$q$で構成され、それぞれ$a$と$b$に接続される。

```haskell
p :: c -> a
q :: c -> b
```

![](images/productpattern.jpg){width=30%}

このパターンに一致するすべての$c$は、積の候補と見なされる。それは大量にあるかもしれない。

![](images/productcandidates.jpg){width=40%}

たとえば、構成要素として、2つのHaskellの型`Int`と`Bool`を選択し、それらの積の候補を挙げてみよう。

1番目の候補は`Int`だ。`Int`は`Int`と`Bool`の積の候補と見なせるだろうか？
そう、見なせる――その射影はこうなる:

```haskell
p :: Int -> Int
p x = x

q :: Int -> Bool
q _ = True
```

これはかなり酷いが、基準を満たしている。

2番目の候補は`(Int, Int, Bool)`だ。要素が3つのタプル、あるいはトリプルだ。これを正当な候補にする2つの射を以下に示す (ここではトリプルに対してパターンマッチングを使っている)。

```haskell
p :: (Int, Int, Bool) -> Int
p (x, _, _) = x

q :: (Int, Int, Bool) -> Bool
q (_, _, b) = b
```

1番目の候補は小さすぎ、積の`Int`次元だけをカバーしている。一方で、2番目の候補は大きすぎ、`Int`次元が誤って重複している。

しかし、この普遍構成の他の部分である順位付けについてはまだ調べていない。そこで、パターンの2つのインスタンスを比較できるようにしたい。つまり、対象の1つの候補$c$とその2つの射影$p$および$q$を、別の対象の候補$c'$とその2つの射影$p'$および$q'$と比較したい。$c'$から$c$への射$m$がある場合に$c$は$c'$よりも「優れている」と言いたいのだが、それではあまりにも弱い。$c$の射影が$c'$の射影よりも「優れている」、あるいは「より普遍的」であることも望んでいる。つまり、射影$p'$と$q'$は、$p$と$q$から$m$を使って再構成できる。

```haskell
p' = p . m
q' = q . m
```

![](images/productranking.jpg){width=40%}

別の観点でこれらの方程式を見ると、$m$は$p'$と$q'$を_分解_している。これらの方程式が自然数について成り立ち、ドットが乗算であると仮定する。$m$は$p'$と$q'$で共通の係数だ。

ある種の直観を築くために、2つの正準射影`fst`と`snd`を持つペア`(Int, Bool)`が、前に提示した2つの候補より本当に_優れている_ことを示そう。

![](images/not-a-product.jpg){width=40%}

最初の候補に対する写像`m`は次のようになる。

```haskell
m :: Int -> (Int, Bool)
m x = (x, True)
```

実際、2つの射影`p`と`q`は次のように再構成できる:

```haskell
p x = fst (m x) = x
q x = snd (m x) = True
```

2番目の例の`m`も同様に一意に決まる:

```haskell
m (x, _, b) = (x, b)
```

`(Int, Bool)`が2つの候補のどちらよりも優れていることを示せた。その逆がなぜ真ではないのかを見てみよう。`p`と`q`から`fst`と`snd`を再構築するのに役立つ`m'`を見つけられるだろうか？


```haskell
fst = p . m'
snd = q . m'
```

1番目の例では、`q`は常に`True`を返す。しかし、第2要素が`False`であるペアが存在するのは分かっている。したがって、`q`からは`snd`を再構築できない。

2番目の例は別物だ: `p`または`q`を実行した後でも十分な情報が保持される。しかし、`fst`と`snd`を分解する方法が複数ある。`p`と`q`はどちらもトリプルの第2要素を無視するので、`m'`には何でも入れられる。たとえば、

```haskell
m' (x, b) = (x, x, b)
```

あるいは

```haskell
m' (x, b) = (x, 42, b)
```

などだ。

以上すべてをまとめると、2つの射影`p`と`q`を持つ任意の型`c`について、それらの射影を分解する一意な`m`が`c`からカルテシアン積`(a, b)`へと存在する。実際には、`p`と`q`を組み合わせてペアにしているだけだ。

```haskell
m :: c -> (a, b)
m x = (p x, q x)
```

これによってカルテシアン積`(a, b)`がベストマッチとなり、すなわち、この普遍構成が集合の圏で機能することを意味する。これは任意の2つの集合の積を選択する。

さて、集合のことは忘れて、同じ普遍構成を使って任意の圏にある2つの対象の積を定義しよう。そのような積が必ず存在するわけではないが、存在する場合は、一意な同型を除いて一意だ。

> 2つの対象$a$と$b$の**積**は、2つの射影を備えた対象$c$であり、2つの射影を備えた他の対象$c'$に対しては、それらの射影を分解する$c'$から$c$への一意な射$m$が存在する。

2つの候補から分解関数`m`を生成する (高階) 関数は、[factorizer]{.keyword #factorizer}と呼ばれることもある。この例では、次の関数になる:

```haskell
factorizer :: (c -> a) -> (c -> b) -> (c -> (a, b))
factorizer p q = \x -> (p x, q x)
```

## 余積

圏論のすべての構成と同じく、積にも双対があり、余積と呼ばれる。積のパターンの矢を逆にすると、2つの_単射_、`i`と`j`を備えた対象_c_になる。すなわち、$a$と$b$から$c$への射だ。

```haskell
i :: a -> c
j :: b -> c
```

![](images/coproductpattern.jpg){width=40%}

順位付けも逆転している: 対象$c$は、もし$c$から$c'$への射$m$が単射を分解するなら、$i'$と$j'$の単射を備えた対象$c'$よりも「優れて」いる。

```haskell
i' = m . i
j' = m . j
```

![](images/coproductranking.jpg){width=40%}

このような「最も優れた」対象は、それを他のすべてのパターンとつなぐ一意の射を持つもので、余積と呼ばれ、もし存在すれば、一意な同型を除いて一意だ。

> 2つの対象$a$と$b$の**余積**は、2つの単射を備えた対象$c$であり、2つの単射を備えた他の対象$c'$に対しては、それらの単射を分解する一意な射$m$が$c$から$c'$へ存在する。

集合の圏では、余積は2つの集合の_非交和_ (disjoint union) だ。　$a$と$ b$の非交和の要素は、$a$の要素か$b$の要素のどちらかだ。2つの集合が重なる場合、非交和には共通部分のコピーが2つ含まれる。非交和の要素は、その起源を示す識別子でタグ付けされていると見なせる。

プログラマーにとっては、型の観点から余積を理解する方が簡単だ。それは2つの型のタグ付き共用体だ。C++は共用体をサポートしているが、それらはタグ付けされていない。つまり、プログラム内では共用体のどのメンバーが有効であるかを何らかの方法で追跡しなければならないということだ。タグ付き共用体を作成するには、タグ――列挙型――を定義して共用体と結びつける必要がある。たとえば、`int`と`char const*`のタグ付き共用体は次のように実装できる。

```cpp
struct Contact {
    enum { isPhone, isEmail } tag;
    union { int phoneNum; char const * emailAddr; };
};
```

この2つの単射は、コンストラクターとしても関数としても実装できる。たとえば、関数`PhoneNum`としての最初の単射は以下のようになる。

```cpp
Contact PhoneNum(int n) {
    Contact c;
    c.tag = isPhone;
    c.phoneNum = n;
    return c;
}
```

これは`Contact`に整数を注入する。

タグ付き共用体は[variant]{.keyword #variant}とも呼ばれ、boostライブラリに非常に汎用的な`boost::variant`という実装がある^[訳註: C++17以降では[std::variant](https://cpprefjp.github.io/reference/variant/variant.html)が利用できる。]。

Haskellでは、データコンストラクタを縦棒で区切ることで、任意のデータ型をタグ付き共用体にまとめられる。`Contact`の例は、次の宣言に変換される。

```haskell
data Contact = PhoneNum Int | EmailAddr String
```

ここで、`PhoneNum`と`EmailAddr`は、コンストラクター (単射) としても、パターンマッチングのタグとしても機能する (これについては後で詳しく説明する)。たとえば、電話番号を使って連絡先を作成する方法は次のとおりだ。

```haskell
helpdesk :: Contact
helpdesk = PhoneNum 2222222
```

積の正規実装がプリミティブなペアとしてHaskellに組み込まれているのとは異なり、余積の正規実装は`Either`と呼ばれるデータ型であり、標準のPreludeで次のように定義されている。

```haskell
Either a b = Left a | Right b
```

これは`a`と`b`の2つの型によってパラメータ化され、2つのコンストラクタを持つ。`Left`は型`a`の値をとり、`Right`は型`b`の値を取る。

積についてfactorizerを定義したように、余積についても定義できる。候補となる型`c`と候補となる2つの単射`i`と`j`が与えられると、`Either`のfactorizerは分解関数を生成する:

```haskell
factorizer :: (a -> c) -> (b -> c) -> Either a b -> c
factorizer i j (Left a)  = i a
factorizer i j (Right b) = j b
```

## 非対称性

これまでに2組の双対の定義を見てきた。終対象の定義は、始対象の定義から矢の方向を逆にすることで得られ、余積の定義は積の定義から得られる。しかし、集合の圏では、始対象は最終的な対象とは大きく異なり、余積は積とは大きく異なる。後述するように、積は乗算のように振る舞い、終対象は1の役目を果たし、余積は和のように振る舞い、始対象は0の役目を果たしている。特に、有限集合の場合、積のサイズは個々の集合のサイズの積であり、余積のサイズはサイズの合計だ。

これは集合の圏が矢の反転に関して対称でないことを示している。

空集合はどの集合に対しても一意な射 (`absurd`関数) を持っているが、戻ってくる射を持っていないことに注意してほしい。単集合では、どの集合からも一意な射が来るが、(空集合を除く) すべての集合へ向かう外向きの射_も_ある。これまで見てきたように、終対象から発するこれらの射は、他の集合の要素を選択するのに非常に重要な役目を果たしている (空集合には要素がないので、選択するものは何もない)。

それを余積と区別しているのは、単集合と積の関係だ。unit型`()`で表される単集合を、積パターンのもう1つの――非常に劣っている――候補として使うことを考えてみてほしい。それを2つの射影`p`と`q`、すなわち単集合から各構成要素の集合への関数として実装してみよう。それぞれが具体的な要素をいずれかの集合から選択する。積は普遍的であるため、我々の候補である単集合から積へ、(一意な) 射`m`も存在する。この射は積の集合から要素を選択する。つまり、具体的なペアを選択する。また、次の2つの射影を分解する。

```haskell
p = fst . m
q = snd . m
```

単集合の唯一の要素である値`()`に作用する場合、これら2つの方程式は次のようになる。

```haskell
p () = fst (m ())
q () = snd (m ())
```

`m ()`は`m`によって選択された積の要素であるため、これらの方程式は、最初の集合`p ()`から`p`によって選択された要素が`m`によって選択されたペアの最初の要素であることを示す。同様に、`q ()`は第2要素に等しい。これは、積の要素は構成要素の集合からの要素のペアであるという理解と完全に一致している。

余積にはそのような単純な解釈はない。単集合を余積での候補として要素を抽出しようと試みることもできるが、2つの射影がそこから出てくるのではなく、2つの単射がそこに入ることになるだろう。それらはその起源について何も教えてくれないだろう (実際、入力パラメータが無視されるのを見てきた)。また、余積から単集合への一意な射についても同様だろう。集合の圏は、始対象の向きで見たときと終対象から見たときとでは全く違って見える。

これは集合の固有の特性ではなく、$\Set$で射として使う関数の特性だ。関数は (一般に) 非対称だ。説明しよう。

関数は、その始域のすべての要素に対して定義する必要がある (プログラミングでは、[全]{.keyword #total}関数 (total function) と呼ぶ)。しかし、終域全体を網羅する必要はない。すでにその極端な例をいくつか見てきた。単集合からの関数――終域内の1つの要素だけを選択する関数だ。(実際に、空集合からの関数は本当に極端だ。)
始域のサイズが終域のサイズよりもずっと小さい場合、そのような関数はよく、始域を終域に埋め込むようなものと考えられる。たとえば、単集合からの関数は、その1つの要素を終域に埋め込むものだと考えられる。私はそれらを[埋め込み]{.keyword #embedding} (embedding) 関数と呼んでいるが、数学者は名前を反対に付けた方を好む。つまり、終域をきっちり満たす関数を[surjective]{.keyword #surjective}または[onto]{.keyword #onto}と呼ぶ。

非対称性のもう1つの原因は、関数が始域の多くの要素を終域の1つの要素に写せることだ。それらは自身を潰せる。極端な例は、集合全体を単集合に写す関数だ。これまでに、まさにそれを行う多相`unit`関数を見てきた。The collapsing can only be compounded by composition. 潰す関数2つの合成は、個々の関数よりもさらに潰す。数学者は潰さない関数を[単射]{.keyword #injective} (injective) または[1対1 ]{.keyword #one-to-one} (one-to-one) という名前で呼ぶ。

当然、埋め込みも潰しもしない関数もある。それらは[双射]{.keyword #bijections} (bijection) と呼ばれ、可逆なので真に対称だ。集合の圏では、同型は双射と同じだ。

## 課題

1. 終対象が一意な同型を除いて一意であることを示せ。

2. ポセットの中の2つの対象の積は何か？
   ヒント: 普遍構成を使う。

3. ポセットの中の2つの対象の余積は何か？


4. Haskellの`Either`に相当するものを、(Haskell以外の) 好きな言語で総称型として実装せよ。

5. `Either`が、2つの単射を備えた`int`よりも「優れた」余積であることを示せ。

   ```cpp
   int i(int n) { return n; }
       int j(bool b) { return b? 0: 1; }
   ```

   ヒント: 関数を定義する。

   ```cpp
   int m(Either const & e);
   ```

   that factorizes `i` and `j`.

6. 前の問題の続き。`i`と`j`という2つの単射を持つ`int`が、`Either`よりも「優れている」ことはないと主張するにはどうするか？


7. さらに続き: 単射についてはどうか？


   ```cpp
   int i(int n) {
           if (n < 0) return n;
           return n + 2;
       }
       int j(bool b) { return b? 0: 1; }
   ```

8. `Either`への射を複数許容するという理由で、`int`と`bool`の余積の候補として`Either`より劣るものを挙げよ。

## 参考文献

1. The Catsters, [Products and Coproducts](https://www.youtube.com/watch?v=upCSDIO9pjc) video.
