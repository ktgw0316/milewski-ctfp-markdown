# 積と余積 {#products-and-coproducts}

<!-- ## 矢に従え -->

古代ギリシアの劇作家のエウリーピデースは「人間は、喜んで交際している仲間たちと異なるところがない」^[訳註：『ポイニクス』812番の台詞に基づく。英訳の “Every man is like the company he is wont to keep.” が格言として広まったものと考えられる。この日本語訳は『ギリシア悲劇全集 (12) エウリーピデース断片』（岩波書店、1993）に従った。]と言った。我々は人間関係によって定義される。これほど圏論に当てはまる言葉はない。圏の中の特定の対象を選び出すには、他の対象（およびそれ自身）との関係のパターンを記述するしかない。これらの関係は射によって定義される。

圏論には[普遍的構成]{.keyword #universal_construction} (universal construction) と呼ばれる構成がよく現れ、対象をその関係の観点から定義する。そのための方法の1つとしては、対象と射から構成された特定の形のパターンを選び、圏に出現するすべてのパターンを探すことが挙げられる。そのパターンが十分に一般的であり、圏が大きい場合、該当するものがたくさん出てくるだろう。秘訣は、該当したものに対するある種の順位付けを確立し、最適と考えられるものを選択することだ。

このプロセスは、ウェブ検索のやり方を思い起こさせる。クエリはパターンのようなものだ。非常に一般的なクエリなら、*再現率* (recall) が高く、すなわち該当するものの数が多い。関連性があるものもあれば、そうでないものもあるだろう。無関係なヒットを削除するには、クエリを絞り込む。これにより*精度* (precision) が向上する。最終的に、検索エンジンは検索結果を順位付けして、うまくいけば、あなたが興味のある結果がリストの一番上に表示される。

## 始対象

最も単純な形は単一の対象だ。明らかに、この形の実例は、特定の圏にある対象と同じ数だけ存在する。それでは候補が多すぎる。ある種の順位付けを確立し、この階層のトップにある対象を見つける必要がある。利用できる唯一の手段は射だ。射を矢として捉えるなら、矢の全体的な総フローが、圏の一方の端から他方の端へと存在しうる。これは半順序などの順序付けられた圏に当てはまる。$a$から$b$へ向かう矢（射）が存在するなら、対象$a$は対象$b$よりも「始め」だとして、対象の優先順位の概念を一般化できる。次に、*唯一の*始対象を、他のすべての対象に向かう矢を持つものとして定義する。明らかに、そのような対象が存在する保証はないのだが、大丈夫だ。より大きな問題は、そのような対象が多すぎる可能性があることだ。再現率は高いが、精度を欠いている。解決策は、順序付けられた圏からヒントを得ることだ。それらの圏では、任意の2つの対象の間に最大で1つの矢だけが存在できる。そのため、別の対象以下となる方法は1つしかない。これは始対象の次のような定義につながる：

> **始対象** (the initial object) とは、圏内の任意の対象に対し、そこへ向かう射をちょうど1つだけ持つ対象だ。

`\begin{figure} \centering`{=latex}
![](images/initial.jpg){width=40%}
`\end{figure}`{=latex}

それでも、始対象が（存在するにしても）一意だとは保証されない。しかし、それは次善のものを保証する。[同型を除いて]{.keyword #up_to_isomorphism}一意 (unique up to isomorphism) という性質だ。同型は圏論では非常に重要なので、すぐに説明する。差し当たっては、同型を除いて一意という性質が始対象の定義における「the」の使用を正当化することに同意しよう。

以下にいくつかの例を示す。半順序集合 (partially ordered set) は、しばしば[ポセット]{.keyword #poset} (poset) と呼ばれ、最小要素が始対象となる。始対象を持たないポセットもある。たとえば、正と負のすべての整数の集合のように、射について等号付き大小関係を持つものだ。

集合と関数の圏では、始対象は空集合だ。空集合はHaskellの型`Void`に対応し（C++には対応する型は存在せず）、`Void`から他の型へのそれぞれ一意な多相関数は`absurd`と呼ばれることを思い出してほしい。

```haskell
absurd :: Void -> a
```

`Void`を型の圏における始対象にしているのは、この射の族なのだ。

## 終対象

引き続き単一対象パターンを扱うが、対象の順位付け方法を変更しよう。$b$から$a$への射がある場合、対象$a$は対象$b$よりも「終わりの側」と言える（方向が逆になっていることに注意してほしい）。探したいのは、圏のどの対象よりも終わりの側となる対象だ。再び、一意性を主張することになる：

> **終対象**は、圏内のどの対象からも1つの射しか来ない対象だ。

`\begin{figure} \centering`{=latex}
![](images/final.jpg){width=40%}
`\end{figure}`{=latex}

繰り返しになるが、終対象は同型を除いて一意だ。これについてはすぐ後で説明する。まずは、いくつかの例を見てみよう。ポセットでは、終対象があれば、それが最大の対象だ。集合の圏では、終対象は単集合だ。単集合についてはすでに説明した。単集合は、C++では`void`型に対応し、Haskellではunit型`()`に対応する。これは1つの値しか持たない型で、C++では暗黙的に、Haskellでは明示的に`()`で表された。また、あらゆる型からunit型への唯一の純粋関数：

```haskell
unit :: a -> ()
unit _ = ()
```

が、終対象のすべての条件を満たして存在することも確立した。

この例では、一意性条件が決定的に重要であることに注意してほしい。なぜなら、すべての集合から入ってくる射を持つ他の集合（実際には、空集合を除くすべての集合）が存在するからだ。たとえば、すべての型に対して定義されたブール値関数（述語）がある：

```haskell
yes :: a -> Bool
yes _ = True
```

しかし、`Bool`は終対象ではない。すべての型に対して、少なくとももう1つの`Bool`値関数がある（`Void`に対してはどちらの関数も`absurd`と等しくなるので除く）：

```haskell
no :: a -> Bool
no _ = False
```

一意性を主張することで、終対象の定義を1つの型だけに絞り込むのにちょうど良い精度が得られる。

## 双対性

始対象と終対象の定義の対称性には注目せずにいられないだろう。両者の唯一の違いは、射の方向だった。どの圏$\cat{C}$に対しても、すべての矢を逆にするだけで[反対圏]{.keyword #opposite_category} (opposite category) $\cat{C}^\mathit{op}$を定義できると分かる。反対圏は、同時に圏を再定義する限り、合成のすべての要件を自動的に満たす。もとの射$f \Colon a \to b$と$g \Colon b \to c$が$h=g \circ f$によって$h \Colon a \to c$へと合成される場合、逆の射$f^\mathit{op} \Colon b \to a$と$g^\mathit{op} \Colon c \to b$は$h^\mathit{op} = f^\mathit{op} \circ g^\mathit{op}$によって$h^\mathit{op} \Colon c \to a$へと合成される。そして、恒等射を逆にすることは、（駄洒落に注意！）
no-opだ。

双対性は圏の非常に重要な特性だ。圏論を扱うすべての数学者の生産性を倍増させるからだ。思いつくすべての構成にはその反対があり、証明するすべての定理について無料で手に入る。反対圏の構成にはしばしば「余」(co) が前置され、積と余積、モナドとコモナド、錐と余錐、極限と余極限などがある。ただし、矢を2回反転させればもとの状態に戻るので、ココモナドはない。

そして、終対象は反対圏の始対象だと言える。

## 同型

プログラマーである我々は、等価性を定義することが簡単な作業ではないことをよく知っている。2つのオブジェクトが等しいとはどういう意味だろう？
メモリ内の同じ場所を占有する必要があるだろうか（ポインタの等価性）。あるいは、すべての要素の値が同じであれば十分だろうか？
2つの複素数の一方を実部と虚部で表し、もう一方を絶対値と偏角で表すしたとき、それらは等しいだろうか。数学者たちが等価性の意味を解明済みだろう、と思うかも知れないが、そうではない。数学者も、等価性に複数の競合する定義があるという、同じ問題を抱えている。命題的等価性、内包的等価性、外延的等価性、ホモトピー型理論の経路としての等価性がある。そして同型射のより弱い概念、さらには同値性のより弱い概念もある。

直観としては、同型の対象は同じように見える――同じ形をしている。これは、1対1の写像において、ある対象の一部はすべて別の対象の一部にそれぞれ対応することを意味する。調べ得る限り、2つの対象はお互いの完全なコピーだ。数学的には、対象$a$から対象$b$への写像があり、対象$b$から対象$a$への写像があり、それらが互いに逆であることを意味する。圏論では、写像を射に置き換える。同型射は可逆な射で、すなわち互いに逆である射のペアだ。

逆についての理解は合成と恒等射の観点に基づいている。射$g$は、合成すると恒等射になるなら、射$f$の逆だ。これらの2つの射は、合成する方法が2つあるので、実際には2つの等式で表される：

```haskell
f . g = id
g . f = id
```

始（終）対象が同型を除いて一意だと言ったとき、2つの始（終）対象は同型だということを意味していた。これは簡単に理解できる。2つの始対象$i_{1}$と$i_{2}$があるとしよう。$i_{1}$が始対象であるため、$i_{1}$から$i_{2}$への一意な射$f$が存在する。同様に、$i_{2}$が始対象であるため、$i_{2}$から$i_{1}$への一意な射$g$が存在する。これらの2つの射を合成すると何になるだろう？


![この図中のすべての射は一意だ](images/uniqueness.jpg){width=40%}

合成$g\circ f$は、$i_{1}$から$i_{1}$への射でなければならない。しかし、$i_{1}$は始対象なので、$i_{1}$から$i_{1}$へ向かう射は1つだけだ。圏の中なので、$i_{1}$から$i_{1}$への恒等射があるのは分かっている。候補は1つだけなので、それで間違いない。したがって、$g\circ f$は恒等射と等しくなる。同様に、$f\circ g$は恒等射と等しくなければならない。$i_{2}$から$i_{2}$に戻る射は1つしかないからだ。これは、$f$と$g$が互いに逆でなければならないことを証明している。したがって、任意の2つの始対象は同型だ。

この証明では、始対象からそれ自体への射の一意性を用いたことに注意してほしい。そうしなければ「同型を除いて」の部分は証明できない。しかし、なぜ$f$と$g$の一意性が必要なのだろうか。始対象は同型を除いて一意なだけでなく、*一意な*同型を除いて一意だからだ。原則として、2つの対象間には複数の同型が存在する可能性があるが、ここではそうではない。この「一意な同型を除いて一意という性質」は、すべての普遍的構成の重要な特性だ。

## 積

次の普遍的構成は積 (product) に関するものだ。2つの集合のカルテシアン積が何なのかは知っている。ペアからなる集合だ。しかし、積の集合とそれを構成する集合を結びつけるパターンは何だろう？
それが分かれば、他の圏にも一般化できるはずだ。

唯一言えるのは、積から各構成要素への射影 (projection) という関数が2つある、ということだ。Haskellでは、これら2つの関数は`fst`と`snd`と呼ばれ、それぞれペアの最初と2番目の要素を選択する。

```haskell
fst :: (a, b) -> a
fst (x, y) = x
```

```haskell
snd :: (a, b) -> b
snd (x, y) = y
```

ここで、関数は引数のパターンマッチングによって定義される。パターン`(x, y)`は任意のペアにマッチし、要素を変数`x`と`y`に抽出する。

これらの定義はワイルドカードを使ってさらに単純化できる。

```haskell
fst (x, _) = x
snd (_, y) = y
```

C++では、次のようなテンプレート関数を使う。

```cpp
template<class A, class B>
A fst(pair<A, B> const & p) {
    return p.first;
}
```

この一見非常に限られた知識をもって、集合の圏における対象と射のパターンを定義してみよう。このパターンは、2つの集合（$a$と$b$）からなる積の構成につながる。このパターンは対象$c$と2つの射$p$と$q$で構成され、それぞれ$a$と$b$に接続される。

```haskell
p :: c -> a
q :: c -> b
```

`\begin{figure} \centering`{=latex}
![](images/productpattern.jpg){width=30%}
`\end{figure}`{=latex}

このパターンに一致するすべての$c$が積の候補と見なされる。それは大量にあるかもしれない。

`\begin{figure} \centering`{=latex}
![](images/productcandidates.jpg){width=40%}
`\end{figure}`{=latex}

たとえば、構成要素として、2つのHaskellの型`Int`と`Bool`を選択し、それらの積の候補を挙げてみよう。

1番目の候補は`Int`だ。`Int`は`Int`と`Bool`の積の候補と見なせるだろうか？
そう、見なせる――その射影はこうなる：

```haskell
p :: Int -> Int
p x = x

q :: Int -> Bool
q _ = True
```

これはかなり酷いが、基準を満たしている。

2番目の候補は`(Int, Int, Bool)`だ。要素が3つのタプル、すなわちトリプルだ。これを正当な候補にする2つの射を以下に示す（ここではトリプルに対してパターンマッチングを使っている）。

```haskell
p :: (Int, Int, Bool) -> Int
p (x, _, _) = x

q :: (Int, Int, Bool) -> Bool
q (_, _, b) = b
```

1番目の候補は狭すぎ、積の`Int`の次元だけをカバーしている。一方で、2番目の候補は広すぎ、`Int`の次元が重複してしまっている。

しかし、この普遍的構成の別の部分である順位付けについてはまだ調べていない。そこで、パターンの2つの例を比較できるようにしたい。つまり、対象の1つの候補$c$とその2つの射影$p$および$q$を、別の対象の候補$c'$とその2つの射影$p'$および$q'$と比較したい。$c'$から$c$への射$m$がある場合に$c$は$c'$よりも「優れている」と言いたいのだが、それではあまりにも弱い。それに加えて、$c$の射影が$c'$の射影よりも「優れている」、すなわち「より普遍的」であってほしい。つまり、射影$p'$と$q'$は、$p$と$q$から$m$を使って再構成できる。

```haskell
p' = p . m
q' = q . m
```

`\begin{figure} \centering`{=latex}
![](images/productranking.jpg){width=40%}
`\end{figure}`{=latex}

別の観点でこれらの等式を見ると、$m$は$p'$と$q'$を*分解* (factorize) している。これらの等式が自然数について成り立ち、ドットが乗算であると仮定する。$m$は$p'$と$q'$で共通の係数だ。

ある種の直観を築くために、2つの正準射影 (canonical projection) `fst`と`snd`を持つペア`(Int, Bool)`が、前に提示した2つの候補より本当に*優れている*ことを示そう。

`\begin{figure} \centering`{=latex}
![](images/not-a-product.jpg){width=40%}
`\end{figure}`{=latex}

1番目の候補に対する写像`m`は次のようになる：

```haskell
m :: Int -> (Int, Bool)
m x = (x, True)
```

実際、2つの射影`p`と`q`は次のように再構成できる：

```haskell
p x = fst (m x) = x
q x = snd (m x) = True
```

2番目の例の`m`も同様に一意に定まる：

```haskell
m (x, _, b) = (x, b)
```

`(Int, Bool)`が2つの候補のどちらよりも優れていることを示せた。その逆がなぜ真ではないのかを見てみよう。`p`と`q`から`fst`と`snd`を再構築するのに役立つ`m'`を見つけられるだろうか？


```haskell
fst = p . m'
snd = q . m'
```

1番目の例では、`q`は常に`True`を返す。しかし、第2要素が`False`であるペアが存在するのは分かっている。したがって、`q`からは`snd`を再構築できない。

2番目の例は別物だ。`p`または`q`を経た後でも十分な情報が保持される。しかし、`fst`と`snd`を分解する方法が複数ある。`p`と`q`はどちらもトリプルの第2要素を無視するので、`m'`には何でも入れられる。たとえば：

```haskell
m' (x, b) = (x, x, b)
```

あるいは

```haskell
m' (x, b) = (x, 42, b)
```

などを定義できる。

以上すべてをまとめると、2つの射影`p`と`q`を持つ任意の型`c`について、それらの射影を分解する一意な`m`が`c`からカルテシアン積`(a, b)`へと存在する。実際には、`p`と`q`を組み合わせてペアにしているだけだ。

```haskell
m :: c -> (a, b)
m x = (p x, q x)
```

これによってカルテシアン積`(a, b)`がベストマッチとなり、すなわち、この普遍的構成が集合の圏で機能することを意味する。これは任意の2つの集合の積を選ぶ。

さて、集合のことは忘れて、同じ普遍的構成を使って任意の圏にある2つの対象の積を定義しよう。そのような積が必ず存在するわけではないが、存在する場合は、一意な同型を除いて一意だ。

> 2つの対象$a$と$b$の**積**とは、2つの射影を伴う対象$c$であり、別の任意の対象$c'$が伴う2つの射影について、それらを分解する$c'$から$c$への一意な射$m$が存在するものを言う。

2つの候補から分解関数`m`を生成する（高階）関数は、[factorizer]{.keyword #factorizer}と呼ばれることもある。この例では、次の関数になる：

```haskell
factorizer :: (c -> a) -> (c -> b) -> (c -> (a, b))
factorizer p q = \x -> (p x, q x)
```

## 余積

圏論のすべての構成と同じく、積にも双対があり、余積 (coproduct) と呼ばれる。積のパターンの矢を逆にすると、2つの*単射* (injection) `i`と`j`を伴う対象*c*になる。すなわち、$a$と$b$から$c$への射だ。

```haskell
i :: a -> c
j :: b -> c
```

`\begin{figure} \centering`{=latex}
![](images/coproductpattern.jpg){width=40%}
`\end{figure}`{=latex}

順位付けも逆転している：対象$c$は、もし$c$から$c'$への射$m$が単射を分解するなら、$i'$と$j'$の単射を伴う対象$c'$よりも「優れて」いる。

```haskell
i' = m . i
j' = m . j
```

`\begin{figure} \centering`{=latex}
![](images/coproductranking.jpg){width=40%}
`\end{figure}`{=latex}

「最も優れた」対象は、他のすべてのパターンとつながる一意な射を持つもので、余積と呼ばれ、存在する場合は、一意な同型を除いて一意だ。

> 2つの対象$a$と$b$の**余積**とは、2つの単射を伴う対象$c$であり、別の任意の対象$c'$が伴う2つの単射について、それらを分解する$c$から$c'$への一意な射$m$が存在するものを言う。

集合の圏では、余積は2つの集合の*非交和* (disjoint union) だ。$a$と$b$の非交和の要素は、$a$の要素か$b$の要素のどちらかだ。2つの集合が重なる場合、非交和には共通部分のコピーが2つ含まれる。非交和の要素は起源を示す識別子でタグ付けされていると見なせる。

プログラマーにとっては、型の観点から余積を理解する方が簡単だ。それは2つの型からなるタグ付き共用体だ。C++がサポートしている共用体はタグ付けされていない。つまり、プログラム内では共用体のどのメンバーが有効であるかを何らかの方法で追跡しなければならないということだ。タグ付き共用体を作成するには、タグ――列挙型――を定義して共用体と結びつける必要がある。たとえば、`int`と`char const*`のタグ付き共用体は次のように実装できる。

```cpp
struct Contact {
    enum { isPhone, isEmail } tag;
    union { int phoneNum; char const * emailAddr; };
};
```

この2つの単射は、コンストラクターとしても、関数としても実装できる。たとえば、最初の単射を関数`PhoneNum`として実装するとこうなる：

```cpp
Contact PhoneNum(int n) {
    Contact c;
    c.tag = isPhone;
    c.phoneNum = n;
    return c;
}
```

これは`Contact`に整数を注入 (inject) する。

タグ付き共用体は[variant]{.keyword #variant}とも呼ばれ、boostライブラリに非常に汎用的な`boost::variant`という実装がある^[訳註：C++17以降では[std::variant](https://cpprefjp.github.io/reference/variant/variant.html)が利用できる。]。

Haskellでは、データコンストラクターをバーティカルバーで区切ることで、任意のデータ型をタグ付き共用体にまとめられる。`Contact`の例だと次のような宣言になる：

```haskell
data Contact = PhoneNum Int | EmailAddr String
```

ここで、`PhoneNum`と`EmailAddr`は、コンストラクター（単射）としても、パターンマッチングのタグとしても機能する（これについては後で詳しく説明する）。たとえば、電話番号を使って連絡先を作成する方法はこうなる：

```haskell
helpdesk :: Contact
helpdesk = PhoneNum 2222222
```

正統な実装では、積がプリミティブなペアとしてHaskellに組み込まれているのに対し、余積は`Either`と呼ばれるデータ型であり、標準のPreludeで次のように定義されている：

```haskell
Either a b = Left a | Right b
```

これは`a`と`b`の2つの型によってパラメーター化され、2つのコンストラクターを持つ。`Left`は型`a`の値をとり、`Right`は型`b`の値を取る。

積についてfactorizerを定義したのと同様に、余積についても定義できる。型の候補`c`と2つの単射の候補`i`と`j`について、`Either`のfactorizerは次の分解関数を生成する：

```haskell
factorizer :: (a -> c) -> (b -> c) -> Either a b -> c
factorizer i j (Left a)  = i a
factorizer i j (Right b) = j b
```

## 非対称性

これまでに2組の双対の定義を見てきた。終対象の定義は、始対象の定義から矢の方向を逆にすることで得られ、余積の定義は積の定義から得られる。しかし、集合の圏では、始対象と終対象は大きく異なり、余積と積は大きく異なる。後述するように、積は乗算のように振る舞い、終対象は1の役割を果たし、余積は和のように振る舞い、始対象は0の役割を果たす。特に、有限集合の場合、積のサイズは個々の集合のサイズの積であり、余積のサイズはサイズの合計だ。

これは集合の圏が矢の反転に関して対称でないことを示している。

空集合では、どの集合に対しても一意な射（`absurd`関数）がある一方で、戻ってくる射はないことに注意してほしい。単集合では、どの集合からも一意な射が来るうえに、（空集合を除く）すべての集合へ向かう外向きの射*も*ある。これまで見てきたように、終対象から発するこれらの射は、他の集合の要素を選択するのに非常に重要な役割を果たしている（空集合には要素がないので、選択するものは何もない）。

単集合と積の関係は、余積とは全く違う。unit型`()`で表される単集合を、積パターンのもう1つの――非常に劣った――候補として使うことを考えてみてほしい。それを2つの射影`p`と`q`、すなわち単集合から各構成要素の集合への関数として実装してみよう。それらは具体的な要素をそれぞれの集合から選択する。積は普遍的なので、ここでの候補の単集合から積への（一意な）射`m`も存在する。この射は積の集合から要素を選択する。つまり、具体的なペアを選択する。さらに、次の2つの射影を分解する：

```haskell
p = fst . m
q = snd . m
```

単集合の唯一の要素である値`()`に作用させると、これら2つの式は次のようになる：

```haskell
p () = fst (m ())
q () = snd (m ())
```

`m ()`は`m`によって選択された積の要素なので、これらの式は、第1の集合から`p`によって選択された要素`p ()`が、`m`によって選択されたペアの第1要素であることを示す。同様に、`q ()`は第2要素に等しい。これは、積の要素は構成要素の集合からの要素のペアであるという理解と完全に一致している。

余積にはそのような単純な解釈はない。単集合を余積での候補として要素を抽出しようと試みることもできるが、2つの射影がそこから出てくるのではなく、2つの単射がそこに入ることになる。それらはその起源について何も教えてくれないだろう（実際、入力パラメーターが無視されるのを見てきた）。また、余積から単集合への一意な射についても同様だろう。集合の圏は、始対象の向きから見たときと終対象から見たときとでは全く違って見える。

これは集合の固有の特性ではなく、$\Set$で射として使う関数の特性だ。関数は（一般に）非対称だ。説明しよう。

関数は、その始域のすべての要素に対して定義する必要がある（プログラミングでは、[全]{.keyword #total}関数 (total function) と呼ぶ）。しかし、終域全体を網羅する必要はない。すでにその極端な例をいくつか見てきた。単集合からの関数――終域内の1つの要素だけを選択する関数のことだ。（実際に、空集合からの関数は本当に極端だ。）
始域のサイズが終域のサイズよりもずっと小さい場合、そのような関数はよく、始域を終域に埋め込むようなものと考えられる。たとえば、単集合からの関数は、その1つの要素を終域に埋め込むものだと考えられる。私はそれらを[埋め込み]{.keyword #embedding} (embedding) 関数と呼んでいるが、数学者は名前を反対に付けた方を好む。つまり、終域をきっちり満たす関数を[全射]{.keyword #surjective} (surjective) または[上への]{.keyword #onto} (onto) 関数と呼ぶ。

非対称性のもう1つの原因は、関数が始域の多くの要素を終域の1つの要素に写せることだ。それらは自身を潰す (collapse) ことができる。極端な例としては、集合全体を単集合に写す関数が挙げられる。これまでに、まさにそれを行う多相`unit`関数を見てきた。合成すると、より酷く潰すことにしかならない。潰す関数2つの合成は、個々の関数よりもさらに潰すことになる。数学者は潰さない関数を[単射]{.keyword #injective} (injective) または[1対1]{.keyword #one-to-one} (one-to-one) という名前で呼ぶ。

当然、埋め込みも潰しもしない関数もある。それらは[全単射]{.keyword #bijections} (bijection) と呼ばれ、可逆なので真に対称だ。集合の圏では、同型は全単射と同じだ。

## 課題

1. 終対象が一意な同型を除いて一意であることを示せ。

2. ポセットの中の2つの対象の積は何か？
   ヒント：積の普遍的構成を使う。

3. ポセットの中の2つの対象の余積は何か？

4. Haskellの`Either`に相当するものを、（Haskell以外の）好きな言語で総称型として実装せよ。

5. `Either`が、次の2つの単射を伴う`int`よりも「優れた」余積であることを示せ。

   ```cpp
   int i(int n) { return n; }
   int j(bool b) { return b? 0: 1; }
   ```

   ヒント：関数

   ```cpp
   int m(Either const & e);
   ```

   を、`i`と`j`を分解するように定義する。

6. 前の問題の続き：`i`と`j`という2つの単射を伴う`int`が`Either`よりも「優れている」ことはありえないと主張するにはどうすればよいか？

7. さらに続き：次の単射についてはどうか？

   ```cpp
   int i(int n) {
       if (n < 0) return n;
       return n + 2;
   }
   int j(bool b) { return b? 0: 1; }
   ```

8. `int`と`bool`の余積の候補として、`Either`への射を複数許容するという理由で`Either`より劣るものを挙げよ。

## 参考文献

1. The Catsters, [Products and Coproducts](https://www.youtube.com/watch?v=upCSDIO9pjc) video.
