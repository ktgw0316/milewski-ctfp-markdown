# 関数型 {#function-types}

ここまでは、関数型の意味について言い繕ってきた。関数型は他の型とは異なる。

たとえば`Integer`を考えてみる。これは単に整数の集合だ。`Bool`は2要素の集合だ。しかし、関数型$a \to b$はそれ以上のもので、対象$a$と$b$の間の射の集合だ。任意の圏における2つの対象間の射の集合はhom集合と呼ばれる。たまたま$\Set$圏では、どのhom集合もそれ自体がまさにその圏の対象だ。結局それは*集合*だからだ。

![Set圏のなかのhom集合は単なる集合だ。](images/set-hom-set.jpg "Set圏のなかのhom集合は単なる集合だ。"){width=35%}

\noindent
同じことは、hom集合が圏の外にあるような他の圏には言えない。それらは*外部* (external) hom集合と呼ばれることもある。

![この圏Cのhom集合は外部集合だ。](images/hom-set.jpg "この圏Cのhom集合は外部集合だ。"){width=35%}

\noindent
$\Set$圏の自己参照的な性質によって、関数型は特殊なものになっている。しかし、少なくともいくつかの圏では、hom集合を表す対象を構成する方法がある。そういった対象は[*内部*]{.keyword #internal}\index{内部} (internal) hom集合と呼ばれる。

## 普遍的構成

関数型が集合であることをいったん忘れて、ゼロから関数型を、というより一般的に言えば内部hom集合を構成してみよう。いつものように、ここでは$\Set$圏からヒントを得る。ただし、集合の性質に一切頼らないように気を付けることで、その構成が他の圏でも自動的に機能するようにする。

関数型は、引数の型と結果の型の関係性から複合型と見なせる。複合型の構成のうち、対象間の関係性が関わっているものについてはすでに見た。[積と余積に相当する型](#products-and-coproducts)を定義するのに普遍的構成を使った。同じトリックを使って関数型を定義できる。そのためには3つの対象が関わるパターンが必要になる。すなわち、構成しようとする関数型自体と、その関数型における引数の型と結果の型だ。

これら3つの型を結びつける自明なパターンは[*関数適用*]{.keyword #function_application}\index{関数適用} (function application) あるいは[*評価*]{.keyword #evaluation}\index{評価} (evaluation) と呼ばれる。ある関数型の候補を$z$と呼ぼう（$\Set$圏でない場合、これは他の対象と同様の単なる対象であることに注意）。また、引数の型を$a$と呼ぼう（これは対象だ）。関数適用はこれらのペアを結果の型$b$（つまり対象）に写す。対象が3つあり、そのうち（引数の型と結果の型を表す）2つはすでに決まっている。

関数適用は写像だ。どうすればその写像をパターンに組み込めるだろう？　対象の内部を見ることが許されていたなら、関数$f$（$z$の要素）と引数$x$（$a$の要素）をペアにした後でそれを$f x$（$f$を$x$へ適用したものであり、$b$の要素）に写せただろう。

![Setでは、関数の集合zから関数fを選び、集合（型）aから引数xを選べる。その結果、集合（型）bの中の要素f xが得られる。](images/functionset.jpg "Setでは、関数の集合zから関数fを選び、集合（型）aから引数xを選べる。その結果、集合（型）bの中の要素f xが得られる。"){width=35%}

\noindent
しかし、個々のペア $(f, x)$ を扱う代わりに、関数型$z$と引数の型$a$の*積*全体について述べることもできる。積$z\times{}a$は対象であり、関数適用を表す射として、その対象から$b$への射$g$を選べる。$\Set$では、$g$は任意のペア $(f, x)$ を$f x$に写す関数となるだろう。

したがって、関数適用のパターンは、2つの対象$z$と$a$の積が別の対象$b$に射$g$で接続されている、というものになる。

![普遍的構成の出発点である対象と射のパターン](images/functionpattern.jpg "普遍的構成の出発点である対象と射のパターン"){width=40%}

\noindent
このパターンは、普遍的構成を使って関数型を一意に特定できるほど十分に具体的だろうか？　すべての圏でそうだとは言えない。しかし、我々が関心を持っている圏ではそうだ。さらに、別の疑問もある：積を先に定義することなく関数対象 (function object) を定義できるだろうか？　積が全く存在しない圏や、対象のすべてのペアに対しては積が存在しない圏もある。答えはノーだ。直積型がなければ関数型はない。これについては、後で冪について述べるときに再び説明する。

普遍的構成をおさらいしよう。まず対象と射のパターンから始める。これは粗い検索であり、通常はヒットするものが多すぎる。特に、$\Set$では、ほとんどすべてのものがすべてに接続されている。任意の対象$z$を選んで$a$との積を作れば、そこから$b$への関数を作れる（$b$が空集合の場合を除く）。

そこで秘密兵器の出番となる。順位付けだ。それを行うには通常、候補となる対象たちの間に（構成を何らかの形で分解する）一意な写像が存在することが必要となる。今回の場合においては、$z \times a$から$b$への射$g$を伴う$z$がそれ自身の関数適用$g'$を伴う別の$z'$よりも*優れて*いるとして選別するのは、関数適用$g'$が関数適用$g$を通じて分解するような、$z'$から$z$への一意な写像$h$が存在する場合、かつその場合に限る（ヒント：この文は図を見ながら読むこと）。

![関数対象の候補間の順位付けの確立](images/functionranking.jpg "関数対象の候補間の順位付けの確立"){width=40%}

\noindent
ここでトリッキーな点がある。それが、この特定の普遍的構成の説明をいままで延期した主な理由だ。射$h \Colon z'\to z$が与えられたときに、$z'$と$z$をそれぞれ$a$と掛けた図式を閉じたい。だが、与えられているのは$z'$から$z$への写像$h$なのに、本当に必要なのは$z'\times a$から$z\times a$への写像だ。そしていま、[積の関手性](#product-and-coproduct-bifunctors)についてすでに第8章2節で議論したので、そのやり方は分かっている。積自体が関手（正確には自己双関手）なので射のペアをリフトできる。言い換えると、対象の積だけでなく、射の積も定義できる。

積$z' \times a$の2番目の要素には触れていないので、射のペア $(h, \id)$ をリフトしよう。ここで、$\id$は$a$についての恒等射だ。

そして、ある関数適用$g$で別の関数適用$g'$を分解する（$g$を$g'$からくくり出す）とこうなる：
$$g' = g \circ (h \times \id)$$
ここで鍵となるのは、射に対する積の作用だ。

普遍的構成の第3の部分は、普遍的に最も優れた対象を選ぶことだ。その対象を$a \Rightarrow b$と呼ぶことにしよう（これは1つの対象に対する記号的な名前だと考えてほしい。Haskellの型クラス制約と混同しないように。後で別の命名方法について議論する）。この対象は独自の関数適用を伴う。それは $(a \Rightarrow b) \times a$から$b$への射だ。これを$\mathit{eval}$と呼ぶことにしよう。対象$a \Rightarrow b$は、他のどの関数対象の候補も、その関数適用の射$g$が$\mathit{eval}$を通じて分解するようなかたちでその対象へと一意に写せる場合、最も優れている。我々の順位付けにおいてこの対象は他のどの対象よりも優れている。

![普遍的な関数対象の定義。これは上記と同じ図式だが、対象$a \Rightarrow b$は*普遍*だ。](images/universalfunctionobject.jpg "普遍的な関数対象の定義。これは上記と同じ図式だが、対象$a \Rightarrow b$は*普遍*だ。"){width=40%}

\noindent
形式的には：

> $a$から$b$への*関数対象*は、対象$a \Rightarrow b$に射
> $$\mathit{eval} \Colon ((a \Rightarrow b) \times a) \to b$$
> を伴ったものであり、他の任意の対象$z$に射
> $$g\Colon z \times a \to b$$
> を伴ったものに対して、一意な射
> $$h \Colon z \to (a \Rightarrow b)$$
> が存在して$g$を$\mathit{eval}$を通じて分解する:
> $$g=\mathit{eval} \circ (h \times \id)$$

\noindent
当然、このような対象$a \Rightarrow b$が、与えられた圏内の任意の対象$a$と$b$について存在する保証はない。しかし、$\Set$では常に存在する。さらに、$\Set$では、この対象はhom集合$\Set(a, b)$ と同型だ。

そのため、Haskellにおいて我々は、関数型`a -> b`を圏論の関数対象$a \Rightarrow b$として解釈する。

## カリー化

関数対象の全候補を見てみよう。ただし今回は、射$g$を2つの引数$z$と$a$の関数として考えてみよう：
$$g \Colon z \times a \to b$$
積からの射であることと2引数関数であることは極めて近い。特に、$\Set$では$g$は値のペアを取る関数であり、そのペアの片方は集合$z$から、もう片方は集合$a$からの値だ。

一方、普遍性 (universal property) は、このような$g$ごとに、$z$を関数対象$a \Rightarrow b$に写す一意な射$h$が存在することを示している：
$$h \Colon z \to (a \Rightarrow b)$$
$\Set$において、これは単に関数$h$が$z$型の引数を1つ受け取って$a$から$b$への関数を返すことを意味する。これによって$h$は高階関数になる。したがって、普遍的構成は、2引数関数と、関数を返す1引数関数との間に1対1の対応を確立する。この対応は[*カリー化*]{.keyword #currying}\index{カリー化} (currying) と呼ばれ、$h$は$g$をカリー化したものと言える。

これは1対1の対応だ。任意の$g$に対し一意な$h$が存在し、任意の$h$に対して次の式を使って引数2つの関数$g$を常に再生成できるからだ：
$$g = \mathit{eval} \circ (h \times \id)$$
関数$g$は$h$の*非カリー化* (uncurrying) したものと言える。

カリー化はHaskellの構文に本質的に組み込まれている。関数を返す関数：

```haskell
a -> (b -> c)
```

\noindent
は2引数関数と見なされることが多い。実際に我々は括弧を外した型をそのように読む：

```haskell
a -> b -> c
```

\noindent
この解釈は、複数の引数を取る関数を定義する方法において明確だ。たとえば：

```haskell
catstr :: String -> String -> String
catstr s s' = s ++ s'
```

\noindent
と同じ関数を、関数を返す1引数関数、すなわちラムダとして記述できる：

```haskell
catstr' s = \s' -> s ++ s'
```

\noindent
これら2つの定義は等価であり、どちらも1つの引数だけに部分適用でき、次のような1引数関数が得られる：

```haskell
greet :: String -> String
greet = catstr “Hello “
```

\noindent
厳密に言えば、2引数関数というのはペア（直積型）を取る関数のことだ：

```haskell
(a, b) -> c
```

\noindent
2つの表現の間の変換は自明であり、それを行う2つの（高階）関数は、もちろん、`curry`と`uncurry`と呼ばれる：

```haskell
curry :: ((a, b) -> c) -> (a -> b -> c)
curry f a b = f (a, b)
```

\noindent
および

```haskell
uncurry :: (a -> b -> c) -> ((a, b) -> c)
uncurry f (a, b) = f a b
```

\noindent
`curry`は、関数対象の普遍的構成の*factorizer*であることに注目してほしい。これは、次の形に書き直した場合に特に顕著だ[^factorizer]：

```haskell
factorizer :: ((a, b) -> c) -> (a -> (b -> c))
factorizer g = \a -> (\b -> g (a, b))
```

\noindent
（備忘録：factorizerは候補から分解関数を生成する。）

[^factorizer]: 訳注：変数の名前をこの節の冒頭のものに対応させて

    `factorizer :: ((z, a) -> b) -> (z -> (a -> b))`

    `factorizer g = \z -> (\a -> g (z, a))`

    と書き直すと圏論的概念との対応が分かりやすいかもしれない。

C++のような非関数型言語でもカリー化は可能だが、簡単ではない。C++の複数引数関数は、Haskellでの組を取る関数に対応すると見なせる（ただし、さらに混乱を招くことに、C++では明示的な`std::tuple`を取る関数や、可変長引数関数や、初期化子リストを取る関数も定義できる）。

テンプレート`std::bind`を使えばC++でも関数を部分適用できる。たとえば、文字列2つを取る関数があるとする：

```cpp
std::string catstr(std::string s1, std::string s2) {
    return s1 + s2;
}
```

\noindent
文字列1つを取る関数は次のように定義できる：

```cpp
using namespace std::placeholders;

auto greet = std::bind(catstr, "Hello ", _1);
std::cout << greet("Haskell Curry");
```

\noindent
ScalaはC++やJavaよりも関数型寄りで、中間的な立場に立っている。定義したい関数が部分適用されると予想されるときは、複数引数のリストを使って定義する：

```scala
def catstr(s1: String)(s2: String) = s1 + s2
```

\noindent
当然、これにはある程度の先見の明や予測がライブラリーの作者に求められる。

## 冪

数学の文献では、関数対象、すなわち2つの対象$a$と$b$の間の内部hom対象を[*冪*]{.keyword #exponential}\index{冪} (exponential) と呼んで$b^{a}$と記すことが多い。引数の型が指数に含まれていることに注目してほしい。この記法は一見奇妙に思えるかもしれないが、関数と積の関係を考えると完全に理にかなっている。内部hom対象の普遍的構成で積を使わなければならないことはすでに見たが、つながりはそれよりも深い。

関数と積の密接なつながりは、有限型の間の関数を考えるときに最もよく見える。有限型とは、`Bool`、`Char`、さらには`Int`や`Double`など、有限個の値しか持たない型のことだ。それらの間の関数は、少なくとも原理的には、完全にメモ化したり、データ構造に変換してルックアップしたりできる。そしてこれが、射である関数と、対象である関数型との同値性の本質だ。

たとえば、`Bool`を取る（純粋）関数は、`False`に対応する値と`True`に対応する値のペアによって完全に決まる。`Bool`から、たとえば`Int`へのすべての可能な関数の集合は`Int`のすべてのペアの集合だ。これは積`Int` $\times{}$ `Int`と同じ集合であり、記法を少し創意工夫するなら`Int`$^{2}$とも書ける。

別の例として、256種類の値を含むC++の型`char`を見てみよう（Haskellの`Char`はUnicodeを使っているのでもっと多い）^[訳注：Unicodeのコードポイントの数である1,114,112種類。]。C++標準ライブラリーの一部には、実装に通常はルックアップが使われる関数がいくつかある。`isupper`や`isspace`のような関数はテーブルを使って実装される。テーブルは256個のブール値の組と等価だ。組は直積型であるため、256個のブーリアンの積`bool × bool × bool × ... × bool`を扱っていることになる。算術で学んだとおり、積を繰り返したものが冪だった。`bool`を256（つまり`char`）回「掛ける」と、`bool`の`char`乗、つまり`bool`$^\mathbf{char}$になる。

`bool`の256個の組として定義される型には何通りの値が含まれているだろう？　ちょうど$2^{256}$通りだ。これはまた、`char`から`bool`への関数の種類の数でもあり、各関数は一意な256要素の組に対応する。同様に、`bool`から`char`への関数の数は$256^{2}$と計算できる。以下同様だ。このような場合には、関数型の冪記法が完全に理にかなっている。

`int`や`double`を取る関数を完全にメモ化したいとは思わないだろう。だが、関数とデータ型の間には、常に実用的だとは限らないにしても、同値性がある。（有限型だけでなく）リスト・文字列・木などの無限型もある。それらの型を取る関数の積極的 (eager) なメモ化には、無限のストレージが必要になるだろう。しかし、Haskellは遅延評価言語であるため、遅延評価された（無限）データ構造と関数の境界は曖昧だ。この関数とデータの双対性は、Haskellの関数型と圏論の冪対象との同一視を説明している。冪対象の方が*データ*という概念によく対応している。

## デカルト閉圏

私はこれ以降も型や関数のモデルとして集合の圏を使うが、同じ目的に使えるような、圏のより大きな族があることは言及する価値がある。それらは[*デカルト閉*]{.keyword #Cartesian_closed}\index{デカルト閉} (Cartesian closed) 圏と呼ばれ、$\Set$はそのような圏の一例だ。

デカルト閉圏は以下のものを含む必要がある：

#. 終対象
#. 任意の対象のペアの積
#. 対象の任意のペアの冪

\noindent
冪を（無限に繰り返される可能性がある）積の反復と見なすなら、デカルト閉圏は任意のアリティ^[訳注：関数や演算が取る引数の個数。]の積をサポートするものと見なせる。特に、終対象は0個の対象の積、すなわち対象の0乗と見なせる。

コンピューター科学の観点から興味深いのは、デカルト閉圏が単純型付きラムダ計算（simply typed lambda calculus）のモデルを提供し、あらゆる型付きプログラミング言語の基礎を形成していることだ。

終対象と積には、始対象と余積という双対がある。それら2つも含むデカルト閉圏では、余積に対し積を分配できる：
$$
\begin{aligned}
a\times{}(b + c) = a\times{}b + a\times{}c \\
(b + c)\times{}a = b\times{}a + c\times{}a
\end{aligned}
$$
そのような圏は[*双デカルト閉*]{.keyword #bicartesian_closed}\index{双デカルト閉} (bicartesian closed) 圏と呼ばれる。次の節では、$\Set$に代表される双デカルト閉圏の興味深い特性について説明する。

## 冪と代数的データ型

関数型を冪として解釈すると、代数的データ型の体系に非常にうまく適合する。高校で習う代数における数0と1や和・積・冪に関する基本的な恒等式はどれも、双デカルト閉圏においてそれぞれ始対象と終対象や余積・積・冪を考えれば、ほとんどそのまま使えることが分かる。それらについて、証明する手段（随伴や米田の補題など）はまだ得ていないが、価値ある直観の源としてここに挙げておこう。

### 0乗

$$a^{0} = 1$$
圏論的解釈では、0を始対象に、1を終対象に、等しさを同型に置き換える。冪は内部hom対象だ。ここに示した冪は、始対象から任意の対象$a$への射の集合を表している。始対象の定義によれば、そのような射は1つだけ存在するので、hom集合$\cat{C}(0, a)$ は単元集合となる。単元集合は$\Set$内の終対象なので、この恒等式は$\Set$内で自明に成り立つ。言いたいことは、これがどんな双デカルト閉圏でも成り立つということだ。

Haskellでは、0を`Void`で、1をunit型`()`で、冪を関数型でそれぞれ置き換える。これは、`Void`から任意の型`a`への関数の集合と、単元集合であるunit型が等価だと主張している。言い換えると、関数`Void -> a`は1つしかない。この関数は以前見た。`absurd`と呼ばれる関数だ。

2つの理由から、これは少しトリッキーだ。1つは、Haskellは実際には住人がいない型を持たないことだ――すべての型には「終わりのない計算の結果」、つまりボトムが含まれている。第2の理由は、`absurd`のすべての実装は等価であるということだ[^absurd]。なぜなら、それらが何をしようと、誰も実行できないからだ。`absurd`に渡せる値はない。（そして、終わりのない計算を渡せたとしても、決して値は返らない！）

[^absurd]: 監訳注：ここでは$\bot$は考慮に入れているが`seq :: a -> b -> b`は考慮に入れていないことに注意する。ここで`seq a b`は、直観的には（それ自身を評価する際に）`a`を評価してから`b`を評価することを表し、`a`が$\bot$ならば$\bot$と、そうでなければ`b`と等価である。詳細は省くが、`seq`があることで、9.6節で定義されるような`absurd`と、`absurd = absurd`で定義される`absurd`とを区別できる（区別できてしまう）。

### 1の冪

$$1^{a} = 1$$
この恒等式を$\Set$で解釈すると、終対象の定義である「どの対象にも終対象への一意な射がある」を言い換えている。一般に、$a$から終対象への内部hom対象は、終対象そのものと同型だ。

Haskellでは、型`a`からunit型への関数は1つしかない^[訳注：ここから再びボトムを無視している。]。この関数は以前にも見たことがある。`unit`と呼ばれる関数だ。`()`に部分適用された`const`関数とも見なせる。

### 1乗

$$a^{1} = a$$
これは、終対象からの射が対象`a`の「要素」を選ぶのに利用できるという観点を言い換えたものだ。このような射の集合は対象そのものと同型だ。$\Set$とHaskellでは、集合`a`の要素と、それらの要素を選択する関数`() -> a`との間に同型が成り立つ。

### 和による冪

$$a^{b+c} = a^{b} \times a^{c}$$
これは、圏論では2つの対象の余積による冪が2つの冪の積と同型だと明示している。Haskellでは、この代数的恒等式に非常に実用的な解釈がある。これは、2つの型の直和型を取る関数が、それら個々の型を取る関数のペアと等価だと示している。直和型を取る関数を定義するときに使う場合分け (case analysis) そのものだ。`case`式で1つの関数定義を記述する代わりに、通常はそれを2つ（またはそれ以上）の関数に分割して、それぞれの構成子を別々に処理する。たとえば、直和型 `(Either Int Double)` を取る関数を考えよう：

```haskell
f :: Either Int Double -> String
```

\noindent
これは、それぞれ`Int`と`Double`を取る2つの関数のペアとして定義できる。

```haskell
f (Left n)  = if n < 0 then "Negative int" else "Positive int"
f (Right x) = if x < 0.0 then "Negative double" else "Positive double"
```

\noindent
ここで、`n`は`Int`で、`x`は`Double`だ。

### 冪の冪

$$(a^{b})^{c} = a^{b \times c}$$
これは単にカリー化を純粋に冪対象の観点で表現したものだ。関数を返す関数は、積を引数に取る関数（2引数の関数）と等価だ。

### 積の冪

$$(a \times b)^{c} = a^{c} \times b^{c}$$
Haskellでは、ペアを返す関数は、それぞれがペアの1つの要素を生成する関数のペアと等価だ。

これらの高校数学の単純な代数的恒等式が、このように圏論に持ち上げられ、関数プログラミングで実用的な応用があるのは、実に驚くべきことだ。

## カリー・ハワード同型

論理と代数的データ型の対応についてはすでに述べた。`Void`型とunit型`()`は、偽と真に対応する。直積型と直和型は、論理積$\wedge$ (AND) と論理和$\vee$ (OR) に対応する。この図式では、先ほど定義した関数型は論理包含$\Rightarrow$に対応する。つまり、型`a -> b`は「aならばb」と読める。

カリー・ハワード同型 (Curry-Howard isomorphism) によれば、すべての型は命題として解釈できる。命題とは、真または偽に定まる言明や判断だ。そのような命題は、型が居住されているならば真とされ、そうでなければ偽とされる。論理包含では、対応する関数型が居住されている（その型の関数が存在する）ならば真となる。したがって、関数の実装は定理の証明になる。プログラムを書くのは定理を証明するのと等価だ。いくつか例を見てみよう。

関数対象の定義で導入した関数`eval`を取り上げよう。シグネチャーは次のとおりだ：

```haskell
eval :: ((a -> b), a) -> b
```

\noindent
これは関数とその引数のペアを取り、適切な型の結果を生成する。つまり、次の射をHaskellで実装したものだ：
$$\mathit{eval} \Colon (a \Rightarrow b) \times a \to b$$
この射は関数型$a \Rightarrow b$（すなわち冪対象$b^{a}$）を定義する。この型を、カリー・ハワード同型を使って論理の命題に変換しよう。
$$((a \Rightarrow b) \wedge a) \Rightarrow b$$
この命題の読み方はこうだ：$a$ならば$b$が真であり、かつ$a$が真ならば、$b$は必ず真である。これは完全に直観に適っていて、古代から[*modus ponens*]{.keyword #modus_ponen}\index{modus ponens}として知られていた。次の関数を実装することで、この定理を証明できる：

```haskell
eval :: ((a -> b), a) -> b
eval (f, x) = f x
```

\noindent
`a`を取り`b`を返す関数`f`と、型`a`の具体的な値`x`とのペアがあれば、`f`を`x`に適用するだけで型`b`の具体的な値を得られる。この関数を実装することで、型`((a -> b), a) -> b`が居住されていることが示せた。modus ponensは我々の論理では真だ。

では、あからさまに間違っている命題ではどうだろうか？　例：$a$または$b$が真ならば$a$は真でなければならない：
$$a \vee b \Rightarrow a$$
これは明らかに間違っている。なぜなら、$a$が偽で$b$が真の場合が反例となるからだ。

この命題をカリー・ハワード同型を使って関数型に写すと、次のようになる：

```haskell
Either a b -> a
```

\noindent
いくらやってみても、この関数は実装できない――`Right`の形の値で呼び出された場合、型`a`の値は生成できない（ここでは*純粋*関数について説明していることを思い出してほしい）。

最終的に、`absurd`関数が意味するものに辿り着く：

```haskell
absurd :: Void -> a
```

\noindent
`Void`が偽に変換されることを考えると、次のようになる：
$$\mathit{false} \Rightarrow a$$
虚偽からは何でも導ける (_ex falso quodlibet_)。Haskellにおけるこの命題（関数）の証明（実装）として可能なものを以下に1つ示す。

```haskell
absurd (Void a) = absurd a
```

\noindent
ここで、`Void`は次のように定義される：

```haskell
newtype Void = Void Void
```

\noindent
いつものように、型`Void`はトリッキーだ。この定義により、値を構成するには値を提供する必要があるため、値を構成できない^[訳注：ここで構成しようとしている値も提供されるべき値もともにVoid型である。]。したがって、この関数`absurd`は決して呼び出せない。

いずれも興味深い例だが、カリー・ハワード同型に実用面はあるのだろうか？　おそらく日々のプログラミングではないだろう。しかし、AgdaやCoqのようなプログラミング言語では、定理を証明するためにカリー・ハワード同型が利用されている。

コンピューターは数学者の仕事を助けている[^lean]だけでなく、数学の基礎そのものに革命をもたらしている。この分野の注目の最新のホットな研究テーマはホモトピー型理論 (Homotopy Type Theory, HoTT) と呼ばれ、型理論の派生物だ。ブーリアン、整数、積と余積、関数型などでいっぱいだ。そして、疑念を払拭するかのように、その理論はCoqとAgdaで定式化されようとしている。コンピューターは世界にさまざまな形で革命を起こしている。

[^lean]: 訳注：実際にこの種の言語のひとつであるLeanは、Scholze（フィールズ賞受賞者）が定理を確認するのに役立った。参考：

    - <https://www.microsoft.com/en-us/research/project/lean/>
    - <https://github.com/leanprover-community/lean-liquid/>

## 参考文献

#. Ralf Hinze, Daniel W. H. James, [Reason Isomorphically!](http://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf)^[<http://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf> 訳注：<https://doi.org/10.1145/1863495.1863507>]. この論文には、この章で述べた圏論におけるすべての高校数学の代数的恒等式の証明が含まれている。
