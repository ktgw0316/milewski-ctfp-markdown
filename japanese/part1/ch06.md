# シンプルな代数的データ型 {#simple-algebraic-data-types}

型を組み合わせる2つの基本的な方法として、積と余積を使う方法を見てきた。日常のプログラミングにおける多くのデータ構造は、この2つのメカニズムだけを使って構築できると分かった。この事実は重要で実用的な結果をもたらす。データ構造の特性の多くは合成可能だ。たとえば、基本型の値が等価かどうか比較する方法を知っていて、それらの比較を積と余積の型に一般化する方法を知っていれば、自動的に複合型の等値演算子を導出できる。Haskellでは、複合型の大きな部分集合に対して、等価性、比較、文字列への変換、文字列からの変換などを自動的に導出できる。

次に、直積型 (product type) と直和型 (sum type) がプログラミングに現れる様子を詳しく見てみよう。

## 直積型

プログラム言語における2つの型の積の正統な実装はペアだ。Haskellではペアはプリミティブな型コンストラクターだ。C++では比較的複雑なテンプレートとして標準ライブラリで定義されている。

`\begin{figure}[H] \centering`{=latex}
![](images/pair.jpg){width=35%}
`\end{figure}`{=latex}
\noindent
ペアは厳密には可換ではない。ペア`(Int, Bool)`は、同じ情報を保持していても、ペア`(Bool, Int)`には置き換えられない。しかし、それらは同型を除いて可換だ。同型は`swap`関数（それ自体の逆関数）で与えらる：

```haskell
swap :: (a, b) -> (b, a)
swap (x, y) = (y, x)
```

\noindent
この2つのペアは、単に同じデータを格納するために異なるフォーマットを使っていると見なせる。ビッグエンディアンとリトルエンディアンのようなものだ。

ペアの中にペアをネストすれば型をいくつでも積に結合できるが、もっと簡単な方法がある。ネストされたペアはタプルと等価なのだ。これは、ペアをネストする様々な方法が同型であるという事実からの帰結だ。3つの型`a`、`b`、`c`を順に積によって結合する場合、次の2つの方法がある：

```haskell
((a, b), c)
```

\noindent
あるいは

```haskell
(a, (b, c))
```

\noindent
これらは型が異なり、一方の型を期待する関数に他方の型を渡すことはできない。しかし、要素は1対1で対応している。そのため、相互に写す関数が存在し：

```haskell
alpha :: ((a, b), c) -> (a, (b, c))
alpha ((x, y), z) = (x, (y, z))
```

\noindent
その逆関数も存在する：

```haskell
alpha_inv :: (a, (b, c)) -> ((a, b), c)
alpha_inv  (x, (y, z)) = ((x, y), z)
```

\noindent
したがって、これは同型だ。データは同じで、再パッケージ化するための方法が違うにすぎない。

直積型の生成は、型における二項演算として解釈できる。この観点から見ると、上記の同型は、モノイドで見た結合律 (associativity law) に非常によく似ている：
$$(a * b) * c = a * (b * c)$$
ただし、モノイドの場合は積を構成する2つの方法が等価であったのに対して、ここでは「同型を除いて」等価であるにすぎない。

同型を認めて、厳密な等価性に固執しないならば、さらに進んで、1が乗算の単位元であるのと同じようにunit型`()`が積の単位元であるのを示せる。実際、ある型`a`の値と単位元の組み合わせは、何の情報も追加しない。型：

```haskell
(a, ())
```

\noindent
は`a`と同型だ。その同型はこのようになる：

```haskell
rho :: (a, ()) -> a
rho (x, ()) = x
```

```haskell
rho_inv :: a -> (a, ())
rho_inv x = (x, ())
```

\noindent
これらの観察は、$\Set$（集合の圏）は[*モノイダル圏*]{.keyword #monoidal_category}\index{モノイダル圏} (monoidal category) である、と述べることによって形式化できる。それは、対象を（ここではカルテシアン積で）乗算できるという意味で、モノイドでもある圏だ。モノイダル圏についてさらに説明しよう。完全な定義は将来的に示す。

Haskellには直積型を定義するもっと一般的な方法がある。特に、すぐ後で説明するとおり、直和型と組み合わされたときにはっきりする。その定義には複数の引数を持つ名前付きコンストラクターを使う。たとえば、ペアは次のようにも定義できる：

```haskell
data Pair a b = P a b
```

\noindent
ここで、`Pair a b`は他の2つの型`a`と`b`によってパラメーター化された型の名前であり、`P`はデータコンストラクターの名前だ。ペアの型を定義するには`Pair`型コンストラクターに2つの型を渡す。適切な型の2つの値をコンストラクター`P`に渡すことで、ペアの値を構成する。たとえば、値`stmt`を`String`と`Bool`のペアとして定義したとする：

```haskell
stmt :: Pair String Bool
stmt = P "This statements is" False
```

\noindent
最初の行は型宣言だ。これは型コンストラクター`Pair`を使い、その`Pair`の総称定義の`a`と`b`を、それぞれ`String`と`Bool`で置き換えたものだ。2行目では、具体的な文字列と具体的なブール値をデータコンストラクター`P`に渡すことで、実際の値を定義している。型コンストラクターは型を構成するために使われ、データコンストラクターは値を構成するために使われる。

Haskellでは型コンストラクターとデータコンストラクターの名前空間が分離されているため、次のように両方に同じ名前が使われていることがよくある：

```haskell
data Pair a b = Pair a b
```

\noindent
さらに目を細めれば、組み込みのペア型を、この種の宣言のバリエーションとして見ることもできる。この場合、`Pair`という名前は`(,)`という二項演算子で置き換えられる。実際、`(,)`を他の名前付きコンストラクターと同じように扱い、前置記法を使ってペアを作成できる：

```haskell
stmt = (,) "This statement is" False
```

\noindent
同様に、`(,,)`を使ってトリプルを作成する、などもできる。

総称ペアやタプルを使う代わりに、次のように特定の名前を付けた直積型を定義してもよい：

```haskell
data Stmt = Stmt String Bool
```

\noindent
これは単に`String`と`Bool`の積だが、独自の名前とコンストラクターが与えられている。このスタイルの宣言の利点は、内容は同じでも意味と機能が異なる互いに置き換えられない型を多数定義できることだ。

タプルや複数の引数を持つコンストラクターを使ってプログラミングすると、複雑で間違いが生じやすくなる。どの成分が何を表しているかを追うのが大変になるからだ。成分に名前を付ける方が望ましい場合はよくある。名前付きフィールドを持つ直積型は、Haskellでは[*record*]{.keyword #record}\index{record}、Cでは`struct`と呼ばれる。

## レコード

簡単な例を見てみよう。化学元素を記述するために、2つの文字列（名前と元素記号）と整数（原子番号）を組み合わせて1つのデータ構造にしたい。タプル`(String, String, Int)`を使えば、どの成分が何を表しているかを記憶できる。成分はパターンマッチングによって抽出しよう。たとえば、この関数は元素記号が名前の接頭辞かをチェックする（**He**は**Helium**の接頭辞だ）。

```haskell
startsWithSymbol :: (String, String, Int) -> Bool
startsWithSymbol (name, symbol, _) = isPrefixOf symbol name
```

\noindent
このコードは間違いが生じやすく、読むのもメンテナンスするのも困難だ。レコードを定義する方がはるかに良い。

```haskell
data Element = Element { name         :: String
                       , symbol       :: String
                       , atomicNumber :: Int }
```

\noindent
2つの表現は同型だ。そのことは、互いに逆になっている2つの変換関数からも分かる。

```haskell
tupleToElem :: (String, String, Int) -> Element
tupleToElem (n, s, a) = Element { name = n
                                , symbol = s
                                , atomicNumber = a }
```

```haskell
elemToTuple :: Element -> (String, String, Int)
elemToTuple e = (name e, symbol e, atomicNumber e)
```

\noindent
レコードのフィールド名は、それらのフィールドにアクセスするための関数としても機能することに注意してほしい。たとえば、`atomicNumber`は`e`から`atomicNumber`フィールドを取得する。つまり、`atomicNumber`は次のような型の関数として使われる：

```haskell
atomicNumber :: Element -> Int
```

\noindent
 `Element`のレコード構文によって、関数`startsWithSymbol`はより読みやすくなる：

```haskell
startsWithSymbol :: Element -> Bool
startsWithSymbol e = isPrefixOf (symbol e) (name e)
```

\noindent
Haskellのトリックを使って、関数`isPrefixOf`をバッククォーテーションで囲んで中置演算子に変換すれば、まるで文のように読めるようにさえできる：

```haskell
startsWithSymbol e = symbol e `isPrefixOf` name e
```

\noindent
中置演算子は関数呼び出しよりも優先順位が低いため、この場合は括弧を省略できる。

## 直和型

集合の圏の積が直積型を生み出すのと同じように、余積は直和型を生み出す。Haskellにおける直和型の正統な実装は次のようなものだ：

```haskell
data Either a b = Left a | Right b
```

\noindent
また、ペアと同様に、`Either`は（同型を除いて）可換であり、ネストでき、ネストの順序は（同型を除いて）無関係だ。したがって、たとえば、トリプルに相当する和：

```haskell
data OneOfThree a b c = Sinistral a | Medial b | Dextral c
```

\noindent
などを定義できる。

$\Set$は余積に関する（対称な）モノイダル圏でもあることが分かる。二項演算の役割を演じるのは非交和であり、単位元の役割を演じるのは始対象だ。型に関しては、モノイダル演算子として`Either`があり、中立元として無人型 (uninhabited type) である`Void`がある。 `Either`は加算、`Void`は0と見なせる。実際、直和型に`Void`を足しても内容は変わらない。例として：

```haskell
Either a Void
```

\noindent
は`a`と同型だ。これは、この型の`Right`バージョンを構築する方法がないためだ。型`Void`に値は存在しない。 `Either a Void`の唯一の要素は、`Left`コンストラクターを使って構築され、単純に型`a`の値をカプセル化する。したがって、象徴的に、$a + 0 = a$となる。

直和型がHaskellではごく普通に使われるのに対し、C++で同等のものであるunionやvariantは稀にしか使われない。その理由はいくつかある。

まず、最も単純な直和型は単なる列挙であり、C++では`enum`を使って実装されている。Haskellの直和型：

```haskell
data Color = Red | Green | Blue
```

\noindent
にC++で相当するものは：

```cpp
enum { Red, Green, Blue };
```

\noindent
だ。もっとシンプルな直和型：

```haskell
data Bool = True | False
```

\noindent
は、C++ではプリミティブ`bool`だ。

値の有無をエンコードする単純な直和型は、C++ではさまざまに実装されており、特殊なトリックや、空文字列・負値・ヌルポインタなどの「不可能な」値が使われる。この種のオプション性は、意図的な場合、Haskellでは`Maybe`型を使って表現される：

```haskell
data Maybe a = Nothing | Just a
```

\noindent
 `Maybe`型は2つの型の和だ。このことは2つのコンストラクターを個々の型に分けると分かる。1つ目は次のようになる：

```haskell
data NothingType = Nothing
```

\noindent
これは`Nothing`という名前の1つの値を持つ列挙だ。言い換えると、これは単集合であり、unit型`()`と等価だ。2つ目の部分：

```haskell
data JustType a = Just a
```

\noindent
は、型`a`を単にカプセル化したものだ。`Maybe`を次のように書いてもよかっただろう：

```haskell
type Maybe a = Either () a
```

\noindent
より複雑な直和型は、C++ではポインタを使って模擬することが多い。ポインタはヌルとなるか、あるいは特定の型の値を指し示す。たとえば、Haskellで（再帰的な）直和型として定義できるリスト型：

```haskell
List a = Nil | Cons a (List a)
```

\noindent
をC++に変換するには、ヌルポインタのトリックを使って空のリストを実装する：

```cpp
template<class A>
class List {
    Node<A> * _head;
public:
    List() : _head(nullptr) {}  // Nil
    List(A a, List<A> l)        // Cons
      : _head(new Node<A>(a, l))
    {}
};
```

\noindent
Haskellでの2つのコンストラクター`Nil`と`Cons`が、よく似た引数（`Nil`は空、`Cons`は値1つとリスト1つ）でオーバーロードされた2つの`List`コンストラクターへと変換されたことに注目してほしい。この`List`クラスには、直和型の2つの成分を区別するためのタグは必要ない。その代わり、`_head`に特別な`nullptr`値を使って`Nil`を表現する。

もっとも、HaskellとC++の型の主な違いは、Haskellではデータ構造が不変であることだ。ある特定のコンストラクターを使ってオブジェクトを作成する場合、オブジェクトはどのコンストラクターが使われ、どの引数が渡されたかを永久に記憶する。したがって、`Just "energy"`として作成された`Maybe`オブジェクトが`Nothing`に変わることはない。同様に、空のリストは永久に空であり、3つの要素のリストは常に同じ3つの要素を持つことになる。

この不変性こそが構成を可逆的にする。オブジェクトがあれば、いつでも構成で使われた部品に分解できる。この分解はパターンマッチングで行われ、コンストラクターをパターンとして再利用する。コンストラクター引数がある場合は、変数（またはその他のパターン）に置き換えられる。

`List`データ型には2つのコンストラクターがあるため、任意の`List`の分解では、これらのコンストラクターに対応する2つのパターンを使う。1つは空の`Nil`リストに一致し、もう1つは`Cons`で構成されたリストに一致する。たとえば、複数の`List`に対する単純な関数の定義は次のとおりだ。

```haskell
maybeTail :: List a -> Maybe (List a)
maybeTail Nil = Nothing
maybeTail (Cons _ t) = Just t
```

\noindent
`maybeTail`の定義の最初の部分は、`Nil`コンストラクターをパターンとして使い、`Nothing`を返す。2番目の部分では、`Cons`コンストラクターをパターンとして使う。コンストラクターの最初の引数には興味がないため、ワイルドカードで置き換える。`Cons`の2番目の引数は、変数`t`に束縛される（厳密に言えば、一度式に束縛されたら決して変化しないものの、変数と呼ぶことにする）。戻り値は`Just t`だ。こうして、`List`の作成方法に応じて、句の1つに一致するようになった。作成に`Cons`が使われるときは、渡した2つの引数が取得される（最初の引数は破棄される）。

さらに複雑な直和型は、C++では多相クラス階層を使って実装されている。共通の祖先を持つ一連のクラスは、1つのバリアント型として理解でき、その中では仮想関数テーブルが隠しタグとして機能する。Haskellではコンストラクター上のパターンマッチングで特殊なコードを呼び出して行っていることを、C++では仮想関数テーブルのポインターに基づいて仮想関数呼び出しをディスパッチして実現している。

C++で`union`が直和型として使われることはめったにない。含められるものに厳しい制限があるからだ。`std::string`でさえ、コピー・コンストラクターを持っているので、unionに入れられない。

## 型の代数

直積型と直和型を別々に用いても有用なデータ構造をいろいろ定義できるが、真の強みはこの2つを組み合わせることで得られる。合成の力が再び発揮される時がきた。

これまでに分かったことをまとめておこう。型システムの下にある2つの可換モノイダル構造を見た。中立元として`Void`を持つ直和型と、中立元として`()`というunit型を持つ直積型だ。それらを加法や乗法に似たものだと見なそう。この比喩では、`Void`は0に対応し、`()`は1に対応する。

この比喩をどこまで拡張できるか見てみよう。例として、0を掛けると0になるだろうか？
言い換えれば、1つの成分が`Void`である直積型は、`Void`と同型だろうか？
たとえば、`Int`と`Void`のペアを作成できるだろうか？

ペアを作成するには2つの値が必要だ。整数なら簡単だが、型`Void`には値がない。したがって、すべての型`a`に対して、型`(a, Void)`は値を持たない無人型であり、つまり`Void`と等価になる。言い換えれば、$a \times 0 = 0$ということだ。

加算と乗算をつなぐもう1つのものとして、分配法則がある：

```haskell
a * (b + c) = a * b + a * c
```

\noindent
これは直積型と直和型にも当てはまるだろうか？
当てはまる――いつものように同型を除いて。左辺は次の型に相当する：

```haskell
(a, Either b c)
```

\noindent
また、右辺は次の型に相当する：

```haskell
Either (a, b) (a, c)
```

\noindent
これらをある向きで変換する関数は次のとおりだ：

```haskell
prodToSum :: (a, Either b c) -> Either (a, b) (a, c)
prodToSum (x, e) =
    case e of
      Left  y -> Left  (x, y)
      Right z -> Right (x, z)
```

\noindent
また、その逆向きだと次のとおりだ：

```haskell
sumToProd :: Either (a, b) (a, c) -> (a, Either b c)
sumToProd e =
    case e of
      Left  (x, y) -> (x, Left  y)
      Right (x, z) -> (x, Right z)
```

\noindent
`case of`式は、パターンマッチング内部関数に使われる。各パターンの後には矢印と、パターンが一致したときに評価される式が続く。たとえば、次の値を指定して`prodToSum`を呼び出すとする。

```haskell
prod1 :: (Int, Either String Float)
prod1 = (2, Left "Hi!")
```

\noindent
`case e of`内の`e`は`Left "Hi!"`と等しくなる。これはパターン`Left y`と一致し、`y`を`"Hi!"`に置き換える。`x`はすでに`2`と一致しているので、`case of`句の結果と関数全体は、期待どおり`Left (2, "Hi!")`となる。

この2つの関数が互いに逆であることの証明は省くが、よく考えれば分かるだろう。これらは2つのデータ構造の内容を単に再パックしている。データは同じで、フォーマットが異なるだけだ。

数学者たちは、このような絡み合った2つのモノイドに[*半環*]{.keyword #semiring}\index{半環} (semiring) という名前をつけている。これは完全な[*環*]{.keyword #ring}\index{環} (ring) ではない。型の減算は定義できないからだ。そのため、半環は「*n* (negative) がない環 (ring)」をかけて[*リグ*]{.keyword #rig}\index{リグ} (rig) と呼ばれることがある。しかし、そのことを除けば、リグを形成する自然数などに関する命題を型に関する命題に変換することで、多くのメリットが得られる。興味深い項目を含む変換表を以下に示す：

Numbers      Types
---------- ----------------------------------
0          `Void`
1          `()`
a + b      `Either a b = Left a | Right b`
a * b      `(a, b)`または`Pair a b = Pair a b`
2 = 1 + 1  `data Bool = True | False`
1 + a      `data Maybe = Nothing | Just a`

リスト型は、非常に興味深いことに、方程式の解として定義される。定義している型は、式の両辺に現れる：

```haskell
List a = Nil | Cons a (List a)
```

\noindent
通常の置換を行い、さらに`List a`を`x`に置き換えると、次の式が得られる：

```haskell
x = 1 + a * x
```

\noindent
型の減算や除算はできないので、これは従来の代数的方法では解けない。しかし、置換の連続なら試せる。つまり、ひたすら右辺の`x`を`(1 + a*x)`に置き換えては分配法則を使う。これによって次の一連の結果が得られる：

```haskell
x = 1 + a*x
x = 1 + a*(1 + a*x) = 1 + a + a*a*x
x = 1 + a + a*a*(1 + a*x) = 1 + a + a*a + a*a*a*x
...
x = 1 + a + a*a + a*a*a + a*a*a*a...
```

\noindent
最終的には積（タプル）の和が無限に続くことになった。これは次のように解釈できる。リストは空集合`1`か、単集合`a`か、ペア`a*a`か、トリプル`a*a*a`か、などなど……。まさにそれがリストだ。一連の`a`だ！


リストについては語るべきことがまだまだある。関手や不動点について学んだ後で、リストやその他の再帰的なデータ構造について再び説明する。

記号変数を使って方程式を解く――これぞ代数だ！
それゆえ、これらの型は代数的データ型と呼ばれる。

最後に、型の代数の非常に重要な解釈について述べなければならない。`a`と`b`の2つの型の積には、型`a`*および*型`b`の両方の値が含まれている必要があることに注意してほしい。これは、両方の型が居住 (inhabit) である必要があることを意味する。一方、2つの型の和には、型`a` *または*型`b`のいずれかの値が含まれるので、どちらかが居住であれば十分だ。また、*論理積* (logical and) と*論理和* (logical or) も半環を形成し、型理論と対応付けられる：

論理型
------- --------------------------------
false   `Void`
true    `()`
a || b  `Either a b = Left a | Right b`
a && b  `(a, b)`

この比喩はさらに深く、論理と型理論を結ぶカリー・ハワード同型の基礎となっている。それについては関数型について説明するときに再び取り上げる。

## 課題

1. `Maybe a`と`Either () a`の間の同型を示せ。
2. 円と長方形の直和型をHaskellで定義する。

   ```haskell
   data Shape = Circle Float
                  | Rect Float Float
   ```

\noindent
   `Shape`に作用し面積を求める`area`のような関数を定義したい場合は、次の2つのコンストラクターでパターンマッチングを使う。

   ```haskell
   area :: Shape -> Float
       area (Circle r) = pi * r * r
       area (Rect d h) = d * h
   ```

\noindent
   C++またはJavaでインタフェースとして`Shape`を実装し、`Circle`と`Rect`という2つのクラスを作成せよ。`area`は仮想関数として実装せよ。

3. 先ほどの例を続ける。`Shape`の周の長さを求める新しい関数`circ`は簡単に追加できる。`Shape`の定義に触れる必要はない。

   ```haskell
   circ :: Shape -> Float
       circ (Circle r) = 2.0 * pi * r
       circ (Rect d h) = 2.0 * (d + h)
   ```

\noindent
   C++またはJavaの実装に`circ`を追加せよ。もとのコードのどの部分に触れる必要があったか？


4. さらに続ける。新しい図形として正方形`Square`を`Shape`に追加し、必要なすべてを更新する。HaskellならびにC++およびJavaでは、コードのどこに触れる必要があったか？
   (Haskellプログラマーでないとしても、変更箇所はごく自明なはずだ。）


5. 型について$a + a = 2 \times a$が（同型を除いて）成り立つことを示せ。前掲の変換表によれば、$2$は`Bool`に対応する。
