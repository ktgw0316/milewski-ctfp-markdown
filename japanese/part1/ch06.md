# シンプルな代数的データ型

型を組み合わせる2つの基本的な方法として、積と余積を使う方法を見てきた。日常のプログラミングにおける多くのデータ構造は、この2つのメカニズムだけを使って構築できると分かった。この事実は重要で実用的な結果をもたらす。データ構造の多くの特性は合成可能だ。たとえば、基本型の値が等値かどうか比較する方法を知っていて、これらの比較を直積型と余積の型に一般化する方法を知っていれば、自動的に複合型の等値演算子を導出できる。Haskellでは、複合型の大きな部分集合に対して、等値性、比較、文字列への変換、文字列からの変換などを自動的に導出できる。

次に、直積型と直和型がプログラミングに現れる様子を詳しく見てみよう。

## 直積型

プログラム言語における2つの型の直積の標準的な実装はペアだ。Haskellではペアはプリミティブな型コンストラクタだ。C++では比較的複雑なテンプレートとして標準ライブラリで定義されている。

![](images/pair.jpg){width=35%}

ペアは厳密には可換ではない。ペア`(Int, Bool)`は、同じ情報を保持していても、ペア`(Bool, Int)`には置き換えられない。しかし、それらは同型を除いて可換だ。同型は`swap`関数 (それ自体の逆関数) で与えらる。

```haskell
swap :: (a, b) -> (b, a)
swap (x, y) = (y, x)
```

この2つのペアは、単に同じデータを格納するために異なるフォーマットを使っていると見なせる。ビッグエンディアンとリトルエンディアンのようなものだ。

ペアの中にペアをネストすることで、任意の数の型を積に結合できるが、もっと簡単な方法がある。ネストされたペアはタプルと等価なのだ。これは、ペアをネストする様々な方法が同型であるという事実からの帰結だ。`a`、`b`、`c`の3つの型をこの順序で積のなかで結合する場合、次の2つの方法がある。

```haskell
((a, b), c)
```

あるいは

```haskell
(a, (b, c))
```

これらの型は異なる。一方の型を期待する関数に他方の型を渡すことはできない。しかし、要素は1対1で対応している。相互に写す関数が存在する:

```haskell
alpha :: ((a, b), c) -> (a, (b, c))
alpha ((x, y), z) = (x, (y, z))
```

また、その逆関数も存在する:

```haskell
alpha_inv :: (a, (b, c)) -> ((a, b), c)
alpha_inv  (x, (y, z)) = ((x, y), z)
```

したがって、これは同型だ。これらは単に、同じデータを再パッケージ化するための異なる方法だ。

直積型の作成は、型における二項演算として解釈できる。この観点から見ると、上記の同型は、モノイドで見てきた結合則に非常によく似ている:

$$(a * b) * c = a * (b * c)$$

ただし、モノイドの場合は積を構成する2つの方法が等価であったのに対して、ここでは「同型を除いて」等価であるにすぎない。

同型を認めて、厳密な等価性に固執しないならば、さらに進んで、1が乗算の単位であるのと同じようにunit型`()`が積の単位であるのを示せる。実際、ある型`a`の値と単位の組み合わせは、何の情報も追加しない。型:

```haskell
(a, ())
```

は`a`と同型だ。同型はこうだ:

```haskell
rho :: (a, ()) -> a
rho (x, ()) = x
```

```haskell
rho_inv :: a -> (a, ())
rho_inv x = (x, ())
```

これらの観察は、$\Set$ (集合の圏) は[モノイダル圏]{.keyword #monoidal_category} (monoidal category) である、と述べることによって形式化できる。それは、対象を (ここではカルテシアン積で) 乗算できるという意味で、モノイドでもある圏だ。モノイダル圏についてさらに説明しよう。完全な定義は将来的に示す。

Haskellには直積型を定義するもっと一般的な方法がある。特に、すぐ後で説明するように、直和型と組み合わされた場合にはそうだ。それには複数の引数を持つ名前付きコンストラクタを使う。たとえば、ペアを次のように定義することもできる。

```haskell
data Pair a b = P a b
```

ここで、`Pair a b`は他の2つの型`a`と`b`によってパラメータ化された型の名前であり、`P`はデータコンストラクタの名前だ。ペアの型を定義するには`Pair`型コンストラクタに2つの型を渡す。適切な型の2つの値をコンストラクタ`P`に渡すことで、ペアの値を構成する。たとえば、値`stmt`を`String`と`Bool`のペアとして定義するとする。

```haskell
stmt :: Pair String Bool
stmt = P "This statements is" False
```

最初の行は型宣言だ。これは型コンストラクタ`Pair`を使い、`String`と`Bool`で、`Pair`の総称定義の`a`と`b`を置き換えたものだ。2行目では、具体的な文字列と具体的なブール値をデータコンストラクタ`P`に渡すことで、実際の値を定義する。型コンストラクタは型を構成するために使われ、データコンストラクタは値を構成するために使われる。

Haskellでは型コンストラクタとデータコンストラクタの名前空間が分離されているため、次のように両方に同じ名前が使われていることがよくある。

```haskell
data Pair a b = Pair a b
```

さらに目を細めて見れば、組み込みのペア型を、この種の宣言のバリエーションとして見ることもできる。この場合、`Pair`という名前は、`(,)`という二項演算子で置き換えられる。実際、他の名前付きコンストラクタと同じように`(,)`を使い、前置記法を使ってペアを作成できる。

```haskell
stmt = (,) "This statement is" False
```

同様に、`(,,)`を使ってトリプルを作成する、などのこともできる。

総称ペアまたはタプルを使う代わりに、次のように特定の名前を付けた直積型を定義することもできる。

```haskell
data Stmt = Stmt String Bool
```

これは単に`String`と`Bool`の直積だが、独自の名前とコンストラクターが与えられている。このスタイルの宣言の利点は、内容は同じでも意味と機能が異なり、互いに置き換えられない型を多数定義できることだ。

タプルや複数の引数を持つコンストラクターを使ってプログラミングすると、複雑で間違いが生じやすくなる。どのコンポーネントが何を表しているかを追うのが大変だ。コンポーネントに名前を付ける方が望ましい場合がよくある。名前付きフィールドを持つ直積型は、Haskellでは[record]{.keyword #record}、Cでは`struct`と呼ばれる。

## レコード

簡単な例を見てみよう。化学元素を記述するために、2つの文字列 (名前と元素記号) と整数 (原子番号) を組み合わせて1つのデータ構造にしたい。タプル`(String, String, Int)`を使えば、どのコンポーネントが何を表しているかを記憶できる。コンポーネントはパターンマッチングによって抽出しよう。たとえば、この関数は元素記号が名前の接頭辞かをチェックする (**He**は**Helium**の接頭辞だ)。

```haskell
startsWithSymbol :: (String, String, Int) -> Bool
startsWithSymbol (name, symbol, _) = isPrefixOf symbol name
```

このコードは間違いが生じやすく、読むのもメンテナンスするのも困難だ。レコードを定義する方がはるかに良い。

```haskell
data Element = Element { name         :: String
                       , symbol       :: String
                       , atomicNumber :: Int }
```

2つの表現は同型だ。そのことは、互いに逆になっている2つの変換関数からも分かる。

```haskell
tupleToElem :: (String, String, Int) -> Element
tupleToElem (n, s, a) = Element { name = n
                                , symbol = s
                                , atomicNumber = a }
```

```haskell
elemToTuple :: Element -> (String, String, Int)
elemToTuple e = (name e, symbol e, atomicNumber e)
```

レコードフィールドの名前は、それらのフィールドにアクセスするための関数としても機能することに注意してほしい。たとえば、`atomicNumber`は`e`から`atomicNumber`フィールドを取得する。 `atomicNumber`を次のような型の関数として使う:

```haskell
atomicNumber :: Element -> Int
```

 <g>Element</g>のレコード構文により、関数<g>startsWithSymbol</g>はより読みやすくなった。

```haskell
startsWithSymbol :: Element -> Bool
startsWithSymbol e = isPrefixOf (symbol e) (name e)
```

Haskellのトリックを使って、関数`isPrefixOf`をバッククォーテーションで囲むことで中置演算子に変換すれば、まるで文のように読めるようにさえできる。

```haskell
startsWithSymbol e = symbol e `isPrefixOf` name e
```

中置演算子は関数呼び出しよりも優先順位が低いため、この場合は括弧を省略できる。

## 直和型

集合の圏の積が直積型を生み出すのと同じように、余積は直和型を生み出す。Haskellにおける直和型の標準的な実装は次のようなものだ。

```haskell
data Either a b = Left a | Right b
```

また、ペアと同様に、`Either`は (同型を除いて) 可換であり、入れ子にすることができ、入れ子の順序は (同型を除いて) 無関係だ。したがって、たとえば、トリプルに相当する直和を定義できる。

```haskell
data OneOfThree a b c = Sinistral a | Medial b | Dextral c
```

などだ。

$\Set$は余積に関する (対称な) モノイダル圏でもあることがわかる。二項演算の役割を演じるのは非交和であり、単位元の役割を演じるのは始対象だ。型に関しては、モノイダル演算子として`Either`があり、中立元として無人型 (uninhabited type) である`Void`がある。 `Either`は加算、`Void`は0と見なせる。実際、直和型に`Void`を足しても内容は変わらない。例として:

```
Either a Void
```

は`a`と同型だ。これは、この型の`Right`バージョンを構築する方法がないためだ。型`Void`に値は存在しない。 `Either a Void`の唯一の要素は、`Left`コンストラクタを使って構築され、単純に型`a`の値をカプセル化する。したがって、象徴的に、$a+0=a$となる。

直和型はHaskellでは非常に一般的だが、C++の同等のものであるunionやvariantは、はるかに一般的でない。その理由はいくつかある。

まず、最も単純な直和型は単なる列挙であり、C++では`enum`を使って実装されている。Haskellの直和型に相当するもの:

```haskell
data Color = Red | Green | Blue
```

C++では:

```cpp
enum { Red, Green, Blue };
```

さらにシンプルな直和型:

```haskell
data Bool = True | False
```

はC++のプリミティブ`bool`だ。

値の有無をエンコードする単純な直和型は、C++ではさまざまに実装されており、特殊なトリックや、空文字列・負値・ヌルポインタなどの「不可能な」値が使われる。この種のオプション性は、意図的なものなら、Haskellでは`Maybe`型を使って表現される。

```haskell
data Maybe a = Nothing | Just a
```

 `Maybe`型は、2つの型の直和だ。このことは、2つのコンストラクターを個々の型に分けるとわかる。1つ目は次のようになる。

```haskell
data NothingType = Nothing
```

 `Nothing`という名前の1つの値を持つ列挙だ。言い換えると、これはsingletonであり、unit型`()`と等価だ。2つ目の部分:

```haskell
data JustType a = Just a
```

これは型`a`の単なるカプセル化だ。`Maybe`は次のようにエンコードできる。

```haskell
data Maybe a = Either () a
```

より複雑な直和型は、C++ではポインタを使って偽装されることがよくある。ポインタはヌル、または特定の型の値を指し示せる。たとえば、Haskellのリスト型は、(再帰的な) 直和型として定義できる。

```haskell
List a = Nil | Cons a (List a)
```

これは、空のリストを実装するヌルポインタのトリックを使ってC++に変換できる。

```cpp
template<class A>
class List {
    Node<A> * _head;
public:
    List() : _head(nullptr) {}  // Nil
    List(A a, List<A> l)        // Cons
      : _head(new Node<A>(a, l))
    {}
};
```

2つのHaskellコンストラクタ`Nil`と`Cons`は、類似した引数 (`Nil`の場合はnone、`Cons`の場合は値とリスト) を持つ2つのオーバーロードされた`List`コンストラクタに変換されることに注意してほしい。 `List`クラスには、直和型の2つのコンポーネントを区別するためのタグは必要ない。代わりに、`_head`の特別な`nullptr`値を使って`Nil`をエンコードする。

しかし、HaskellとC++の型の主な違いは、Haskellではデータ構造が不変であることだ。ある特定のコンストラクターを使ってオブジェクトを作成する場合、オブジェクトはどのコンストラクターが使われ、どの引数が渡されたかを永久に記憶する。したがって、`Just "energy"`として作成された`Maybe`オブジェクトが`Nothing`に変わることはない。同様に、空のリストは永久に空であり、3つの要素のリストは常に同じ3つの要素を持つことになる。

この不変性こそが構成を可逆的にする。オブジェクトがあれば、いつでも構成で使われた部品に分解できる。この分解はパターンマッチングで行われ、コンストラクターをパターンとして再利用する。コンストラクタ引数がある場合は、変数 (またはその他のパターン) に置き換えられる。

`List`データ型には2つのコンストラクターがあるため、任意の`List`の分解では、これらのコンストラクターに対応する2つのパターンを使う。1つは空の`Nil`リストに一致し、もう1つは`Cons`で構成されたリストに一致する。たとえば、複数の`List`に対する単純な関数の定義は次のとおりだ。

```haskell
maybeTail :: List a -> Maybe (List a)
maybeTail Nil = Nothing
maybeTail (Cons _ t) = Just t
```

`maybeTail`の定義の最初の部分は、`Nil`コンストラクタをパターンとして使い、`Nothing`を返す。2番目の部分では、`Cons`コンストラクタをパターンとして使う。コンストラクタの最初の引数には興味がないため、ワイルドカードで置き換える。`Cons`の2番目の引数は、変数`t`に束縛される (厳密に言えば、一度式に束縛された変数は決して変化しないものの、変数と呼ぶことにする)。戻り値は`Just t`だ。これで、`List`の作成方法に応じて、句の1つに一致するようになった。`Cons`を使って作成された場合は、渡された2つの引数が取得される (最初の引数は破棄される)。

さらに複雑な直和型は、C++では多相クラス階層を使って実装されている。共通の祖先を持つ一連のクラスは、1つのバリアント型として理解でき、その中では仮想関数テーブルが隠しタグとして機能する。Haskellでは、コンストラクター上でパターンマッチングが行い、特殊なコードを呼び出すことで、仮想関数テーブルのポインターに基づいて仮想関数呼び出しをディスパッチすることで実現している。

C++では直和型として`union`が使われることはめったにない。unionに含められるものに厳しい制限があるためだ。`std::string`でさえ、コピー・コンストラクターを持っているので、unionに入れられない。

## 型の代数

別々に用いると、直積型と直和型でさまざまな有用なデータ構造を定義できるが、真の強みはこの2つを組み合わせることにある。我々は再び合成の力を行使している。

これまで分かったことをまとめておこう。型システムの下にある2つの可換モノイダル構造を見てきた。中立元として`Void`を持つ直和型と、中立元として`()`というunit型を持つ直積型だ。それらを加法や乗法に似たものだと見なしたい。この比喩では、`Void`は0に対応し、`()`は1に対応する。

この比喩をどこまで拡張できるか見てみよう。例として、0を掛けると0になるか？
言い換えれば、1つのコンポーネントが`Void`である直積型は、`Void`と同型か？
たとえば、`Int`と`Void`のペアを作成できるか？


ペアを作成するには、2つの値が必要だ。整数なら簡単だが、型`Void`には値がない。したがって、すべての型`a`に対して、型`(a, Void)`は値を持たず、`Void`と等価だ。言い換えれば、$a \times 0= 0 $だ。

加算と乗算をつなぐもう1つのものは分配律だ:

```haskell
a * (b + c) = a * b + a * c
```

これは直積型と直和型にも当てはまるだろうか？
当てはまる――いつものように同型を除いて。左側は次の型に相当する:

```haskell
(a, Either b c)
```

また、右側は次の型に相当する:

```haskell
Either (a, b) (a, c)
```

これらをある方向に変換する関数は次のとおりだ:

```haskell
prodToSum :: (a, Either b c) -> Either (a, b) (a, c)
prodToSum (x, e) =
    case e of
      Left  y -> Left  (x, y)
      Right z -> Right (x, z)
```

また、その逆方向だと次のとおりだ:

```haskell
sumToProd :: Either (a, b) (a, c) -> (a, Either b c)
sumToProd e =
    case e of
      Left  (x, y) -> (x, Left  y)
      Right (x, z) -> (x, Right z)
```

`case of`ステートメントは、パターンマッチング内部関数に使われる。各パターンの後には矢印と、パターンが一致したときに評価される式が続く。たとえば、次の値を指定して`prodToSum`を呼び出すとする。

```haskell
prod1 :: (Int, Either String Float)
prod1 = (2, Left "Hi!")
```

`case e of`内の`e`は`Left "Hi!"`と等しくなる。これはパターン`Left y`と一致し、`y`を`"Hi!"`に置き換える。`x`はすでに`2`と一致しているので、`case of`句の結果と関数全体は、期待どおり`Left (2, "Hi!")`となる。

この2つの関数が互いに逆であることの証明は省くが、考えてみれば逆であるはずだ！
これらは、2つのデータ構造の内容を単純に再パックしているだけだ。同じデータで、フォーマットが異なるだけだ。

数学者たちは、このような絡み合った2つのモノイドに[半環]{.keyword #semiring} (semiring) という名前をつけている。これは完全な[環]{.keyword #ring} (ring) ではない。型の減算を定義できないからだ。そのため、半環は「*n* (negative) がない環 (ring)」をかけて[リグ]{.keyword #rig} (rig) と呼ばれることがある。しかし、そうでなければ、たとえば、リグを形成する自然数に関する命題を型に関する命題に変換することで、多くのメリットを得られる。いくつかの興味深い項目を含む変換表をここに示す。

Numbers      Types
---------- ----------------------------------
0          `Void`
1          `()`
a + b      `Either a b = Left a | Right b`
a * b      `(a, b)` or `Pair a b = Pair a b`
2 = 1 + 1  `data Bool = True | False`
1 + a      `data Maybe = Nothing | Just a`

リスト型は、方程式の解として定義されているので、非常に興味深い。定義している型は、式の両側に現れる。

```haskell
List a = Nil | Cons a (List a)
```

通常の代入を行い、`List a`を`x`に置き換えると、次の式が得られる。

```haskell
x = 1 + a * x
```

型の差や除算はできないので、従来の代数的方法でこれを解くことはできない。しかし、右側の`x`を`(1 + a*x)`に置き換え続け、分配律を使うという一連の置換を試せる。これにより、次の一連の結果が得られる。

```haskell
x = 1 + a*x
x = 1 + a*(1 + a*x) = 1 + a + a*a*x
x = 1 + a + a*a*(1 + a*x) = 1 + a + a*a + a*a*a*x
...
x = 1 + a + a*a + a*a*a + a*a*a*a...
```

最終的には無限の直積の直和 (タプル) になる。これは次のように解釈できる。リストは空集合`1`か、単集合`a`か、ペア`a*a`か、トリプル`a*a*a`か、などなど……。まさにそれがリストだ。一連の`a`だ！


リストにはそれ以上の内容があり、関手や不動点について学んだ後で、リストやその他の再帰的なデータ構造について再び説明する。

記号変数を使って方程式を解く――すなわち代数だ！
それゆえ、これらの型は代数的データ型と呼ばれる。

最後に、型の代数の非常に重要な解釈について述べなければならない。`a`と`b`の2つの型の直積には、型`a` *と*型`b`の両方の値が含まれている必要があることに注意してほしい。これは、両方の型に居住している必要があることを意味する。一方、2つの型の直和には、型`a` *または*型`b`のいずれかの値が含まれるので、どちらかに住んでいれば十分だ。また、*論理積*と*論理和*も半環を形成し、型理論に写せる。

論理型
------- --------------------------------
false   `Void`
true    `()`
a || b  `Either a b = Left a | Right b`
a && b  `(a, b)`

この比喩はさらに深く、論理と型理論を結ぶカリー・ハワード同型の基礎となっている。この点については、関数型について説明するときに再び取り上げる。

## 課題

1. `Maybe a`と`Either () a`の間の同型を表示せよ。
2. 円と長方形の直和型をHaskellで定義する。

   ```haskell
   data Shape = Circle Float
                  | Rect Float Float
   ```

   `Shape`に作用し面積を求める`area`のような関数を定義したい場合は、次の2つのコンストラクタでパターンマッチングを使う。

   ```haskell
   area :: Shape -> Float
       area (Circle r) = pi * r * r
       area (Rect d h) = d * h
   ```

   C++またはJavaでインタフェースとして`Shape`を実装し、`Circle`と`Rect`という2つのクラスを作成せよ。`area`は仮想関数として実装せよ。

3. 先ほどの例を続ける。`Shape`の周の長さを求める新しい関数`circ`は簡単に追加できる。`Shape`の定義に触れる必要はない。

```haskell
circ :: Shape -> Float
    circ (Circle r) = 2.0 * pi * r
    circ (Rect d h) = 2.0 * (d + h)
```

C++またはJavaの実装に`circ`を追加せよ。もとのコードのどの部分に触れる必要があったか？


4. さらに続ける。新しい図形として正方形`Square`を`Shape`に追加し、必要なすべてを更新する。HaskellならびにC++およびJavaでは、コードのどこに触れる必要があったか？
   (たとえHaskellプログラマーでなくても、変更は極めて自明なはずだ。）


5. 型に対して$a + a = 2 \times a$が (同型を除いて) 保持されることを示せ。前述の変換表によれば、$2$は`Bool`に対応している。
