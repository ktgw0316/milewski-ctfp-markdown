# シンプルな代数的データ型 {#simple-algebraic-data-types}

型を組み合わせる2つの基本的な方法として、積と余積を使う方法を見たところだ。日常のプログラミングにおける多くのデータ構造は、実はこの2つのメカニズムだけを使って構築できる。この事実は重要かつ有用な帰結をもたらす。データ構造の性質の多くは合成可能だということだ。たとえば、基本型の値が等しいかどうか比較する方法を知っていて、それらの比較を積と余積に相当する型に一般化する方法を知っていれば、自動的に複合型の等値演算子を導出できる。Haskellでは、等しさの検査、大小比較、文字列への変換、文字列からの変換などを、複合型の大きな部分集合に対して自動的に導出できる。

次に、直積型 (product type)^[訳注：直積 (direct product) は、具体圏（concrete category、集合に何らかの構造を追加したものの圏）においては積と同じ。プログラミングの文脈においては一般的にproductは直積と訳される。] と直和型 (sum type) がプログラミングに現れる様子を詳しく見てみよう。

## 直積型

2つの型の直積（直積型）のプログラム言語における標準的な実装はペアだ。Haskellではペアはプリミティブな型構成子 (type constructor) だ。C++では比較的複雑なテンプレートとして標準ライブラリーで定義されている。

`\begin{figure}[H] \centering`{=latex}
![](images/pair.jpg){width=35%}
`\end{figure}`{=latex}

\noindent
ペアは厳密には可換ではない。`(Int, Bool)`型のペアは、同じ情報を保持していても、ペア`(Bool, Int)`型のペアには置き換えられない。しかし、それらは同型を除いて可換だ。同型写像は`swap`関数（それ自身の逆関数）によって与えられる：

```haskell
swap :: (a, b) -> (b, a)
swap (x, y) = (y, x)
```

\noindent
これら2つのペア型は、単に同じデータを格納するために異なるフォーマットを使っていると見なせる。ビッグエンディアンとリトルエンディアンのようなものだ。

ペアの中にペアをネストすれば任意の個数の型の直積を作れるが、もっと簡単な方法がある。ネストされたペアは組 (tuple) と等価なのだ。これは、ペアをネストする様々な方法が同型であるという事実からの帰結だ。3つの型`a`、`b`、`c`を順に積にする場合、次の2つの方法がある：

```haskell
((a, b), c)
```

\noindent
あるいは

```haskell
(a, (b, c))
```

\noindent
これらは型が異なる。つまり、一方の型の引数を期待する関数に他方の型の値を渡すことはできない。しかし、これらの要素は1対1で対応している。そのため、一方を他方に写す関数が存在し：

```haskell
alpha :: ((a, b), c) -> (a, (b, c))
alpha ((x, y), z) = (x, (y, z))
```

\noindent
そして、その関数は逆関数を持つ：

```haskell
alpha_inv :: (a, (b, c)) -> ((a, b), c)
alpha_inv  (x, (y, z)) = ((x, y), z)
```

\noindent
したがって、この関数は同型写像だ。データは同じで再パッケージ化するための方法が違うにすぎない。

直積型の生成は、型上の二項演算として解釈できる。この観点から見ると、上記の同型は、モノイドで見た結合律 (associativity law) に非常によく似ている：
$$(a * b) * c = a * (b * c)$$
ただし、モノイドの場合は積を合成する2つの方法が等しかったのに対して、ここでは「同型を除いて」等価であるにすぎない。

同型を認めて、厳密な等しさに固執しないならば、さらに進んで、1が乗算の単位元であるのと同じようにunit型`()`が積の単位元であるのを示せる。実際、ある型`a`の値とunit型の値を組み合わせても何の情報も追加されない。型：

```haskell
(a, ())
```

\noindent
は`a`と同型だ。対応する同型写像はこのようになる：

```haskell
rho :: (a, ()) -> a
rho (x, ()) = x
```

```haskell
rho_inv :: a -> (a, ())
rho_inv x = (x, ())
```

\noindent
これらの観察は、$\Set$（集合の圏）は[*モノイダル圏*]{.keyword #monoidal_category}\index{モノイダル圏} (monoidal category) である、と述べることによって形式化できる。それは、対象を（ここではデカルト積で）乗算できるという意味で、モノイドでもある圏だ。モノイダル圏についてさらに説明しよう。完全な定義は将来的に示す。

Haskellには直積型を定義するもっと一般的な方法がある。特に、すぐ後で説明するとおり、直和型と組み合わされたときにはっきりする。その方法は複数の引数を持つ名前付き構成子を使うというものだ。たとえば、ペアは次のようにも定義できる：

```haskell
data Pair a b = P a b
```

\noindent
ここで、`Pair a b`は他の2つの型`a`と`b`によってパラメーター化された型の名前であり、`P`はデータ構成子の名前だ。ペア型を定義するには型構成子`Pair`に2つの型を渡す。適切な型の2つの値を構成子`P`に渡すことで、ペア値を構成する。たとえば、値`stmt`を`String`と`Bool`のペアとして定義したとする：

```haskell
stmt :: Pair String Bool
stmt = P "This statements is" False
```

\noindent
1行目は型シグネチャーだ^[訳注：原文はtype declarationとあるが、type signatureの誤りであろう。]。そこでは、型構成子`Pair`が、その`Pair`の総称定義の`a`と`b`をそれぞれ`String`と`Bool`で置き換えた形で使われている。2行目では、具体的な文字列と具体的なブール値をデータ構成子`P`に渡すことで、実際の値を定義している。型構成子は型を構成するために使われ、データ構成子は値を構成するために使われる。

Haskellでは型構成子とデータ構成子の名前空間が分離されているため、次のように両方に同じ名前が使われていることがよくある：

```haskell
data Pair a b = Pair a b
```

\noindent
さらに目を細めれば、組み込みのペア型をこの種の宣言のバリエーションとして見ることもできる。組み込みのペア型においては、`Pair`という名前が`(,)`という二項演算子で置き換わっている。実際、`(,)`を他の名前付き構成子と同じように扱い、前置記法を使ってペアを作成できる：

```haskell
stmt = (,) "This statement is" False
```

\noindent
同様に、`(,,)`を使って3つ組を作成する、などもできる。

総称ペアや組を使う代わりに、次のように特定の名前を付けた直積型を定義してもよい：

```haskell
data Stmt = Stmt String Bool
```

\noindent
これは単に`String`と`Bool`の積だが、独自の名前と構成子が与えられている。このスタイルの宣言の利点は、内容は同じでも意味と機能が異なる互いに置き換えられない型を多数定義できることだ。

組や複数の引数を持つ構成子を使ってプログラミングすると、ぐちゃぐちゃになり間違いが生じやすくなる。どの成分が何を表しているかを追うのが大変になるからだ。成分に名前を付ける方が望ましい場合はよくある。名前付きフィールドを持つ直積型は、Haskellでは[*record*]{.keyword #record}\index{record}^[訳注：厳密に言えばHaskellに存在するレコード記法（構成子の引数に名前を付ける機能）であり、型そのものは通常のデータ型と相違ない。]、Cでは`struct`と呼ばれる。

## レコード

簡単な例を見てみよう。化学元素を記述するために、2つの文字列（名前と元素記号）と整数（原子番号）を組み合わせて1つのデータ構造にしたい。組`(String, String, Int)`を使い、どの成分が何を表しているかを覚えておくという方法がある。そして、成分はパターンマッチングによって、以下の関数のように抽出することにしよう。この関数は元素記号が元素名の接頭辞かを（**He**は**Helium**の接頭辞だというように）チェックする：

```haskell
startsWithSymbol :: (String, String, Int) -> Bool
startsWithSymbol (name, symbol, _) = isPrefixOf symbol name
```

\noindent
このコードは間違いが生じやすく、読むのもメンテナンスするのも困難だ。レコードを定義する方がはるかに良い。

```haskell
data Element = Element { name         :: String
                       , symbol       :: String
                       , atomicNumber :: Int }
```

\noindent
これら2つの表現は同型だ。そのことは、互いに逆になっている2つの変換関数から分かる。

```haskell
tupleToElem :: (String, String, Int) -> Element
tupleToElem (n, s, a) = Element { name = n
                                , symbol = s
                                , atomicNumber = a }
```

```haskell
elemToTuple :: Element -> (String, String, Int)
elemToTuple e = (name e, symbol e, atomicNumber e)
```

\noindent
レコードのフィールド名は、それらのフィールドにアクセスするための関数としても機能することに注意してほしい。たとえば、`atomicNumber`は`e`から`atomicNumber`フィールドを取得する。つまり、`atomicNumber`は次のような型の関数として使われる：

```haskell
atomicNumber :: Element -> Int
```

\noindent
 `Element`についてのレコード構文によって、関数`startsWithSymbol`はより読みやすくなる：

```haskell
startsWithSymbol :: Element -> Bool
startsWithSymbol e = isPrefixOf (symbol e) (name e)
```

\noindent
関数`isPrefixOf`をバッククォーテーションで囲んで中置演算子に変換するというHaskellの小技を使えば、まるで英文のように読めるようにさえできる：

```haskell
startsWithSymbol e = symbol e `isPrefixOf` name e
```

\noindent
中置演算子は関数呼び出しよりも優先順位が低いため、この場合は括弧を省略できる。

## 直和型

集合の圏の積が直積型のもととなるのと同じように、余積は直和型のもととなる。Haskellにおける直和型の標準的な実装は次のようなものだ：

```haskell
data Either a b = Left a | Right b
```

\noindent
また、ペアと同様に、`Either`は（同型を除いて）可換であり、ネストでき、ネストの順序は（同型を除いて）無関係だ。したがって、たとえば、3つ組に相当する和：

```haskell
data OneOfThree a b c = Sinistral a | Medial b | Dextral c
```

\noindent
などを定義できる。

$\Set$は余積に関する（対称）モノイダル圏でもあることが分かる。二項演算の役割を演じるのは非交和であり、単位元の役割を演じるのは始対象だ。型に関しては、モノイダル演算子として`Either`があり、その中立元として住人^[訳注：大雑把には、その型を持つ式のこと。]がいない型 (uninhabited type) である`Void`がある。 `Either`は加算、`Void`は0と見なせる。実際、直和型に`Void`を足しても内容は変わらない。例として：

```haskell
Either a Void
```

\noindent
は`a`と同型だ。これは、この型の`Right`版を構成する方法がないためだ。型`Void`に値は存在しない。 `Either a Void`の唯一の要素は、`Left`構成子を使って構築されたものであり、単純に型`a`の値をカプセル化したものだ。したがって、記号的に表すと、$a + 0 = a$となる。

直和型がHaskellではごく普通に使われるのに対し、C++で同等のものである共用体やvariantはあまり使われない。その理由はいくつかある。

まず、最も単純な直和型は単なる列挙であり、C++では`enum`を使って実装できる。Haskellの直和型：

```haskell
data Color = Red | Green | Blue
```

\noindent
にC++で相当するものは：

```cpp
enum { Red, Green, Blue };
```

\noindent
だ。もっとシンプルな直和型：

```haskell
data Bool = True | False
```

\noindent
は、C++ではプリミティブ`bool`だ。

値の有無を表す単純な直和型は、C++では、特殊なトリックや「不可能な」値（空文字列・負の数・ヌルポインターなど）を使ってさまざまに実装される。この種のオプション性は、意図的な場合、Haskellでは`Maybe`型を使って表現される：

```haskell
data Maybe a = Nothing | Just a
```

\noindent
 `Maybe`型は2つの型の直和だ。このことは構成子の2つの部分を個々の型に分けると分かる。1つ目は次のようになる：

```haskell
data NothingType = Nothing
```

\noindent
これは`Nothing`という名前の1つの値を持つ列挙だ。言い換えると、これは単元集合であり、unit型`()`と等価だ。2つ目の部分：

```haskell
data JustType a = Just a
```

\noindent
は、型`a`を単にカプセル化したものだ。`Maybe`を次のように書いてもよかっただろう：

```haskell
type Maybe a = Either () a
```

\noindent
より複雑な直和型は、C++ではポインターを使って模擬することが多い。ポインターはヌルとなるか、あるいは特定の型の値を指し示す。たとえば、Haskellで（再帰的な）直和型として定義できるリスト型：

```haskell
List a = Nil | Cons a (List a)
```

\noindent
をC++に変換するには、ヌルポインターのトリックを使って空のリストを実装する：

```cpp
template<class A>
class List {
    Node<A> * _head;
public:
    List() : _head(nullptr) {}  // Nil
    List(A a, List<A> l)        // Cons
      : _head(new Node<A>(a, l))
    {}
};
```

\noindent
Haskellでの2つの構成子`Nil`と`Cons`が、よく似た引数（`Nil`は空、`Cons`は値1つとリスト1つ）でオーバーロードされた2つの`List`構成子へと変換されたことに注目してほしい。この`List`クラスには、直和型の2つの成分を区別するためのタグは必要ない。その代わり、`_head`に特別な`nullptr`値を使って`Nil`を表現する。

だが、HaskellとC++の型の主な違いは、Haskellではデータ構造が不変であることだ。ある特定の構成子を使ってオブジェクトを作成する場合、オブジェクトはどの構成子が使われ、どの引数が渡されたかを永久に記憶する。したがって、`Just "energy"`として作成された`Maybe`オブジェクトが`Nothing`に変わることはない。同様に、空のリストは永久に空であり、3つの要素のリストは常に同じ3つの要素を持つことになる。

この不変性こそが構成を可逆的にする。オブジェクトがあれば、いつでも構成で使われた部品に分解できる。この分解はパターンマッチングで行われ、構成子をパターンとして再利用する。構成子の引数がある場合は、変数（またはその他のパターン）に置き換えられる。

`List`データ型には2つの構成子があるため、どんな`List`を分解するときもそれらの構成子に対応する2つのパターンを使う。1つは空である`Nil`リストにマッチし、もう1つは`Cons`で構成されたリストにマッチする。たとえば、複数の`List`に対する単純な関数の定義は次のとおりだ。

```haskell
maybeTail :: List a -> Maybe (List a)
maybeTail Nil = Nothing
maybeTail (Cons _ t) = Just t
```

\noindent
`maybeTail`の定義の1番目の部分は、`Nil`構成子をパターンとして使い、`Nothing`を返す。2番目の部分では、`Cons`構成子をパターンとして使っている。構成子の1番目の引数には興味がないため、ワイルドカードに置き換わっている。`Cons`の2番目の引数は、変数`t`に束縛される（厳密に言えば一度式に束縛されたら決して変化しないものの、変数と呼ぶことにする）。戻り値は`Just t`だ。こうして、`List`の作成方法に応じて、節の1つに一致するようになった^[訳注：ここでの節 (clause) とは定義の一部で大雑把には`…… = ……`の形のもののこと。]。作成に`Cons`が使われるときは、作成時に渡した2つの引数が取得される（1番目の引数は破棄される）。

さらに複雑な直和型は、C++では多相クラス階層を使って実装されている。共通の祖先を持つクラスたちは、1つのバリアント型として理解でき、その中では仮想関数テーブルが隠しタグとして機能する。Haskellでは構成子に対するパターンマッチングおよびパターンごとに特化したコードで行っていることを、C++では仮想関数テーブルのポインターに基づいて仮想関数呼び出しをディスパッチすることで実現している。

C++で共用体が直和型として使われることはめったにない。含められるものに厳しい制限があるからだ。`std::string`でさえ、コピーコンストラクターを持っているので、共用体に入れられない。

## 型の代数

直積型と直和型を別々に用いても有用なデータ構造をいろいろ定義できるが、真の強みはこの2つを組み合わせることで得られる。合成の力が再び発揮される時がきた。

これまでに分かったことをまとめておこう。型システムの下にある2つの可換モノイド構造を見た。中立元として`Void`を持つ直和型と、中立元として`()`というunit型を持つ直積型だ。それらを加法や乗法から類推したい。この類推では、`Void`は0に対応し、`()`は1に対応する。

この類推をどこまで拡張できるか見てみよう。例として、0を掛けると0になるだろうか？　言い換えれば、1つの成分が`Void`である直積型は、`Void`と同型だろうか？　たとえば、`Int`と`Void`のペアを作成できるだろうか？

ペアを作成するには2つの値が必要だ。整数なら簡単だが、型`Void`には値がない。したがって、型`(a, Void)`は、すべての型`a`について住人がいない――値を持たない――ので`Void`と等価になる。言い換えれば、$a \times 0 = 0$ということだ。

また別の、加算と乗算をつなぐものとして、分配則 (distributive property) がある：

```haskell
a * (b + c) = a * b + a * c
```

\noindent
これは直積型と直和型にも当てはまるだろうか？　そう、当てはまる――いつものように同型を除いて。左辺は次の型に相当する：

```haskell
(a, Either b c)
```

\noindent
また、右辺は次の型に相当する：

```haskell
Either (a, b) (a, c)
```

\noindent
これらをある向きで変換する関数は次のとおりだ：

```haskell
prodToSum :: (a, Either b c) -> Either (a, b) (a, c)
prodToSum (x, e) =
    case e of
      Left  y -> Left  (x, y)
      Right z -> Right (x, z)
```

\noindent
また、その逆向きの変換は次のとおりだ：

```haskell
sumToProd :: Either (a, b) (a, c) -> (a, Either b c)
sumToProd e =
    case e of
      Left  (x, y) -> (x, Left  y)
      Right (x, z) -> (x, Right z)
```

\noindent
`case of`式は、関数の内部でパターンマッチングを行うために使われる。各パターンの後には矢印と、パターンが一致したときに評価される式が続く。たとえば、次の値を引数として`prodToSum`を呼び出すとする。

```haskell
prod1 :: (Int, Either String Float)
prod1 = (2, Left "Hi!")
```

\noindent
`case e of`内の`e`は`Left "Hi!"`と等しくなる。これはパターン`Left y`とマッチし、`y`に`"Hi!"`を代入する。`x`はすでに`2`とマッチしているので、`case of`式の結果と関数全体は、期待どおり`Left (2, "Hi!")`となる。

この2つの関数が互いの逆関数であることの証明は省くが、よく考えれば分かるだろう。これらは2つのデータ構造の内容を単に再パックしている。データは同じで、フォーマットが異なるだけだ。

数学者たちは、このような絡み合った2つのモノイドに[*半環*]{.keyword #semiring}\index{半環} (semiring) という名前をつけている。これは完全な[*環*]{.keyword #ring}\index{環} (ring) ではない。型の減算は定義できないからだ。そのため、半環は「*n* (negative) がない環 (ring)」をかけて[*リグ*]{.keyword #rig}\index{リグ} (rig) と呼ばれることがある。しかし、そのことを除けば、リグをなす自然数などに関する命題を型に関する命題に変換することによる多くのメリットが得られる。興味深い項目を含む変換表を以下に示す：

| 数値          | 型                                      |
|:-------------|:----------------------------------------|
| $0$          | `Void`                                  |
| $1$          | `()`                                    |
| $a + b$      | `data Either a b = Left a | Right b`    |
| $a \times b$ | `(a, b)`または`data Pair a b = Pair a b` |
| $2 = 1 + 1$  | `data Bool = True | False`              |
| $1 + a$      | `data Maybe a = Nothing | Just a`       |

リスト型は、非常に興味深いことに、方程式の解として定義される。定義しようとしている型は等式の両辺に現れる：

```haskell
data List a = Nil | Cons a (List a)
```

\noindent
いつもの置換を行い、さらに`List a`を`x`に置き換えると、次の式が得られる：

```haskell
x = 1 + a * x
```

\noindent
型の減算や除算はできないので、これは従来の代数的方法では解けない。しかし、置換の連続なら試せる。つまり、ひたすら右辺の`x`を`(1 + a*x)`に置き換えては分配則を使う。これによって次の列が得られる：

```haskell
x = 1 + a*x
x = 1 + a*(1 + a*x) = 1 + a + a*a*x
x = 1 + a + a*a*(1 + a*x) = 1 + a + a*a + a*a*a*x
...
x = 1 + a + a*a + a*a*a + a*a*a*a...
```

\noindent
最終的には積（組）の和が無限に続くことになった。これは次のように解釈できる。リストは空集合`1`か、単元集合`a`か、ペア`a*a`か、3つ組`a*a*a`か、などなど……。まさにそれがリストだ。つまり、`a`の列だ！

リストについては語るべきことがまだまだある。関手や不動点について学んだ後で、リストやその他の再帰的なデータ構造について再び説明する。

記号変数を使って方程式を解く――これぞ代数だ！　それゆえ、これらの型は代数的データ型と呼ばれる。

最後に、型の代数の非常に重要な解釈について述べなければならない。`a`と`b`の2つの型の直積には、型`a`*および*型`b`の両方の値が含まれている必要があることに注意してほしい。これは、［訳注：2つの型の直積が居住されているためには］両方の型が居住されている (inhabited) 必要があることを意味する^[訳注：居住とは、ここでは（非停止性を含む副作用のない世界を考えているので）値を持つことを意味する。]。一方、2つの型の直和には、型`a` *または*型`b`のいずれかの値が含まれるので、［訳注：2つの型の直和が居住されているためには］どちらかが居住されていれば十分だ。*論理積* (logical and) と*論理和* (logical or) も半環を形成し、型理論の言葉に写せる：

| 論理          | 型                                   |
|:-------------|:-------------------------------------|
| $false$      | `Void`                               |
| $true$       | `()`                                 |
| $a\,||\,b$   | `data Either a b = Left a | Right b` |
| $a\,\&\&\,b$ | `(a, b)`                             |

この類推はさらに深く、論理と型理論を結ぶカリー・ハワード同型の基礎となっている。それについては関数型について説明するときに再び取り上げる。

## 課題

#. `Maybe a`と`Either () a`の間の同型を示せ。

#. 円と長方形の直和型をHaskellで定義する。

   ```haskell
   data Shape = Circle Float
              | Rect Float Float
   ```

   \noindent
   面積を求めるための関数`area`のような`Shape`に作用する関数を定義したい場合は、これら2つの構成子に関するパターンマッチングにより行う：

   ```haskell
   area :: Shape -> Float
   area (Circle r) = pi * r * r
   area (Rect d h) = d * h
   ```

   \noindent
   C++またはJavaで`Shape`をインタフェースとして実装し、`Circle`と`Rect`という2つのクラスを作成せよ。`area`は仮想関数として実装せよ。

#. 先ほどの例を続ける。`Shape`の周の長さを求める新しい関数`circ`は簡単に追加できる。`Shape`の定義に触れる必要はない。

   ```haskell
   circ :: Shape -> Float
   circ (Circle r) = 2.0 * pi * r
   circ (Rect d h) = 2.0 * (d + h)
   ```

   \noindent
   C++またはJavaの実装に`circ`を追加せよ。もとのコードのどの部分に触れる必要があったか？

#. さらに続ける。新しい図形として正方形`Square`を`Shape`に追加し、必要なすべてを更新する。HaskellならびにC++およびJavaでは、コードのどこに触れる必要があったか^[監訳注：興味のある読者はさらに "expression problem" について調べてみるとよい。]？（Haskellプログラマーでないとしても、変更箇所はごく自明なはずだ。）

#. 型について$a + a = 2 \times a$が（同型を除いて）成り立つことを示せ。前掲の変換表によれば、$2$は`Bool`に対応する。
