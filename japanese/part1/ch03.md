# 圏のさまざま

さまざまな例を調べれば圏の真価が理解できる。圏にはさまざまな形やサイズがあり、予期しない場所によく現れる。ごくシンプルなものから始めよう。

## 対象がない場合

最も自明な圏は、対象が0個で、したがって射が0本のものだ。それ自体は非常に哀しい圏だが、他の圏との関連、たとえば、すべての圏の圏（そう、そういうものが存在する）において重要になるだろう。空集合に意味があると思うなら、空圏 (empty category) が無意味だとは思わないだろう？

## 有向グラフ

対象を射で接続するだけで圏を作成できる。任意の有向グラフから始めて、単に射を追加するだけで圏になるのは想像できるだろう。最初に、各ノードに恒等射を追加する。次に、一方の終点が他方の始点と一致するような2つの射（つまり、2つの[*合成可能な*]{.keyword #composable}\index{合成可能な}射）に対して、それらの合成として機能する新しい射を追加する。新しい射を追加するたびに、（恒等射を除く）他の射との合成も考慮する必要がある。たいていは射が無限に多くなるが、問題ない。

このプロセスを別の方法で見ると、グラフ内の各ノードを対象とし、合成可能なグラフの辺からなるすべての[*チェイン*]{.keyword #chain}\index{チェイン}^[訳注：グラフ理論で歩道 (walk) と呼ばれるもの。]を射とする圏を作成していることになる。（恒等射はチェインの長さが0の特殊な場合とも見なせる。）

このような圏は、与えられたグラフによって生成される[*自由圏*]{.keyword #free_category}\index{自由圏} (free category) と呼ばれる。これは自由構成 (free construction) の例であり、任意の構造を、その規則（ここでは圏の規則）を満たせる最少の項目で拡張して完成させるプロセスだ。今後さらに多くの例について見ていく。

## 順序

さて、全く別のものを見てみよう！　射が対象間の関係、具体的には小なりイコール（$\leqslant$）であるような圏だ。これが本当に圏かどうか調べてみよう。恒等射はあるだろうか？　すべての対象はそれ自身以下だろうか？　良し！　合成はあるだろうか？　$a \leqslant b$かつ$b \leqslant c$ならば$a \leqslant c$である。良し！　合成は結合的か？　良し！　このような関係は[*前順序*]{.keyword #preorder}\index{前順序} (preorder) と呼ばれる。前順序は確かに圏だ。

$a \leqslant b$かつ$b \leqslant a$ならば$a$は$b$と等しくなければならないという追加の条件も満たす、より強い関係も考えられる。これを[*半順序*]{.keyword #partial_order}\index{半順序} (partial order) と呼ぶ。

最後に、任意の2つの対象が$\leqslant$またはその逆で関係しているという条件も課せる。そうすると、[*線形順序*]{.keyword #linear_order}\index{線形順序} (linear order) または[*全順序*]{.keyword #total_order}\index{全順序} (total order) と呼ばれる関係が得られる。

これらの関係を満たす順序集合を圏として特徴づけよう。前順序は、任意の対象$a$から任意の対象$b$に向かう射が高々1つ存在する圏となる。そのような圏は別名「細い圏」(thin category) と呼ばれる。前順序圏は細い圏だ。

圏$\cat{C}$における対象$a$から対象$b$への射の集合は[*hom集合*]{.keyword #hom-set}\index{hom集合}と呼ばれ^[訳注：後述のように、本書ではこれが一般には集合にならないということは敢えて無視している。]、$\cat{C}(a, b)$ と書かれる（$\mathbf{Hom}_{\cat{C}}(a, b)$ とも書かれる）。したがって、前順序のhom集合はどれも空集合か単元集合になる。これはhom集合$\cat{C}(a, a)$、つまり$a$から$a$への射の集合にも当てはまる。その場合はどの前順序においても必ず単元集合になり、恒等射だけを含む。ただし、前順序では循環が起こりうる。半順序では循環は禁止されている。

整列（ソーティング）においては前順序・半順序・全順序を区別できることが非常に重要だ。クイックソート・バブルソート・マージソートなどの整列アルゴリズムは全順序に対してのみ正しく機能する。半順序にはトポロジカルソートが使える。

## 集合としてのモノイド

モノイドは非常にシンプルにもかかわらず驚くほど強力な概念だ。それは基礎的な計算の背景にある概念であり、加算と乗算は両方ともモノイドをなす。モノイドはプログラミングの世界では至るところにある。それは、文字列、リスト、foldできるデータ構造、並行プログラミングのfuture、関数型リアクティブプログラミングのイベントなどとして現れる。

伝統的に、モノイドは二項演算を持つ集合として定義される。この演算に要求されるのは、結合律を満たすことと、単位元のように振る舞う特別な要素が1つあることだけだ。

たとえば、0を含む自然数は加算についてモノイドをなす。結合律は次のことを意味する。
$$(a + b) + c = a + (b + c)$$
（言い換えると、数を加算するときは括弧を無視できる。）

中立元^[訳注：単位元に同じ。]は0だ。なぜなら
$$0 + a = a$$
かつ
$$a + 0 = a$$
だからだ。2つ目の等式は冗長だ。加算は可換 $(a + b = b + a)$ だからだ。ただし、可換律はモノイドの定義の一部ではない。たとえば、文字列連接は可換ではないが、モノイドをなす。ちなみに、文字列連接の中立元は空文字列であり、文字列を変更せずに文字列の両側に付加できる。

Haskellではモノイドに対して型クラスを定義できる。その型クラスに属する型は、`mempty`と呼ばれる中立元と`mappend`と呼ばれる二項演算を持つ^[訳注：現在のHaskellでは`Monoid`は`Semigroup`の派生クラス。`Semigroup`では`(<>) :: a -> a -> a`が定義されており、`Monoid`で`mappend = (<>)`以外の定義をすると警告が表示される。`mapppend`は将来廃止される予定。]。

```haskell
class Monoid m where
    mempty  :: m
    mappend :: m -> m -> m
```

\noindent
この2引数関数の型シグネチャーでの`m -> m -> m`という型は、最初は奇妙に見えるかもしれないが、カリー化を知った後には完全に理にかなったものだと思えるようになるだろう。複数の矢印を含むシグネチャーには、2つの基本的な解釈がある。複数の引数を取る関数とみなして右端の型を戻り値の型とする解釈と、1引数（左端の引数）の関数とみなして関数を返すという解釈だ。後者の解釈は、`m -> (m -> m)`のように括弧（矢印が右結合であるため冗長）を追加することによって強調できる。この解釈については後で説明する。

Haskellでは、`mempty`と`mappend`のモノイド性（monoidal
properties、すなわち、`mempty`は中立で、`mappend`は結合律を満たすという事実）を表現する方法がないことに注意してほしい。それらを満たすことを確認するのはプログラマーの責任だ。

HaskellのクラスはC++のクラスほど押し付けがましくはない。新しい型を定義するときに事前にクラスを指定する必要はない。先延ばしして、与えられた型を後からあるクラスのインスタンスであると宣言してよい。例として、`mempty`と`mappend`の実装を提供することで`String`をモノイドとして宣言しよう（実際には、これは標準のPreludeですでにやってくれている）。

```haskell
instance Monoid String where
    mempty = ""
    mappend = (++)
```

\noindent
ここで、`String`の値は単に文字のリストなので、リスト連接演算子`(++)`を再利用した。

Haskellの構文に関する注：中置演算子は括弧で囲うことで2つの引数を取る関数に変換できる。与えられた2つの文字列を連接するには、それらの間に`++`を挟んでもよい。

```haskell
"Hello " ++ "world!"
```

\noindent
あるいは、括弧付きの`(++)`に2つの文字列を引数として渡してもよい。

```haskell
(++) "Hello " "world!"
```

\noindent
関数の引数がコンマで区切られたり括弧で囲まれたりしていないことに注意してほしい。（これはおそらく、Haskellを学ぶときに慣れるのが一番難しい部分だろう。）

Haskellでは関数の等しさを次のように表現できることは、強調しておく価値がある。

```haskell
mappend = (++)
```

\noindent
概念的には、これは関数によって生成される値の等しさを次のように表現するのとは異なる。

```haskell
mappend s1 s2 = (++) s1 s2
```

\noindent
前者は、$\Hask$圏（または、終わりのない計算を指すボトムを無視するなら、$\Set$）の射の等しさに変換される。このような等式はより簡潔であるだけでなく、しばしば他の圏にも一般化できる。後者は[*外延的*]{.keyword #extensional}\index{外延的}等価性 (extensional equivalence) と呼ばれ、どんな2つの入力文字列に対しても`mappend`と`(++)`の出力は同じであることを述べている。引数の値は[*点*]{.keyword #point}\index{点} (point) と呼ばれることが（「点$x$における$f$の値」という言い回しのように）あるため、これは点ごとの等しさ (point-wise equality) と呼ばれる。引数を指定しない関数の等しさは[*ポイントフリー*]{.keyword #point-free}\index{ポイントフリー} (point-free) と表現される。（ちなみに、ポイントフリーの式は関数合成を含むことが多く、これは点記号`.`で表されるため、初心者は少し混乱するかもしれない。）

C++でモノイドを宣言するのに最も近い方法は、C++20標準のコンセプト機能を使うことだ。

```cpp
template<class T>
struct mempty;

template<class T>
  T mappend(T, T) = delete;

template<class M>
  concept Monoid = requires (M m) {
    { mempty<M>::value() } -> std::same_as<M>;
    { mappend(m, m); } -> std::same_as<M>;
  };
```

\noindent
最初の定義は、各特殊化で中立元を保持するための構造だ。

キーワード`delete`は、デフォルト値が定義されていないことを意味する。これはケースバイケースで指定する必要がある。同様に、`mappend`にもデフォルトはない。

`Monoid`というコンセプトは、与えられた型`M`に対して`mempty`と`mappend`の適切な定義が存在するかをテストする。

このMonoidコンセプトのインスタンス化は、適切な特殊化とオーバーロードを提供することで実現できる。

```cpp
template<>
struct mempty<std::string> {
    static std::string value() { return ""; }
};

template<>
std::string mappend(std::string s1, std::string s2) {
    return s1 + s2;
}
```

## 圏としてのモノイド {#monoid-as-set}

ここまではモノイドの「おなじみの」定義として、集合の要素に基づくものを見た。しかし、ご存知のように、圏論では集合とその要素から逃れようとし、代わりに対象と射について述べる。そこで、少し視点を変えて、二項演算子を適用すると集合の周りで何かを「移動」したり「シフト」したりすると考えてみよう。

たとえば、各自然数に5を加算する演算を考える。これは0を5、1を6 、2を7のように写す。これは関数で、自然数の集合上で定義されている。良い感じだ。関数と集合がある。一般に、任意の数$n$について、$n$を加算する関数が存在する。これは$n$の「加算器」だ。

加算器はどのように合成すればよいだろう？　5を加算する関数と7を加算する関数の合成は、12を加算する関数だ。これにより、加算器の合成を加算ルールと等価にできる。これまた良い感じだ。加算を関数合成に置き換えられる。

ちょっと待った。それだけではない。中立元0の加算器もある。0を加算しても何も写されないので、これは自然数の集合における恒等関数だ。

従来の加算の規則を与える代わりに、情報を失うことなく加算器を構成する規則を与えることもできる。加算器の合成は結合律を満たすことに注目してほしい。これは、関数の合成が結合律を満たし、恒等関数に対応する0加算器があるからだ。

鋭い読者なら、整数から加算器への写像が`mappend`の型シグネチャーを`m -> (m -> m)`と解釈した結果であることに気付いただろう。これは`mappend`がモノイド集合の要素を、その集合に作用する関数に写すことを表している。

さて、自然数の集合を扱っていることを忘れて、たくさんの射――加算器たちをひとかたまりにした、単一の対象だと考えてほしい。モノイドは単一対象の圏だ。実際、monoidという名前は、ギリシャ語で単一を意味する*mono*に由来する。すべてのモノイドは、適切な合成規則に従う射の集合を持つ単一対象の圏として表せる。

`\begin{figure}[H] \centering`{=latex}
![](images/monoid.jpg){width=35%}
`\end{figure}`{=latex}

\noindent
文字列の連接は興味深いケースだ。なぜなら、右連接器（right appender）と左連接器（left appender、あるいはお好みなら前置器prepender）^[訳注：appendは後ろにくっつけることなので、前（左）にappendするのは英語話者には違和感があるのだろう。]を定義する選択肢があるからだ。2つのモデルの合成表は互いに鏡像反転している。「foo」に「bar」を後置するのと「bar」に「foo」を前置するのが同じなのは簡単に納得できるだろう。

圏論的モノイド――単一対象の圏――はどれも二項演算を伴う集合としてのモノイドを一意に定義するのか、という疑問を持つかもしれない。単一対象の圏からは常に集合を抽出できることが分かる。その集合は射――この例では加算器――の集合だ。言い換えれば、圏$\cat{M}$内の単一対象$m$についてhom集合$\cat{M}(m, m)$ が得られるということだ。この集合における二項演算は簡単に定義できる。2つの集合要素のモノイド的な積は、それらに対応する射を合成したものに対応する要素だ。つまり、$\cat{M}(m, m)$ の2つの要素が与えられ、それらに対応する射が$f$と$g$だとすると、それらの積は合成$f \circ g$に対応する要素となる。この合成は常に存在する。なぜなら、射の始点と終点が同じ対象だからだ。また、圏の規則より、結合律も満たす。恒等射はこの積の中立元だ。このように、圏論的モノイドからは常に集合論的モノイドを復元できる。どこからどう見てもそれらは同一だ。

![射あるいは集合内の点として見たモノイドhom集合](images/monoidhomset.jpg "射あるいは集合内の点として見たモノイドhom集合"){width=40%}

\noindent
数学者が補足すべき箇所は、射は必ずしも集合をなさないということだけだ。圏の世界には集合よりも大きなものがある。任意の2つの対象間の射が集合をなす圏は、局所的に小さい、と呼ばれる。約束どおり、私はそのような些細なことはほとんど無視するが、念のため言及すべきだと考えた。

hom集合の要素は、合成律に従う射とも、ある集合内の点とも見なせる。圏論における多くの興味深い現象はこの事実に根ざしている。ここで、$\cat{M}$の射の合成は、集合$\cat{M}(m, m)$ でのモノイド的な積に変換される。

## 課題

1. 以下から自由圏を生成せよ。
   1. 1つのノードを持ち、辺のないグラフ
   1. 1つのノードと1つの（有向）辺を持つグラフ（ヒント：この辺は自身と合成できる）
   1. 2つのノードと、それらの間の（有向）辺を1つ持つグラフ
   1. 1つのノードと、アルファベットa, b, c $\ldots$ zでマークされた26個の（有向）辺を持つグラフ

1. 以下はどんな順序だろうか？
   1. 複数の集合を要素とする集合と、その上の包含関係。なお、$A$が$B$に包含されるとは、$A$の全要素が$B$の要素でもあることを指す。
   1. C++の型の集合とその上の部分型関係。なお、`T1`が`T2`の部分型であるとは、`T2`へのポインターを期待する関数に`T1`をコンパイルエラーを発生させずに渡せることを指す。

1. `Bool`が2つの値`True`と`False`の集合であることを踏まえて、それが2つの演算子`&&` (AND) と`||` (OR) のそれぞれについて（集合論的）モノイドをなすことを示せ。

1. AND演算子を伴う`Bool`モノイドを圏として表せ。射と合成の規則を列挙せよ。

1. モジュロ3加算^[訳注：加算して3で割った余りを取る演算。]をモノイドの圏として表せ。
