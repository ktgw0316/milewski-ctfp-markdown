# 大きい圏から小さい圏まで

様々な例を調べることで、圏の実際の用途を知ることができる。圏にはさまざまな形やサイズがあり、予期しない場所に現れることがよくある。ごくシンプルなものから始めよう。

## 対象の不在

最も簡単な圏は、0個の対象、したがって0個の射を持つものだ。それ自体は非常に哀しい圏だが、他の圏の文脈、たとえば、すべての圏の圏 (そう、1つ存在する) において重要になるだろう。空集合に意味があると思うなら、空の圏が無意味だとは思わないだろう？


## シンプルなグラフ

対象を矢で接続するだけで圏を作成できる。任意の有向グラフから始めて、単に矢を追加するだけで圏になるのは想像できるだろう。最初に、各ノードに恒等射を追加する。次に、一方の終点が他方の始点と一致するような2つの矢 (つまり、2つの[合成可能な]{.keyword #composable}矢) に対して、新しい矢を追加して合成として機能させる。新しい矢を追加するたびに、(恒等射を除く) 他の矢との合成も考慮する必要がある。通常は矢が無限に多くなるが、構わない。

このプロセスを別の方法で見ると、グラフ内のすべてのノードに対する圏と、射として構成可能なグラフエッジのすべての[チェイン]{.keyword #chain}を持つ対象を作成していることになる。(恒等射はチェインの長さが0の特殊な場合とも見なせる。)


このような圏は、与えられたグラフによって生成される[自由圏]{.keyword #free_category} (free category) と呼ばれる。これは自由構成の例であり、与えられた構成を、その規則 (ここでは圏の規則) を満たすために最小限の数の項目で拡張して完成させるプロセスだ。今後さらに多くの例について見ていく。

## 順序

さて、全く別のものを見てみよう！
射が対象間の等号付き大小関係 ($\leqslant$) を表すような圏だ。これが本当に圏かどうか調べてみよう。恒等射はあるだろうか？
すべての対象はそれ自身以下だろうか：良し！
合成はあるだろうか？
$a \leqslant b$かつ$b \leqslant c$ならば$a \leqslant c$：良し！
合成は結合性を持つか？
良し！
このような関係を持つ集合は[前順序]{.keyword #preorder} (preorder) と呼ばれる。前順序は確かに圏だ。

$a \leqslant b$かつ$b \leqslant a$ならば$a$は$b$と等しくなければならないという追加条件を満たす、より強い関係も考えられる。これを[半順序]{.keyword #partial_order} (partial order) と呼ぶ。

最後に、任意の2つの対象が何らかの方法で互いに関係しているという条件も課せる。これにより、[線形順序]{.keyword #linear_order} (linear order) あるいは[全順序]{.keyword #total_order} (total order) が得られる。

これらの順序付けられた集合を圏として特徴づけよう。前順序は、任意の対象$a$から任意の対象$b$に向かう射が最大1つ存在する圏だ。そのような圏は別名「やせた圏」 (thin category) と呼ばれる。前順序はやせた圏だ。

圏$\cat{C}$における対象$a$から対象$b$への射の集合は[hom集合]{.keyword #hom-set}と呼ばれ、$\cat{C}(a, b)$ と書かれる ($\mathbf{Hom}_{\cat{C}}(a, b)$ と書かれることもある)。したがって、前順序のhom集合はどれも空集合か単集合になる。それはhom集合$\cat{C}(a, a)$ を含む。これは、$a$から$a$への射の集合であり、単集合であり、恒等射だけを含み、どの前順序においても存在する。ただし、前順序では循環が起こりうる。半順序では循環は禁止されている。

ソートのためには、前順序・半順序・全順序を区別できることが非常に重要だ。クイックソート・バブルソート・マージソートなどのソートアルゴリズムは全順序に対してのみ正しく機能する。半順序にはトポロジカルソートが使える。

## 集合としてのモノイド

モノイドは非常にシンプルにもかかわらず驚くほど強力な概念だ。それは基礎的な計算の背景にある概念であり、加算と乗算は両方ともモノイドを形成する。モノイドはプログラミングの世界では至るところにある。それは、文字列、リスト、畳み込み可能なデータ構造、並行プログラミングの先物、関数型リアクティブプログラミングのイベントなどとして現れる。

伝統的に、モノイドは二項演算を持つ集合として定義される。この操作に必要なのは、結合性を持つことと、それに関して単位のように動作する特別な要素が1つあることだけだ。

たとえば、0を含む自然数は加算についてモノイドを形成する。結合性は次のことを意味する：

$$(a + b) + c = a + (b + c)$$

(つまり、数を追加するときに括弧をスキップできる。)


中立元は0だ。なぜなら：

$$0 + a = a$$

かつ

$$a + 0 = a$$

だからだ。第2の方程式は冗長だ。なぜなら、加算は可換 $(a+b=b+a)$ だからだ。ただし、可換性はモノイドの定義の一部ではない。たとえば、文字列連結は可換ではないが、モノイドを形成する。ちなみに、文字列連結の中立元は空文字列であり、文字列を変更せずに文字列の両側に付加できる。

Haskellでは、モノイドに対して型クラスを定義できる。その型は`mempty`と呼ばれる中立元と`mappend`と呼ばれる二項演算を持つ。

```haskell
class Monoid m where
    mempty  :: m
    mappend :: m -> m -> m
```

2つの引数を持つ関数`m -> m -> m`の型シグネチャは、最初は奇妙に見えるかもしれないが、カリー化について知った後には完全に理にかなったものに思えるようになるだろう。複数の型を持つシグネチャは、2つの基本的な方法で解釈できる。1つは複数の引数の関数として解釈し、右端の型を戻り値の矢印とする方法、もう1つは1つの引数 (左端の引数) の関数として解釈し、関数を返す方法だ。後者の解釈は、`m -> (m -> m)`のように括弧 (矢印が右結合であるため冗長) を追加することによって強調できる。この解釈については後で説明する。

Haskellでは、`mempty`と`mappend`のモノイダル特性 (すなわち、`mempty`は中立で、`mappend`は結合性を持つという事実) を表現する方法がないことに注意してほしい。それらを満たすことを確認するのは、プログラマーの責任だ。

HaskellのクラスはC++クラスほど侵襲的ではない。新しい型を定義するときは、事前にクラスを指定する必要はない。先延ばしして、与えられた型をあるクラスのインスタンスとして後から宣言してよい。例として、`mempty`と`mappend`の実装を提供することで`String`をモノイドとして宣言しよう (実際、これは標準プレリュードで自動的に行われる)：

```haskell
instance Monoid String where
    mempty = ""
    mappend = (++)
```

ここで、`String`は単なる文字のリストなので、リスト連結演算子`(++)`を再利用した。

Haskellの構文に関する註：中置演算子は括弧で囲めば2つの引数を持つ関数に変換できる。与えられた2つの文字列の間に`++`を挿入すれば、それらを連結できる：

```haskell
"Hello " ++ "world!"
```

あるいは、括弧で括られた`(++)`に2つの引数として渡してもよい：

```haskell
(++) "Hello " "world!"
```

関数への引数がコンマで区切られたり括弧で囲まれたりしていないことに注意してほしい。(これはおそらく、Haskellを学ぶときに慣れるのが一番難しい部分だろう。)


Haskellでは関数の等価性を次のように表現できることは、強調しておく価値がある：

```haskell
mappend = (++)
```

概念的には、これは関数によって生成される値の等価性を次のように表現するのとは異なる：

```haskell
mappend s1 s2 = (++) s1 s2
```

前者は、$\Hask$圏 (または、終わりのない計算を指すボトムを無視するなら、$\Set$圏) の射の等価性に変換される。このような方程式はより簡潔であるだけでなく、しばしば他の圏にも一般化できる。後者は[外延的]{.keyword #extensional}同値性 (extensional equivalence) と呼ばれ、どんな2つの入力文字列に対しても`mappend`と`(++)`の出力は同じであることを述べている。引数の値は[点]{.keyword #point} (point) と呼ばれることがあるため (例：点$x$における$f$の値)、これはpoint-wise equalityと呼ばれる。引数を指定しない関数の等価性は[ポイントフリー]{.keyword #point-free} (point-free) と表現される。(ちなみに、ポイントフリーの式は関数合成を含むことが多く、これは点記号で表されるため、初心者は少し混乱するかもしれない。)


C++でモノイドを宣言するのに最も近い方法は、C++20標準のコンセプト機能を使うことだ。

```cpp
template<class T>
  T mempty = delete;

template<class T>
  T mappend(T, T) = delete;

template<class M>
  concept bool Monoid = requires (M m) {
    { mempty<M> } -> M;
    { mappend(m, m); } -> M;
  };
```

最初の定義は、各特殊化で中立元を保持するための構造だ。

キーワード`delete`は、デフォルト値が定義されていないことを意味する。これはケースバイケースで指定する必要がある。同様に、`mappend`にもデフォルトはない。

`Monoid`というコンセプトは、与えられた型`M`に対して`mempty`と`mappend`の適切な定義が存在するかをテストする。

このMonoidコンセプトのインスタンス化は、適切な特殊化とオーバーロードを提供することで実現できる：

```cpp
template<>
std::string mempty<std::string> = {""};

std::string mappend(std::string s1, std::string s2) {
    return s1 + s2;
}
```

## 圏としてのモノイド

ここまでは集合の要素という観点でのモノイドの「おなじみの」定義だった。しかし、ご存知のように、圏論では集合とその要素から逃れようとし、代わりに対象と射について述べる。そこで、少し視点を変えて、二項演算子の適用先を、集合の周りを「移動」したり「シフト」したりするものと考えてみよう。

たとえば、各自然数に5を加算する演算を考える。これは0を5、1を6 、2を7のように写す。これは、一連の自然数で定義された関数だ。結構だ。関数と集合がある。一般に、任意の数nに対し$n$を加算する関数がある。これは$n$の「加算器」だ。

加算器はどのように合成すればよいだろう？
5を加算する関数と7を加算する関数の合成は、12を加算する関数だ。これにより、加算器の合成を加算ルールと等価にできる。これまた結構だ。加算を関数合成に置き換えられる。

ちょっと待った。それだけではない。中立元0の加算器もある。0を加算しても何も写されないので、これは自然数の集合における恒等関数だ。

従来の加算の規則を与える代わりに、情報を失うことなく加算器を構成する規則を与えることもできる。加算器の合成は結合性を持つことに注目してほしい。これは、関数の合成が結合性を持ち、恒等関数に対応する0加算器があるからだ。

鋭い読者なら、整数から加算器への写像が`mappend`の型シグネチャを`m -> (m -> m)`と解釈した結果であることに気付いただろう。これは`mappend`がモノイド集合の要素を、その集合に作用する関数に写すことを表している。

さて、自然数を集合として扱っていることを忘れて、たくさんの射――加算器たちをひとかたまりにした、単一の対象だと考えてほしい。モノイドは対象が単一の圏だ。実際、monoidという名前は、ギリシャ語で単一を意味する*mono*に由来する。すべてのモノイドは、適切な合成規則に従う射の集合をもつ単一の対象の圏として記述できる。

![](images/monoid.jpg){width=35%}

文字列の連結は興味深いケースだ。なぜなら、右アペンダーと左アペンダー (あるいは*prependers*) を定義する選択肢があるからだ。2つのモデルの合成テーブルは、互いに鏡像反転している。「foo」に「bar」を後置するのと「bar」に「foo」を前置するのが同じなのは容易に納得できるだろう。

すべての圏論的モノイド――対象が1つの圏――が二項演算付き集合 (set-with-binary-operator) のモノイドを一意に定義するのか、という疑問を持つかもしれない。単一対象の圏からは常に集合を抽出できる。その集合は射の集合であり、この例では加算器だ。言い換えれば、圏$\cat{M}$内の単一対象$m$についてhom集合$\cat{M}(m, m)$ が存在する。この集合における二項演算は簡単に定義できる。2つの集合要素のモノイダル積 (monoidal product) とは、それらに対応する射を合成したものに対応する要素だ。つまり、$f$と$g$に対応する$\cat{M}(m, m)$ の2つの要素を指定すると、その積は合成$f \circ g$に対応する。この合成は常に存在する。なぜなら、射の始域と終域が同じ対象だからだ。また、圏の規則より、結合性も持つ。恒等射はこの積の中立元だ。このように、圏論的モノイドからは常に集合論的モノイドを復元できる。どこからどう見てもそれらは同一だ。

![射あるいは集合内の点として見たモノイドhom集合](images/monoidhomset.jpg){width=40%}

数学者が補足すべき箇所は、射は必ずしも集合を形成しないということだけだ。圏の世界には集合よりも大きなものがある。任意の2つの物体間の射が集合を形成する圏は、局所的に小さい、と呼ばれる。約束どおり、私はそのような些細なことはほとんど無視するが、記録のために言及すべきだと考えた。

hom集合の要素は、合成則に従う射としても、ある集合内の点としても見なせる。圏論における多くの興味深い現象はこの事実に根ざしている。ここで、$\cat{M}$の射の合成は、集合$\cat{M}(m, m)$ のモノイダル積に変換される。

## 課題

1. 以下から自由圏を生成せよ：
   1. 1つのノードを持ち、エッジのないグラフ
   2. 1つのノードと1つの (有向) エッジを持つグラフ (ヒント：このエッジは自身と合成できる)
   3. 2つのノードと、それらの間の矢を1つ持つグラフ
   4. 1つのノードと、アルファベットa, b, c $\ldots$ zでマークされた26個の矢を持つグラフ

2. 以下はどんな順序だろうか？

   1. 包含関係：$A$を持つ集合の集合は、$A$のすべての要素が$B$の要素でもある場合、$B$に含まれる。
   2. 次のサブタイプ関係を持つC++の型：`T1`が`T2`のサブタイプなのは、`T2`へのポインタを期待する関数に`T1`をコンパイルエラーを発生させずに渡せる場合だ。

3. `Bool`が2つの値`True`と`False`の集合であることを考えると、演算子`&&` (AND) と`||` (OR) にそれぞれ対応する2つの (集合論的) モノイドを形成することを示せ。

4. AND演算子を伴う`Bool`モノイドを圏として表せ。射と合成の規則を列挙せよ。

5. モジュロ3加算をモノイドの圏として表せ。
