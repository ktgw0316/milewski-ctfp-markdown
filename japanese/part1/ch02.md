# 型と関数 {#types-and-functions}

型と関数の圏はプログラミングにおいて重要な役割を果たす。そこで、型とは何か、なぜ型が必要なのかについて説明しよう。

## 型を必要とするのは誰か？


静的型付けと動的型付け、および強い型付けと弱い型付けの利点については、議論があるようだ。これらの選択肢を思考実験で説明しよう。コンピューターのキーボードを操作する何百万匹もの猿が喜んでランダムにキーを打ち、プログラムを作成したり、コンパイルしたり、実行したりする様子を想像してみてほしい。

![](images/img_1329.jpg){width=30%}

機械語では、猿が生成するバイトの組み合わせはどれでも受け入れられて実行される。しかし、より高級な言語ではコンパイラーが語彙や文法上の誤りを検出できるという事実を我々は理解している。多くの猿はバナナなしで去るだろうが、残されたプログラムは役に立つ可能性が高いだろう。型チェックも、無意味なプログラムに対するもう1つの防御壁となる。さらに、型の不一致は動的型付け言語では実行時に発見されるのに対し、強く型付けされ静的にチェックされる言語ではコンパイル時に発見されるので、多くの不正なプログラムが実行される前に排除される。

そこで、問題は次のようになる。猿を幸せにしたいのか、それとも正しいプログラムを作りたいのか？

タイピング猿の思考実験における通常の目標はシェークスピア全集を作ることだ。スペルチェッカーと文法チェッカーをループに含めれば、勝算は大幅に上昇するだろう。型チェッカーに類するものを含めれば、さらなる前進が見込める。ロミオは人間である、と宣言されていれば、この主人公は決して葉を発芽したり、自身の強力な重力場に光子を閉じ込めたりはしない。

## 型は合成に関する

圏論は矢を合成することに関する。しかし、2本の矢なら何でも合成できるわけではない。ある矢の終域 (target) となる対象は、次の矢の始域 (source) となる対象と同じでなくてはならない。プログラミングでは、ある関数の結果を別の関数に渡す。後段の関数が前段の関数によって生成されたデータを正しく解釈できない場合、プログラムは機能しない。合成が機能するためには両端が適合しなければならない。言語の型システムが強力であればあるほど、この一致はよりよく記述され、機械的に検証される。

強力な静的型チェックに対して耳にする唯一の重要な反対意見は、意味的に正しいプログラムを排除する可能性がある、というものだ。実際には、そうなることは極めてまれで、いずれにしても、どの言語にも、本当に必要な場合に型システムを迂回するための何らかのバックドアが用意されている。Haskellにさえ`unsafeCoerce`がある。しかし、このような装備は慎重に使うべきだ。フランツ・カフカの小説の主人公グレゴール・ザムザが、巨大なバグに変身したとき型システムを破壊し、どんな結末を迎えたかは誰もが知っている。

よく耳にするもう1つの意見は、型を扱うのはプログラマーにとって負担が大きすぎる、というものだ。私もC++でイテレーターの宣言をいくつか自分で書かなければならなかったら共感するだろう。もっとも、[型推論]{.keyword #type_inference} (type inference) と呼ばれる技術があり、コンパイラーはほとんどの型を文脈から推論できるようになっている。C++では、変数を`auto`で宣言してコンパイラーにその型を認識させられるようになった。

Haskellでは、稀な場合を除いて、型アノテーションは純粋にオプションだ。プログラマーはどのみち型アノテーションを使う傾向がある。なぜなら、コードのセマンティクスについて多くを伝えられ、コンパイル・エラーを理解しやすくできるからだ。Haskellでは、型を設計することからプロジェクトを始めるのが一般的な慣習だ。後々、型アノテーションは実装を駆動し、コンパイラーによって強制されるコメントになる。

強力な静的型付けはコードをテストしない言い訳としてよく使われる。Haskellのプログラマーが「コンパイルが通るなら正しいはずだ」と言っているのを耳にすることがあるだろう。しかし、型が正しいプログラムなら正しい出力を生成する、などという保証は当然ない。そのような無頓着な態度の結果、いくつかの研究では、Haskellのコード品質は予想ほど群を抜いて高くはなかった。商用の環境では、バグを修正する圧力はある品質レベルまでしか働かないようだ。そのレベルは、ソフトウェア開発の経済性とエンドユーザーの許容度に深く関係し、プログラミング言語や方法論にはほとんど関係しない。より良い基準は、スケジュールより遅れているプロジェクトや、大幅に機能が削減されたプロジェクトの数を調べることだろう。

単体テストによって強い型付けを置き換えられる、という意見に関しては、強い型付けの言語で一般的に行われているリファクタリング手法である、関数の引数の型の変更について考えてみてほしい。強い型付けの言語では、その関数の宣言を変更してから、すべてのビルド・ブレークを修正すれば十分だ。弱い型付けの言語では、関数が異なるデータを要求するようになったという事実は呼び出し側に伝わらない。単体テストはミスマッチのいくつかを捉えるかもしれないが、テストはほとんどの場合、確率論的なプロセスにすぎず、決定論的なプロセスではない。テストは証明の代わりにはならないのだ。

## 型とは何か？


型とは、最も単純な直観としては、値の集合だ。型`Bool`は`True`と`False`の2要素集合だ（Haskellでは具体的な型は大文字で始まることを思い出してほしい）。`Char`型はaやąのようなユニコード文字すべての集合だ。

集合は有限集合と無限集合のどちらでもよい。`String`は、`Char`のリストの同義語で、その型は無限集合の例だ。

`x`を`Integer`として宣言しよう：

```haskell
x :: Integer
```

これは、整数集合の要素だと言っていることになる。Haskellの`Integer`は無限集合であり、任意の精度の演算に使える。また、C++の`int`と同様の、機械語の型に対応する有限集合`int`もある。

いくつか微妙な点があるせいで、型と集合の区別は厄介なものになっている。循環定義を含む多相関数には問題があり、すべての集合の集合は存在できないという事実にも問題がある。だが、約束したとおり、私は数学にこだわるつもりはない。ありがたいことに、集合の圏が存在する。$\Set$と呼ばれるその圏をここでは扱う。$\Set$では、対象は集合であり、射（矢）は関数だ。

$\Set$は非常に特別な圏だ。対象の内部を実際に見られ、そうすることで多くの直観が得られるからだ。たとえば、空集合には要素がないと分かっている。特別な1要素集合があるのも分かっている。関数がある集合の要素を別の集合の要素に写すのも分かっている。関数は、2つの要素を1つに写すことはできるが、1つの要素を2つに写すことはできない。恒等関数が集合の各要素を自身に写すことなども分かっている。予定としては、これらすべての情報を徐々に忘れ、すべての概念を純粋に圏論の用語、つまり対象と矢によって表していく。

理想的な世界では、Haskellの型は集合であり、Haskellの関数は集合間の数学的関数であると言えば済んだだろう。だが、1つだけ小さな問題がある。数学関数はコードを実行せず、単に解を知っているだけなのだ。Haskellの関数は解を計算する必要がある。有限のステップ数で解が得られるなら、何ステップかかっても問題はない。ところが、計算のなかには再帰を伴うものもあり、ずっと停止しないことがあり得る。Haskellから非停止関数 (non-terminating function) を単に追放はできない。なぜなら、停止関数と非停止関数の区別は決定できないからだ。これは停止性問題 (halting problem) として有名だ。そのため計算機科学者たちは素晴らしいアイデアを考案した。それは捉え方によっては大きなハッキングとも言えるだろう。そのアイデアとは、[ボトム]{.keyword #bottom} (bottom) と呼ばれる、記号`_|_`またはユニコードの$\bot$で^[訳註：Up Tack (U+22A5) を指す。]表される特別な値を用いてすべての型を拡張する、というものだ。この「値」は非停止計算に対応する。したがって、次のように宣言される関数：

```haskell
f :: Bool -> Bool
```

は`True`か`False`か`_|_`を返し、ボトムの場合は決して停止しないことを意味する。

興味深いことに、ひとたび型システムの一部としてボトムを受け入れたなら、すべての実行時エラーをボトムとして扱い、さらには関数からボトムを明示的に返せるようにするのが便利になる。後者は通常、`undefined`という式を使って行われる：

```haskell
f :: Bool -> Bool
f x = undefined
```

この定義が型検査を通るのは、`undefined`が評価されるとボトムになるからだ。ボトムは`Bool`も含むすべての型のメンバーだ。さらに：

```haskell
f :: Bool -> Bool
f = undefined
```

のように（`x`なしで）書くことさえできる。ボトムが`Bool->Bool`型のメンバーでもあるためだ。

取りうるすべての引数に対して有効な結果を返す関数が全域関数 (total function) と呼ばれるのに対し、ボトムを返す可能性のある関数は部分関数 (partial function) と呼ばれる。

ボトムがあるため、Haskellの型と関数の圏は、$\Set$ではなく$\Hask$と呼ばれる。理論的な観点から見ると、これは果てしない複雑さの原因となる。だから、この時点で一連の推論を肉切り包丁で捌いて終わらせよう。実用的な観点からは、停止しない関数とボトムを無視し、$\Hask$を真正な$\Set$として扱うことは問題ない。

## なぜ数学モデルが必要なのか？

プログラマーであるあなたは、プログラミング言語の構文と文法に精通している。言語のそれらの側面は、通常、言語仕様の冒頭で形式的な表記法によって記述される。一方で、言語が意味するもの、つまりセマンティクスを記述するのははるかに困難だ。より多くのページを必要とし、十分に形式化されていることはほとんどなく、完全であることもほとんどない。それゆえ、言語法律家たちの間では終わりのない議論が交わされ、言語標準の細かい解釈を目的とした書籍が家内工業的に出版されている。

言語のセマンティクスを記述するための形式手法ツールは存在するが、複雑なため、ほとんどの場合は簡略化された学術言語で使われ、実用される巨大なプログラミング言語ではあまり使われない。そのようなツールのうち[操作的意味論]{.keyword #operational_semantics} (operational semantics) と呼ばれるものは、プログラム実行の仕組みを記述する。それは形式化され理想化されたインタープリターを定義する。C++のような産業用言語のセマンティクスは通常、非形式的な操作的推論を用いて「抽象機械」として述べられることが多い。

問題は、操作的意味論を使ってプログラムに関することを証明するのが非常に難しいことだ。プログラムの特性を表示するためには、基本的には理想化されたインタープリターを通して「実行」しなければならない。

プログラマーが正確さを形式的に証明しないことは問題ではない。我々はいつも正しいプログラムを書いていると「思っている」。キーボードの前に座って、「さて、コードを数行打ち込んで、何が起こるか見てみよう」と言う人はいない。我々は、作成するコードが望ましい結果を生み出す特定のアクションを実行すると考えている。そうでない場合、たいていかなり驚くことになる。つまり、我々は自分が書いたプログラムについて推論していて、通常は頭の中でインタープリターを走らせることでそうしている。すべての変数を追跡するのは極めて難しい。コンピューターはプログラムを実行するのが得意だが、人間は不得意だ！
もし得意だったら、コンピューターは必要ないだろう。

しかし、別の選択肢もある。それは[表示的意味論]{.keyword #denotational_semantics} (denotational semantics) と呼ばれ、数学に基づいている。表示的意味論では、すべてのプログラミング構成体に数学的解釈が与えられる。それを使えば、プログラムの特性を証明したいときは数学的定理を証明するだけでよい。定理を証明するのは難しいと思うかもしれないが、実際には、人類は数千年にわたって数学的手法を構築してきたので、利用できる知識が豊富に蓄積されている。また、プロの数学者が証明する定理と比べると、プログラミングで遭遇する問題は、自明ではないにせよ、通常は極めて単純なものだ。

表示的意味論に従う言語であるHaskellで階乗関数の定義を考えてみよう：

```haskell
fact n = product [1..n]
```

式`[1..n]`は、`1`から`n`までの整数のリストだ。関数`product`は、リストのすべての要素を乗算する。これは数学の教科書に載っている階乗の定義と同じだ。これをCと比較してほしい：

```c
int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
        result *= i;
    return result;
}
```

これ以上言う必要があるだろうか？

確かに、不当な批判だったのは真っ先に認めよう！
そもそも階乗関数には自明な数学的表記がある。鋭い読者なら「キーボードから文字を読み取ったり、ネットワークを介してパケットを送信したりするための数学的モデルは何か？」と尋ねるだろう。長きに渡って、それはかなり複雑な説明につながる面倒な質問だった。有用なプログラムを書くために不可欠な多くの重要なタスクには、表示的意味論は最適でないように思われたが、操作的意味論では容易に解決できた。突破口は圏論からもたらされた。エウジニオ・モッジ (Eugenio Moggi) によって、計算作用をモナドに写せることが発見された。これは表示的意味論に新たな生命を与え、純粋関数プログラムをより使いやすくするだけでなく、従来のプログラミングに新たな光を当てる重要な知見となった。モナドについては後ほど、より圏論的なツールを開発するときに述べる。

プログラミングに数学的モデルがあることの重要な利点の1つは、ソフトウェアの正しさを形式的に証明できることだ。消費者向けのソフトウェアを書く際にはそれほど重要でないように思えるだろうが、失敗の代償が法外なものになったり人命が危険にさらされたりするようなプログラミングの領域もある。もっとも、医療システム用のWebアプリケーションを作成する場合でさえ、Haskell標準ライブラリの関数やアルゴリズムが正しさを証明済みであることをありがたく思うだろう。

## 純粋関数と非純粋関数

C++やその他の命令型言語で関数と呼ぶものは、数学者が関数と呼ぶものとは異なる。数学関数は値から値への写像にすぎない。

数学関数はプログラミング言語で実装できる。そのような関数は、入力値が与えられると、出力値を計算する。数の2乗を生成する関数は、入力値をそれ自身で乗算するはずだ。これは呼び出されるたびに行われ、同じ入力で呼び出されるたびに同じ出力を生成することが保証されている。数の2乗は月の満ち欠けによって変化しない。

また、数の2乗を計算することで犬においしい餌を出すという副作用があってはならない。それを行う「関数」は数学関数として簡単にモデル化できない。

プログラミング言語では、同じ入力に対して常に同じ結果を生成し副作用のない関数は[純粋関数]{.keyword #pure_function} (pure function) と呼ばれる。Haskellのような純粋関数型言語では、すべての関数が純粋だ。そのため、これらの言語に表示的意味論を与え、圏論でモデル化することが容易になる。他の言語の場合は、純粋なサブセットだけを使うように制限したり、副作用を切り分けて扱ったりすることは常に可能だ。モナドによって、純粋関数のみを使ってあらゆる種類の作用をモデル化する方法については、後ほど説明する。数学的関数だけという制約を課しても何も失われないのだ。

## 型の例

型が集合であることを理解すれば、ややエキゾチックな型を考えられる。たとえば、空集合に対応するのはどんな型だろう？
それは決してC++の`void`ではないが、Haskellでは`Void`と呼ばれている。その型には値が存在しない。`Void`を取る関数は、定義はできるが、呼び出せない。呼び出すには`Void`型の値を提供する必要があるが、それは存在しないからだ。この関数が返す内容に関しては、何ら制限はない。それは任意の型を返せる（ただし、呼び出せないため、返すことはない）。言い換えると、戻り値の型が多相な関数だ。Haskell使いたちはこう呼ぶ：

```haskell
absurd :: Void -> a
```

（`a`は任意の型を表せる型変数なのを覚えておいてほしい。）
この名前は偶然ではない^[訳註：abserdは不条理を意味する。]。Curry-Howard同型と呼ばれる論理の観点から、型と関数についてのより深い解釈が存在する。型`Void`は虚偽を表し、関数`absurd`の型は「虚偽からは何でも導ける」というラテン語の格言 "ex falso sequitur quodlibet" に対応している。

次は、単集合に対応する型だ。これが持てる値は1つしかない。その値は単に "is" だ。すぐには分からないかもしれないが、これがC++の`void`だ。この型を引数に取る関数と、この型を返す関数を考えてみてほしい。`void`を取る関数は常に呼び出せる。それが純粋関数なら、常に同じ結果を返す。そのような関数の例を示そう：

```c
int f44() { return 44; }
```

この関数は "nothing" を取ると思うかもしれないが、先ほど見たように、"nothing" を取る関数は決して呼び出されない。なぜなら、"nothing" を表す値がないからだ。この関数は何を取るのだろうか？
概念的には、インスタンスが1つしか存在しないダミー値を取るため、明示的に言及する必要はない。しかしHaskellでは、この値を表す記号として、空の括弧のペア`()`がある。そのため、奇妙な偶然（これは偶然なのか？）によって、void関数の呼び出しはC++とHaskellで同じように見える。また、Haskellは簡潔さを好むので、同じシンボル`()`が型、コンストラクター、そして単集合に対応する唯一の値に使われる。この関数をHaskellで書くとこうなる：

```haskell
f44 :: () -> Integer
f44 () = 44
```

最初の行は、`f44`が "unit" と発音される型`()`を型`Integer`に取り込むことを宣言している。2番目の行は`f44`を定義するためにunitの唯一のコンストラクター`()`に対してパターンマッチングを行い、44という番号を生成する。この関数を呼び出すにはunitの値`()`を指定する。

```haskell
f44 ()
```

unitのどの関数も、終域の型から1つの要素を選択するのと等価であることに注意してほしい（ここでは`Integer` 44を選択する）。実際、`f44`は番号44の別の表現と見なせる。これは、集合の要素を明示的に指定する代わりに関数（矢）について説明する方法の例だ。unitから任意の型$A$への関数は、その集合$A$の要素と1対1で対応している。

`void`型を返す関数や、Haskellでunit型を返す関数はどうだろうか？
C++ではそのような関数が副作用を目的として使われるものの、数学的な意味では実際には関数ではないのは分かっている。unitを返す純粋関数は何もせず、引数を破棄する。

数学的には、集合$A$から単集合への関数は$A$のすべての要素をその単集合の単一の要素に写す。$A$ごとに、そのような関数が1つだけ存在する。`Integer`に対するこの関数は次のとおりだ：

```haskell
fInt :: Integer -> ()
fInt x = ()
```

任意の整数を指定すると、unitが返される。簡潔さの精神で、Haskellでは、破棄する引数をワイルドカード・パターンであるアンダースコアで示せる。この方法なら名前を付ける必要はない。つまり上記は次のように書き直せる：

```haskell
fInt :: Integer -> ()
fInt _ = ()
```

この関数の実装は、渡された値に依存しないだけでなく、引数の型にも依存しないことに注目してほしい。

どの型に対しても同じ式で実装できる関数は、パラメトリック多相関数 (parametrically polymorphic function) と呼ばれる。そのような関数の族 (family) はすべて、具体的な型の代わりに型パラメーターを使う1つの等式によって実装できる。任意の型からunit型への多相関数を何と呼ぶべきだろう？
もちろん`unit`と呼ぶ：

```haskell
unit :: a -> ()
unit _ = ()
```

C++では、この関数を次のように記述する：

```cpp
template<class T>
void unit(T) {}
```

型の類型学における次のものは2要素集合だ。C++では`bool`と呼ばれ、Haskellでは予想どおり`Bool`と呼ばれる。違いは、C++の`bool`は組み込みの型であるのに対して、Haskellでは次のように定義できることだ：

```haskell
data Bool = True | False
```

（この定義の読み方は`Bool` is `True` or `False`だ。）
原理的には、C++でもBoolean型を列挙型として定義できるはずだ：

```cpp
enum bool {
    true,
    false
};
```

しかし、C++の`enum`は密かに整数だ。C++11の "`{enum class}`" を代わりに使うこともできたが、その場合は、`bool::true`や`bool::false`のように、クラス名で値を修飾する必要がある。言うまでもなく、それを使うすべてのファイルに適切なヘッダを含める必要がある。

`Bool`を取る純粋関数は、終域の型から2つの値を選択するだけだ。1つは`True`に対応し、もう1つは`False`に対応する。

`Bool`を返す関数は[述語]{.keyword #predicate} (predicate) と呼ばれる。たとえば、Haskellライブラリ`Data.Char`は`isAlpha`や`isDigit`のような述語でいっぱいだ。C++には`isalpha`や`isdigit`などを定義する同様のライブラリがあるが、これらはブール値ではなく`int`を返す。実際の述語は`std::ctype`で定義され、`ctype::is(alpha, c)`、`ctype::is(digit, c)`などの形式がある。

## 課題

1. 任意の言語で高階関数（または関数オブジェクト）`memoize`を定義せよ。この関数は純粋関数`f`を引数として受け取り、`f`とほぼ同じ動作をする関数を返す。ただし、もとの関数を引数ごとに1回だけ呼び出し、結果を内部に格納し、その後は同じ引数で呼び出されるたびに格納済みの結果を返す。メモ化 (memoize) された関数ともとの関数は、パフォーマンスを見れば区別できる。たとえば、評価に時間のかかる関数のメモ化を試みること。最初に呼び出したときは結果を待つ必要があるが、同じ引数を使って次に呼び出したときは結果をすぐ得られるだろう。

2. 乱数を生成するために通常使う標準ライブラリ関数をメモ化してみよ。うまくいくか？

3. ほとんどの乱数発生器はシードで初期化できる。シードを受け取り、そのシードで乱数発生器を呼び出し、結果を返す関数を実装せよ。その関数をメモ化せよ。うまくいくか？

4. 以下のC++関数のうち、純粋なのはどれか？
   これらをメモ化してみて、何度も呼び出したときに何が起こるかを、メモ化した場合とそうでない場合について観察せよ。

   1. 本文中で例示した階乗関数。

   2. ```cpp
      std::getchar()
      ```

   3. ```cpp
      bool f() {
        std::cout << "Hello!" << std::endl;
        return true;
      }
      ```

   4. ```cpp
      int f(int x)
      {
        static int y = 0;
        y += x;
        return y;
      }
      ```

5. `Bool`を取り`Bool`を返す関数は何種類あるか？
   それらすべてを実装できるか？

6. `Void`型、`()` (unit) 型、`Bool`型だけを対象とする圏の絵を描け。矢はこれらの型の間のすべての可能な関数に対応している。矢には関数名のラベルを付けよ。

## 参考文献

1. Nils Anders Danielsson, John Hughes, Patrik Jansson, Jeremy Gibbons, [Fast and Loose Reasoning is Morally Correct](www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf). この論文は、ほとんどの文脈でボトムを無視することの正当性を説明している。
