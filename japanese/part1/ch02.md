# 型と関数 {#types-and-functions}

型と関数の圏はプログラミングにおいて重要な役割を果たす。そこで、型とは何か、なぜ型が必要なのかについて説明しよう。

## 型を必要とするのは誰か？

静的型付けと動的型付け、および強い型付けと弱い型付けの利点については、議論があるようだ。これらの選択肢を思考実験で説明しよう。コンピューターのキーボードを操作する何百万匹もの猿が喜んでランダムにキーを打ち、プログラムを作成したり、コンパイルしたり、実行したりする様子を想像してみてほしい。

`\begin{figure}[H] \centering`{=latex}
![](images/img_1329.jpg){width=30%}
`\end{figure}`{=latex}
\noindent
機械語では、猿が生成するバイトの組み合わせはどれでも受け入れられて実行される。しかし、より高級な言語ではコンパイラーが語彙や文法上の誤りを検出できるという事実を我々は理解している。多くの猿はバナナなしで去るだろうが、残されたプログラムは役に立つ可能性が高いだろう。型検査も、無意味なプログラムに対するもう1つの防御壁となる。さらに、型の不一致は動的型付け言語では実行時に発見されるのに対し、強く型付けされ静的に型検査される言語ではコンパイル時に発見されるので、多くの不正なプログラムが実行される機会を得る前に排除される。

そこで、問題は次のようになる。猿を幸せにしたいのか、それとも正しいプログラムを作りたいのか？

タイピング猿の思考実験における通常の目標はシェークスピア全集を作ることだ。スペルチェッカーと文法チェッカーをループに含めれば、勝算は大幅に上昇するだろう。型検査器に類するものを含めれば、さらなる前進が見込める。ロミオは人間である、と宣言されていれば、彼は決して葉を発芽したり自身の強力な重力場に光子を閉じ込めたりはしない。

## 型は合成に関する

圏論は矢を合成することに関する。しかし、2本の矢なら何でも合成できるわけではない。ある矢の終点 (target) となる対象は、次の矢の始点 (source) となる対象と同じでなくてはならない。プログラミングでは、ある関数の結果を別の関数に渡す。後段の関数が前段の関数によって生成されたデータを正しく解釈できない場合、プログラムは機能しない。合成が機能するためには両端が適合しなければならない。言語の型システムが強力であればあるほど、この一致はよりよく記述され、機械的に検証される。

強力な静的型検査に対して私が耳にする唯一の重要な反対意見は、意味的に正しいプログラムを排除する可能性がある、というものだ。実際には、そうなることは極めてまれで、いずれにしても、どの言語にも、本当に必要な場合に型システムを迂回するための何らかのバックドアが用意されている。Haskellにさえ`unsafeCoerce`がある。しかし、このような装備は思慮深く使うべきだ。フランツ・カフカの小説の主人公グレゴール・ザムザが、巨大なバグに変身したとき型システムを破壊し、どんな結末を迎えたかは誰もが知っている。

私がよく耳にするもう1つの意見は、型を扱うのはプログラマーにとって負担が大きすぎる、というものだ。私もC++でイテレーターの宣言をいくつか自分で書かなければならなかったら共感するだろう。もっとも、[*型推論*]{.keyword #type_inference}\index{型推論} (type inference) と呼ばれる技術があり、コンパイラーはほとんどの型を文脈から推論できるようになっている。C++では、変数を`auto`で宣言してコンパイラーにその型を発見させられるようになった。

Haskellでは、稀な場合を除いて、型注釈は純粋にオプションだ。プログラマーはどのみち型注釈を使う傾向がある。なぜなら、コードの意味について多くを伝えられ、コンパイル・エラーを理解しやすくできるからだ。Haskellでは、型を設計することからプロジェクトを始めるのが一般的な慣習だ。後々、型注釈は実装を駆動し、コンパイラーによって強制されるコメントになる。

強力な静的型付けはコードをテストしない言い訳としてよく使われる。Haskellのプログラマーが「コンパイルが通るなら正しいはずだ」と言っているのを耳にすることがあるだろう。しかし、型が正しいプログラムなら正しい出力を生成する、などという保証は当然ない。そのような無頓着な態度の結果、いくつかの研究では、Haskellのコード品質は予想ほど群を抜いて高くはなかった。商用の環境では、バグを修正する圧力はある品質レベルまでしか働かないようだ。そのレベルは、ソフトウェア開発の経済的状況とエンドユーザーの許容度に深く関係し、プログラミング言語や方法論にはほとんど関係しないのだろう。より良い基準は、スケジュールより遅れているプロジェクトや、大幅に機能が削減されたプロジェクトの数を調べることだろう。

単体テストによって強い型付けを置き換えられる、という意見に関しては、強い型付けの言語で一般的に行われているリファクタリング手法である、関数の引数の型の変更について考えてみてほしい。強い型付けの言語では、その関数の宣言を変更してから、すべてのビルド・ブレークを修正すれば十分だ。弱い型付けの言語では、関数が異なるデータを要求するようになったという事実は呼び出し側に伝わらない。単体テストはミスマッチのいくつかを捉えるかもしれないが、テストはほとんどすべての場合において、確率論的なプロセスにすぎず、決定論的なプロセスではない。テストは証明の代わりにはならないのだ。

## 型とは何か？

型とは、最も単純な直観としては、値の集合だ。型`Bool`は`True`と`False`の2要素集合だ（Haskellでは具体的な型は大文字で始まることを思い出してほしい）。`Char`型は`a`や`ą`のようなUnicode文字すべてからなる集合だ。

集合は有限の場合も無限の場合もあり得る。`String`型は、`Char`のリストの同義語で、無限集合の例だ。

以下のように`x`を`Integer`として宣言すること：

```haskell
x :: Integer
```

\noindent
は、`x`が整数の集合の要素だと言っていることになる。Haskellの`Integer`は無限集合であり、任意精度の演算が可能だ。また、C++の`int`と同様の、マシンネイティブの型に対応する有限集合`Int`もある。

いくつか微妙な点があるせいで、こうした型と集合の同一視はトリッキーなものになっている。多相関数には循環定義の問題があり、すべての集合の集合が存在しないことも問題だ。だが、約束したとおり、私は数学にこだわるつもりはない。ありがたいことに、集合の圏が存在する。$\Set$と呼ばれるその圏をここでは扱う。$\Set$では、対象は集合であり、射（矢）は関数だ。

$\Set$は非常に特別な圏だ。対象の内部を実際に見られ、そうすることで多くの直観が得られるからだ。たとえば、空集合には要素がないと分かっている。特別な1要素集合があるのも分かっている。関数が1つの集合の要素を別の集合の要素に写すのも分かっている。関数は、2つの要素を1つに写すことはできるが、1つの要素を2つに写すことはできない。恒等関数が集合の各要素を自身に写すことなども分かっている。予定としては、これらすべての情報を徐々に忘れ、すべての概念を純粋に圏論の言葉、つまり対象と矢によって表していく。

理想的な世界では、Haskellの型は集合であり、Haskellの関数は集合間の数学的関数であると言えば済んだだろう。だが、1つだけ小さな問題がある。数学関数はコードを実行せず、単に解を知っているだけなのだ。Haskellの関数は解を計算する必要がある。有限のステップ数で解が得られるなら、何ステップかかっても問題はない。ところが、計算のなかには再帰を伴うものもあり、ずっと停止しないことがあり得る。Haskellで停止しない関数をただ単に禁止はできない。なぜなら、停止する関数と停止しない関数の区別は決定不能だからだ。これは停止性問題 (halting problem) として有名だ。そのため計算機科学者たちは素晴らしいアイデアを考案した。それは捉え方によっては大きなハッキングとも言えるだろう。そのアイデアとは、[*ボトム*]{.keyword #bottom}\index{ボトム} (bottom) と呼ばれる、記号`_|_`またはUnicodeの$\bot$で^[訳註：Up Tack (U+22A5) を指す。]表される特別な値を用いてすべての型を拡張する、というものだ。この「値」は停止しない計算に対応する。したがって、次のように宣言される関数：

```haskell
f :: Bool -> Bool
```

\noindent
は`True`か`False`か`_|_`を返し、ボトムの場合は決して停止しないことを意味する。

興味深いことに、ひとたび型システムの一部としてボトムを受け入れたなら、すべての実行時エラーをボトムとして扱い、さらには関数からボトムを明示的に返せるようにするのが便利になる。後者は通常、`undefined`という式を使って行われる：

```haskell
f :: Bool -> Bool
f x = undefined
```

\noindent
この定義が型検査を通るのは、`undefined`が評価されるとボトムになるからだ。ボトムは`Bool`も含むすべての型のメンバーだ。さらに：

```haskell
f :: Bool -> Bool
f = undefined
```

\noindent
のように（`x`なしで）書くことさえできる。ボトムが`Bool->Bool`型のメンバーでもあるためだ。

取りうるすべての引数に対して有効な結果を返す関数が全域関数 (total function) と呼ばれるのに対し、ボトムを返す可能性のある関数は部分関数 (partial function) と呼ばれる。

ボトムがあるため、Haskellの型と関数の圏は、$\Set$ではなく$\Hask$と呼ばれる。理論的な観点から見ると、これは果てしない複雑さの原因となる。だから、この時点で一連の推論を肉切り包丁で捌いて終わらせよう。実用的な観点からは、停止しない関数とボトムを無視し、$\Hask$を正真正銘の$\Set$として扱うことは問題ない^[Nils Anders Danielsson, John Hughes, Patrik Jansson, Jeremy Gibbons, *Fast and Loose Reasoning is Morally Correct*. <https://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf> この論文は、ほとんどの文脈でボトムを無視することの正当性を説明している。]。

## なぜ数学モデルが必要なのか？

プログラマーであるあなたは、自分が使っているプログラミング言語の構文と文法に精通している。言語のそれらの側面は、通常、言語仕様の冒頭で形式的な表記法によって記述される。一方で、言語の意味、すなわちセマンティクスを記述するのははるかに困難だ。より多くのページを必要とし、十分に形式的であることはほとんどなく、完全であることもほとんどない。それゆえ、言語法律家たちの間では終わりのない議論が交わされ、言語標準の細かい解釈を目的とした書籍が家内工業的に出版されている。

言語のセマンティクスを記述するための形式手法ツールは存在するが、複雑なため、ほとんどの場合は簡略化された学術言語で使われ、実用される巨大なプログラミング言語ではあまり使われない^[監訳者註：注目に値する例外の一つがWebAssemblyである。]。そのようなツールのうち[*操作的意味論*]{.keyword #operational_semantics}\index{操作的意味論} (operational semantics) と呼ばれるものは、プログラム実行の仕方を記述する。それは形式化され理想化されたインタープリターを定義する。C++のような産業用言語のセマンティクスは通常、操作的挙動に関する非形式的な議論により「抽象機械」として述べられることが多い。

問題は、操作的意味論を使ってプログラムに関することを証明するのが非常に難しいことだ。プログラムの性質を示すには、基本的には理想化されたインタープリターを通して「実行」しなければならない^[監訳者註：こちらは言いすぎであるように思われる。監訳者の感覚的には、操作的意味論に基づくプログラムの性質の証明を指して「（プログラムを）『実行』しなければならない」と言うことは、多くの場合そういった証明が操作に関する数学的帰納法に基いて行われることを考えると、自然数の上の数学的帰納法に基づく証明を指して「（数を）『数え』なければならない」と言っているように聞こえる。また、表示的意味論については、しばしばそれそのものの記述に比較的高度な数学的道具が必要となる。たとえば、停止しない関数を扱うためには、ボトムを追加するのだけでは十分ではなく、止まらないかもしれないループや再帰定義を数学的に解釈するための構造も必要となる。]。

プログラマーが正しさを形式的に証明しないことは問題ではない。我々はいつも正しいプログラムを書いていると「思っている」。キーボードの前に座って、「さて、コードを数行打ち込んで、何が起こるか見てみよう」と言う人はいない。我々は、作成するコードが望ましい結果を生み出す特定のアクションを実行すると考えている。そうならない場合、たいていかなり驚くことになる。つまり、我々は自分が書いたプログラムについて推論していて、通常は頭の中でインタープリターを走らせることでそうしている。すべての変数を追跡するのは極めて難しい。コンピューターはプログラムを実行するのが得意だが、人間は不得意だ！
もし得意だったら、コンピューターは必要ないだろう。

しかし、別の選択肢もある。それは[*表示的意味論*]{.keyword #denotational_semantics}\index{表示的意味論} (denotational semantics) と呼ばれ、数学に基づいている。表示的意味論では、すべてのプログラム要素に数学的解釈が与えられる。それを使えば、プログラムの性質を証明したいときは数学的定理を証明するだけでよい^[監訳者註：操作的意味論を用いた場合もプログラムの性質を証明するのは数学的定理を証明することになる。]。定理を証明するのは難しいと思うかもしれないが、実際には、人類は数千年にわたって数学的手法を構築してきたので、利用できる知識が豊富に蓄積されている。また、プロの数学者が証明する定理と比べると、プログラミングで遭遇する問題は、自明ではないにせよ、通常は極めて単純なものだ。

表示的意味論ととても相性が良い言語であるHaskellで階乗関数の定義を考えてみよう：

```haskell
fact n = product [1..n]
```

\noindent
式`[1..n]`は、`1`から`n`までの整数のリストだ。関数`product`は、リストのすべての要素を乗算する。これは数学の教科書に載っている階乗の定義と同じだ。これをCと比較してほしい：

```c
int fact(int n) {
    int i;
    int result = 1;
    for (i = 2; i <= n; ++i)
        result *= i;
    return result;
}
```

\noindent
これ以上言う必要があるだろうか？

確かに、不当な批判だったのは真っ先に認めよう！
そもそも階乗関数には自明な数学的解釈がある。鋭い読者なら「キーボードから文字を読み取ったり、ネットワークを介してパケットを送信したりするための数学的モデルは何か？」と尋ねるだろう。長きに渡って、それはかなり複雑な説明につながる面倒な質問だった。有用なプログラムを書くために不可欠な多くの重要なタスクには、表示的意味論は最適でないように思われたが、操作的意味論では容易に解決できた。突破口は圏論からもたらされた。エウジニオ・モッジ (Eugenio Moggi) によって、計算作用をモナドに写せることが発見された。これは表示的意味論に新たな生命を与え、純粋関数プログラムをより使いやすくするだけでなく、従来のプログラミングに新たな光を当てる重要な観察となった。モナドについては後ほど、より多くの圏論的な道具立てを説明するときに述べる。

プログラミングに数学的モデルがあることの重要な利点の1つは、ソフトウェアの正しさを形式的に証明できることだ^[監訳者註：繰り返すが、操作的意味論でも可能である。]。消費者向けのソフトウェアを書く際にはそれほど重要でないように思えるだろうが、失敗の代償が法外なものになったり人命が危険にさらされたりするようなプログラミングの領域もある。もっとも、医療システム用のWebアプリケーションを作成する場合でさえ、Haskell標準ライブラリの関数やアルゴリズムが正しさの証明を伴うというアイデアに価値を見出すだろう。

## 純粋関数と非純粋関数

C++やその他の命令型言語で関数と呼ぶものは、数学者が関数と呼ぶものとは異なる。数学関数は値から値への写像にすぎない。

数学関数はプログラミング言語で実装できる。そのような関数は、入力値が与えられると、出力値を計算する。数の2乗を生成する関数は、入力値をそれ自身で乗算するはずだ。この関数は呼び出すたびに同じことを行い、同じ入力で呼び出されるたびに同じ出力を生成することが保証されている。数の2乗は月の満ち欠けによって変化しない。

また、数の2乗を計算することで犬においしい餌を出すという副作用があってはならない。それを行う「関数」は数学関数として簡単にモデル化できない。

プログラミング言語では、同じ入力に対して常に同じ結果を生成し副作用のない関数は[*純粋関数*]{.keyword #pure_function}\index{純粋関数} (pure function) と呼ばれる。Haskellのような純粋関数型言語では、すべての関数が純粋だ^[監訳者註：この言明の背景として、停止しない場合（作用のひとつ）を無視していることに注意されたい。]。そのため、これらの言語に表示的意味論を与え、圏論でモデル化することが容易になる。他の言語の場合は、純粋なサブセットだけを使うように制限したり、副作用を切り分けて扱ったりすることは常に可能だ。モナドによって、純粋関数のみを使ってあらゆる種類の作用をモデル化する方法については、後ほど説明する。数学的関数だけという制約を課しても何も失われないのだ。

## 型の例

型が集合であることを理解すれば、ややエキゾチックな型を考えられる。たとえば、空集合に対応するのはどんな型だろう？
それは決してC++の`void`ではないが、Haskellでは`Void`と呼ばれている。その型には値が存在しない。`Void`を引数に取る関数は、定義はできるが呼び出せない。呼び出すには`Void`型の値を提供する必要があるが、それは存在しないからだ。この関数が返す内容に関しては、何ら制限はない。それは任意の型を返せる（ただし、呼び出せないため、返すことはない）。言い換えると、戻り値の型が多相な関数だ。Haskell使いたちはこう呼ぶ：

```haskell
absurd :: Void -> a
```

\noindent
（`a`は任意の型を表せる型変数なのを覚えておいてほしい。）この名前は偶然ではない^[訳註：absurdは「理屈に合わない・不条理な」を表す形容詞。その名詞形absurdityは特に論理学においては矛盾を指す。]。型と関数を論理の言葉でより深く解釈したCurry-Howard同型と呼ばれるものが存在する。型`Void`は矛盾を表し、関数`absurd`の型は「矛盾からは何でも導ける」というラテン語の格言 "ex falso sequitur quodlibet" に対応している^[訳註：この格言の内容は論理学では爆発律 (principle of explosion) と呼ばれる。]。

次は、単集合に対応する型だ。これが持てる値は1つしかない。その値は単に "is" だ。すぐには分からないかもしれないが、これがC++の`void`だ。この型を引数に取る関数と、この型を返す関数を考えてみてほしい。`void`を取る関数は常に呼び出せる。それが純粋関数なら、常に同じ結果を返す。そのような関数の例を示そう：

```c
int f44() { return 44; }
```

\noindent
この関数は引数に取るものが「何もない」のだと思うかもしれないが、先ほど見たように、「何もない」を取る関数は決して呼び出されない。「何もない」を表す値がないからだ。この関数は何を取るのだろうか？
概念的には、インスタンスが1つしか存在しないダミー値を取る。そのため、その値に明示的に言及する必要はない。しかしHaskellでは、その値を表す記号として、空の括弧のペア`()`がある。こうして、奇妙な偶然（これは偶然なのか？）によって、voidに対する関数の呼び出しはC++とHaskellで同じように見える。また、Haskellは簡潔さを好むので、同じシンボル`()`が型、コンストラクター、そして単集合に対応する唯一の値に使われる。この関数をHaskellで書くとこうなる：

```haskell
f44 :: () -> Integer
f44 () = 44
```

\noindent
最初の行は、`f44`が "unit" と発音される型`()`を型`Integer`に写すことを宣言している。2番目の行は`f44`を、unitの唯一のコンストラクター`()`に対してパターンマッチングを行い、44という数を返すことによって定義している。この関数を呼び出すにはunitの値`()`を与える：

```haskell
f44 ()
```

\noindent
unitのどの関数も、結果の型から1つの要素を選択するのと等価であることに注意してほしい（ここでは`Integer`である44を選択する）。実際、`f44`は数44の別の表現と見なせる。これは、集合の要素への明示的な言及の代わりに関数（矢）についての議論に置き換える方法の例だ。unitからどんな型$A$へのどんな関数も、その集合$A$の要素と1対1で対応している。

`void`型を返す関数や、Haskellでunit型を返す関数はどうだろうか？
C++ではそのような関数が副作用を目的として使われるものの、数学的な意味での本当の関数ではないのは分かっている。unitを返す純粋関数は何もせず、引数を破棄する。

数学的には、集合$A$から単集合への関数は$A$のすべての要素をその単集合の単一の要素に写す。$A$ごとに、そのような関数が1つだけ存在する。`Integer`に対するこの関数は次のとおりだ：

```haskell
fInt :: Integer -> ()
fInt x = ()
```

\noindent
任意の整数を与えると、unitが返される。簡潔さの精神で、Haskellでは、破棄する引数をワイルドカード・パターンであるアンダースコアで示せる。この方法なら引数に名前を付ける必要はない。よって、上記は次のように書き直せる：

```haskell
fInt :: Integer -> ()
fInt _ = ()
```

\noindent
この関数の実装は、渡された値に依存しないだけでなく、引数の型にも依存しないことに注目してほしい。

どの型に対しても同じ式で実装できる関数は、パラメトリック多相関数 (parametrically polymorphic function) と呼ばれる。そのような関数の族 (family) はすべて、具体的な型の代わりに型パラメーターを使う1つの等式によって実装できる。任意の型からunit型への多相関数を何と呼ぶべきだろう？
もちろん`unit`と呼ぶ：

```haskell
unit :: a -> ()
unit _ = ()
```

\noindent
C++では、この関数を次のように記述する：

```cpp
template<class T>
void unit(T) {}
```

\noindent
型の類型学における次のものは2要素集合だ。C++では`bool`と呼ばれ、Haskellでは予想どおり`Bool`と呼ばれる。違いは、C++の`bool`は組み込みの型であるのに対して、Haskellでは次のように定義できることだ：

```haskell
data Bool = True | False
```

\noindent
（この定義の読み方は`Bool` is `True` or `False`だ。）
原理的には、C++でもBoolean型を列挙型として定義できるはずだ：

```cpp
enum bool {
    true,
    false
};
```

\noindent
しかし、C++の`enum`は密かに整数だ。C++11の "`enum class`" を代わりに使うこともできたが、その場合は、`bool::true`や`bool::false`のように、クラス名で値を修飾する必要がある。そして、言うまでもなく、それを使うすべてのファイルに適切なヘッダを含める必要がある。

`Bool`を取る純粋関数は、結果の型から2つの値を選択するだけだ。1つは`True`に対応し、もう1つは`False`に対応する。

`Bool`を返す関数は[*述語*]{.keyword #predicate}\index{述語} (predicate) と呼ばれる。たとえば、Haskellライブラリ`Data.Char`は`isAlpha`や`isDigit`のような述語でいっぱいだ。C++には`isalpha`や`isdigit`などを定義する同様のライブラリがあるが、これらはブール値ではなく`int`を返す。実際の述語は`std::ctype`で定義され、`ctype::is(alpha, c)`、`ctype::is(digit, c)`などの形式がある。

## 課題

#. 任意の言語で高階関数（または関数オブジェクト）`memoize`を定義せよ。この関数は純粋関数`f`を引数として受け取り、次の点を除いて`f`と同じ動作をする関数を返す。すなわち、`momoize`の結果として返される関数は、もとの関数を引数ごとに1回だけ呼び出し、結果を内部に格納し、その後は同じ引数で呼び出されるたびに格納済みの結果を返す。メモ化 (memoize) された関数ともとの関数は、パフォーマンスを見れば区別できる。たとえば、評価に時間のかかる関数のメモ化を試みること。最初に呼び出したときは結果を待つ必要があるが、同じ引数を使って次に呼び出したときは結果をすぐ得られるだろう。

#. 乱数を生成するためにあなたが普段使う標準ライブラリ関数をメモ化してみよ。うまくいくか？

#. ほとんどの乱数発生器はシードで初期化できる。シードを受け取り、そのシードで乱数発生器を呼び出し、結果を返す関数を実装せよ。その関数をメモ化せよ。うまくいくか？

#. 以下のC++関数のうち、純粋なのはどれか？
   これらをメモ化してみて、何度も呼び出したときに何が起こるかを、メモ化した場合とそうでない場合について観察せよ。

   #. 本文中で例示した階乗関数。

   #.

       ```cpp
       std::getchar()
       ```

   #.

       ```cpp
       bool f() {
           std::cout << "Hello!" << std::endl;
           return true;
       }
       ```

   #.

       ```cpp
       int f(int x) {
           static int y = 0;
           y += x;
           return y;
       }
       ```

#. `Bool`を取り`Bool`を返す関数は何種類あるか？
   それらすべてを実装できるか？

#. `Void`型、`()` (unit) 型、`Bool`型だけを対象とする圏の絵を描け。ただし、矢についてはこれらの型の間のすべての可能な関数に対応するようにせよ。矢には関数名のラベルを付けよ。
