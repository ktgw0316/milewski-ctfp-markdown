# 自然変換 {#natural-transformations}

圏と圏との間で構造を保存する写像としての関手について述べた。関手は、ある圏を別の圏に「埋め込む」。複数のものを1つに潰すことはできるが、接続が切断されることはない。1つの考え方は、関手を使ってある圏を別の圏の中にモデル化していると捉えることだ。始域圏は、終域圏の一部である構造物のモデル、あるいは青写真として機能する。

![](images/1_functors.jpg){width=40%}

ある圏を別の圏に埋め込む方法はいろいろある。それらは同等の場合もあれば、大きく異なる場合もある。始域圏全体を1つの対象に潰すこともあれば、すべての対象を異なる対象に写し、すべての射を異なる射に写すこともある。同じ青写真を現実化する方法はいろいろある。自然変換は、それらの現実化方法を比較するのに役立つ。それらは関手の写像であり、その関手的性質を保存する特別な写像だ。

圏$\cat{C}$と$\cat{D}$の間に$F$と$G$という2つの関数があるとする。$\cat{C}$内の1つの対象$a$だけに注目すると、それは2つの対象$F\ a$と$G\ a$に写されている。したがって、関手の写像では$F\ a$を$G\ a$に写す必要がある。

![](images/2_natcomp.jpg){width=30%}

Notice that $F\ a$ and $G\ a$ are objects in the same category $\cat{D}$. 同じ圏内の対象間の写像は、圏の特性に反するものであってはならない。対象同士の間に人工的な接続を作成したくはない。So it's *natural* to use existing connections, namely morphisms. 自然変換は射の選択であり、対象$a$ごとに$F\ a$から$G\ a$への射を1つ選択する。自然変換を$\alpha$と呼ぶ場合、この射は$\alpha$の$a$における<g3>コンポーネント</g3>{.keyword #component} (component) または$\alpha_a$と呼ばれる。

$$\alpha_a \Colon F\ a \to G\ a$$

$a$は$\cat{C}$の対象であり、$\alpha_a$は$\cat{D}$の射であることに注意してほしい。

ある$a$について、$\cat{D}$内の$F\ a$と$G\ a$の間に射がない場合、$F$と$G$の間に自然変換はない。

もちろん、これは話の半分にすぎない。なぜなら、関手は対象を写すだけでなく、射も写すからだ。では自然変換はこれらの写像をどうするのだろうか？
射の写像は固定されている――$F$と$G$の間の自然変換では、$F\ f$は$G\ f$に変換されなければならない。さらに、2つの関手による射の写像は、それに適合する自然変換を定義する際の選択肢を大幅に制限する。$\cat{C}$の2つの対象$a$と$b$の間に射$f$があるとする。それは$\cat{D}$内の2つの射、$F\ f$と$G\ f$に写されている。

$$
\begin{gather*}
F f \Colon F a \to F b \\
G f \Colon G a \to G b
\end{gather*}
$$

自然変換$\alpha$は、$\cat{D}$内で図式を完成させる2つの追加の射を提供する。

$$
\begin{gather*}
\alpha_a \Colon F\ a \to G\ a \\
\alpha_b \Colon F\ b \to G\ b
\end{gather*}
$$

![](images/3_naturality.jpg){width=40%}

いま、$F\ a$から$G\ b$への移行には2つの方法がある。これらが等しいことを確認するには、$f$に適用される[自然性条件]{.keyword #naturality_condition} (naturality condition) を強制する必要がある:

$$G\ f \circ \alpha_a = \alpha_b \circ F\ f$$

自然条件はかなり厳しい要件だ。たとえば、射$F\ f$が可逆である場合、自然性は、$\alpha_a$に関して$\alpha_b$を決定する。それは$f$に沿って$\alpha_a$を*輸送* (transport) する:

$$\alpha_b = (G\ f) \circ \alpha_a \circ (F\ f)^{-1}$$

![](images/4_transport.jpg){width=40%}

2つの対象間に2つ以上の可逆な射がある場合、これらの輸送はすべて一致する必要がある。ただし、一般に、射は可逆ではない。しかし、2つの関手間に自然変換が存在することは全く保証されていないことがわかる。したがって、自然変換によって関連する関手が多いか少ないかは、それらが作用する圏の構造について多くのことを教えてくれるだろう。極限と米田の補題について話すときに、いくつかの例を見ることになる。

自然変換をコンポーネントごとに見ると、対象を射に写していると言える。自然条件によって、それは射を可換な正方図式に写しているとも言えるだろう――$\cat{C}$のすべての射に対して$\cat{D}$内に可換な自然性の正方図式が1つある。

![](images/naturality.jpg){width=40%}

自然変換のこの性質は、多くの圏の構造 (可換図式を含むことが多い) で非常に便利になる。関手を適切に選択すれば、これらの可換性条件の多くは自然条件に変換できる。その例は、極限・余極限・随伴に辿り着いたときに見ることになるだろう。

最後に、自然変換を使って関手の同型を定義できる。2つの関手が自然に同型であると言うのは、全く同じだと言っているようなものだ。[自然同型]{.keyword #natural_isomorphism} (natural isomorphism) は、コンポーネントがすべて同型 (可逆な同型) である自然変換として定義される。

## 多相関数

プログラミングにおける関手 (より具体的には自己関手) の役割について話した。それらは型を型に写す型コンストラクターに対応している。また、関数を関数に写し、その写像は高階関数`fmap` (あるいはC++では`transform`, `then`など) によって実装される。

自然変換を構築するにはまず対象から、ここでは型`a`から始める。それを、ある関手`F`は型$F\ a$に写す。別の関手`G`は$G\ a$に写す。`a`における自然変換`alpha`のコンポーネントは、$F\ a$から$G\ a$への関数だ。疑似Haskellでは:

$$\alpha_a \Colon F\ a \to G\ a$$

自然変換は、すべての型`a`に対して定義される多相関数だ。

```haskell
alpha :: forall a . F a -> G a
```

Haskellでは`forall`はオプションだ (そして実際に言語拡張`ExplicitForAll`を有効にする必要がある)。通常は、次のように記述する:

```haskell
alpha :: F a -> G a
```

これは実際には`a`によってパラメータ化された一連の関数であることに注意してほしい。これは、Haskellの構文の簡潔さのもう1つの例だ。C++では同様の構文はもう少し冗長になる:

```cpp
template<class A> G<A> alpha(F<A>);
```

Haskellの多相 (polymorphic) 関数とC++の総称 (generic) 関数との間にはさらに大きな違いがあり、それらの関数の実装や型チェックの方法に反映されている。Haskellでは、多相関数はすべての型に対して一様に定義されなければならない。1つの式があらゆる型にわたって機能する必要がある。これは*パラメトリック多相*と呼ばれる。

一方、C++はデフォルトで[アドホック多相]{.keyword #ad_hoc_polymorphism} (ad hoc polymorphism) をサポートしており、テンプレートはすべての型に対して明確に定義されている必要はない。ある型に対してテンプレートが機能するかどうかは、型パラメータに具体的な型が代入されるインスタンス化時に決定される。型チェックが遅延されるため、残念ながら、理解できないエラーメッセージにつながることがよくある。

C++には、関数のオーバーロードとテンプレートの特殊化のためのメカニズムもあり、同じ関数で異なる型に対して異なる定義を行える。Haskellでは、この機能は型クラスと型ファミリーによって提供されている。

Haskellのパラメトリック多相は予想外の結果をもたらす: 型のあらゆる多相関数:

```haskell
alpha :: F a -> G a
```

ここで、`F`と`G`は関数で、自動的に自然条件を満たす。ここでは、圏論の表記法で表す ($f$は関数$f \Colon a \to b$だ)。

$$G\ f \circ \alpha_a = \alpha_b \circ F\ f$$

Haskellでは、関手`f`の射`G`に対する作用は`fmap`を使って実装される。最初に疑似Haskellで、明示的な型アノテーションを付けて書く:

$$fmap_G f . alpha_a = alpha_b . fmap_F f$$

型推論によって、これらのアノテーションは不要になり、次の方程式が成立する:

```haskell
fmap f . alpha = alpha . fmap f
```

これはまだ本物のHaskellではない――関数の等値性がコードで表現できない――しかし、これは恒等射であり、プログラマーが等式推論で、あるいはコンパイラが最適化を実装するのに使える。

Haskellで自然条件が自動である理由は、"theorems for free" に関係している。Haskellで自然変換を定義するのに使われるパラメトリック多相は、実装に非常に強い制限を課す――すべての型に対して1つの式だ。これらの制限は、そのような関数に関する等式定理に変換される。関手を変換する関数の場合、free定理は自然条件だ。(You may read more about free theorems in my blog [Parametricity: Money for Nothing and Theorems for Free](https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/ "Parametricity: Money for Nothing and Theorems for Free").)

関手についてHaskellで考える1つの方法として先に述べたのは、汎用化されたコンテナと見なす方法だった。この類推を続けて、自然変換を、あるコンテナの中身を別のコンテナに再パッケージするレシピと見なせる。要素自体に触れることはない: 要素を変更したり、新しい要素を作成したりはしない。それら (の一部) を、時には複数回、新しいコンテナにコピーしているだけだ。

自然条件は、最初に`fmap`を適用して要素を変更してから後で再パッケージするのか、それとも最初に再パッケージしてから`fmap`を独自に実装して新しいコンテナ内の要素を変更するのか、は問題ではないという宣言になる。再パッケージ化と`fmap`の2つの作用は直交している。「一方は卵を動かし、もう一方は茹でる。」

Haskellでの自然変換の例をいくつか見てみよう。1つ目はlist関手と`Maybe`関手の間だ。これはリストの頭部を返すが、リストが空でない場合に限る:

```haskell
safeHead :: [a] -> Maybe a
safeHead [] = Nothing
safeHead (x:xs) = Just x
```

`a`について多相な関数だ。`a`がどんな型であっても制限なく機能するので、パラメトリック多相の一例だ。そのため、これら2つの関手の間の自然変換だ。しかし、納得するために、自然条件を証明してみよう。

```haskell
fmap f . safeHead = safeHead . fmap f
```

考慮すべき2つのケースがある。1つは空リストだ:

```haskell
fmap f (safeHead []) = fmap f Nothing = Nothing
```

```haskell
safeHead (fmap f []) = safeHead [] = Nothing
```

もう1つは空でないリストだ:

```haskell
fmap f (safeHead (x:xs)) = fmap f (Just x) = Just (f x)
```

```haskell
safeHead (fmap f (x:xs)) = safeHead (f x : fmap f xs) = Just (f x)
```

ここで、`fmap`の実装として以下の2つを利用した。リスト用:

```haskell
fmap f [] = []
fmap f (x:xs) = f x : fmap f xs
```

`Maybe`用:

```haskell
fmap f Nothing = Nothing
fmap f (Just x) = Just (f x)
```

興味深いケースは、関手の1つが自明な`Const`関手である場合だ。`Const`関手からの自然変換、あるいは`Const`関手への自然変換は、戻り値の型か引数の型のどちらかについて多相な関数のように見える。

たとえば、`length`はlist関手から`Const Int`関手への自然変換と見なせる。

```haskell
length :: [a] -> Const Int a
length [] = Const 0
length (x:xs) = Const (1 + unConst (length xs))
```

ここで、`unConst`は`Const`コンストラクタを引き剥がすのに使われる:

```haskell
unConst :: Const c a -> c
unConst (Const x) = x
```

当然、実用上は`length`は次のように定義される:

```haskell
length :: [a] -> Int
```

これは実質的に、自然変換であるという事実を隠してしまう。

`Const`関手*から*のパラメトリック多相関数を見つけるのは少し難しい。無から値を生成する必要があるからだ。我々にできる最善のことは、次のとおりだ:

```haskell
scam :: Const Int a -> Maybe a
scam (Const x) = Nothing
```

すでに見たもう1つの一般的な関手で、後ほど米田の補題で重要な役を果たすのは、`Reader`関手だ。定義を`newtype`に書き直そう:

```haskell
newtype Reader e a = Reader (e -> a)
```

これは2つの型によってパラメータ化されているが、(共変的に) 関手的なのは2番目の型だけだ:

```haskell
instance Functor (Reader e) where
    fmap f (Reader g) = Reader (\x -> f (g x))
```

すべての型`e`について、`Reader e`から他の任意の関手`f`への自然変換の族を定義できる。この族のメンバーが常に`f e`の要素と1対1で対応している ([米田の補題](#the-yoneda-lemma)) ことを後で説明する。

たとえば、1つの要素`()`を持つ、ある意味で自明な単位型`()`について考えてみよう。関手`Reader ()`は、任意の型`a`を取り、それを関数型`() -> a`に写す。これらは単に、集合`a`から1つの要素を選択するすべての関数だ。`a`にある要素と同じ数だけある。ここで、この関手から`Maybe`関手への自然変換を考えてみよう。

```haskell
alpha :: Reader () a -> Maybe a
```

あるのは`dumb`と`obvious`の2つだけだ:

```haskell
dumb (Reader _) = Nothing
```

かつ

```haskell
obvious (Reader g) = Just (g ())
```

(`g`でできる唯一のことは、それをunit値`()`に適用することだ。)

そして実際、米田の補題によって予言されるように、これらは`Maybe ()`型の2つの要素、`Nothing`と`Just ()`に対応している。We'll come back to the Yoneda lemma later — this was just a little teaser.

## 自然性を越えて

2つの関手間のパラメトリック多相関数 (`Const`関手のエッジケースを含む) は、常に自然変換だ。標準的な代数的データ型はすべて関手であるため、これらの型の間の多相関数はすべて自然変換だ。

また、自由に使える関数型もあり、それらは戻り値の型について関手的だ。それらを使って (`Reader`関手のような) 関手を構築し、高階関数である自然変換を定義できる。

ただし、関数型は引数について共変ではない。それらは[反変]{.keyword #contravariant} (contravariant) だ。当然、反変関手は反対圏からの共変関手と等価だ。2つの反変関手の間の多相関数は、反対圏からHaskellの型への関手を処理する点を除けば、圏論的には自然変換だ。

反変関手の例を前に見たのを覚えているだろう:

```haskell
newtype Op r a = Op (a -> r)
```

この関手は`a`について反変だ:

```haskell
instance Contravariant (Op r) where
    contramap f (Op g) = Op (g . f)
```

たとえば、`Op Bool`から`Op String`への多相関数を書ける:

```haskell
predToStr (Op f) = Op (\x -> if f x then "T" else "F")
```

ただし、2つの関手は共変ではないので、これは$\Hask$の自然変換ではない。しかし、どちらも反変なので、「反対」の自然条件は満たしている。

```haskell
contramap f . predToStr = predToStr . contramap f
```

次のような`contramap`のシグネチャのため、関数`f`は`fmap`で使うのとは逆方向でなければならないことに注意してほしい。

```haskell
contramap :: (b -> a) -> (Op Bool a -> Op Bool b)
```

共変にしろ反変にしろ、関手ではない型コンストラクターは存在するのだろうか？
次に例を示す:

```haskell
a -> a
```

同じ型`a`が負 (反変) と正 (共変) の両側で使われているので、これは関手ではない。この型には`fmap`や`contramap`を実装できない。したがって、次のシグネチャを持つ関数:

```haskell
(a -> a) -> f a
```

は自然変換にはなれない。ここで、`f`は任意の関手だ。興味深いことに、このような場合を扱う一般化された自然変換として、対角自然変換 (dinatural transformation) と呼ばれるものがある。これについてはエンドについて議論するときに説明しよう。

## 関手圏

関手間の写像――自然変換――ができた今、関手が圏を形成するかどうかを問うのは自然なことだ。そして実際に形成する！
$\cat{C}$と$\cat{D}$の圏のペアごとに、関手の圏が1つある。この圏の対象は$\cat{C}$から$\cat{D}$への関手であり、射はこれらの関手間の自然変換だ。

2つの自然変換の合成を定義する必要があるが、それは非常に簡単だ。自然変換のコンポーネントは射であり、射を合成する方法は知っている。

実際に、関手$F$から$G$への自然変換$\alpha$を取ろう。対象$a$におけるそのコンポーネントはこのような射だ:

$$\alpha_a \Colon F\ a \to G\ a$$

$\alpha$を、関手$G$から$H$への自然変換である$\beta$と合成したい。$a$での$\beta$のコンポーネントは次の射だ:

$$\beta_a \Colon G\ a \to H\ a$$

これらの射は合成可能であり、その合成は次のような別の射だ:

$$\beta_a \circ \alpha_a \Colon F\ a \to H\ a$$

この射を自然変換$\beta \cdot \alpha$――2つの自然変換を$\beta$より先に$\alpha$として合成したもの――のコンポーネントとして使う。

$$(\beta \cdot \alpha)_a = \beta_a \cdot \alpha_a$$

![](images/5_vertical.jpg){width=40%}

図式を (長く) 見ていると、この合成の結果は本当に$F$から$H$への自然変換だと確信できる。

$$H\ f \circ (\beta \cdot \alpha)_a = (\beta \cdot \alpha)_b \circ F\ f$$

![](images/6_verticalnaturality.jpg){width=35%}

自然変形の合成は結合的だ。なぜなら、それらの構成要素は正則 (regular) な射であり、合成に関して結合的であるからだ。

最後に、各関手$F$について恒等自然変換$1_F$があり、そのコンポーネントは恒等射だ。

$$\id_{F\ a} \Colon F\ a \to F\ a$$

したがって、確かに関手は圏を形成している。

記法について。ソーンダーズ・マックレーンにしたがって、私は先ほど述べたような自然変換の合成にドットを使う。問題は、自然変換を合成する方法が2つあることだ。これは、垂直合成 (vertical composition) と呼ばれている。なぜなら、通常は関数を上下に積んだ図式で説明されるからだ。垂直合成は関手圏を定義するうえで重要だ。水平合成についてもすぐに説明する。

![](images/6a_vertical.jpg){width=30%}

圏$\cat{C}$と$\cat{D}$の間の関手圏は、$\cat{Fun(C, D)}$または$\cat{[C, D]}$、場合によっては$\cat{D^C}$と書かれる。この最後の表記法は、関手圏自体が他の圏では関数オブジェクト (冪乗) と見なせることを示唆している。本当にそうだろうか？


これまでに構築してきた抽象化の階層を見てみよう。最初は対象と射の集まりとしての圏から始めた。圏自体 (厳密に言えば、対象が集合を形成する*小さな*圏) は、それ自体がより高いレベルの圏$\Cat$における対象だ。その圏における射は関手だ。$\Cat$におけるhom集合は関手の集合だ。たとえば、$\cat{Cat(C, D)}$は、2つの圏$\cat{C}$と$\cat{D}$の間の関手の集合だ。

![](images/7_cathomset.jpg){width=30%}

関手圏$\cat{[C, D]}$も、2つの圏の間の関手の集合だ (それと、射としての自然変換も加わる)。その対象は$\cat{Cat(C, D)}$のメンバーと同じだ。さらに、関手圏は圏なので、それ自体が$\Cat$の対象でなければならない (2つの小さい圏の間の関手圏自体が小さいこともある)。ある圏のhom集合と、同じ圏の対象の間の関係は知っている。この状況は、前の章で見た冪乗対象とまったく同じだ。後者を$\Cat$で構築する方法を見てみよう。

覚えているだろうが、冪乗を構成するには、まず積を定義する必要がある。$\Cat$では、これは比較的簡単であることがわかる。なぜなら、小さい圏は対象の*集合*であり、集合のカルテシアン積を定義する方法は知っているからだ。したがって、直積圏$\cat{C \times D}$内の対象は単なる対象のペア $(c, d)$ であり、$\cat{C}$と$\cat{D}$からそれぞれ1つ取ったものだ。同様に、2つのそのようなペア $(c, d)$ と $(c', d')$ の間の射は、射のペア $(f, g)$ であり、ここで$f \Colon c \to c'$および$g \Colon d \to d'$だ。これらの射のペアはコンポーネントごとに合成し、また、単なる恒等射のペアである恒等ペアが常に存在する。手短に言うと、$\Cat$は本格的なカルテシアン閉圏であり、そこにはあらゆる圏のペアに対する冪乗対象$\cat{D^C}$が存在する。そして、$\Cat$の「対象」は圏を意味するので、$\cat{D^C}$は圏であり、$\cat{C}$と$\cat{D}$の間の関手圏と同一視できる。

## 2-圏

もう心配いらないので、$\Cat$を詳しく見てみよう。定義より、$\Cat$内のすべてのHom集合は関手の集合だ。しかし、これまで見てきたように、2つの対象の間の関手は、単なる集合よりも豊かな構造を持っている。それらは圏を形成し、自然変換は射として作用する。関手は$\Cat$では射と見なされるので、自然変換は射の間の射だ。

このより豊かな構造は、圏の一般化である$\cat{2}$-圏の例であり、対象と射 (この文脈では$1$-射とも呼べる) の他に、射の間の射である$2$-射も存在する。

$\Cat$を$\cat{2}$-圏と見なす場合、次のようになる:

* 対象: (小さな) 圏
* 1-射: 圏の間の関手
* 2-射: 関手の間の自然変換。

![](images/8_cat-2-cat.jpg){width=30%}

2つの圏$\cat{C}$と$\cat{D}$の間のHom集合の代わりに、Hom圏――関手圏$\cat{D^C}$がある。正則関手合成がある: $\cat{D^C}$からの関手$F$は、$\cat{E^D}$からの関手$\cat{G}$と合成し、$\cat{E^C}$から$G \circ F$を与える。しかし、それぞれのHom圏内での合成――自然変換の垂直合成、つまり2つの射、が関手間にある。

2種類の合成が$\cat{2}$-圏にあるので、それらはどのように相互作用するのか、という疑問が生じる。

$\Cat$内の2つの関手、つまり1つの射を選択しよう:

$$
\begin{gather*}
F \Colon \cat{C} \to \cat{D} \\
G \Colon \cat{D} \to \cat{E}
\end{gather*}
$$

これらの合成は次のとおりだ:

$$G \circ F \Colon \cat{C} \to \cat{E}$$

$\alpha$と$\beta$という2つの自然変換があって、それぞれ$F$と$G$に作用するとする:

$$
\begin{gather*}
\alpha \Colon F \to F' \\
\beta \Colon G \to G'
\end{gather*}
$$

![](images/10_horizontal.jpg){width=40%}

$\alpha$の終域と$\beta$の始域が異なるため、このペアには垂直合成を適用できないのに注意してほしい。実際、彼らは別々の関手圏$\cat{D^C}$と$\cat{E^D}$のメンバーだ。しかし、関手$F'$と$G'$に合成を適用することはできる。なぜなら、$F'$の終域も$G'$の始域も圏$\cat{D}$だからだ。関手$G' \circ F'$と$G \circ F$はどのような関係だろうか？


$\alpha$と$\beta$を自由に使えるので、$G \circ F$から$G \circ F'$への自然変換を定義できるだろうか？
構成をスケッチしよう。

![](images/9_horizontal.jpg){width=50%}

いつものように、$\cat{C}$内の対象$a$から始める。その像は$\cat{D}$の2つの対象$F\ a$と$F'a$に分割される。また、$\alpha$のコンポーネントである射が2つの対象を接続している。

$$\alpha_a \Colon F\ a \to F'a$$

$\cat{D}$から$\cat{E}$に移行するとき、これら2つの対象はさらに4つの対象$G(F\ a)$、$G'(F\ a)$、$G'(F'a)$、$G'(F'a)$ に分割される。正方図式を生成する4つの射もある。これらの射のうちの2つは、自然変換$\beta$のコンポーネントだ。

$$
\begin{gather*}
\beta_{F\ a} \Colon G (F\ a) \to G'(F\ a) \\
\beta_{F'a} \Colon G (F'a) \to G'(F'a)
\end{gather*}
$$

他の2つは、2つの関手による$\alpha_a$の像だ (関手は射を写す)。

$$
\begin{gather*}
G \alpha_a \Colon G (F\ a) \to G (F'a) \\
G'\alpha_a \Colon G'(F\ a) \to G'(F'a)
\end{gather*}
$$

射がとても多い。目標は、$G(F\ a)$ から$G'(F'a)$ への射を見つけることだ。これは2つの関手$G \circ F$と$G \circ F'$を接続する自然変換のコンポーネントの候補だ。実際、$G(F\ a)$ から$G'(F'a)$ への道は1つではなく2つある。

$$G'\alpha_a \circ \beta_{F\ a}$$
$$\beta_{F'a} \circ G \alpha_a$$

幸運なことに、それらは同じだ。なぜなら、我々が生成した正方図式は$\beta$の自然性の正方図式だからだ。

$G \circ F$から$G \circ F'$への自然変換のコンポーネントが定義できた。この変換に対する自然性の証明は、十分に忍耐強い人にとっては、非常に簡単だ。

この自然変換を、$\alpha$と$\beta$の[水平合成]{.keyword #horizontal_composition} (horizontal composition) と呼ぶ:

$$\beta \circ \alpha \Colon G \circ F \to G' \circ F'$$

ここでも私はマックレーンに従って、水平合成を表すのに小さな円を使うが、代わりに星が使われることもある。

圏論のルールをまとめると、合成があるたびに圏を探すべきだ、となる。自然変換の垂直合成があり、それは関手圏の一部だ。しかし、水平合成はどうだろうか？
それはどの圏にあるのだろう？


これを解明する方法は、$\Cat$を横から見ることだ。自然変換を、関手の間の矢としてではなく、圏の間の矢として見てほしい。自然変換は、それが変換する関手で接続された2つの圏の間に位置する。この2つの圏を結びつけるものと見なせる。

![](images/sideways.jpg){width=50%}

ここでは$\Cat$の2つの対象――圏$\cat{C}$と$\cat{D}$に焦点を当てる。$\cat{C}$を$\cat{D}$に接続する関手間をつなぐ自然変換の集合がある。それらの自然変換は$\cat{C}$から$\cat{D}$への新しい矢だ。同じトークンによって、$\cat{D}$を$\cat{E}$に接続する関手間をつなぐ自然変換が存在する。これは$\cat{D}$から$\cat{E}$へ向かう新しい矢として扱える。水平合成はこれらの矢の合成だ。

また、$\cat{C}$から$\cat{C}$への恒等射もある。これは恒等自然変換であり、$\cat{C}$上の恒等関手をそれ自体に写す。水平合成の恒等射は垂直合成の恒等射でもあるが、逆は成り立たないことに注意してほしい。

最後に、2つの合成は交換則を満たす:

$$(\beta' \cdot \alpha') \circ (\beta \cdot \alpha) = (\beta' \circ \beta) \cdot (\alpha' \circ \alpha)$$

ここでソーンダーズ・マックレーンの言葉を引用しよう:「読者はこの事実を証明するのに必要となる証明の図式を書き下すと楽しいだろう。」

あともう1つ、将来役に立つだろう表記法がある。$\Cat$のこの新しい横方向の解釈では、対象から対象へ行く方法が2つある: 関手を使う方法と自然変換を使う方法だ。しかし、関手の矢を特別な種類の自然変換、つまりその関手に作用する恒等自然変換として再解釈することはできる。したがって、このような記法をよく目にするだろう:

$$F \circ \alpha$$

ここで、$F$は$\cat{D}$から$\cat{E}$への関手で、$\alpha$は$\cat{C}$から$\cat{D}$への2つの関手間の自然変換だ。関手と自然変換は合成できないので、これは恒等自然変換$1_F$を$\alpha$の後に水平合成したものと解釈される。

同様に:

$$\alpha \circ F$$

は$\alpha$を$1_F$の後に水平合成したものだ。

## おわりに

これで本の第1部は終わりだ。我々は圏論の基本的な語彙を学んだ。対象・圏は名詞、射・関手・自然変換は動詞と見なせる。射は対象を接続し、関手は圏を接続し、自然変換は関手を接続する。

しかし、ある抽象化レベルで作用として現れるものが、次のレベルでは対象になるのも見てきた。射の集合は関数オブジェクトになる。対象としては、それは別の射の始域や終域になり得る。それが高階関数の背景にある概念だ。

関手は対象を対象に写すため、型コンストラクタやパラメトリック型として使える。関手は射も写すので、高階関数`fmap`だ。`Const`・積・余積などの単純な関手がいくつかあって、さまざまな代数的データ型の生成に使える。関数型も共変と反変の両方について関手的で、代数的データ型を拡張するのに使える。

関手は関手圏での対象とも見なせる。そのようにして、それらは自然変換、すなわち射の始域および終域になる。自然変換は特別な多相関数だ。

## 課題

1. `Maybe`関手からlist関手への自然変換を定義せよ。その自然条件を証明せよ。

2. `Reader ()`とlist関手の間に、少なくとも2つの異なる自然変換を定義せよ。`()`のリストは何種類あるか？


3. `Reader Bool`と`Maybe`を使って前の課題を続けよ。

4. 自然変換の水平合成が自然条件を満たしていることを示せ (ヒント: コンポーネントを使う)。これは図式を追ういい練習になる。

5. 交換則を証明するために必要な明確な図を描くのを楽しむ方法について、短いエッセイを書け。

6. 異なる`Op`関手間の変換の反対の自然条件について、テストケースをいくつか作成せよ。選択肢の1つはこうだ:

   ```haskell
   op :: Op Bool Int
       op = Op (\x -> x > 0)
   ```

   かつ

   ```haskell
   f :: String -> Int
       f x = read x
   ```
