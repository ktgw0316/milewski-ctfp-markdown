# 関手 {#functors}

壊れたレコードのように聞こえるかもしれないが、関手についてこう述べておきたい：関手は非常に単純だが強力な概念だ。圏論はこのような単純だが強力な概念であふれている。関手は圏の間の写像だ。2つの圏$\cat{C}$と$\cat{D}$について、関手$F$は$\cat{C}$の対象を$\cat{D}$の対象に写す。これは対象についての関数だ。$a$が$\cat{C}$内の対象である場合に、$\cat{D}$内の像を$F a$と（括弧なしで）書くことにする。しかし、圏は単に対象の集まりではない――対象とそれらを接続する射からなる。関手は射も写す――射についての関数だ。ただし、射を行きあたりばったりに写すわけではない――接続を維持して写す。
つまり、$\cat{C}$内の射$f$が対象$a$を対象$b$に接続する場合：
$$f \Colon a \to b$$
$\cat{D}$内の$f$の像$F f$は、$a$の像を$b$の像に接続する：
$$F f \Colon F a \to F b$$
（これは数学的記法とHaskellの記法を組み合わせたものであり、ここでは理にかなっているだろう。対象や射に関数を適用するときは括弧を使わないことにする。）

`\begin{figure}[H] \centering`{=latex}
![](images/functor.jpg){width=30%}
`\end{figure}`{=latex}

\noindent
ご覧のとおり、関手は圏の構造を保存している。一方の圏で接続されているものは、もう一方の圏でも接続されている。しかし、圏の構造にはそれ以上の何かがある。それは射の合成だ。$h$が$f$と$g$の合成：
$$h = g \circ f$$
である場合、$F$による$h$の像が$f$と$g$の像の合成になるようにしたい：
$$F h = F g \circ F f$$

`\begin{figure}[H] \centering`{=latex}
![](images/functorcompos.jpg){width=30%}
`\end{figure}`{=latex}

\noindent
最後に、$\cat{C}$内のすべての恒等射が$\cat{D}$内の恒等射に写されるようにしたい：
$$F \idarrow[a] = \idarrow[F a]$$
ここで、$\idarrow[a]$は対象$a$における恒等射を、$\idarrow[F a]$は$F a$における恒等射を表す。

`\begin{figure}[H] \centering`{=latex}
![](images/functorid.jpg){width=30%}
`\end{figure}`{=latex}

\noindent
これらの条件によって、関手は通常の関数よりもはるかに制約が厳しくなることに注意してほしい。関手は圏の構造を保存しなければならない。圏を、射のネットワークによって織りなされた対象の集まりと見なすなら、関手がこの織物に裂け目を入れることは許されない。対象を潰してまとめたり、複数の射を1つにくっつけたりすることはあるが、何かを引き裂くことは決してない。この引き裂きなしという制約は、微積分学において知られる連続性条件に似ている。この意味では、関手は「連続的」である（もっとも、関手にはさらに制約が厳しい連続性の概念が存在する）。関数と同じように、関手にも潰すものと埋め込むものがある。埋め込みの傾向がより顕著なのは、もとの圏が行き先の圏よりずっと小さいときだ。極端な場合、域は、自明な単元圏 (singleton category) であり得る。すなわち、ただ1つの対象とただ1つの射（恒等射）を持つ圏だ。単元圏から他の圏への関手は、単にその圏内の対象を選択するだけだ。これは、単元集合からの射は余域内の要素を選択する、という特性と完全に類似している。最も潰す関手は定関手$\Delta_c$と呼ばれる。それはもとの圏内のすべての対象を、行き先の圏内で選択された1つの対象$c$に写す。また、もとの圏のすべての射を恒等射$\idarrow[c]$に写す。まるでブラックホールのように働き、すべてを1つの特異点に圧縮する。この関手については極限と余極限について議論するときに詳しく見よう。

## プログラミングにおける関手

地に足をつけてプログラミングについて話をしよう。我々には型と関数の圏がある。この圏をそれ自体に写す関手について話そう。そのような関手は自己関手 (endofunctor) と呼ばれる。型の圏での自己関手とは何だろうか？　まず、それは型を型に写す。そのような写像の例はすでに見たが、おそらくそれとは気付かなかったのだろう。別の型によってパラメーター化されているような型の定義のことだ。いくつか例を見てみよう。

### Maybe関手

`Maybe`の定義は型`a`から型`Maybe a`への写像だ：

```haskell
data Maybe a = Nothing | Just a
```

\noindent
ここで重要な注意点がある。`Maybe`自体は型ではなく、*型構成子*だ。型に変換するには、`Int`や`Bool`のような型引数を与える必要がある。引数のない`Maybe`は、型上の関数を表す。だが、`Maybe`は関手に変えられるだろうか？
（これ以降、私がプログラミングの文脈で関手と言うとき、ほとんどの場合は自己関手を意味する。）
関手は、対象（ここでは型）を写すだけでなく、射（ここでは関数）も写す。`a`から`b`への任意の関数：

```haskell
f :: a -> b
```

\noindent
について`Maybe a`から`Maybe b`への関数を生成したい。そのような関数を定義するには、`Maybe`の2つの構成子それぞれに対応する2つの場合を考慮する必要がある。`Nothing`の場合は単純で、`Nothing`を返すだけでよい。そして引数が`Just`の場合は、関数`f`をその中身に適用すればよい。したがって、`Maybe`の下での`f`の像は次の関数だ：

```haskell
f' :: Maybe a -> Maybe b
f' Nothing = Nothing
f' (Just x) = Just (f x)
```

\noindent
（ところで、Haskellでは変数名でアポストロフィーを使えるため、いまのような場合にとても便利だ。）
Haskellでは、関手における射の写像の部分は`fmap`と呼ばれる高階関数として実装されている。`Maybe`の場合、そのシグネチャーは次のとおりだ：

```haskell
fmap :: (a -> b) -> (Maybe a -> Maybe b)
```

`\begin{figure}[H] \centering`{=latex}
![](images/functormaybe.jpg){width=35%}
`\end{figure}`{=latex}

\noindent
`fmap`は関数を*持ち上げる* (lift) という言い方がよく使われる。持ち上げられた関数は`Maybe`値に対して作用する。いつものように、カリー化のため、このシグネチャーには次の2通りの解釈がある。ひとつは、`fmap`は1引数関数であり、それ自体が関数である`(a -> b)`型の引数を取って、`(Maybe a -> Maybe b)`型の関数を返すという解釈だ。もうひとつは、2つの引数を取り、`Maybe b`を返すという解釈だ：

```haskell
fmap :: (a -> b) -> Maybe a -> Maybe b
```

\noindent
これまでの議論に基づいて、`Maybe`に対して`fmap`を実装する方法は次のとおりだ：

```haskell
fmap _ Nothing = Nothing
fmap f (Just x) = Just (f x)
```

\noindent
型構成子`Maybe`に関数`fmap`を合わせたものが関手をなすことを示すには、`fmap`が恒等射と合成を保存することを証明する必要がある。これらは「関手則」と呼ばれているが、単に圏の構造の保存を保証するだけのものだ。

### 等式による推論

関手則を証明するために、Haskellでの一般的な証明テクニックである[*等式による推論*]{.keyword #equational_reasoning}\index{等式による推論} (equational reasoning) を使う。これは、Haskellの関数が等式、つまり左辺が右辺に等しいものである、として定義されているという事実を利用している。左辺と右辺はいつでも入れ替えられる。ただし、名前の競合を避けるために変数名を変更する必要はあるかもしれない。これは、関数をインライン化するか、あるいは逆に式を関数にリファクタリングすることと考えてほしい。例として恒等関数を考えてみよう：

```haskell
id x = x
```

\noindent
たとえば、ある式の中に`id y`があるなら、`y`に置き換えられる（インライン化）。さらに、（たとえば`id (y + 2)`のように）式に`id`が適用されているなら、`(y + 2)`のように式そのものに置き換えられる。そして、この置換は両方向に機能する。つまり、任意の式`e`を`id e`で置き換えられる（リファクタリング）。関数がパターンマッチングによって定義されている場合は、各サブ定義を独立して使える。たとえば、上記の`fmap`の定義では、`fmap f Nothing`を`Nothing`に置き換えることも、その逆を行うこともできる。これが実際にどのように機能するか見てみよう。まずは恒等射の保存から始めよう：

```haskell
fmap id = id
```

\noindent
`Nothing`と`Just`の2つの場合を考慮する必要がある。1つ目の場合は次のようになる（Haskell疑似コードを使って左辺を右辺に変換している）：

```haskell
  fmap id Nothing
= { fmapの定義 }
  Nothing
= { idの定義 }
  id Nothing
```

\noindent
最後のステップで`id`の定義を逆向きに使ったことに注目してほしい。式`Nothing`を`id Nothing`に置き換えた。実際には、このような証明は、真ん中の同じ式に辿り着くまで「ロウソクを両端から燃やす」ことで成される。今回については真ん中に残るのは`Nothing`だ。2つ目の場合も簡単だ：

```haskell
  fmap id (Just x)
= { fmapの定義 }
  Just (id x)
= { idの定義 }
  Just x
= { idの定義 }
  id (Just x)
```

\noindent
では、`fmap`が合成を保存することを示そう：

```haskell
fmap (g . f) = fmap g . fmap f
```

\noindent
まずは`Nothing`のケース：

```haskell
  fmap (g . f) Nothing
= { fmapの定義 }
  Nothing
= { fmapの定義 }
  fmap g Nothing
= { fmapの定義 }
  fmap g (fmap f Nothing)
```

\noindent
次は`Just`のケース：

```haskell
  fmap (g . f) (Just x)
= { fmapの定義 }
  Just ((g . f) x)
= { 合成の定義 }
  Just (g (f x))
= { fmapの定義 }
  fmap g (Just (f x))
= { fmapの定義 }
  fmap g (fmap f (Just x))
= { 合成の定義 }
  (fmap g . fmap f) (Just x)
```

\noindent
等式による推論はC++スタイルの副作用のある「関数」では使えないことは、強調しておく価値がある。次のコードを考えてみよう：

```cpp
int square(int x) {
    return x * x;
}

int counter() {
    static int c = 0;
    return c++;
}

double y = square(counter());
```

\noindent
等式による推論を使うと、`square`をインライン展開して次のようにできる：

```cpp
double y = counter() * counter();
```

\noindent
明らかにこれは有効な変換ではなく、同じ結果は生成されない。それにもかかわらず、マクロとして`square`を実装すると、C++コンパイラーは等式による推論を使おうとし、悲惨な結果になる。

### Optional

関手はHaskellで簡単に表現できるが、総称プログラミングや高階関数をサポートする言語ならどれでも定義できる。`Maybe`のC++版であるテンプレート型`optional`について考えてみよう。以下に実装の概略を示す（実際の実装ははるかに複雑で、C++に特有の引数のさまざまな渡し方やコピーセマンティクスやリソース管理の問題を扱わなくてはならない）。

```cpp
template<class T>
class optional {
    bool _isValid; // the tag
    T    _v;
public:
    optional()    : _isValid(false) {}         // Nothing
    optional(T x) : _isValid(true) , _v(x) {}  // Just
    bool isValid() const { return _isValid; }
    T val() const { return _v; }
};
```

\noindent
このテンプレートは、関手の定義の一部である型の写像を提供する。これは任意の型`T`を新しい型`optional<T>`に写す。関数に対するその関手の作用を定義しよう：

```cpp
template<class A, class B>
std::function<optional<B>(optional<A>)>
fmap(std::function<B(A)> f)
{
    return [f](optional<A> opt) {
        if (!opt.isValid())
            return optional<B>{};
        else
            return optional<B>{ f(opt.val()) };
    };
}
```

\noindent
これは高階関数で、引数として関数を受け取り、関数を返す。非カリー化版はこうなる：

```cpp
template<class A, class B>
optional<B> fmap(std::function<B(A)> f, optional<A> opt) {
    if (!opt.isValid())
        return optional<B>{};
    else
        return optional<B>{ f(opt.val()) };
}
```

\noindent
`fmap`を`optional`のテンプレートメソッドにするという選択肢もある。このように選択肢に迷うことになるため、C++で関手パターンを抽象化するのは問題となる。関手は継承元となるインターフェイスにすべきだろうか？（残念ながら、テンプレート仮想関数は作れない。）
フリーテンプレート関数は、カリー化版と非カリー化版のどちらにすべきだろうか？　不足した型情報を、C++コンパイラーは正しく推論してくれるだろうか、それとも明示的に指定しなければならないだろうか？　入力関数`f`が`int`から`bool`への関数である状況を考えてみよう。コンパイラーに`g`の型が分かるだろうか：

```cpp
auto g = fmap(f);
```

\noindent
特に将来、複数の関手が`fmap`をオーバーロードするようになった場合は？
（近いうちにさらに多くの関手について見てみよう。）

### 型クラス

では、Haskellは関手の抽象化にどのように対処するのだろうか？　それには型クラスの機構を使う。型クラスは、共通のインターフェイスをサポートする型の族を定義する。たとえば、等しさの検査をサポートする対象についてのクラスは次のように定義される：

```haskell
class Eq a where
    (==) :: a -> a -> Bool
```

\noindent
この定義は、型`a`の引数を2つ取り`Bool`を返す演算子`(==)`がサポートされる場合、型`a`はクラス`Eq`であることを示している。特定の型が`Eq`であることをHaskellに伝えたい場合は、その型をこのクラスの[*インスタンス*]{.keyword #instance}\index{インスタンス}であると宣言し、`(==)`の実装を提供する必要がある。たとえば、2次元空間における点を表す型`Point`（2つの`Float`の直積型）が定義されているとする：

```haskell
data Point = Pt Float Float
```

\noindent
点の等しさは次のように定義できる：

```haskell
instance Eq Point where
    (Pt x y) == (Pt x' y') = x == x' && y == y'
```

\noindent
ここでは演算子`(==)`（いま定義しようとしているもの）を2つのパターン`(Pt x y)`と`(Pt x'y Pt x y)`の間に中置した。関数の本体は、単一の等号の後に続く。いったん`Point`が`Eq`のインスタンスであると宣言されると、点同士の等しさを直接比較できるようになる。C++やJavaとは異なり、`Point`を定義するときに`Eq`クラス（またはインターフェイス）を指定する必要はなく、クライアントコード内で後から指定できることに注目してほしい。また、型クラスは関数（および演算子）をオーバーロードするためのHaskellにおける唯一の機構でもある。型クラスは`fmap`を異なる関数（や演算子）についてオーバーロードするために必要となる。ただし、1つ複雑な点がある。関手は型として定義されるのではなく、型の写像、つまり型構成子として定義される。必要な型クラスは、`Eq`の場合のような型の族ではなく、型構成子の族だ。幸い、Haskellの型クラスは型だけでなく型構成子に対しても使える。以下に`Functor`クラスの定義を示す。

```haskell
class Functor f where
    fmap :: (a -> b) -> f a -> f b
```

\noindent
これは、指定された型シグネチャーを持つ関数`fmap`が存在する場合、`f`は`Functor`だと規定している。小文字の`f`は型変数であり、型変数`a`や`b`と似ている。しかし、コンパイラーはそれが型ではなく型構成子を表していることを、その使われ方から推論できる。つまり、`f a`や`f b`のように他の型に作用していることから推論できる。したがって、`Functor`のインスタンスを宣言するときは型構成子を考える必要がある。例として`Maybe`の場合を示す：

```haskell
instance Functor Maybe where
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just (f x)
```

\noindent
ちなみに、`Functor`クラスや、`Maybe`を含む多くの単純なデータ型のインスタンス定義は、標準のPreludeライブラリーの一部となっている。

### C++での関手

C++でも同じアプローチを試せるだろうか？　型構成子は、`optional`のようなテンプレートクラスに対応しているので、同様に`fmap`を[*テンプレート・テンプレート引数*]{.keyword #template_template_parameter}\index{テンプレート・テンプレート引数} (template template parameter) でパラメーター化しよう。構文は次のとおりだ：

```cpp
template<template<class> F, class A, class B>
F<B> fmap(std::function<B(A)>, F<A>);
```

\noindent
このテンプレートをさまざまな関手に特殊化できるようにしたい。残念ながら、C++ではテンプレート関数の部分的な特殊化は禁止されている。そのため、次のような記述はできない：

```cpp
template<class A, class B>
optional<B> fmap<optional>(
    std::function<B(A)> f, optional<A> opt)
```

\noindent
代わりに関数のオーバーロードに頼る必要がある。結局、もとのカリー化されていない`fmap`の定義に戻る：

```cpp
template<class A, class B>
optional<B> fmap(std::function<B(A)> f, optional<A> opt)
{
    if (!opt.isValid())
        return optional<B>{};
    else
        return optional<B>{ f(opt.val()) };
}
```

\noindent
この定義は機能するが、どのオーバーロードが使われるかを`fmap`の2番目の引数が選択しているからにすぎない。より汎用的な`fmap`の定義を完全に無視している。

### リスト関手

プログラミングにおける関手の役割についてある程度の直観を育むには、もっといろいろな例を見る必要がある。別の型によってパラメーター化される型はどれも関手の候補だ。総称コンテナーも格納する要素の型によってパラメーター化されているる。では、ごく単純なコンテナーであるリストを見てみよう：

```haskell
data List a = Nil | Cons a (List a)
```

\noindent
型構成子`List`がある。これは、任意の型`a`から型`List a`への写像だ。`List`が関手だと示すには、関数の持ち上げを定義する必要がある。つまり、関数`a -> b`について関数`List a -> List b`を定義する：

```haskell
fmap :: (a -> b) -> (List a -> List b)
```

\noindent
`List a`に作用する関数は、リストの2つのコンストラクターに対応する2つの場合を考慮する必要がある。`Nil`の場合は自明で、単に`Nil`を返す。空のリストに対してできることはあまりない。`Cons`の場合は、再帰を伴うため、ややトリッキーだ。そこで、少し前に戻って、何をしようとしているのか考えてみよう。`a`のリストと、`a`を`b`に変換する関数`f`があり、`b`のリストを生成したい。自明なのは、`f`を使ってリストの各要素を`a`から`b`に変換することだ。（空でない）リストが先頭要素headと先頭を除いた残りのリストtailの`Cons`として定義されている場合、実際にはどうやるのだろうか？　`f`をheadに適用し、持ち上げられた（`fmap`された）`f`をtailに適用すればよい。これは再帰的な定義だ。持ち上げられた`f`を持ち上げられた`f`を用いて定義しているからだ：

```haskell
fmap f (Cons x t) = Cons (f x) (fmap f t)
```

\noindent
右辺の`fmap f`が、それに対して定義しようとしているリスト［訳注：`Cons x t`］よりも短いリストに適用されていることに注意してほしい。`fmap f`はそのリストのtailに適用されている。再帰的に処理されるにつれてリストが短くなるため、最終的には空リスト、つまり`Nil`に到達することになる。しかし、先ほど決めたとおり、`fmap f`が`Nil`に作用すると`Nil`を返すため、再帰は停止する。最終的な結果を得るために、`Cons`コンストラクターを使って、新しいheadの`(f x)`と新しいtailの`(fmap f t)`を結合する。すべてをまとめると、リスト関手のインスタンス宣言はこうなる：

```haskell
instance Functor List where
    fmap _ Nil = Nil
    fmap f (Cons x t) = Cons (f x) (fmap f t)
```

\noindent
C++の方が慣れているなら、`std::vector`の場合を考えてみてほしい。それは最も汎用的なC++コンテナーと見なせるかもしれない。`fmap`の`std::vector`用の実装は単に`std::transform`の単純なカプセル化だ：

```cpp
template<class A, class B>
std::vector<B> fmap(std::function<B(A)> f, std::vector<A> v)
{
    std::vector<B> w;
    std::transform( std::begin(v)
                  , std::end(v)
                  , std::back_inserter(w)
                  , f);
    return w;
}
```

\noindent
これを使えば、たとえば次のように数列の要素を2乗できる^[訳注：2乗するだけでなく、結果を標準出力にコンマ区切りで出力している。]：

```cpp
std::vector<int> v{ 1, 2, 3, 4 };
auto w = fmap([](int i) { return i*i; }, v);
std::copy( std::begin(w)
         , std::end(w)
         , std::ostream_iterator(std::cout, ", "));
```

\noindent
ほとんどのC++コンテナーは関手だと言える。それらは`std::transform`に渡せるイテレーターを実装していて、`std::transform`は`fmap`のより原始的な従兄弟だからだ。残念ながら、関手の単純さは、イテレーターや一時変数（上記の`fmap`の実装を参照）でいつも煩雑になるため失われてしまう。新しく提案されたC++のrangeライブラリーによってrangeの関手的な性質がより顕著になったのは喜ばしい。

### Reader関手

さて、直観が育ってきただろう。たとえば、関手をある種のコンテナーと見なせるようになった。では、一見非常に異なる例をお見せしよう。型`a`からの、`a`を返す関数の型への写像を考えてみよう。関数型についてはあまり詳しく述べていない（完全に圏論的な扱いはこれからだ）が、プログラマーならある程度理解している。Haskellでは、関数型はアロー型構成子`(->)`を使って構成され、引数の型と結果の型の2つの型を取る。すでに中置記法`a -> b`で見たことがあるが、括弧で括れば前置記法でも同様に使える：

```haskell
(->) a b
```

\noindent
通常の関数と同様に、複数の引数を取る型関数も部分適用できる。したがって、矢印に対して型引数を1つだけ与えた後もなお、もう1つの型引数が期待される。それが：

```haskell
(->) a
```

\noindent
が型構成子である理由だ。完全な型`a -> b`を生成するには、もう1つの型`b`が必要だ。いまのところは、`a`によってパラメーター化された型構成子の族の全体を定義していると言える。これが関手の族でもあるかどうか見てみよう。2つの型パラメーターを扱うのは混乱を招くかもしれないので、名前を変更しておこう。前の関手の型定義に従って、引数の型を`r` 、結果の型を`a`と呼ぼう。そうすると、この型構成子は任意の型`a`を取り、それを型`r -> a`に写す。これが関手であることを示すために、関数`a -> b`を、`r -> a`を受け取って`r -> b`を返す関数に持ち上げたい。これらの型は`a`と`b`のそれぞれに型構成子`(->) r`を作用させて作られたものだ。この場合における`fmap`の型シグネチャーは次のとおりだ：

```haskell
fmap :: (a -> b) -> (r -> a) -> (r -> b)
```

\noindent
ここでパズルを解かなくてはならない：関数`f :: a -> b`と関数`g :: r -> a`が与えられるとき、関数`r -> b`を作成せよ。2つの関数を合成する方法は1つしかなく、その結果はまさに必要なものだ。`fmap`の実装は次のようになる：

```haskell
instance Functor ((->) r) where
    fmap f g = f . g
```

\noindent
うまくいった！　簡潔な表記が好みなら、さらに短く定義できる。そのためには、合成を前置記法で書き直せることと：

```haskell
fmap f g = (.) f g
```

\noindent
そのときの引数を省略できることに着目し、2つの関数の間の等式を得る：

```haskell
fmap = (.)
```

\noindent
型構成子 `(->) r`と上記の`fmap`の実装の組み合わせは、reader関手と呼ばれる。

## コンテナーとしての関手

汎用コンテナーを定義できるか、オブジェクトをそれが含む値の型によってパラメーター化して定義できるプログラミング言語において、関手の例をいくつか見た。Reader関手は異端に思える。我々は関数をデータとは見なさないからだ。しかし、純粋関数はメモ化でき、関数の実行はテーブル参照に変えられるのをすでに見た。テーブルはデータだ。逆に、Haskellは遅延評価を採用しているため、リストのような従来のコンテナーは、実際には関数として実装されうる。たとえば、次のように簡潔に定義できる自然数の無限リストを考えてみよう：

```haskell
nats :: [Integer]
nats = [1..]
```

\noindent
最初の行では、一対の角括弧はHaskellの組み込みリスト用の型構成子だ。2行目では、リストを作成するために角括弧が使われている。明らかに、このような無限リストはメモリーに格納できない。コンパイラーはこれを、必要に応じて`Integer`を生成する関数として実装する。Haskellは効果的に、データとコードの区別を曖昧にしている。リストは関数と見なせて、関数は引数を結果に写すテーブルと見なせる。後者は、関数の領域が有限かつ大きすぎない場合なら現実的だ。しかし、`strlen`をテーブル参照として実装するのは現実的でない。無限に多くの異なる文字列が存在するからだ。プログラマーとして、我々は無限大は好きではないが、圏論では朝食に無限大を食べるのを学ぶことになる。すべての文字列の集合であっても、過去・現在・未来の宇宙のすべての可能な状態の集まりであっても、対処できる！　そこで、関手オブジェクト（自己関手によって生成された型のオブジェクト）はパラメーター化される型の値を含むと考えたい。それらの値が物理的にそこに存在しない場合でもだ。関手の一例はC++の`std::future`で、ある時点で値を含みうるが、必ず含む保証はない。また、その値にアクセスしたいとき、別スレッドの実行終了を待つためにブロックされることがある。別の例としてはHaskellの`IO`オブジェクトがあり、ユーザー入力を含んだり、画面に「Hello World!」と表示されているような未来版の宇宙を含んだりできる。この解釈によれば、関手オブジェクトとは、パラメーター化された型の値を含みうるものだ。あるいは、これらの値を生成するためのレシピも含みうる。値にアクセスできるかは全く気にしない――それは完全にオプショナルであり、関手の守備範囲外だ。関心があるのは、これらの値を関数を使って操作できるかだけだ。値にアクセスできるなら、操作の結果を確認できるはずだ。アクセスできないなら、操作が正しく合成され、恒等関数による操作が何も変更しないことに注意するだけでよい。関手オブジェクト内の値へのアクセスを全く気にしていないことを明示するために、引数`a`を完全に無視する型構成子を例に挙げよう：

```haskell
data Const c a = Const c
```

\noindent
`Const`型構成子は`c`と`a`の2つの型を取る。アローコンストラクターで行ったように、部分適用で関手を作成しよう。`Const`型のデータ構成子（これも`Const`と呼ばれる）は型`c`の値を1つだけ取る。これは`a`には依存しない。この型構成子の`fmap`の型は次のようになる：

```haskell
fmap :: (a -> b) -> Const c a -> Const c b
```

\noindent
この関手は型引数を無視するので、`fmap`の実装はその関数引数を無視してよい――その関数は作用するものがない：

```haskell
instance Functor (Const c) where
    fmap _ (Const v) = Const v
```

\noindent
これはC++ではもう少し明確かもしれない（この言葉を口にするとは思わなかった！）。コンパイル時に決まる型引数と実行時に決まる値がよりはっきり区別されるからだ。

```cpp
template<class C, class A>
struct Const {
    Const(C v) : _v(v) {}
    C _v;
};
```

\noindent
`fmap`のC++実装も、関数の引数を無視し、`Const`の引数を値は変更せず実質的に再キャストする：

```cpp
template<class C, class A, class B>
Const<C, B> fmap(std::function<B(A)> f, Const<C, A> c) {
    return Const<C, B>{c._v};
}
```

\noindent
その奇妙さにもかかわらず、`Const`関手は多くの構成で重要な役割を果たしている。圏論では、これは先に述べた$\Delta_c$関手の特殊なケースであり、ブラックホールの自己関手版だ。今後もっと詳しく知ることになるだろう。

## 関手の合成

圏の間の関手が合成できることは、集合の間の関数が合成できるのと同様だと考えれば納得するのは難しくない。2つの関手の合成は、対象に作用するときは、それぞれの対象の写像の合成にすぎず、射に作用するときも同様だ。2つの関手を飛び越えた後で、恒等射は恒等射となり、射の合成は射の合成となる。ただそれだけだ。特に、自己関手を合成するのは簡単だ。関数`maybeTail`を覚えているだろうか？　ここではHaskellの組み込みのリスト実装を使って書き直そう：

```haskell
maybeTail :: [a] -> Maybe [a]
maybeTail [] = Nothing
maybeTail (x:xs) = Just xs
```

\noindent
（`Nil`と呼んでいた空リストコンストラクターは、空の角括弧のペア`[]`に置き換えられる。`Cons`コンストラクターは、中置演算子`:`（コロン）に置き換えられる。）
`maybeTail`の結果は、`Maybe`と`[]`という2つの関手の合成が`a`に作用するような型だ。これらの関数はそれぞれ独自版の`fmap`を備えているが、もし何らかの関数`f`を合成の内容、つまり`Maybe`リストに適用したい場合はどうなるだろう？　2層の関手を突破しなければならない。`fmap`を使えば外側の`Maybe`は突破できる。しかし、`f`はリストに対しては動かないので、`Maybe`内に`f`を単に送ることはできない。内側のリストを操作するには`(fmap f)`を送る必要がある。たとえば、整数の`Maybe`リストの要素を2乗するにはどうするか見てみよう：

```haskell
square x = x * x

mis :: Maybe [Int]
mis = Just [1, 2, 3]

mis2 = fmap (fmap square) mis
```

\noindent
コンパイラーは、型を分析した後、外側の`fmap`に対しては`Maybe`インスタンスからの実装を使い、内側のものに対してはリスト関手の実装を使う必要があることを理解する。上記のコードを次のように書き換えられるのは、すぐには自明に思えないかもしれない：

```haskell
mis2 = (fmap . fmap) square mis
```

\noindent
だが、`fmap`は引数が1つだけの関数と見なせることを思い出してほしい：

```haskell
fmap :: (a -> b) -> (f a -> f b)
```

\noindent
この例では、`(fmap . fmap)`内の2番目の`fmap`は引数として次のものを取る：

```haskell
square :: Int -> Int
```

\noindent
そして、次の型の関数を返す：

```haskell
[Int] -> [Int]
```

\noindent
最初の`fmap`がこの関数を受け取り、次の型の関数を返す：

```haskell
Maybe [Int] -> Maybe [Int]
```

\noindent
最後に、この関数は`mis`に適用される。したがって、2つの関手を合成すると、対応する2つの`fmap`を合成した`fmap`を持つ関手になる。圏論に話を戻すと、関手の合成が結合性を持つのはごく自明だ（対象の写像が結合性を持ち、射の写像も結合性を持つ）。また、すべての圏には自明な恒等関手がある。すなわち、どの対象もその対象自身へ写し、どの射もその射自身へ写すような関手だ。つまり、関手はある圏の射と全く同じ性質を持っている。しかし、それはどのような圏だろうか？　対象が圏であり射が関手である圏でなければならない。すなわち、圏の圏だ。ところが、*すべての*圏の圏はそれ自体を含まなければならず、すべての集合の集合を不可能にしたのと同じ種類の矛盾にぶつかることになる。しかし、$\Cat$と呼ばれる、すべての*小さい*圏の圏がある（$\Cat$自体は大きい圏なので、それ自体のメンバーにはなれない）。小さい圏とは、対象が集合よりも大きな何かではなく集合をなすような圏のことだ。圏論では、非可算無限集合であっても「小さい」と見なされることに注意してほしい。これらに言及しようと思ったのは、同じ構造が抽象化の多くのレベルで繰り返されているのを認識できることが、非常に驚くべきことだからだ。関手が圏をなすことについても後で説明する。

## 課題

#. 次のように定義することで、`Maybe`型構成子を関手に変換できるか？

   ```haskell
   fmap _ _ = Nothing
   ```

   \noindent
   これは両方の引数を無視する。（ヒント：関手則をチェックする。）

#. Reader関手について関手則を証明せよ。ヒント：本当に単純だ。

#. 2番目に好きな言語でReader関手を実装せよ（1番目はHaskell、それ一択だ）。

#. リスト関手について関手則を証明せよ。その際は、`fmap f`を適用するリストのtailについて規則が真であると仮定せよ（言い換えると、*帰納法*を使用せよ）。
