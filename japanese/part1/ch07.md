# 関手 {#functors}

壊れたレコードのように聞こえるかもしれないが、関手についてこう述べておきたい：関手は非常に単純だが強力な概念だ。圏論はこのような単純だが強力な概念であふれている。関手は圏の間の写像だ。ある2つの圏$\cat{C}$と$\cat{D}$について、関手$F$は$\cat{C}$内の対象を$\cat{D}$内の対象に写す。これは対象についての関数だ。$a$が$\cat{C}$内の対象である場合は、$\cat{D}$内の像を$F a$と（括弧なしで）書く。しかし、圏は単なる対象ではない――対象とそれらを接続する射からなる。関手は射も写す――射についての関数だ。ただし、射を行きあたりばったりに写すわけではない――接続を維持して写す。
したがって、$\cat{C}$内の射$f$が対象$a$を対象$b$に次のように接続する場合：

$$f \Colon a \to b$$

$\cat{D}$内の$f$の像$F f$は、$a$の像を$b$の像に接続する：

$$F f \Colon F a \to F b$$

（これは数学的記法とHaskellの記法を組み合わせたものであり、ここでは理にかなっているだろう。対象や射に関数を適用するときは括弧を使わないことにする。）

![](images/functor.jpg){width=30%}

ご覧のとおり、関手は圏の構造を保存している。一方の圏で接続しているものは、もう一方の圏でも接続している。しかし、圏の構造にはそれ以上の何かがある：射の合成だ。$h$が$f$と$g$の合成：

$$h = g \circ f$$

の場合、$F$の下の像を$f$と$g$の像の合成にしたい：

$$F h = F g \circ F f$$

![](images/functorcompos.jpg){width=30%}

最後に、$\cat{C}$内のすべての恒等射を$\cat{D}$内の恒等射に写したい：

$$F \idarrow[a] = \idarrow[F a]$$

ここで、$\idarrow[a]$は対象$a$の恒等射であり、$\idarrow[F a]$は$F a$の恒等射だ。

![](images/functorid.jpg){width=30%}

これらの条件によって、関手は通常の関数よりもはるかに制約が厳しくなることに注意してほしい。関手は圏の構造を保存しなければならない。圏を、射のネットワークによって織りなされた対象の集まりと見なすなら、関手がこの織物に裂け目を入れることは許されない。対象を潰してまとめたり、複数の射を1つにくっつけたりすることはあるが、何かを引き裂くことは決してない。この引き裂きなしの拘束条件は、微積分学において知られる連続性条件に似ている。この意味では、関手は「連続的」である（もっとも、関手にはさらに制約が厳しい連続性の概念が存在する）。関数と同じように、関手にも潰すものと埋め込むものがある。埋め込みの傾向がより顕著なのは、始域圏が終域圏よりずっと小さいときだ。極端な場合、始域は、自明な単元圏 (singleton category) でありうる。すなわち、1つの対象と1つの射（恒等射）を持つ圏だ。単元圏から他の圏への関手は、単にその圏内の対象を選択するだけだ。これは、単集合からの射は終域内の要素を選択する、という特性と完全に類似している。最も潰す関手は定関手$\Delta_c$と呼ばれる。それは始域圏内のすべての対象を、終域圏内で選択された1つの対象$c$に写す。また、始域圏のすべての射を恒等射$\idarrow[c]$に写す。まるでブラックホールのように働き、すべてを1つの特異点に圧縮する。この関手については極限と余極限について議論するときに詳しく見よう。

## プログラミングにおける関手

現実に戻ってプログラミングについて話をしよう。我々には型と関数の圏がある。この圏をそれ自体に写す関手について話そう。そのような関手は自己関手 (endofunctor) と呼ばれる。型の圏での自己関手とは何だろうか？
まず、それは型を型に写す。そのような写像の例はすでに見たが、おそらくそれとは気付かなかったのだろう。いま述べているのは、ある型の定義が別の型によってパラメーター化されている場合についてだ。いくつか例を見てみよう。

### Maybe関手

`Maybe`は、型`a`から型`Maybe a`への写像として定義される：

```haskell
data Maybe a = Nothing | Just a
```

ここで重要な注意点がある。`Maybe`自体は型ではなく、*型コンストラクター*だ。型に変換するには、`Int`や`Bool`のような型引数を指定する必要がある。引数のない`Maybe`は、型の関数を表す。だが、`Maybe`は関手に変えられるだろうか？
（これ以降、プログラミングの文脈で関手と言うとき、ほとんどの場合は自己関手を意味する。）
関手は、対象（ここでは型）の写像であるだけでなく、射（ここでは関数）の写像でもある。`a`から`b`への任意の関数：

```haskell
f :: a -> b
```

について`Maybe a`から`Maybe b`への関数を生成したい。そのような関数を定義するには、`Maybe`の2つのコンストラクターに対応する2つの場合を考慮する必要がある。`Nothing`の場合は、単に`Nothing`を返すだけだ。引数が`Just`の場合は、関数`f`をその内容に適用すればよい。したがって、`Maybe`の下にある`f`の像は次の関数だ：

```haskell
f' :: Maybe a -> Maybe b
f' Nothing = Nothing
f' (Just x) = Just (f x)
```

（ところで、Haskellでは変数名でアポストロフィーを使えるため、今のような場合にとても便利だ。）
Haskellでは、関手で射を写す部分は`fmap`と呼ばれる高階関数として実装されている。`Maybe`の場合、シグネチャーは次のとおりだ：

```haskell
fmap :: (a -> b) -> (Maybe a -> Maybe b)
```

![](images/functormaybe.jpg){width=35%}

`fmap`は関数を*リフト*するという言い方がよく使われる。リフトされた関数は`Maybe`値に対して作用する。いつものように、カリー化のため、このシグネチャーは次の2つの方法で解釈できる。1つは、関数`(a -> b)`を1つの引数と捉えて、関数`(Maybe a -> Maybe b)`を返しているとする解釈だ。もうひとつは、2つの引数を取る関数が`Maybe b`を返しているとする解釈だ：

```haskell
fmap :: (a -> b) -> Maybe a -> Maybe b
```

これまでの議論に基づいて、`Maybe`に`fmap`を実装する方法は次のとおりだ：

```haskell
fmap _ Nothing = Nothing
fmap f (Just x) = Just (f x)
```

型コンストラクター`Maybe`が関数`fmap`を伴う関手を形成することを示すには、`fmap`が恒等射と合成を保存することを証明する必要がある。これらは「関手の規則」と呼ばれているが、単に圏の構造の保存を保証するだけのものだ。

### 等式推論

関手の規則を証明するために、Haskellでの一般的な証明テクニックである[等式推論]{.keyword #equational_reasoning} (equational reasoning) を使う。これは、Haskellの関数が等価関数として定義されている、つまり左辺が右辺に等しい、という事実を利用している。左辺と右辺はいつでも入れ替えられる。ただし、名前の競合を避けるために変数名を変更する必要はあるかもしれない。これは、関数をインライン化するか、あるいは逆に式を関数にリファクタリングすることと考えてほしい。例として恒等関数を考えてみよう：

```haskell
id x = x
```

たとえば、ある式の中に`id y`があるなら、`y`に置き換えられる（インライン化）。さらに、（たとえば`id (y + 2)`のように）式に`id`が適用されているなら、`(y + 2)`のように式そのものに置き換えられる。そして、この置換は両方向に機能する。つまり、任意の式`e`を`id e`で置き換えられる（リファクタリング）。関数がパターンマッチングによって定義されている場合は、各サブ定義を独立して使える。たとえば、上記の`fmap`の定義では、`fmap f Nothing`を`Nothing`に置き換えることも、その逆を行うこともできる。これが実際にどのように機能するか見てみよう。恒等射の保存から始めよう：

```haskell
fmap id = id
```

`Nothing`と`Just`の2つのケースを考慮する必要がある。1つ目のケースは次のようになる（Haskell疑似コードを使って左辺を右辺に変換している）：

```haskell
  fmap id Nothing
= { definition of fmap }
  Nothing
= { definition of id }
  id Nothing
```

最後のステップで`id`の定義を逆向きに使ったことに注目してほしい。式`Nothing`を`id Nothing`に置き換えた。実際には、このような証明は、真ん中の同じ式に辿り着くまで「ロウソクを両端から燃やす」ことで成される。ここで真ん中に残るのは`Nothing`だ。2つ目のケースも簡単だ：

```haskell
  fmap id (Just x)
= { definition of fmap }
  Just (id x)
= { definition of id }
  Just x
= { definition of id }
  id (Just x)
```

では、`fmap`が合成を保存することを示そう：

```haskell
fmap (g . f) = fmap g . fmap f
```

まずは`Nothing`のケース：

```haskell
  fmap (g . f) Nothing
= { definition of fmap }
  Nothing
= { definition of fmap }
  fmap g Nothing
= { definition of fmap }
  fmap g (fmap f Nothing)
```

次は`Just`のケース：

```haskell
  fmap (g . f) (Just x)
= { definition of fmap }
  Just ((g . f) x)
= { definition of composition }
  Just (g (f x))
= { definition of fmap }
  fmap g (Just (f x))
= { definition of fmap }
  fmap g (fmap f (Just x))
= { definition of composition }
  (fmap g . fmap f) (Just x)
```

等式推論はC++スタイルの副作用のある「関数」では使えないことは、強調しておく価値がある。次のコードを考えてみよう：

```cpp
int square(int x) {
    return x * x;
}

int counter() {
    static int c = 0;
    return c++;
}

double y = square(counter());
```

等式推論を使うと、`square`をインライン展開して次のようにできる：

```cpp
double y = counter() * counter();
```

明らかにこれは有効な変換ではなく、同じ結果は生成されない。それにもかかわらず、マクロとして`square`を実装すると、C++コンパイラーは等式推論を使おうとし、悲惨な結果になる。

### Optional

関手は、Haskellでは簡単に表現できるが、総称プログラミングや高階関数をサポートする言語ならどれでも定義できる。`Maybe`のC++版であるテンプレート型`optional`について考えてみよう。以下に実装の概略を示す（実際の実装ははるかに複雑で、C++に特有の引数のさまざまな渡し方やコピーセマンティクスやリソース管理の問題を扱わなくてはならない）。

```cpp
template<class T>
class optional {
    bool _isValid; // the tag
    T    _v;
public:
    optional()    : _isValid(false) {}         // Nothing
    optional(T x) : _isValid(true) , _v(x) {}  // Just
    bool isValid() const { return _isValid; }
    T val() const { return _v; }
};
```

このテンプレートは、関手の定義の一部である型の写像を提供する。これは任意の型`T`を新しい型`optional<T>`に写す。関数に対するアクションを定義しよう：

```cpp
template<class A, class B>
std::function<optional<B>(optional<A>)>
fmap(std::function<B(A)> f)
{
    return [f](optional<A> opt) {
        if (!opt.isValid())
            return optional<B>{};
        else
            return optional<B>{ f(opt.val()) };
    };
}
```

これは高階関数で、引数として関数を受け取り、関数を返す。非カリー化版はこうなる：

```cpp
template<class A, class B>
optional<B> fmap(std::function<B(A)> f, optional<A> opt) {
    if (!opt.isValid())
        return optional<B>{};
    else
        return optional<B>{ f(opt.val()) };
}
```

`fmap`を`optional`のテンプレートメソッドにするという選択肢もある。このように選択肢に迷うことになるため、C++で関手パターンを抽象化するのは難しい。関手は継承元となるインターフェースにすべきだろうか？（残念ながら、テンプレート仮想関数は作れない。）
フリーテンプレート関数は、カリー化版と非カリー化版のどちらにすべきだろうか？
C++コンパイラーは不足した型情報を正しく推論できるのか、それとも明示的に指定すべきだろうか？
入力関数`f`が`int`から`bool`への関数である状況を考えてみよう。コンパイラーに`g`の型が分かるだろうか：

```cpp
auto g = fmap(f);
```

特に将来、複数の関手が`fmap`をオーバーロードするようになった場合は？
（近いうちにさらに多くの関手について見てみよう。）

### 型クラス

では、Haskellは関手の抽象化にどのように対処するのだろうか？
それには型クラスの機構を使う。型クラスは、共通のインターフェースをサポートする一連の型を定義する。たとえば、等価性をサポートする対象についてのクラスは次のように定義される：

```haskell
class Eq a where
    (==) :: a -> a -> Bool
```

この定義は、型`a`の引数を2つ取り`Bool`を返す演算子`(==)`がサポートされる場合、型`a`はクラス`Eq`であることを示している。特定の型が`Eq`であることをHaskellに伝えたい場合は、それをこのクラスの[インスタンス]{.keyword #instance}として宣言し、`(==)`の実装を提供する必要がある。たとえば、2次元の点について`Point`（2つの`Float`の直積型）が定義されているとする：

```haskell
data Point = Pt Float Float
```

点の等価性は次のように定義できる：

```haskell
instance Eq Point where
    (Pt x y) == (Pt x' y') = x == x' && y == y'
```

ここでは演算子`(==)`を定義し、2つのパターン`(Pt x y)`と`(Pt x'y Pt x y)`の中置記法として使った。関数の本体は、単一の等号の後に続く。`Point`が`Eq`のインスタンスとして宣言してあると、点同士を直接比較して等価性を調べられる。C++やJavaとは異なり、`Point`を定義するときに`Eq`クラス（またはインターフェース）を指定する必要はなく、クライアントコード内で後から指定できることに注目してほしい。また、型クラスは関数（および演算子）をオーバーロードするためのHaskellの唯一の機構でもある。これは`fmap`を異なる関数（や演算子）についてオーバーロードするために必要だ。ただし、1つ複雑な点がある。関手は型として定義されるのではなく、型の写像、つまり型コンストラクターとして定義される。必要な型クラスは、`Eq`の場合のような一連の型ではなく、一連の型コンストラクターだ。幸い、Haskellの型クラスは型だけでなく型コンストラクターでも使える。以下に`Functor`クラスの定義を示す。

```haskell
class Functor f where
    fmap :: (a -> b) -> f a -> f b
```

これは、指定された型シグネチャーを持つ関数`fmap`が存在する場合、`f`は`Functor`だと規定している。小文字の`f`は型変数であり、型変数`a`や`b`と似ている。しかし、コンパイラーはそれが型ではなく型コンストラクターを表していることを、用法に基づいて推論できる。つまり、`f a`や`f b`のように他の型に作用しているのを見て推論できる。したがって、`Functor`のインスタンスを宣言するときは型コンストラクターを指定する必要がある。例として`Maybe`の場合を示す：

```haskell
instance Functor Maybe where
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just (f x)
```

ちなみに、`Functor`クラスや、`Maybe`を含む多くの単純なデータ型のインスタンス定義は、標準のPreludeライブラリの一部となっている。

### C++での関手

C++でも同じアプローチを試せるだろうか？
型コンストラクターは、`optional`のようなテンプレート・クラスに対応しているので、同様に`fmap`を[テンプレート・テンプレート引数]{.keyword #template_template_parameter} (template template parameter) でパラメーター化しよう。構文は次のとおりだ：

```cpp
template<template<class> F, class A, class B>
F<B> fmap(std::function<B(A)>, F<A>);
```

このテンプレートをさまざまな関手に特殊化できるようにしたい。残念ながら、C++ではテンプレート関数の部分的な特殊化は禁止されている。そのため、次のような記述はできない：

```cpp
template<class A, class B>
optional<B> fmap<optional>(std::function<B(A)> f, optional<A> opt)
```

代わりに関数のオーバーロードに頼る必要がある。これにより、もとのカリー化されていない`fmap`の定義に戻る：

```cpp
template<class A, class B>
optional<B> fmap(std::function<B(A)> f, optional<A> opt)
{
    if (!opt.isValid())
        return optional<B>{};
    else
        return optional<B>{ f(opt.val()) };
}
```

この定義は機能するが、`fmap`の2番目の引数がオーバーロードを選択しているからにすぎない。より汎用的な`fmap`の定義を完全に無視している。

### List関手

プログラミングにおける関手の役割についてある程度の直観を育むには、もっといろいろな例を見る必要がある。別の型によってパラメーター化される型はどれも関手の候補だ。総称コンテナも格納する要素の型によってパラメーター化されるので、ごく単純なコンテナであるリストを見てみよう：

```haskell
data List a = Nil | Cons a (List a)
```

型コンストラクター`List`がある。これは、任意の型`a`から型`List a`への写像だ。`List`が関手だと示すには、次のように関数のリフトを定義する必要がある。つまり、関数`a -> b`について関数`List a -> List b`を定義する：

```haskell
fmap :: (a -> b) -> (List a -> List b)
```

`List a`に作用する関数は、リストの2つのコンストラクターに対応する2つの場合を考慮する必要がある。`Nil`の場合は自明で、単に`Nil`を返す。空のリストでできることはあまりない。`Cons`の場合は、再帰を伴うため、ややトリッキーだ。そこで、少し前に戻って、何をしようとしているのか考えてみよう。`a`のリストと、`a`を`b`に変換する関数`f`があり、`b`のリストを生成したい。自明なのは、`f`を使ってリストの各要素を`a`から`b`に変換することだ。（空でない）リストが頭部と尾部の`Cons`として定義されている場合、実際にはどうやるのだろうか？
`f`を頭部に適用し、リフト（`fmap`）された`f`を尾部に適用すればよい。これは再帰的な定義だ。リフトされた`f`をリフトされた`f`を用いて定義しているからだ：

```haskell
fmap f (Cons x t) = Cons (f x) (fmap f t)
```

右辺では、`fmap f`が定義対象のリストよりも短いリストに適用されていることに注意してほしい。それは尾部に適用されている。再帰的に処理されるにつれてリストが短くなるため、最終的には空リスト、つまり`Nil`に到達することになる。しかし、先ほど決めたとおり、`fmap f`が`Nil`に作用すると`Nil`を返すため、再帰は停止する。最終的な結果を得るために、`Cons`コンストラクターを使って、新しい頭部`(f x)`と新しい尾部`(fmap f t)`を結合する。すべてをまとめると、list関手のインスタンス宣言はこうなる：

```haskell
instance Functor List where
    fmap _ Nil = Nil
    fmap f (Cons x t) = Cons (f x) (fmap f t)
```

C++に慣れている場合は、最も汎用的なC++コンテナと見なせる`std::vector`の場合を考えてみてほしい。 `fmap`の`std::vector`用の実装は`std::transform`の単純なカプセル化だ：

```cpp
template<class A, class B>
std::vector<B> fmap(std::function<B(A)> f, std::vector<A> v)
{
    std::vector<B> w;
    std::transform( std::begin(v)
                  , std::end(v)
                  , std::back_inserter(w)
                  , f);
    return w;
}
```

これを使えば、たとえば次のように数列の要素を自乗できる：

```cpp
std::vector<int> v{ 1, 2, 3, 4 };
auto w = fmap([](int i) { return i*i; }, v);
std::copy( std::begin(w)
         , std::end(w)
         , std::ostream_iterator(std::cout, ", "));
```

`std::transform`は`fmap`のより原始的な従兄弟だ。それに渡せるイテレーターを実装しているため、ほとんどのC++コンテナは関手だと言える。残念ながら、関手の単純さは、イテレーターや一時変数（上記の`fmap`の実装を参照）でいつも煩雑になるため失われてしまう。新しく提案されたC++のrangeライブラリによってrangeの関手的な性質がより顕著になったのは喜ばしい。

### Reader関手

さて、直観が育ってきただろう。たとえば、関手をある種のコンテナと見なせるようになった。では、一見したところ非常に異なる例をお見せしよう。型`a`からの、`a`を返す関数の型への写像を考えてみよう。関数型についてはあまり詳しく述べていない（完全に圏論的な扱いはこれからだ）が、プログラマーならある程度理解している。Haskellでは、関数型はアロー型コンストラクター`(->)`を使って構築され、引数の型と結果の型の2つの型を取る。すでに中置記法`a -> b`で見たことがあるが、括弧で括れば前置記法でも同様に使える：

```haskell
(->) a b
```

通常の関数と同様に、複数の引数を持つ型関数も部分適用できる。したがって、矢印に対して型引数を1つだけ指定したなら、別の引数が必要になる。それが：

```haskell
(->) a
```

が型コンストラクターである理由だ。完全な型`a -> b`を生成するには、もう1つの型`b`が必要だ。現状のままでは、`a`によってパラメーター化された一連の型コンストラクターの全体を定義している。これが関手でもあるかどうか見てみよう。2つの型パラメーターを扱うのは混乱を招くかもしれないので、名前を変更しておこう。前の型定義に従って、引数の型を`r` 、結果の型を`a`と呼ぼう。そうすると、この型コンストラクターは任意の型`a`を取り、それを型`r -> a`に写す。これが関手であることを示すために、関数`a -> b`を、`r -> a`を受け取って`r -> b`を返す関数にリフトしよう。これらの型は`a`と`b`のそれぞれに型コンストラクター`(->) r`を作用させて作る。このケースに適用される`fmap`の型シグネチャーは次のとおりだ：

```haskell
fmap :: (a -> b) -> (r -> a) -> (r -> b)
```

ここでパズルを解かなくてはならない：関数`f :: a -> b`と関数`g :: r -> a`が与えられるとき、関数`r -> b`を作成せよ。2つの関数を合成する方法は1つしかなく、その結果はまさに必要なものだ。`fmap`の実装は次のようになる：

```haskell
instance Functor ((->) r) where
    fmap f g = f . g
```

うまくいった！
簡潔な表記が好みなら、合成を前置記法で書き直せることに着目して、さらに短く定義できる：

```haskell
fmap f g = (.) f g
```

引数を省略すると、2つの関数の直接の等価性が得られる：

```haskell
fmap = (.)
```

型コンストラクター `(->) r`と上記の`fmap`の実装の組み合わせは、Reader関手と呼ばれる。

## コンテナとしての関手

汎用コンテナか、少なくともパラメーター化できる型を何らかの値として含むオブジェクトが定義されているプログラミング言語において、関手の例をいくつか見た。Reader関手は異端に思える。我々は関数をデータとは見なさないからだ。しかし、純粋関数はメモ化でき、関数の実行はテーブル参照に変えられるのを見た。テーブルはデータだ。逆に、Haskellは遅延評価を採用しているため、リストのような従来のコンテナは、実際には関数として実装されうる。たとえば、次のように簡潔に定義できる自然数の無限リストを考えてみよう：

```haskell
nats :: [Integer]
nats = [1..]
```

最初の行では、一対の角括弧はHaskellの組み込みリスト用の型コンストラクターだ。2行目では、リストリテラルを作成するために角括弧が使われている。明らかに、このような無限リストはメモリに格納できない。コンパイラーはこれを、必要に応じて`Integer`を生成する関数として実装する。Haskellは実質的に、データとコードの区別を曖昧にしている。リストは関数と見なせて、関数は引数を結果に写すテーブルと見なせる。後者は、関数の領域が有限かつ大きすぎない場合なら現実的だ。しかし、`strlen`をテーブル参照として実装するのは現実的でない。無限に多くの異なる文字列が存在するからだ。プログラマーとして、我々は無限大は好きではないが、圏論では朝食に無限大を食べるのを学ぶことになる。すべての文字列の集合であっても、過去・現在・未来の宇宙のすべての可能な状態の集まりであっても、対処できる！
そこで、関手対象（自己関手によって生成された型の対象）はパラメーター化される型の値を含むと考えたい。それらの値が物理的にそこに存在しない場合でもだ。関手の一例はC++の`std::future`で、ある時点で値を含みうるが、必ず含む保証はない。また、その値にアクセスしたいとき、別スレッドの実行終了を待つためにブロックされることがある。別の例としてはHaskellの`IO`オブジェクトがあり、ユーザー入力を含んだり、将来のバージョンの宇宙で画面に「Hello World!」と表示されているのを含んだりできる。この解釈によれば、関手対象とは、パラメーター化された型の値を含みうるものだ。あるいは、これらの値を生成するためのレシピも含みうる。値にアクセスできるかは全く気にしない――それは完全にオプションであり、関手の守備範囲外だ。関心があるのは、これらの値を関手を使って操作できるかだけだ。値にアクセスできるなら、操作の結果を確認できるはずだ。アクセスできないなら、操作が正しく合成され、恒等関数による操作が何も変更しないことに注意するだけでよい。関手対象内の値へのアクセスを全く気にしていないことを明示するために、引数`a`を完全に無視する型コンストラクターを例に挙げよう：

```haskell
data Const c a = Const c
```

`Const`型コンストラクターは`c`と`a`の2つの型を取る。アローコンストラクターで行ったように、部分適用で関手を作成しよう。データコンストラクター（これも`Const`と呼ばれる）は型`c`の値を1つだけ取る。これは`a`には依存しない。この型コンストラクターの`fmap`の型は次のようになる：

```haskell
fmap :: (a -> b) -> Const c a -> Const c b
```

この関手は型引数を無視するので、`fmap`の実装は関数の引数を無視してよい――関数は扱うものがない：

```haskell
instance Functor (Const c) where
    fmap _ (Const v) = Const v
```

これはC++ではもう少し明確かもしれない（この言葉を口にするとは思わなかった！）。型引数がコンパイル時に決まるのに対し、値は実行時に決まり、よりはっきり区別されるからだ。

```cpp
template<class C, class A>
struct Const {
    Const(C v) : _v(v) {}
    C _v;
};
```

`fmap`のC++実装も関数の引数を無視し、要するに`Const`引数を値は変更せずに再キャストする：

```cpp
template<class C, class A, class B>
Const<C, B> fmap(std::function<B(A)> f, Const<C, A> c) {
    return Const<C, B>{c._v};
}
```

その奇妙さにもかかわらず、`Const`関手は多くの構成で重要な役割を果たしている。圏論では、これは先に述べた$\Delta_c$関手の特殊なケースであり、ブラックホールの自己関手版だ。今後もっと多く目にすることになるだろう。

## 関手の合成

圏の間の関手が合成することは、集合の間の関数が合成するのと同様だと考えれば納得するのは難しくない。2つの関手の合成は、対象に作用するときは、それぞれの対象の写像の合成にすぎず、射に作用するときも同様だ。2つの関手を飛び越えたあと、恒等射は恒等射となり、射の合成は射の合成となる。これは大したことではない。特に、自己関手を合成するのは簡単だ。関数`maybeTail`を覚えているだろうか？
ここではHaskellの組み込みのリスト実装を使って書き直そう：

```haskell
maybeTail :: [a] -> Maybe [a]
maybeTail [] = Nothing
maybeTail (x:xs) = Just xs
```

（`Nil`と呼んでいた空リストコンストラクターは、空の角括弧のペア`[]`に置き換えられる。`Cons`コンストラクターは、中置演算子`:`（コロン）に置き換えられる。）
`maybeTail`の結果は、`Maybe`と`[]`という2つの関手の合成が`a`に作用するような型だ。これらの関数はそれぞれ独自のバージョンの`fmap`を備えているが、もし何らかの関数`f`を合成の内容、つまり`Maybe`リストに適用したい場合はどうなるだろう？
2層の関手を突破しなければならない。`fmap`を使えば外側の`Maybe`は突破できる。しかし、`f`はリストでは動作しないので、`Maybe`内に`f`を単に送ることはできない。内側のリストを操作するには`(fmap f)`を送る必要がある。たとえば、整数の`Maybe`リストの要素を2乗するにはどうするか見てみよう：

```haskell
square x = x * x

mis :: Maybe [Int]
mis = Just [1, 2, 3]

mis2 = fmap (fmap square) mis
```

コンパイラーは、型を分析した後、外側の`fmap`に対しては`Maybe`インスタンスからの実装を使い、内側のものに対してはlist関手の実装を使う必要があることを理解する。上記のコードを次のように書き換えられるのは、すぐには自明に思えないかもしれない：

```haskell
mis2 = (fmap . fmap) square mis
```

だが、`fmap`は引数が1つだけの関数と見なせることを思い出してほしい：

```haskell
fmap :: (a -> b) -> (f a -> f b)
```

この例では、`(fmap . fmap)`内の2番目の`fmap`は引数として次のものを取る：

```haskell
square :: Int -> Int
```

そして、次の型の関数を返す：

```haskell
[Int] -> [Int]
```

最初の`fmap`がこの関数を受け取り、次の関数を返す：

```haskell
Maybe [Int] -> Maybe [Int]
```

最後に、この関数は`mis`に適用される。したがって、2つの関手を合成すると、対応する2つの`fmap`を合成した`fmap`を持つ関手になる。圏論に話を戻すと、関手の合成が結合性を持つのはごく自明だ（対象の写像が結合性を持ち、射の写像も結合性を持つ）。また、すべての圏には自明な恒等関手があって、すべての対象を対象自身に写し、すべての射を射自身に写す。つまり、関手はある圏の射と全く同じ性質を持っている。しかし、それはどのような圏だろうか？
対象が圏であり射が関手である圏でなければならない。すなわち、圏の圏だ。ところが、*すべての*圏の圏はそれ自体を含まなければならず、すべての集合の集合を不可能にしたのと同じ種類の矛盾にぶつかることになる。しかし、$\Cat$と呼ばれる、すべての*小さい*圏の圏がある（$\Cat$自体は大きい圏なので、それ自体のメンバーにはなれない）。小さい圏で対象が形成するのは、集合よりも大きな何かではなく、集合だ。圏論では、数えられない無限集合であっても「小さい」と見なされることに注意してほしい。これらに言及しようと思ったのは、同じ構造が抽象化の多くのレベルで繰り返されているのを認識できることが、非常に驚くべきことだからだ。関手が圏を形成することについても後で説明する。

## 課題

1. 次のように定義することで、`Maybe`型コンストラクターを関手に変換できるか？

   ```haskell
   fmap _ _ = Nothing
   ```

   これは両方の引数を無視する。（ヒント：関手の規則をチェックする。）

2. Reader関手について関手の規則を証明せよ。ヒント：本当に単純だ。

3. 2番目に好きな言語でReader関手を実装せよ（1番目は当然、Haskellだ）。

4. List関手について関手の規則を証明せよ。適用するリストの尾部について規則が真であると仮定する（言い換えると、*帰納法*を使う）。
