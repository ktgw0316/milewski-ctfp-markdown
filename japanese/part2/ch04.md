# 表現可能関手 {#representable-functors}

そろそろ集合について少し話すべき時が来た。数学者たちは集合論に対して愛憎する関係にある。集合論は数学にとってのアセンブリー言語だ――少なくともかつてはそうだった。圏論はある程度、集合論から距離を置こうとする。たとえば、すべての集合の集合は存在しないが、すべての集合の圏$\Set$なら存在する、というのはよく知られた事実だ。これは良い。一方で我々は、圏内の任意の2対象間の射たちは集合をなす、と仮定した。そしてそれをhom集合と名付けさえした。公平のために言うと、圏論には射たちが集合をなさないことがあるような分野もある^[訳注：ここでは2対象間の射たちについて述べている。$\Set$でも、すべての射の集まり自体は集合にならない。]。その代わりにそれらは別の圏の対象となる。hom集合の代わりにhom対象を使う圏は[*豊穣*]{.keyword #enriched}\index{豊穣}圏 (enriched category) と呼ばれる。だが、以下では古き良きhom集合を持つ圏に留まることにする。

集合は、圏論における対象たちから取り出せる特徴のない塊、というのが最も近い。集合は要素を含むが、それらについて多くは語れない。有限集合なら要素数を数えられる。基数 (cardinal number) を使えば、無限集合の要素数をある意味で数えられる。たとえば、自然数の集合も実数の集合も無限集合だが、前者は後者よりも小さい。しかし、驚くかもしれないが、有理数の集合は自然数の集合と同じ大きさだ。

それ以外には、集合に関するすべての情報は、集合間の関数――特に、同型と呼ばれる可逆関数――として表せる。どこからどう見ても同型集合は同一だ。数学基礎論の研究者の逆鱗に触れる前に、等しさと同型には根本的に重要な区別があることを説明しておこう。これは数学の最新分野であるホモトピー型理論 (Homotopy Type Theory, HoTT) の主要な関心事の1つだ。ここでHoTTについて触れる理由は、それが計算からインスピレーションを得た純粋な数学理論で、主唱者の1人であるVladimir Voevodskyによる大きな発見が定理証明器Coqを研究しているときに得られたものだからだ。数学とプログラミングの相互作用は双方向なのだ。

集合に関する重要な教訓は、別種の要素からなる集合同士を比較しても問題ないということだ。たとえば、任意の自然変換の集合は何らかの射の集合と同型である、などと主張できる。集合は集合にすぎないからだ。この場合の同型は単に、一方の集合に属するどの自然変換に対しても他方の集合に属する一意な射が存在し、その逆もまた成り立つことを意味する。それらは互いにペアにできる。リンゴとオレンジが異なる圏の対象なら比較できないが、リンゴの集合とオレンジの集合は比較できる。多くの場合、圏論の問題を集合論の問題に変換すれば、必要な洞察が得られ、有用な定理を証明することさえ可能になる。

## Hom関手

すべての圏には、$\Set$への写像のカノニカルな族が用意されている。それらの写像は実際には関手であるため、圏の構造を保存している。そのような写像を1つ構築しよう。

$\cat{C}$内のある対象$a$を固定し、同じく$\cat{C}$内の別の対象$x$を選択しよう。Hom集合$\cat{C}(a, x)$ は集合であり、$\Set$の対象だ。$a$を固定したまま$x$を変化させると、$\cat{C}(a, x)$ も$\Set$内で変化する。それゆえ、$x$から$\Set$への写像が得られる。

`\begin{figure}[H] \centering`{=latex}
![](images/hom-set.jpg){width=45%}
`\end{figure}`{=latex}

\noindent
hom集合を2番目の引数に関する写像と見なしていることを強調したい場合は$\cat{C}(a, -)$ と表記する。ここで、ダッシュは引数のプレースホルダーを表している。

この対象の写像は射の写像へと容易に拡張できる。$\cat{C}$内の任意の2対象$x$と$y$の間の射$f$を考えてみよう。先ほど定義した写像によって、対象$x$は集合$\cat{C}(a, x)$ に写され、対象$y$は$\cat{C}(a, y)$ に写される。この写像が関手となるなら、$f$は2つの集合間の関数$\cat{C}(a, x) \to \cat{C}(a, y)$ に写されなければならない。

この関数を点ごとに、つまり、引数ごとに個別に定義しよう。引数として$\cat{C}(a, x)$ の任意の要素を1つ選択する必要がある。それを$h$と呼ぶことにする。射たちは端と端が一致すれば合成できる。たまたま$h$の終点が$f$の始点と一致しているので、それらの合成
$$f \circ h \Colon a \to y$$
は$a$から$y$への射となる。したがって、これは$\cat{C}(a, y)$ の元だ。

`\begin{figure}[H] \centering`{=latex}
![Hom関手](images/hom-functor.jpg){width=45%}
`\end{figure}`{=latex}

\noindent
先ほど、$\cat{C}(a, x)$ から$\cat{C}(a, y)$ への関数を見つけた。これは$f$の像として使える。混乱のおそれがない場合は、この持ち上げられた関数を$\cat{C}(a, f)$と記し、射$h$に対する作用を次のように記すことにしよう。
$$\cat{C}(a, f) h = f \circ h$$
この構成はどの圏でも機能するので、Haskellの型の圏でも機能するはずだ。Haskellでは、hom関手は`Reader`関手としてよく知られている。

```haskell
type Reader a x = a -> x
```

```haskell
instance Functor (Reader a) where
    fmap f h = f . h
```

\noindent
さて、Hom集合の始点を固定する代わりに終点を固定すると何が起こるかを考えてみよう。言い換えれば、写像$\cat{C}(-, a)$ も関手なのかを問うている。答えはそのとおり、関手なのだが、共変関手ではなく反変関手になる。射の端と端を同様にマッチングすると$f$との後合成となり、$\cat{C}(a, -)$ の場合のような前合成ではないからだ。

この反変関手はHaskellですでに見た。それは`Op`と呼ばれていた。

```haskell
type Op a x = x -> a
```

```haskell
instance Contravariant (Op a) where
    contramap f h = h . f
```

\noindent
最後に、両方の対象を変化させると、プロ関手$\cat{C}(-, =)$ が得られる。これは1つ目の引数について反変で、2つ目の引数について共変だ（2つの引数が独立して変化することを強調するため、2つ目のプレースホルダーとしてダブルダッシュを使った）。このプロ関手については、関手性について述べたときにすでに見た。

```haskell
instance Profunctor (->) where
  dimap ab cd bc = cd . bc . ab
  lmap = flip (.)
  rmap = (.)
```

\noindent
重要な教訓として、対象たちをhom集合へ写すことは関手的である、という観察はすべての圏に当てはまる。反変性は反対圏から写すことと等価なので、この事実は簡潔にこう記せる。
$$C(-, =) \Colon \cat{C}^\mathit{op} \times \cat{C} \to \Set$$

## 表現可能関手

これまでに見たように、$\cat{C}$内の対象$a$の選択ごとに$\cat{C}$から$\Set$への関手が得られる。構造を保存する$\Set$へのこの種の写像は[*表現*]{.keyword #representation}\index{表現} (representation) とよく呼ばれる。つまり、$\cat{C}$における対象や射を$\Set$内の集合や関数として表現しているということだ。

関手$\cat{C}(a, -)$ 自体を指して表現可能関手と呼ぶこともある。より一般には、ある$a$の選択に対してhom関手と自然同型である関手$F$はすべて[*表現可能*]{.keyword #representable}\index{表現可能} (representable) 関手と呼ばれる。このような関手は必然的に集合値 ($\Set$-valued) 関手となる。$\cat{C}(a, -)$ がそうだからだ。

以前述べたように、同型集合は同一と見なされることが多い。より一般には、圏の同型*対象*は同一と見なされる。対象たちは他の対象たち（およびそれら自身）との射による関係だけしか構造を持たないからだ。

たとえば、モノイドの圏$\cat{Mon}$について前に説明した。それは最初は集合たちでモデル化されていた。ただし、それらの集合によるモノイドの構造を保存する関数のみを射として選ぶように気を付けた。そのため、$\cat{Mon}$内の2つの対象は、同型なら、つまり可逆な射が間にあるなら、全く同じ構造を持つ。それらが基づく集合と関数を覗き見ると、一方のモノイドの単位元がもう一方のモノイドの単位元へと写され、2つの要素の積がそれらの要素を写したものの積へと写されているのが分かるだろう。

同じ推論が関手にも適用できる。2つの圏の間の関手は圏をなし、そこでは自然変換が射の役割を果たしている。したがって、2つの関手の間に可逆な自然変換があれば、それらは同型であり、同一と見なせる。

この観点から表現可能関手の定義を分析してみよう。$F$が表現可能となるには次が必要だ。$\cat{C}$内に対象$a$があり、$\cat{C}(a, -)$から$F$への自然変換$\alpha$があり、逆方向に別の自然変換$\beta$があり、それらの合成が恒等自然変換である。

ある対象$x$における$\alpha$の成分を見てみよう。それは$\Set$内の関数だ。
$$\alpha_x \Colon \cat{C}(a, x) \to F x$$
この変換の自然性条件は、$x$から$y$への任意の射$f$について、次の関係を表す図式が可換となることを示している。
$$F f \circ \alpha_x = \alpha_y \circ \cat{C}(a, f)$$
Haskellでは、自然変換を多相関数で置き換えることになる。

```haskell
alpha :: forall x. (a -> x) -> F x
```

\noindent
ここで使った量化子`forall`は必須ではない。自然性条件

```haskell
fmap f . alpha = alpha . fmap f
```

\noindent
はパラメトリシティ (parametricity) によって自動的に満たされる（この自然性条件は前述のtheorems for freeのひとつだ）。これは、左辺の`fmap`が関手$F$によって定義され、右辺の`fmap`がreader関手によって定義されるという理解に基づく。readerの`fmap`は単なる関数の前合成^[訳注：引数の関数`f`にreaderの関数を前合成する。]なので、さらにはっきりと書ける。$\cat{C}(a, x)$ の要素である$h$に作用したときの自然性条件は次のように簡潔に書ける。

```haskell
fmap f (alpha h) = alpha (f . h)
```

\noindent
もう1つの変換`beta`は方向が逆だ。

```haskell
beta :: forall x. F x -> (a -> x)
```

\noindent
この関数も自然性条件を満たす必要があり、そして`alpha`の逆関数でなければならない。

```haskell
alpha . beta = id = beta . alpha
```

\noindent
後で説明するとおり、$F a$が空でないならば常に$\cat{C}(a, -)$ から任意の集合値関手への自然変換が存在する（米田の補題）が、この変換は可逆であるとは限らない。

Haskellでリスト関手を用い、`Int`を`a`とした例を挙げよう。以下が具体的な自然変換の一例だ。

```haskell
alpha :: forall x. (Int -> x) -> [x]
alpha h = map h [12]
```

\noindent
勝手な数として12を選び、それを使って単要素リストを作成した。次に、このリストに関数`h`を`fmap`し、`h`の戻り値の型のリストを取得する。（実際には、そのような変換は整数のリストと同じくらいたくさんある。）

自然性条件は`map`（`fmap`のリスト版）の合成可能性と等価だ。

```haskell
map f (map h [12]) = map (f . h) [12]
```

\noindent
しかし、逆変換を見つけるには、任意の型`x`のリストをもとに`x`を返す関数を探さなくてはならない。

```haskell
beta :: forall x. [x] -> (Int -> x)
```

\noindent
`head`か何かを使ってリストから`x`を取得しようと考えたかもしれないが、空のリストには使えない。（`Int`の箇所の）型`a`の選択肢としてここで使えるものがないことに注目してほしい。すなわち、リスト関手は表現可能ではない。

Haskellの（自己）関手がコンテナーに少し似ていると言ったのを覚えているだろうか？　同じように、表現可能関手は関数呼び出しの結果をメモ化して保存するためのコンテナーと見なせる（Haskellでのhom集合の要素は単なる関数だ）。表現対象 (representing object)、すなわち$\cat{C}(a, -)$ における型$a$はキー型と見なせて、それを用いれば表化 (tabulate) された関数値にアクセスできる。ここでの変換`alpha`は`tabulate`と呼ばれ、その逆の`beta`は`index`と呼ばれる。以下に（少し単純化した）`Representable`のクラス定義を示す。

```haskell
class Representable f where
   type Rep f :: *
   tabulate :: (Rep f -> x) -> f x
   index    :: f x -> Rep f -> x
```

\noindent
表現型、すなわち$a$が、ここでは`Rep f`と呼ばれ、`Representable`の定義の一部であることに注目してほしい。スターは`Rep f`が型である（型構成子や他のエキゾチックな種ではない）ことを意味する^[訳注：事実標準のHaskell処理系のGHCでは、現在はこの用法でのスター`*`は非推奨となっている。代わりに`Data.Kind`モジュールが提供する`Type`を用いる。]。

無限リストや無限ストリームは、空ではあり得ず、表現可能だ。

```haskell
data Stream x = Cons x (Stream x)
```

\noindent
それらは`Integer`を引数に取る関数の値をメモ化したものと見なせる。（厳密に言えば、非負整数を使うべきだが、コードを複雑にしたくなかった^[訳注：`Integer`の代わりに`Numeric.Natural`モジュールが提供する`Natural`を用いればよい。]。）

このような関数を`tabulate`にするには、値の無限ストリームを作成する。もちろん、これが可能なのはHaskellが遅延評価だからだ。つまり、値は必要になったとき評価される。メモ化された値にアクセスするには`index`を使う。

```haskell
instance Representable Stream where
    type Rep Stream = Integer
    tabulate f = Cons (f 0) (tabulate (f . (+1)))
    index (Cons b bs) n =
        if n == 0 then b else index bs (n - 1)
```

\noindent
任意の戻り値型を持つ関数の族をすべてカバーするような単一のメモ化スキームを実装できるのは興味深い。

反変関手の表現可能性も同様に定義される。ただし、$\cat{C}(-, a)$ の2番目の引数を固定する。あるいは、$\cat{C}^\mathit{op}$から$\Set$への関手を考えるのでも等価だ。$\cat{C}^\mathit{op}(a, -)$ は$\cat{C}(-, a)$ と同じだからだ。

表現可能性には興味深いひねりがある。デカルト閉圏では、hom集合を内部的には冪対象として扱えることを思い出してほしい。hom集合$\cat{C}(a, x)$ は$x^a$と等価で、表現可能関手$F$に対しては$-^a = F$と書ける。

試しに、両辺の対数を取ってみると$a = \mathbf{log}F$となる。

もちろん、これは純粋に形式的な変換だが、対数の性質を多少知っているなら非常に便利だ。特に、直積型に基づく関手は直和型を用いて表現でき^[訳注：すなわち、上で言うところの$a$が直和型になるということ。]、直和型の関手は一般に表現可能ではないことが知られている（例：リスト関手）。

最後に、表現可能関手が同じものに対する2種類の実装――ひとつは関数、もうひとつはデータ構造――を与えることに注目してほしい。それらの内容は全く同じだ――同じキーを使えば同じ値が取得される。それが、語ろうとしていた「同一性」の感覚だ。2つの自然同型な関手は内容に関する限り同一だ。その一方で、2つの表現は異なる方法で実装されることが多く、パフォーマンス特性が異なる可能性がある。メモ化はパフォーマンス改善策として使われ、実行時間の大幅な短縮につながる可能性がある。同じ計算を背景とする異なる表現を生成できることは、実用上の価値が非常に高い。そのため、驚くべきことに、圏論はパフォーマンスを全く考慮しないにもかかわらず、実用上の価値を持つ別の実装を探求する十分な機会を与えてくれる。

## 課題

1. Hom関手が$\cat{C}$内の恒等射を$\Set$内の対応する恒等関数に写すことを示せ。

1. `Maybe`が表現可能でないことを示せ。

1. `Reader`関手は表現可能か？

1. `Stream`表現を使って、引数を2乗する関数をメモ化せよ。

1. `Stream`に対する`tabulate`と`index`が実際に互いに逆であることを示せ。（ヒント：数学的帰納法を使う。）

1. 次の関手

   ```haskell
   Pair a = Pair a a
   ```

   \noindent
   は表現可能だ。それを表現する型が分かるだろうか？
   `tabulate`と`index`を実装せよ。

## 参考文献

1. [表現可能関手についてのCatstersの動画](https://www.youtube.com/watch?v=4QgjKUzyrhM)^[<https://www.youtube.com/watch?v=4QgjKUzyrhM>]
