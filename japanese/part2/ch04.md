# 表現可能関手 {#representable-functors}

そろそろ集合について少し話そう。数学者は集合論に対して愛憎相半ばする。集合論は数学にとってのアセンブリー言語だ――少なくともかつてはそうだった。圏論はある程度、集合論から距離を置こうとする。たとえば、すべての集合の集合は存在しないが、すべての集合の圏$\Set$なら存在する、というのはよく知られた事実だ。これは良い。一方で我々は、圏内の任意の2対象間の射は集合を形成する、と仮定した。そしてそれをhom集合と名付けさえした。公平のために言うと、圏論には射が集合を形成しないような分野もある。そこでは射は別の圏の対象となる。hom集合の代わりにhom対象を使う圏は[*豊穣*]{.keyword #enriched}\index{豊穣}圏 (enriched category) と呼ばれる。しかし、以下では古き良きhom集合を持つ圏に留まることにする。

集合は、圏論での対象を飲み込める特徴のない塊、というのが最も近い。集合が含む要素については、言えることが少ししかない。有限集合なら要素を数えられる。基数 (cardinal number) を使えば、ある意味で無限集合の要素を数えられる。たとえば、自然数の集合は実数の集合よりも小さいが、両者とも無限だ。ただし、驚くかもしれないが、有理数の集合は自然数の集合と同じ大きさだ。

それ以外には、集合に関するすべての情報は、集合間の関数に――特に、同型と呼ばれる可逆関数に――エンコードできる。どこからどう見ても同型集合は同一だ。数学基礎論の研究者の逆鱗に触れる前に、等価性と同型には根本的に重要な区別があることを説明しておこう。これは数学の最新分野であるホモトピー型理論 (Homotopy Type Theory, HoTT) の主要な関心事の1つだ。ここでHoTTについて触れるのは、その純粋な数学理論が計算機科学にインスピレーションを得たものだからだ。主唱者の1人であるVladimir Voevodskyによる大きな発見は、定理証明系Coqを研究しているときに得られた。数学とプログラミングの相互作用は双方向なのだ。

集合に関する重要な教訓は、異なる要素の集合を比較しても問題ないということだ。たとえば、ある自然変換の集合は何らかの射の集合と同型だと言える。集合はただの集合だからだ。この場合の同型とは、一方の集合からの自然変換すべてについて他方の集合からの一意な射が存在し、逆もまた成り立つことを意味する。それらは互いにペアにできる。リンゴとオレンジが異なる圏の対象なら比較できないが、リンゴの集合とオレンジの集合は比較できる。多くの場合、圏論の問題を集合論の問題に変換すれば、必要な洞察が得られ、有用な定理を証明することさえ可能になる。

## Hom関手

すべての圏には、$\Set$への写像の正統な族が用意されている。それらの写像は実際には関手であるため、圏の構造を保存している。そのような写像を1つ生成しよう。

ある対象$a$を$\cat{C}$内で固定し、別の対象$x$も同様に$\cat{C}$内で選択しよう。Hom集合$\cat{C}(a, x)$ は集合なので、$\Set$の対象だ。$a$を固定したまま$x$を変化させると、$\cat{C}(a, x)$ も$\Set$内で変化する。それゆえ、$x$から$\Set$への写像が存在する。

`\begin{figure}[H] \centering`{=latex}
![](images/hom-set.jpg){width=45%}
`\end{figure}`{=latex}
\noindent
hom集合を写像と見なしているということを2番目の引数で強調したい場合は$\cat{C}(a, -)$ と表記する。ここで、ダッシュは引数のプレースホルダーとして機能する。

この対象の写像は射の写像へと容易に拡張できる。$\cat{C}$内の任意の2対象$x$と$y$の間の射$f$を考えてみよう。先ほど定義した写像によって、対象$x$は集合$\cat{C}(a, x)$ に写され、対象$y$は$\cat{C}(a, y)$ に写される。この写像が関手なら、$f$は2つの集合間の関数に写されなければならない：
$$\cat{C}(a, x) \to \cat{C}(a, y)$$
この関数をpoint-wiseに定義しよう。つまり、引数ごとに個別に定義する。引数として、$\cat{C}(a, x)$ の任意の要素を1つ選択する必要がある。それを$h$と呼ぼう。射は端と端が一致すれば合成可能だ。ここでも$h$の終域が$f$の始域と一致しており、それらの合成：
$$f \circ h \Colon a \to y$$
は$a$から$y$への射となる。したがって、これは$\cat{C}(a, y)$ の元だ。

![Hom関手](images/hom-functor.jpg){width=45%}

\noindent
先ほど、$\cat{C}(a, x)$ から$\cat{C}(a, y)$ への関数を見つけた。これは$f$の像として使える。混乱のおそれがないなら、このリフトされた関数を次のように記述しよう：
$$\cat{C}(a, f)$$
そして、射$h$に対する作用を次のように記述しよう：
$$\cat{C}(a, f) h = f \circ h$$
この構成はどの圏でも機能するので、Haskellの型の圏でも機能するはずだ。Haskellでは、hom関手は`Reader`関手としてよく知られている：

```haskell
type Reader a x = a -> x
```

```haskell
instance Functor (Reader a) where
    fmap f h = f . h
```

\noindent
Hom集合の始域を固定する代わりに終域を固定すると何が起こるかを考えてみよう。言い換えれば、写像$\cat{C}(-, a)$ も関手なのかという疑問だ。そのとおり、関手だ。ただし、共変ではなく反変になる。射の端と端を同様にマッチングすると$f$による後合成 (postcomposition) となり、$\cat{C}(a, -)$ の場合のような前合成 (precomposition) ではないからだ。

この反変関手はHaskellですでに見た。それは`Op`と呼ばれていた。

```haskell
type Op a x = x -> a
```

```haskell
instance Contravariant (Op a) where
    contramap f h = h . f
```

\noindent
最後に、両方の対象を変化させると、プロ関手$\cat{C}(-, =)$ が得られる。これは1つ目の引数について反変で、2つ目の引数について共変だ（2つの引数が独立して変化することを強調するため、2つ目のプレースホルダーとしてダブルダッシュを使った）。このプロ関手については、関手性について話したときに見た：

```haskell
instance Profunctor (->) where
  dimap ab cd bc = cd . bc . ab
  lmap = flip (.)
  rmap = (.)
```

\noindent
重要な教訓として、この観察はどの圏にも当てはまる。すなわち、対象からhom集合への写像は関手的だ。反変は反対圏からの写像と等価なので、この事実は簡潔にこう記せる：
$$C(-, =) \Colon \cat{C}^\mathit{op} \times \cat{C} \to \Set$$

## 表現可能関手

これまでに見たように、$\cat{C}$で対象$a$を選択するたびに$\cat{C}$から$\Set$への関手が得られる。このように構造を保存する$\Set$への写像は[*表現*]{.keyword #representation}\index{表現} (representation) と呼ばれることが多い。$\cat{C}$での対象や射は$\Set$内の集合や関数として表現される。

関手$\cat{C}(a, -)$ 自体を指して表現可能関手と呼ぶこともある。より一般には、ある$a$の選択に対してhom関手と自然同型である関手$F$はすべて[*表現可能*]{.keyword #representable}\index{表現可能} (representable) 関手と呼ばれる。このような関手は必然的に集合値関手 ($\Set$-valued functor) となる。$\cat{C}(a, -)$ がそうだからだ。

以前述べたように、同型集合は同一と見なされることが多い。より一般には、圏の同型*対象*は同一と見なされる。ある対象は、他の対象（およびそれ自身）との射による関係以外の構造を持たないからだ。

たとえば、まず集合でモデル化されたモノイドの圏$\cat{Mon}$について以前説明した。ただし、それらの集合のモノイダル構造を保存する関数のみを射として選ぶように気を付けた。そのため、$\cat{Mon}$内の2つの対象は、同型なら、つまり可逆な射が間にあるなら、全く同じ構造を持つ。それらが基づく集合と関数を見てみると、片方のモノイドの単位元はもう片方のモノイドの単位元に写され、2つの要素の積はそれらの写像の積に写されているのが分かる。

同じ論法が関手にも適用できる。2つの圏の間の関手は圏を形成し、そこでは自然変換が射の役割を果たしている。したがって、2つの関手の間に可逆な自然変換があれば、それらは同型であり、同一と見なせる。

この観点から表現可能関手の定義を分析してみよう。$F$が表現可能となる条件は次のとおりだ：$\cat{C}$に対象$a$があり、$\cat{C}(a, -)$から$F$への自然変換$\alpha$が1つあり、逆方向に別の自然変換$\beta$があり、それらの合成が恒等自然変換であること。

ある対象$x$における$\alpha$の成分を見てみよう。それは$\Set$内の関数だ：
$$\alpha_x \Colon \cat{C}(a, x) \to F x$$
この変換の自然性条件は、$x$から$y$へのすべての射$f$について、次の図式が可換であることを示している：
$$F f \circ \alpha_x = \alpha_y \circ \cat{C}(a, f)$$
Haskellでは、自然変換を多相関数に置き換えればよい：

```haskell
alpha :: forall x. (a -> x) -> F x
```

\noindent
ここで必須ではない量化子`forall`を使った。自然性条件：

```haskell
fmap f . alpha = alpha . fmap f
```

\noindent
はパラメトリック性（前述のtheorems for freeの1つ）によって自動的に満たされる。これは、左辺の`fmap`が関手$F$によって定義され、右辺の`fmap`がreader関手によって定義されるという理解に基づく。readerでの`fmap`は単なる関数の前合成なので、さらに明示的にできる。$\cat{C}(a, x)$ の要素である$h$に作用することで、自然性条件は次のように単純化される：

```haskell
fmap f (alpha h) = alpha (f . h)
```

\noindent
もう1つの変換`beta`は方向が逆だ：

```haskell
beta :: forall x. F x -> (a -> x)
```

\noindent
これは自然性条件を満たす必要があり、`alpha`の逆関数でなければならない：

```haskell
alpha . beta = id = beta . alpha
```

\noindent
後で説明するとおり、$F a$が空でないならば常に$\cat{C}(a, -)$ から任意の集合値関手への自然変換が存在する（米田の補題）が、必ずしも可逆ではない。

Haskellでlist関手を用い、`Int`を`a`とした例を挙げよう。それを実現する自然変換はこうなる：

```haskell
alpha :: forall x. (Int -> x) -> [x]
alpha h = map h [12]
```

\noindent
任意の数字として12を選び、それを使って単要素リストを作成した。次に、このリストに関数`h`を`fmap`し、`h`が返す型のリストを取得する。（実際には、そのような変換は整数のリストと同じくらいたくさんある。）

自然性条件は`map`（`fmap`のリスト版）の合成可能性と等価だ：

```haskell
map f (map h [12]) = map (f . h) [12]
```

\noindent
しかし、逆変換を見つけるには、任意の型`x`のリストをもとに`x`を返す関数を探さなくてはならない。

```haskell
beta :: forall x. [x] -> (Int -> x)
```

\noindent
`head`か何かを使ってリストから`x`を取得しようと考えたかもしれないが、空のリストには使えない。ここで（`Int`の代わりとして）機能する型`a`の選択肢がないことに注目してほしい。すなわち、list関手は表現可能ではない。

Haskellの（自己）関手がコンテナに少し似ていると言ったのを覚えているだろうか？
同じように、表現可能関手は関数呼び出しの結果をメモ化して保存するためのコンテナと見なせる（Haskellでのhom集合の要素は単なる関数だ）。$\cat{C}(a, -)$ 内の対象を表現する型$a$は、関数の表形式の値にアクセスするためのキー型と見なせる。ここでの変換`alpha`は`tabulate`と呼ばれ、その逆の`beta`は`index`と呼ばれる。以下は（少し単純化した）`Representable`のクラス定義だ：

```haskell
class Representable f where
   type Rep f :: *
   tabulate :: (Rep f -> x) -> f x
   index    :: f x -> Rep f -> x
```

\noindent
ここで`Rep f`と呼ばれる型を表現する$a$が`Representable`の定義の一部であることに注意してほしい。アスタリスクは、`Rep f`が型である（型コンストラクターやその他のエキゾチックなカインドではない）ことを意味する。

無限リストや空でないストリームは表現可能だ：

```haskell
data Stream x = Cons x (Stream x)
```

\noindent
それらは`Integer`を引数に取る関数の値をメモ化したものと見なせる。（厳密に言えば、非負整数を使うべきだが、コードを複雑にしたくなかった。）

このような関数を`tabulate`化するためには、値の無限ストリームを作成する。もちろん、これが可能なのはHaskellが遅延評価だからだ。つまり、値は必要になったとき評価される。メモ化された値にアクセスするには`index`を使う。

```haskell
instance Representable Stream where
    type Rep Stream = Integer
    tabulate f = Cons (f 0) (tabulate (f . (+1)))
    index (Cons b bs) n = if n == 0 then b else index bs (n - 1)
```

\noindent
任意の戻り値型を持つ関数の族をすべてカバーするような単一のメモ化スキームを実装できるのは興味深い。

反変関手の表現可能性も同様に定義される。ただし、$\cat{C}(-, a)$ の2番目の引数を固定する。あるいは、$\cat{C}^\mathit{op}$から$\Set$への関手を考えるのでも等価だ。なぜなら、$\cat{C}^\mathit{op}(a, -)$ は$\cat{C}(-, a)$ と同じだからだ。

表現可能性には興味深い捻じれがある。カルテシアン閉圏では、hom集合を内部的には冪対象として扱えることに注意してほしい。hom集合$\cat{C}(a,x)$ は$x^a$と等価で、表現可能関手$F$に対しては次のように書ける：
$$-^a = F$$
試しに、両辺の対数をとってみよう：
$$a = \mathbf{log}F$$
もちろん、これは純粋に形式的な変換だが、対数の性質を多少知っている人にとっては非常に便利だ。特に、直積型に基づく関手は直和型で表現でき、直和型の関手は一般に表現可能ではないことが知られている（例：list関手）。

最後に、表現可能関手が同じものに対して2種類の実装を与えていることに注目してほしい――1つは関数、1つはデータ構造だ。それらの内容は全く同じだ――同じキーを使えば同じ値が取得される。それが、語ろうとしていた「同一性」の感覚だ。2つの自然同型な関手は内容に関する限り同一だ。その一方で、2つの表現は異なる方法で実装されることが多く、パフォーマンス特性が異なる可能性がある。メモ化はパフォーマンス改善策として使われ、実行時間の大幅な短縮につながる可能性がある。同じ基礎計算の異なる表現を生成できることは、実用上の価値が非常に高い。そのため、驚くべきことに、圏論はパフォーマンスを全く考慮しないにもかかわらず、実用上の価値を持つ別の実装を探求する十分な機会を与えてくれる。

## 課題

1. Hom関手が$\cat{C}$内の恒等射を$\Set$内の対応する恒等関数に写すことを示せ。

2. `Maybe`が表現可能でないことを示せ。

3. `Reader`関手は表現可能か？

4. `Stream`表現を使って、引数を2乗する関数をメモ化せよ。

5. `Stream`に対する`tabulate`と`index`が実際に互いに逆であることを示せ。（ヒント：数学的帰納法を使う。）

6. 次の関手：

   ```haskell
   Pair a = Pair a a
   ```

\noindent
   は表現可能だ。それを表現する型が分かるだろうか？
   `tabulate`と`index`を実装せよ。

## 参考文献

1. [表現可能関手](https://www.youtube.com/watch?v=4QgjKUzyrhM)^[<https://www.youtube.com/watch?v=4QgjKUzyrhM>]についてのCatstersの動画
