# 表現可能関手 {#representable-functors}

そろそろ集合について少し話そう。数学者は集合論に対し愛憎関係にある。集合論は数学にとってのアセンブリー言語だ――少なくともかつてはそうだった。圏論はある程度、集合論から距離を置こうとする。たとえば、すべての集合の集合は存在しないが、すべての集合の圏である$\Set$が存在するのは周知の事実だ。それは良いことだ。一方で我々は、圏内の任意の2対象間の射は集合を形成する、と仮定した。そしてそれをhom集合とさえ名付けた。公平のために言うと、圏論には射が集合を形成しないような分野もある。そこでは射は別の圏の対象となる。Hom集合の代わりにhom対象を使う圏は[豊穣]{.keyword #enriched} (enriched) 圏と呼ばれる。しかし、以下では古き良きhom集合を持つ圏に固執しよう。

集合は、圏論での対象の外で得られる特徴のない塊に最も近いものだ。集合が含む要素については、言えることが少ししかない。有限集合なら要素を数えられる。基数 (cardinal number) を使えば、ある意味で無限集合の要素を数えられる。たとえば、自然数の集合は実数の集合よりも小さいが、両者とも無限だ。しかし、驚くべきことに、有理数の集合は自然数の集合と同じ大きさだ。

それ以外には、集合に関するすべての情報は、集合間の関数に――特に、同型と呼ばれる可逆関数に――エンコードできる。どこからどう見ても同型集合は同一だ。数学基礎論の研究者の逆鱗に触れる前に、等価性と同型には根本的に重要な区別があることを説明しておこう。これは数学の最新分野であるホモトピー型理論 (Homotopy Type Theory, HoTT) の主要な関心事のひとつだ。ここでHoTTについて触れるのは、その純粋な数学理論が計算機科学にインスピレーションを得たものだからだ。主唱者の1人であるVladimir Voevodskyは、Coq定理証明系を研究しているときに大きな発見をした。数学とプログラミングは双方向に相互作用する。

集合に関する重要な教訓は、異なる要素の集合を比較しても問題ないということだ。たとえば、任意の自然変換の集合はある射の集合と同型だと言える。集合はただの集合だからだ。この場合の同型とは、一方の集合からの自然変換すべてについて他方の集合からの一意な射が存在し、逆もまた成り立つことを意味する。それらは互いにペアにできる。リンゴとオレンジが異なる圏の対象なら比較できないが、リンゴの集合とオレンジの集合は比較できる。多くの場合、圏論の問題を集合論の問題に変換すれば、必要な洞察が得られ、有用な定理を証明することさえ可能になる。

## Hom関手

すべての圏には、$\Set$への標準的な写像の族が用意されている。それらの写像は実際には関手であるため、圏の構造を保存している。そのような写像をひとつ生成しよう。

ある対象$a$を$\cat{C}$内で固定し、別の対象$x$も同様に$\cat{C}$内で選択しよう。Hom集合$\cat{C}(a, x)$ は集合なので、$\Set$の対象だ。$a$を固定したまま$x$を変化させると、$\cat{C}(a, x)$ も$\Set$内で変化する。したがって、$x$から$\Set$への写像が存在する。

![](images/hom-set.jpg){width=45%}

hom集合を写像と見なしているということを2番目の引数で強調したい場合は$\cat{C}(a, -)$ と表記する。ここで、ダッシュは引数のプレースホルダとして機能する。

この対象の写像は射の写像に容易に拡張できる。$\cat{C}$内の任意の2対象$x$と$y$の間の射$f$を考えてみよう。先ほど定義した写像によって、対象$x$は集合$\cat{C}(a, x)$ に写され、対象$y$は$\cat{C}(a, y)$ に写される。If this mapping is to be a functor, $f$ must be mapped to a function between the two sets:

$$\cat{C}(a, x) \to \cat{C}(a, y)$$

この関数をpoint-wiseに定義しよう。つまり、引数ごとに個別に定義する。引数として、$\cat{C}(a, x)$ の任意の要素を1つ選択する必要がある。それを$h$と呼ぼう。射は端と端が一致すれば合成可能だ。ここでも$h$の終域が$f$の始域と一致しており、それらの合成:

$$f \circ h \Colon a \to y$$

は$a$から$y$への射となる。したがって、これは$\cat{C}(a, y)$ のメンバーだ。

![Hom関手](images/hom-functor.jpg){width=45%}

先ほど、$\cat{C}(a, x)$ から$\cat{C}(a, y)$ への関数を見つけた。これは$f$の像として使える。If there is no danger of confusion, we'll write this lifted function as:

$$\cat{C}(a, f)$$

and its action on a morphism $h$ as:

$$\cat{C}(a, f) h = f \circ h$$

この構成はどの圏でも機能するので、Haskellの型の圏でも機能するはずだ。Haskellでは、hom関手は`Reader`関手としてよく知られている:

```haskell
type Reader a x = a -> x
```

```haskell
instance Functor (Reader a) where
    fmap f h = f . h
```

Hom集合の始域を固定する代わりに終域を固定すると何が起こるかを考えてみよう。言い換えれば、写像$\cat{C}(-, a)$ も関手なのかという疑問だ。その通り、関手だ。ただし、共変ではなく反変だ。なぜなら、同じ種類の射の端と端のマッチングは$f$による後置合成 (postcomposition) で、$\cat{C}(a, -)$ の場合のような前置合成 (precomposition) ではないからだ。

この反変関手はHaskellですでに見た。それは`Op`と呼ばれていた。

```haskell
type Op a x = x -> a
```

```haskell
instance Contravariant (Op a) where
    contramap f h = h . f
```

最後に、両方の対象を変化させると、プロ関手$\cat{C}(-, =)$ が得られる。これは最初の引数について反変で、2番目の引数について共変だ (2つの引数が独立して変化することを強調するため、2番目のプレースホルダとして二重ダッシュを使った)。このプロ関手については、関手性について話したときに見た:

```haskell
instance Profunctor (->) where
  dimap ab cd bc = cd . bc . ab
  lmap = flip (.)
  rmap = (.)
```

重要な教訓は、この観察がどの圏にも当てはまるということだ。すなわち、対象からhom集合への写像は関手的だ。反変は反対圏からの写像と等価なので、この事実は次のように簡潔に述べられる:

$$C(-, =) \Colon \cat{C}^{op} \times \cat{C} \to \Set$$

## 表現可能関手

これまで見てきたように、$\cat{C}$で対象$a$を選択するたびに、$\cat{C}$から$\Set$への関手が得られる。このように構造を保存する$\Set$への写像は、しばしば[表現]{.keyword #representation} (representation) と呼ばれる。$\cat{C}$での対象や射は、$\Set$内の集合や関数として表現される。

関手$\cat{C}(a, -)$ 自体を、表現可能と呼ぶこともある。より一般的には、ある$a$の選択に対してhom関手と自然同型である関手$F$はすべて、[表現可能]{.keyword #representable} (representable) と呼ばれる。このような関手は必ず集合値関手 ($\Set$-valued functor) でなければならない。なぜなら、$\cat{C}(a, -)$ がそうだからだ。

同型集合は同一と見なされることが多い、と前に述べた。より一般的には、圏の同型*対象*は同一と見なされる。ある対象は、他の対象 (およびそれ自身) との射による関係以外の構造を持たないからだ。

たとえば、我々は以前、まず集合でモデル化されたモノイドの圏、$\cat{Mon}$について説明した。ただし、それらの集合のモノイダル構造を保存する関数のみを射として選ぶように気を付けた。したがって、$\cat{Mon}$内の2つの対象が同型である場合、すなわち、それらの間に可逆な射がある場合、それらはまったく同じ構造を持つ。それらが基づく集合と関数を見てみると、片方のモノイドの単位元はもう片方のモノイドの単位元に写され、2つの要素の積はそれらの写像の積に写されているのがわかる。

同じ論法が関手にも適用できる。2つの圏の間の関手は圏を形成し、そこでは自然変換が射の役目を果たしている。したがって、2つの関手の間に可逆な自然変換があれば、それらは同型であり、同一と見なせる。

この観点から、表現可能関手の定義を分析してみよう。For $F$ to be representable we require that: There be an object $a$ in $\cat{C}$; one natural transformation $\alpha$ from $\cat{C}(a, -)$ to $F$; another natural transformation, $\beta$, in the opposite direction; and that their composition be the identity natural transformation.

ある対象$x$における$\alpha$のコンポーネントを見てみよう。それは$\Set$の関数だ:

$$\alpha_x \Colon \cat{C}(a, x) \to F x$$

この変換の自然条件は、$x$から$y$へのすべての射$f$について、次の図式が可換であることを示している:

$$F f \circ \alpha_x = \alpha_y \circ \cat{C}(a, f)$$

Haskellでは、自然変換を多相関数に置き換えればよい:

```haskell
alpha :: forall x. (a -> x) -> F x
```

ここでオプションの全称量化子`forall`を使った。自然条件

```
fmap f . alpha = alpha . fmap f
```

はパラメトリック性 (前述のフリーの定理の1つ) によって自動的に満たされる。これは、左側の`fmap`が関手$F$によって定義され、右側の`fmap`がreader関手によって定義されるという理解に基づく。readerでの`fmap`は単なる関数の前置合成なので、さらに明示的にできる。$\cat{C}(a, x)$ の要素である$h$に作用することで、自然条件は次のように単純化される:

```haskell
fmap f (alpha h) = alpha (f . h)
```

もう1つの変換`beta`は方向が逆だ:

```haskell
beta :: forall x. F x -> (a -> x)
```

これは自然条件を満たす必要があり、`alpha`の逆関数でなければならない:

```haskell
alpha . beta = id = beta . alpha
```

後で説明するとおり、$F a$が空でない限り、$\cat{C}(a, -)$ から任意の集合値関手への自然変換は常に存在する (米田の補題)。ただし、必ずしも可逆ではない。

Haskellの例を挙げよう。list関手と`Int`を`a`とする。それを実現する自然変換はこうだ:

```haskell
alpha :: forall x. (Int -> x) -> [x]
alpha h = map h [12]
```

任意の数字として12を選び、それを使って単要素リストを作成した。次に、このリストに関数`h`を`fmap`し、`h`が返す型のリストを取得する。(実際には、そのような変換は整数のリストと同じくらいたくさんある。)

自然条件は`map`の合成可能性 (`fmap`のリスト版) と等価だ:

```haskell
map f (map h [12]) = map (f . h) [12]
```

しかし、逆変換を見つけるには、任意の型`x`のリストを元に`x`を返す関数を探さなくてはならない。

```haskell
beta :: forall x. [x] -> (Int -> x)
```

`head`か何かを使ってリストから`x`を取得しようと考えたかもしれないが、空のリストには使えない。ここで (`Int`の代わりとして) 機能する型`a`の選択肢がないことに注目してほしい。すなわち、list関手は表現可能ではない。

Haskell (自己) 関手がコンテナに少し似ていると言ったのを覚えているだろうか？
同じように、表現可能関手は、関数呼び出しの結果をメモ化して保存するためのコンテナと見なせる (Haskellでのhom集合の要素は単なる関数だ)。$\cat{C}(a, -)$ 内の対象を表現する型$a$は、関数の表形式の値にアクセスするためのキー型と見なせる。ここでの変換`alpha`は`tabulate`と呼ばれ、その逆の`beta`は`index`と呼ばれる。以下は (少し単純化した) `表現可能`クラス定義だ:

```haskell
class Representable f where
   type Rep f :: *
   tabulate :: (Rep f -> x) -> f x
   index    :: f x -> Rep f -> x
```

ここで`Rep f`と呼ばれる型を表現する$a$は、`表現可能`の定義の一部であることに注意してほしい。星印は`Rep f`が型である (型コンストラクターやその他のエキゾチックなカインドではない) ことを意味する。

無限リストや空でないストリームは表現可能だ。

```haskell
data Stream x = Cons x (Stream x)
```

それらは、`Integer`を引数に取る関数の値をメモ化したものと見なせる。(厳密に言えば、非負整数を使うべきだが、コードを複雑にしたくなかった。)

このような関数を`tabulate`するためには、値の無限ストリームを作成する。もちろん、これが可能なのは、Haskellが遅延評価だからだ。つまり、値は必要になったとき評価される。メモ化された値にアクセスするには`index`を使う。

```haskell
instance Representable Stream where
    type Rep Stream = Integer
    tabulate f = Cons (f 0) (tabulate (f . (+1)))
    index (Cons b bs) n = if n == 0 then b else index bs (n - 1)
```

任意の戻り値型を持つ一連の関数すべてをカバーする、単一のメモ化スキームを実装できるのは興味深い。

反変関手の表現可能性も同様に定義される。ただし、$\cat{C}(-, a)$ の2番目の引数を固定する。あるいは、$\cat{C}^{op}$から$\Set$への関手を考えるのでも等価だ。なぜなら、$\cat{C}^{op}(a, -)$ は$\cat{C}(-, a)$ と同じだからだ。

表現可能性には興味深い捻じれがある。カルテシアン閉圏では、hom集合を内部的には冪乗対象として扱えることに注意してほしい。The hom-set $\cat{C}(a, x)$ is equivalent to $x^a$, and for a representable functor $F$ we can write:

$$-^a = F$$

Let's take the logarithm of both sides, just for kicks:

$$a = \mathbf{log}F$$

もちろん、これは純粋に形式的な変換だが、対数の性質をいくらか知っているなら、非常に便利だ。特に、直積型に基づく関手は直和型で表現でき、直和型の関手は一般に表現可能ではないことが知られている (例: リスト関手)。

最後に、表現可能関手が同じものに対して2種類の実装を与えていることに注目してほしい――1つは関数、1つはデータ構造だ。それらの内容はまったく同じだ――同じキーを使えば同じ値が取得される。それが私が話していた「同一性」の感覚だ。2つの自然同型関手は、その内容に関する限り同一だ。一方、2つの表現は異なる方法で実装されることが多く、パフォーマンス特性が異なる可能性がある。メモ化はパフォーマンス改善策として使われ、実行時間の大幅な短縮につながる可能性がある。同じ基礎計算の異なる表現を生成できることは、実用上の価値が非常に高い。そのため、驚くべきことに、圏論はパフォーマンスをまったく考慮しないにも関わらず、実用上の価値を持つ別の実装を探求する十分な機会を提供する。

## 課題

1. Show that the hom-functors map identity morphisms in $\cat{C}$ to corresponding identity functions in $\Set$.

2. `Maybe`が表現可能でないことを示せ。

3. `Reader`関手は表現可能か？


4. `Stream`表現を使って、引数を自乗する関数をメモ化せよ。

5. `Stream`に対する`tabulate`と`index`が実際に互いに逆であることを示せ。(ヒント: 数学的帰納法を使う。)

6. 次の関手:

   ```haskell
   Pair a = Pair a a
   ```

   は表現可能だ。それを表現する型がわかるか？
   `tabulate`と`index`を実装せよ。

## 参考文献

1. The Catsters video about [representable functors](https://www.youtube.com/watch?v=4QgjKUzyrhM).
