# 米田の補題 {#the-yoneda-lemma}

圏論における構成物のほとんどは、より具体的な他の数学の分野での結果を一般化したものだ。積・余積・モノイド・冪などは、圏論よりずっと前から知られていた。それらは別の数学の分野では別の名前で知られていたかもしれない。集合論におけるデカルト積、順序理論における交わり (meet)、論理学における論理積――これらはすべて圏論的な積という抽象概念に対応する具体例だ。

米田の補題は、この観点から、数学の他の分野では全くと言ってよいほど前例がないような圏一般に関する包括的な主張として際立っている。一番似ているのは群論におけるケイリーの定理（すべての群はある集合の置換群と同型）^[監訳注：詳細は省くが、群の要素$x$を$y \mapsto x \otimes y$という関数に写すような写像を考えると、これが実は単射な準同型写像になっていて像も部分群になっている。同様の写像は、モノイドについて、関数プログラミングにおける差分リストの表現（Hughesのリスト表現）でも用いられる。また、（こちらもモノイドについての）16章の章末課題3も参照。]だという説もある。

米田の補題の問題設定は、$\Set$への関手$F$を持つような任意の圏$\cat{C}$についてのものだ。すでに前章で述べたように、集合値関手のいくつかは表現可能、つまりhom関手と同型だ。米田の補題は、すべての集合値関手がhom関手たちから自然変換によって得られることを示し、そのようなすべての変換を明示的に列挙する。

自然変換について話したとき、自然性条件は制限が非常に強いものになる場合があると述べた。1つの対象における自然変換の成分を定義するとき、射を介して接続されている別の対象へとその成分を「トランスポート」できるほどに自然性が強いことがある。もとの圏と行き先の圏で対象間の射が多いほど、自然変換の成分をトランスポートするための制約が厳しくなる。$\Set$はたまたま射が豊富な圏だ。

米田の補題から言えるのは、あるhom関手と他の任意の関手$F$との間の自然変換が、その単一成分の値をある1点について指定するだけで完全に決定されるということだ！　残りの成分は単に自然性条件に従って決まる。

では、米田の補題に関わる2つの関手について、その間の自然性条件をおさらいしよう。1番目の関手はhom関手だ。それは$\cat{C}$内の任意の対象$x$を射の集合$\cat{C}(a, x)$ に写す。ここで、$a$は$\cat{C}$内の固定された対象だ。また、すでに見たとおり、そのhom関手は$x$から$y$への射$f$をすべて$\cat{C}(a, f)$ に写す。

2番目の関手は任意の集合値関手$F$だ。

この2つの関手の間の自然変換を$\alpha$と呼ぶことにしよう。$\Set$内を扱っているので、$\alpha_x$や$\alpha_y$などの自然変換の成分は集合間の通常の関数にすぎない：
$$
\begin{gathered}
\alpha_x \Colon \cat{C}(a, x) \to F x \\
\alpha_y \Colon \cat{C}(a, y) \to F y
\end{gathered}
$$

`\begin{figure}[H] \centering`{=latex}
![](images/yoneda1.png){width=40%}
`\end{figure}`{=latex}

\noindent
そして、これらは単なる関数なので、特定の点での値を見られる。だが、集合$\cat{C}(a, x)$ 内の点とは何だろうか？　鍵となる観察はこうだ：集合$\cat{C}(a, x)$ 内のすべての点は、$a$から$x$への射$h$でもある。

したがって、$\alpha$についての自然性の四角い図式：
$$\alpha_y \circ \cat{C}(a, f) = F f \circ \alpha_x$$
の両辺を$h$に作用させると、点ごとの等式になる：
$$\alpha_y (\cat{C}(a, f) h) = (F f) (\alpha_x h)$$
前の節でhom関手$\cat{C}(a, -)$ の射$f$への作用を、次のような前合成として定義したことを思い出しただろう：
$$\cat{C}(a, f) h = f \circ h$$
これにより次が導かれる：
$$\alpha_y (f \circ h) = (F f) (\alpha_x h)$$
この条件がどれほど強いかは$x = a$の場合に特化させれば分かる。

`\begin{figure}[H] \centering`{=latex}
![](images/yoneda2.png){width=40%}
`\end{figure}`{=latex}

\noindent
この場合、$h$は$a$から$a$への射となる。そのような射が少なくとも1つ存在するのは分かっている。$h = \id_a$だ。これを代入してみよう：
$$\alpha_y f = (F f) (\alpha_a \id_a)$$
何が起きたか注目してほしい。左辺は$\alpha_y$を$\cat{C}(a, y)$ の任意の要素$f$に作用させている。そして、その結果は$\id_a$における$\alpha_a$という単一の値によって完全に決まる。そのような値は任意に選べて、それによって自然変換が生成される。$\alpha_a$たちの値は集合$F a$に含まれるので、$F a$のどの点からも何らかの$\alpha$が定義される。

逆に、$\cat{C}(a, -)$ から$F$への自然変換$\alpha$が与えられた場合、$\id_a$において評価すれば$F a$の点を得られる。

以上より、米田の補題が証明された：

> $\cat{C}(a, -)$ から$F$への自然変換と$F a$の要素との間には1対1の対応がある。

言い換えれば：
$$\Nat(\cat{C}(a, -), F) \cong F a$$
となる。あるいは、$[\cat{C}, \Set]$という表記で$\cat{C}$と$\Set$の間の関手圏を表すと、自然変換の集合は単にその圏のhom集合であり、次のように書ける：
$$[\cat{C}, \Set](\cat{C}(a, -), F) \cong F a$$
この対応が実際には自然同型である仕組みについては後で説明する。

さて、この結果について直観的に理解してみよう。最も驚くべきことは、自然変換全体の結晶化が、$\id_a$において割り当てた値というたった1粒の種から始まることだ。結晶化はその1点から自然性条件に従って広がっていく。そして$\Set$内に$\cat{C}$の像を溢れさせる。そこで、まずは$\cat{C}(a, -)$ の下で$\cat{C}$の像について考えてみたい。

$a$自体の像から始めよう。$a$は、hom関手$\cat{C}(a, -)$ の下では集合$\cat{C}(a, a)$ に写される。一方、関手$F$の下では集合$F a$に写される。自然変換の成分$\alpha_a$は、$\cat{C}(a, a)$ から$F a$への何らかの関数となる。集合$\cat{C}(a, a)$ の中の1点だけに注目することにしよう。具体的には射$\id_a$に対応する点だ。集合内の1点にすぎないという事実を強調するために、それを$p$と呼ぼう。成分$\alpha_a$は$p$を$F a$内のある点$q$に写すはずだ。どんな$q$を選択しても一意な自然変換が得られることを説明しよう。

`\begin{figure}[H] \centering`{=latex}
![](images/yoneda3.png){width=30%}
`\end{figure}`{=latex}

\noindent
1つ目の主張は、1点$q$を選択すれば関数$\alpha_a$の残りが一意に決まる、というものだ。実際に、$a$から$a$へのある射$g$に対応する他の任意の点$p'$を$\cat{C}(a, a)$ 内で選んでみよう。ここで米田の補題の魔法が起こり、$g$は集合$\cat{C}(a, a)$ 内の点$p'$と見なせる。同時に、それは集合間の2つの*関数*を選択する。確かに射$g$は、hom関手では関数$\cat{C}(a, g)$ に写され、$F$では$F g$に写される。

`\begin{figure}[H] \centering`{=latex}
![](images/yoneda4.png){width=40%}
`\end{figure}`{=latex}

\noindent
ここで、もとの$p$に対する$\cat{C}(a, g)$ の作用を考えてみよう。覚えているとおり、$p$は$\id_a$に対応する。それは前合成$g \circ \id_a$として定義され、$g$と同じであり、点$p'$に対応する。したがって、射$g$は、$p$に作用すると$p'$、すなわち$g$を生成するような関数に写される。ぐるりと一周した！

さて、$q$に対する$F g$の作用を考えてみよう。これは$F a$内のある点$q'$となる。自然性の四角い図式^[訳注：$\alpha_a \circ \cat{C}(a, g) = F g \circ \alpha_a$を$p = \id_a$に作用させたもの。いま、$\cat{C}(a, g) p = g$であり、$p' = g$とおいていたので、左辺が$\alpha_a p'$となり、また$q = \alpha_a p$であったので、右辺が$F g (\alpha_a p) = F g q = q'$となる。]を完成させるには、$p'$が$\alpha_a$によって$q'$に写される必要がある。任意の$p'$（任意の$g$）を選択し、$\alpha_a$の下でのその写し先^[訳注：$q'$、すなわち$F g q$のこと。]を導出した。したがって、関数$\alpha_a$は完全に決定される。

2つ目の主張は、$\cat{C}$内で$a$に接続された対象$x$に対して$\alpha_x$が一意に決定される、というものだ。これも同様の論法による。ただし、ここではさらに2つの集合$\cat{C}(a, x)$ と$F x$があり、$a$から$x$への（訳注：任意に選んだ）射$g$は、hom関手の下では次に写され：
$$\cat{C}(a, g) \Colon \cat{C}(a, a) \to \cat{C}(a, x)$$
$F$の下では次に写される：
$$F g \Colon F a \to F x$$
ここでも、$p$に作用した場合の$\cat{C}(a, g)$ は前合成$g \circ \id_a$によって与えられ、$\cat{C}(a, x)$ 内の点$p'$となる。自然性により、$p'$に作用する$\alpha_x$の値はこう決まる：
$$q' = (F g) q$$
$p'$は任意に決めていたので、関数$\alpha_x$全体が決定される。

`\begin{figure}[H] \centering`{=latex}
![](images/yoneda5.png){width=40%}
`\end{figure}`{=latex}

\noindent
$\cat{C}$内に$a$と接続されていない対象がある場合はどうなるだろう？　それらすべてが$\cat{C}(a, -)$ の下で空集合に写される。空集合は集合の圏における始対象であることを思い出してほしい。これは、この集合から他のどの集合へも一意な関数があることを意味する。その関数を`absurd`と呼んだ。したがって、ここでも自然変換の成分には選択の余地がなく、`absurd`しかあり得ない。

米田の補題を理解する方法の1つは、集合値関手の間の自然変換は関数の族にすぎず、関数は一般には非可逆だと気付くことだ。関数は情報を潰すこともあり、終域の一部しかカバーしないこともある。非可逆でない関数は、可逆なもの、つまり同型たちだけだ。したがって、構造を保存する最良の集合値関手たちは表現可能関手だということになる。それらはhom関手か、あるいはhom関手と自然同型な関手のどちらかだ。その他の関手$F$はすべてhom関手を非可逆変換することで得られる。そのような変換は、情報を失わせるだけでなく、関手$F$による$\Set$内の像のごく一部しかカバーしない可能性がある。

## Haskellにおける米田の補題

Haskellのhom関手には、すでにreader関手という名前で出会っている：

```haskell
type Reader a x = a -> x
```

\noindent
Readerは射たち（ここでは関数たち）を前合成で写す：

```haskell
instance Functor (Reader a) where
    fmap f h = f . h
```

\noindent
米田の補題によれば、reader関手は他の任意の関手へ自然に写せる。

自然変換は多相関数だ。さて、任意の関手`F`について、reader関手からの写像を考えられる：

```haskell
alpha :: forall x . (a -> x) -> F x
```

\noindent
いつものように、`forall`は必須ではないが、自然変換のパラメトリック多相性を強調するために明示的に書くことにしている。

米田の補題によれば、これらの自然変換は`F a`の要素たちと1対1に対応している。

```haskell
forall x . (a -> x) -> F x ≅ F a
```

\noindent
この等式の右辺は、通常はデータ構造と見なしているものだった。一般化されたコンテナーとして関手を解釈したのを覚えているだろうか？　`F a`は`a`のコンテナーだ。一方で、左辺は関数を引数に取る多相関数だ。米田の補題によれば、この2つの表現は等価だ――それらは同じ情報を含んでいる。

別の言い方をすると以下のようになる。次のような型の多相関数：

```haskell
alpha :: forall x . (a -> x) -> F x
```

\noindent
を与えてくれれば`a`のコンテナーを作成してみせよう。ここで使うトリックは米田の補題の証明で使ったものだ。つまり、この関数を`id`で呼び出すことで型`F a`の要素を得る：

```haskell
alpha id :: F a
```

\noindent
逆もまた真だ。型`F a`の任意の値：

```haskell
fa :: F a
```

\noindent
について、適切な型の多相関数：

```haskell
alpha h = fmap h fa
```

\noindent
を定義できる。2つの表現の間は簡単に行き来できるということだ。

表現が複数ある利点は、一方が他方よりも合成しやすかったり、用途によってはより効率的だったりすることだ。

この原則の最も単純な例は、コンパイラーの構成でよく使われるコード変換である、継続渡し形式 (continuation passing style, CPS) だ。これは米田の補題を恒等関手へ最も単純に適用したものだ。`F`を恒等関手に置き換えると、次のようになる：

```haskell
forall r . (a -> r) -> r ≅ a
```

\noindent
この等式は、任意の型`a`は`a`に対する「ハンドラー」を取る関数によって置き換えられる、と解釈できる。ハンドラーは、`a`を受け入れ、残りの計算――継続――を実行する関数だ。（型`r`は通常、ある種のステータスコードをカプセル化している。）

このスタイルのプログラミングは、UI、非同期システム、並行プログラミングではごく一般的だ。CPSの欠点は、制御の反転を伴うことだ。コードが生産者と消費者（ハンドラー）に分割され、簡単には合成できない。Webプログラミングの経験がある人なら誰でも、ステートフルなハンドラーとやり取りするスパゲッティコードの悪夢をよく知っている^[訳注：2026年現在では、そういった処理を直接書くことは`async`/`await`などによって少なくなったかもしれない。]。後で見るように、関手とモナドを慎重に使えばCPSの合成的な特性をいくらか取り戻せる。

## 余米田の補題

いつものように、射の方向を逆にすればおまけの構成が得られる。米田の補題を反対圏$\cat{C}^\mathit{op}$に適用すれば反変関手の間の写像が得られる。

同様に、hom関手の始点となる対象の代わりに終点となる対象を固定することで、余米田の補題を導出できる。$\cat{C}$から$\Set$への反変hom関手を取れる。すなわち$\cat{C}(-, a)$ だ。反変版の米田の補題は、この関手から他の任意の反変関手$F$への自然変換と、集合$F a$の要素との間に1対1の対応を確立する：
$$\cat{Nat}(\cat{C}(-, a), F) \cong F a$$
Haskell版の余米田の補題は次のようになる：

```haskell
forall x . (x -> a) -> F x ≅ F a
```

\noindent
一部の文献では反変版の方を米田の補題と呼んでいるので注意してほしい。

## 課題

#. 米田の同型を成す2つのHaskellの関数`phi`と`psi`が互いに逆であることを示せ。

   ```haskell
   phi :: (forall x . (a -> x) -> F x) -> F a
   phi alpha = alpha id

   psi :: F a -> (forall x . (a -> x) -> F x)
   psi fa h = fmap h fa
   ```

#. 離散圏 (discrete category) は、対象はあるが恒等射以外の射はない圏だ。米田の補題はそのような圏の関手でどのように役立つだろうか？

#. unit型のリスト`[()]`は長さ以外の情報を含まない。したがって、データ型としては、非負整数を表したものと見なせる。空リストは0を表し、単リスト`[()]`（型ではなく値）は1を表し、以下同様だ。このデータ型の別の表現を、リスト関手に対する米田の補題を使って構成せよ。

## 参考文献

#. [Catstersの動画](https://www.youtube.com/watch?v=TLMxHB19khE)^[<https://www.youtube.com/watch?v=TLMxHB19khE>]
