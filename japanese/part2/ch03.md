# 自由モノイド {#free-monoids}

モノイドは圏論においてもプログラミングにおいても重要な概念だ。圏は強い型付けの言語に相当し、モノイドは型なし言語に相当する。なぜなら、モノイドでは任意の2つの矢を合成できるからだ。それは型なし言語で任意の2つの関数を合成できることに当たる (当然、プログラムの実行時にランタイムエラーが発生する可能性はある)。

これまでに見てきたように、モノイドは単一の対象を持つ圏として記述され、その圏ではすべての論理が射の合成の規則として表現されている。この圏論的モデルは、モノイドのより伝統的な集合論的定義と完全に等価だ。そこでは集合の2つの要素を「乗算」することで第3の要素が得られる。この「乗算」の過程はさらに詳細に分析できる。すなわち、まず要素のペア1つを形成し、次にこのペアを既存の要素――それらの「積」と同一視する。

乗算の2番目の部分、つまりペアと既存の要素との同一視を省くとどうなるだろうか？
たとえば、任意の集合から始めて、すべての可能な要素のペアを形成し、それらを新しい要素と呼ぶ、といったことが可能だ。次に、これらの新しい要素をすべての可能な要素とペアにする。以下同様だ。これは連鎖反応だ――新しい要素を永久に追加し続けられる。その結果は、無限集合であり、*ほぼ*モノイドとなる。ただし、モノイドには単位元と結合則も必要だ。しかし、問題ない。特別な単位元を追加し、いくつかのペアを識別できる――単位元則と結合則をちょうど満たせる。

簡単な例で、これがどのように機能するか見てみよう。2要素の集合$\{a, b\}$から始めよう。それらを自由モノイドの生成元 (generator) と呼ぶことにする。まず、単位元として機能する特別な要素$e$を追加する。次に、要素のすべてのペアを追加し、それらを「積」と呼ぶ。$a$と$b$の積はペア $(a, b)$ となる。$b$と$a$の積はペア $(b, a)$ となり、$a$と$a$の積は $(a, a)$ となり、$b$と$b$の積は $(b, b)$ となる。$e$とのペアとして形成できる $(a, e)$、$(e, b)$ などは、$a$、$b$などと同一視する。したがって、このラウンドでは $(a, a)$、$(a, b)$、$(b, a)$、$(b, a)$、$(b, a)$、$(b, b)$ だけを追加して、最終的に$\{e, a, b, (a, a), (a, b), (b, a), (b, b)\}$という集合を作成する。

![](images/bunnies.jpg){width="80%}

次のラウンドでは、$(a, (a, b))$、$((a, b), a)$ などの要素を追加していく。この時点で、結合性が保持されていることを確認する必要があるので、$(a, (b, a))$ を $((a, b), a)$ などと同一視する。言い換えると、内側の括弧は必要ないということだ。

このプロセスの最終的な結果が予想できるだろう: 可能なすべての$a$と$b$のリストが作られる。事実、$e$を空リストで表せば、「乗算」はリストの連結に他ならないことがわかる。

この種の構成では、要素の可能なすべての組み合わせを生成し続け、同一視は最小限に――単位元則と結合則を維持するのにちょうど十分なだけに留める。これは自由構成と呼ばれる。我々はいま、生成元$\{a, b\}$の集合から[自由モノイド]{.keyword #free_monoid} (free monoid) を構築した。

## Haskellにおける自由モノイド

Haskellの2要素集合は型`Bool`と等価であり、この集合によって生成される自由モノイドは型`[Bool]` (`Bool`のリスト) と等価だ。(無限リストの問題は意図的に無視している。)


Haskellのモノイドは型クラスによって定義されている:

```haskell
class Monoid m where
    mempty  :: m
    mappend :: m -> m -> m
```

これが意味しているのは、すべての`Monoid`が`mempty`と呼ばれる中立元と、`mappend`と呼ばれる二項関数 (乗算) を持たなければならないということだ。Haskellでは単位元則と結合則は表現できず、monoidがインスタンス化されるたびにプログラマによって検証されなければならない。

任意の型のリストがモノイドを形成するという事実は、次のインスタンス定義によって記述される:

```haskell
instance Monoid [a] where
    mempty  = []
    mappend = (++)
```

これは、空リスト`[]`が単位元であり、リスト連結`(++)`が二項演算であることを記述している。

これまで見てきたように、型`a`のリストは、集合`a`を生成元とする自由モノイドに対応する。乗算を伴う自然数の集合は、多くの積が同一視されるので、自由モノイドではない。次の例と比較しよう:

```haskell
2 * 3 = 6
[2] ++ [3] = [2, 3] // [6]と同一ではない
```

これは簡単だが、問題は、圏論では対象の中を見るのが許されないのに、この自由構成を実現できるのか、ということだ。我々の馬車馬を使おう: 普遍構成だ。

2番目の興味深い疑問は、単位元則と結合則が必要とする最小数よりも多くの要素を同一視すれば、ある自由モノイドから任意のモノイドを得られるのか、ということだ。これが普遍構成から直接導かれることをお見せしよう。

## 自由モノイドの普遍構成

普遍構成についての経験を振り返れば、それは何かを構築するというより、特定のパターンに最もよく適合する対象を選択するものだと気付くだろう。したがって、普遍構成を使って自由モノイドを「構築」したいなら、選択肢となる多数のモノイドの全体を考慮する必要がある。選択するにはモノイドの圏全体が必要だ。だが、モノイドは圏を形成するのだろうか？


まず、単位元と乗算によって定義された追加構造を備えた集合としてモノイドを見てみよう。モノイダル構造を保存する関数を射として採用する。このような構造保存関数は[準同型]{.keyword #homomorphism} (homomorphism) と呼ばれる。モノイド準同型は2つの要素の積を2つの要素の写像の積に写さなければならない:

```haskell
h (a * b) = h a * h b
```

なおかつ単位元を単位元に写さなければならない。

例として、整数のリストから整数への準同型を考えよう:`[2]`を2に写し、`[3]`を3に写すなら、`[2, 3]`を6に写す必要がある。なぜなら、連結:

```haskell
[2] ++ [3] = [2, 3]
```

が次のような乗算になるからだ:

```haskell
2 * 3 = 6
```

ここで、個々のモノイドの内部構造については忘れて、対応する射をもつ対象としてのみ見よう。モノイドの圏$\cat{Mon}$が得られる。

さて、内部構造を忘れる前に、重要な性質に注目しておこう。$\cat{Mon}$のすべての対象が集合に写せるのは自明だ。それはただの要素の集合だ。この集合は[基底]{.keyword #underlying}集合 (underlying set) と呼ばれる。実際、$\cat{Mon}$の対象を集合に写せるだけでなく、$\cat{Mon}$の射 (準同型) も関数に写せる。これも自明なだけに見えるが、すぐに役立つようになるだろう。この$\cat{Mon}$から$\Set$への対象と射の写像は、実際には関手だ。この関手はモノイダル構造を「忘れている」。いったん通常の集合の中に入ると、もはや単位元を区別したり乗算を気にしたりすることはない。そのため、[忘却関手]{.keyword #forgetful_functor} (forgetful functor) と呼ばれる。忘却関手は圏論ではよく出てくる。

これで、2つの異なる観点から$\cat{Mon}$を見た。それらは対象と射を備えた他のすべての圏と同じように扱える。この観点では、モノイドの内部構造は見えない。$\cat{Mon}$の中の特定の対象について言えるのは、それ自身や他の対象と射を通じて接続しているということだけだ。射の「乗法」表――合成則――は、集合としてのモノイドという、もう一方の観点から導かれる。圏論に進むことによって、この観点を完全に失ったわけではない――まだ忘却関手を通じてそれにアクセスできる。

普遍構成を適用するには、特別な性質を定義することにより、モノイドの圏を探索して自由モノイドの最良の候補を選べるようにする必要がある。しかし、自由モノイドはその生成元によって定義される。生成元の選択を変えれば、生成される自由モノイドも変わる (`Bool`のリストと`Int`のリストは違う)。我々の構成は、生成元の集合から始めなければならない。つまり、集合に戻ってきた！


ここで忘却関手が登場する。それは我々のモノイドをレントゲン撮影するのに使える。これらの小塊のレントゲン写真から生成元を特定できる。その仕組みはこうだ:

生成元の集合$x$から始める。それは$\Set$内の集合だ。

マッチさせるパターンは、モノイド$m$――$\cat{Mon}$の対象――と$\Set$内の関数$p$で構成されている。

```haskell
p :: x -> U m
```

ここで、$U$は$\cat{Mon}$から$\Set$への忘却関手だ。これは奇妙な混成パターンだ――半分は$\cat{Mon}$で半分は$\Set$だ。

この考え方では、$m$のレントゲン写真内の生成元の集合を関数$p$が特定する。関数が集合内の点をきちんと特定できなくても問題ない (関数が点を潰してもよい)。It will all be sorted out by the universal construction, which will pick the best representative of this pattern.

![](images/monoid-pattern.jpg){width="40%}

候補間の順位付けも定義しなければならない。もう1つの候補があるとしよう。モノイド$n$と、そのレントゲン写真内の生成元を特定する関数だ:

```haskell
q :: x -> U n
```

次のようなモノイドの射 (構造保存準同型) がある場合、$m$は$n$よりも優れていると言おう:

```haskell
h :: m -> n
```

これの$U$の下の像 ($U$は関手なので、射を関数に写す) は$p$を通じて分解する:

```haskell
q = U h . p
```

$p$が$m$内の生成元を選択し、$q$が$n$内の「同じ」生成元を選択すると見なすなら、$h$はこれらの生成元を2つのモノイドの間で写していると見なせる。$h$は、定義上、モノイダル構造を保存することを覚えておいてほしい。これは、1つのモノイドにおける2つの生成子の積が、2番目のモノイドにおいて対応する2つの生成子の積に写されることなどを意味する。

![モノイドの順位付け](images/monoid-ranking.jpg){width="40%}

この順位付けは、最も優れた候補、すなわち自由モノイドを見つけるために使われる。定義は次のとおりだ:

> (関数$p$を伴う) $m$と、前述の分解特性を満たす任意の他の (関数$q$を伴う) モノイド$n$とについて、$m$から$n$への*一意な*射$h$が存在する場合に限って、$m$を生成子$x$を伴う**自由モノイド**と呼ぶ。

ちなみに、これは2番目の疑問に対する答えだ。関数$U h$は、$U m$の複数の要素を$U n$の1つの要素へ潰す力を持つ。ここで、潰すことは自由モノイドのいくつかの要素を特定することに対応する。したがって、生成子$x$を伴うモノイドは、$x$に基づく自由モノイドから、いくつかの要素を特定することによって得られる。自由モノイドとは、最小限だけしか特定されていないモノイドのことだ。

随伴について話すとき、自由モノイドに戻ってこよう。

## 課題

1. モノイドの準同型が単位元を保存する、という条件は (もともと私もそう思ったように) 冗長だと思うかもしれない。結局のところ、すべての$a$について次が成り立つのは分かっている:

   ```haskell
   h a * h e = h (a * e) = h a
   ```

   したがって、$h e$は右単位元のように働く (同様に、左単位元のようにも働く)。
   問題は、$h a$は、すべての$a$を考えると、終域モノイドの一部のモノイドしかカバーできないということだ。$h$の像の外部に「真の」単位元が存在する場合がある。モノイド間で乗算を保存する同型は自動的に単位元を保存しなければならないことを示せ。

2. 連結を持つ整数リストから乗算を持つ整数へのモノイド準同型について考える。空リスト`[]`の像は何か？
   すべての単要素リストは、それが含む整数に写されるとする。たとえば、`[3]`は3に写される。`[1, 2, 3, 4]`の像は何か？
   整数12に写されるリストはいくつあるか？
   2つのモノイド間に他の準同型はあるか？


3. 単集合によって生成される自由モノイドとは何か？
   それが何と同型なのか分かるか？

