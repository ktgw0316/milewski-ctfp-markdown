# 自由モノイド {#free-monoids}

モノイドは圏論とプログラミングの両方において重要な概念だ。圏は強い型付けの言語に相当し、モノイドは型なし言語に相当する。モノイドでは任意の2つの射を合成できるからだ。それは型なし言語で任意の2つの関数を合成できることに相当する（当然、プログラムの実行時にランタイムエラーが発生する可能性はある）。

これまでに見てきたように、モノイドは単一の対象を持つ圏として記述され、その圏ではすべての論理が射の合成の規則として表現されている。この圏論的モデルは、より伝統的で集合論的なモノイドの定義と完全に等価だ。そこでは集合の2つの要素を「乗算」することで第3の要素が得られる。この「乗算」の過程はさらに詳細に分析できる。すなわち、まず要素のペア1つを形成し、次にこのペアを既存の要素――それらの「積」と同一視する。

乗算の2番目の部分、つまりペアと既存の要素との同一視を省くとどうなるだろうか？　たとえば、任意の集合から始めて、ペアにできる要素をすべてペアにし、それらを新しい要素と呼ぶ、といったことができる。次に、それらの新しい要素とペアにできる要素をすべてペアにする。以下同様だ。これは連鎖反応だ――新しい要素を永久に追加し続けられる。その結果は、無限集合であり、*ほぼ*モノイドとなる。ただし、モノイドには単位元と結合律も必要だ。しかし、問題ない。特別な単位元を追加し、いくつかのペアを同一視すれば、単位律 (unit law) と結合律をきちんと満たせる。

これがどう機能するか簡単な例を見てみよう。2要素の集合$\{a, b\}$から始めよう。それらを自由モノイドの生成元 (generator) と呼ぶことにする。まず、単位元として機能する特別な要素$e$を追加する。次に、要素のすべてのペアを追加し、それらを「積」と呼ぶ。$a$と$b$の積はペア $(a, b)$ となる。$b$と$a$の積はペア $(b, a)$ となり、$a$と$a$の積は $(a, a)$ となり、$b$と$b$の積は $(b, b)$ となる。$e$とのペアとして形成できる $(a, e)$、$(e, b)$ などは、$a$、$b$などと同一視する。したがって、このラウンドでは $(a, a)$、$(a, b)$、$(b, a)$、$(b, a)$、$(b, a)$、$(b, b)$ だけを追加して、最終的に$\{e, a, b, (a, a), (a, b), (b, a), (b, b)\}$という集合を作成する。

`\begin{figure}[H] \centering`{=latex}
![](images/bunnies.jpg){width="80%"}
`\end{figure}`{=latex}

\noindent
次のラウンドでは、$(a, (a, b))$、$((a, b), a)$ などの要素を追加していく。この時点で、結合律が確実に満たされる必要があるので、$(a, (b, a))$ を $((a, b), a)$ などと同一視する。言い換えると、内側の括弧は必要ないということだ。

このプロセスの最終的な結果が予想できるだろう：$a$と$b$から作れるすべてのリストが作られる。事実として、$e$を空リストで表せば、「乗算」はリストの連接に他ならないことが分かる。

この種の構成では、要素の組み合わせとして可能なものすべてを生成し続け、同一視は最小限に――単位律と結合律を維持するのにちょうど十分なだけに留める。これは自由構成と呼ばれる。以上で生成元$\{a, b\}$の集合から[*自由モノイド*]{.keyword #free_monoid}\index{自由モノイド} (free monoid) を構築したことになる。

## Haskellにおける自由モノイド

Haskellの二元集合は型`Bool`と等価であり、この集合によって生成される自由モノイドは型`[Bool]`（`Bool`のリスト）と等価だ。（無限リストの問題は意図的に無視している。）


Haskellのモノイドは型クラスによって定義されている：

```haskell
class Monoid m where
    mempty  :: m
    mappend :: m -> m -> m
```

\noindent
これが意味しているのは、すべての`Monoid`が`mempty`と呼ばれる中立元と、`mappend`と呼ばれる二項関数（乗算）を持たなければならないということだ。Haskellでは単位律と結合律は表現できず、モノイドがインスタンス化されるたびにプログラマーによって検証されなければならない。

任意の型のリストがモノイドを形成するという事実は、次のインスタンス定義によって記述される：

```haskell
instance Monoid [a] where
    mempty  = []
    mappend = (++)
```

\noindent
これは、空リスト`[]`が単位元であり、リスト連接`(++)`が二項演算であることを記述している。

これまで見てきたように、型`a`のリストは集合`a`を生成元とする自由モノイドに対応する。ところが、乗算を伴う自然数の集合は、多くの積が同一視されるので自由モノイドではない。次の2つを比較しよう：

```haskell
2 * 3 = 6
[2] ++ [3] = [2, 3] -- [6]と同じではない
```

\noindent
これは簡単な例だったが、圏論では対象の中を見るのが許されないのにどうやってこの自由構成を実現できるのか、という問題がある。そこで馬車馬のように働いてもらうのが、普遍的構成だ。

2番目の興味深い疑問は、単位律と結合律が最小限必要とするよりも多くの要素を同一視すれば、ある自由モノイドから任意のモノイドを得られるのか、ということだ。これが普遍的構成から直接導かれることをお見せしよう。

## 自由モノイドの普遍的構成

普遍的構成についての経験を振り返れば、それは何かを構築するというより、特定のパターンに最もよく適合する対象を選択するものだと気付くだろう。したがって、普遍的構成を使って自由モノイドを「構築」したいなら、選択肢となる多数のモノイドの全体を考慮する必要がある。選択するにはモノイドの圏全体が必要だ。だが、モノイドは圏を形成するのだろうか？

まず、単位元と乗算によって定義された追加構造を伴う集合としてモノイドを見てみよう。モノイダル構造を保存する関数を射として採用する。構造を保存するこのような関数は[*準同型*]{.keyword #homomorphisms}\index{準同型} (homomorphism) と呼ばれる。モノイド準同型は2つの要素の積を2つの要素の写像の積に写さなければならない：

```haskell
h (a * b) = h a * h b
```

\noindent
なおかつ単位元を単位元に写さなければならない。

例として、整数のリストから整数への準同型を考えよう。`[2]`を2に写し、`[3]`を3に写すなら、`[2, 3]`を6に写す必要がある。なぜなら、連接：

```haskell
[2] ++ [3] = [2, 3]
```

\noindent
が次のような乗算になるからだ：

```haskell
2 * 3 = 6
```

\noindent
ここで、個々のモノイドの内部構造については忘れて、対応する射を持つ対象としてのみ見よう。すると、モノイドの圏$\cat{Mon}$が得られる。

ところで、内部構造を忘れる前に、重要な性質に注目しておいた方がよいだろう。$\cat{Mon}$のすべての対象が集合に写せるのは自明だ。それはただの要素の集合だ。この集合は[*台*]{.keyword #underlying}\index{台}集合 (underlying set) と呼ばれる。実際、$\cat{Mon}$の対象を集合に写せるだけでなく、$\cat{Mon}$の射（準同型）も関数に写せる。これも自明なだけに見えるが、すぐに役立つようになるだろう。この$\cat{Mon}$から$\Set$への対象と射の写像は、実際には関手だ。この関手はモノイダル構造を「忘れている」。いったん通常の集合の中に入ると、もはや単位元を区別したり乗算を気にしたりすることはない。そのため、[*忘却関手*]{.keyword #forgetful_functor}\index{忘却関手} (forgetful functor) と呼ばれる。忘却関手は圏論ではよく出てくる。

これで、2つの異なる観点から$\cat{Mon}$を見たことになる。それらは対象と射を伴う他のすべての圏と同じように扱える。この観点では、モノイドの内部構造は見えない。$\cat{Mon}$の中の特定の対象について言えるのは、それ自身や他の対象と射を通じて接続しているということだけだ。射の「掛け算の九九」の表――合成律――は、集合としてのモノイドという、もう一方の観点から導かれる。圏論に進んだことでこの観点を完全に失ったわけではない――まだ忘却関手を通じてアクセスできる。

普遍的構成を適用するには、特別な性質を定義することにより、モノイドの圏を探索して自由モノイドの最良の候補を選べるようにする必要がある。しかし、自由モノイドはその生成元によって定義される。別の生成元を選べば、生成される自由モノイドは変わる（`Bool`のリストと`Int`のリストは違う）。我々の構成は、生成元の集合から始めなければならない。つまり、集合に戻ってきた！

ここで忘却関手が登場する。それは我々のモノイドをレントゲン撮影するのに使える。これらの小塊のレントゲン写真から生成元を特定できる。その仕組みは以下のとおりだ：

生成元の集合$x$から始める。それは$\Set$内の集合だ。

マッチさせるパターンは、モノイド$m$――$\cat{Mon}$の対象――と$\Set$内の関数$p$で構成されている：

```haskell
p :: x -> U m
```

\noindent
ここで、$U$は$\cat{Mon}$から$\Set$への忘却関手だ。これは奇妙な混成パターンだ――半分は$\cat{Mon}$で半分は$\Set$だ。

この考え方では、$m$のレントゲン写真内の生成元の集合を関数$p$が特定する。関数が集合内の点をきちんと特定できなくても問題ない（関数が点を潰してもよい）。普遍構成によってそのパターンの最良の代表が選ばれて、すべて整理されるだろう。

`\begin{figure}[H] \centering`{=latex}
![](images/monoid-pattern.jpg){width="40%"}
`\end{figure}`{=latex}

\noindent
候補間の順位付けも定義しなければならない。もう1つの候補があるとしよう。モノイド$n$と、そのレントゲン写真内の生成元を特定する関数だ：

```haskell
q :: x -> U n
```

\noindent
次のようなモノイドの射（構造を保存する準同型）がある場合、$m$は$n$よりも優れていると言うことにしよう：

```haskell
h :: m -> n
```

\noindent
これの$U$の下の像（$U$は関手なので、射を関数に写す）は$p$を通じて分解する：

```haskell
q = U h . p
```

\noindent
$p$が$m$内の生成元を選択し、$q$が$n$内の「同じ」生成元を選択すると見なすなら、$h$はこれらの生成元を2つのモノイドの間で写していると見なせる。$h$は、定義より、モノイダル構造を保存することを思い出してほしい。これは、1つのモノイドにおける2つの生成元の積が、2番目のモノイドにおいて対応する2つの生成元の積に写されることなどを意味する。

`\begin{figure}[H] \centering`{=latex}
![モノイドの順位付け](images/monoid-ranking.jpg){width="40%"}
`\end{figure}`{=latex}

\noindent
この順位付けは、最も優れた候補、すなわち自由モノイドを見つけるために使われる。定義は次のとおりだ：

>（関数$p$を伴う）$m$と、前述の分解特性を満たす任意の他の（関数$q$を伴う）モノイド$n$とについて、$m$から$n$への*一意な*射$h$が存在する場合に限って、$m$を生成元$x$を伴う**自由モノイド**と呼ぶ。

ちなみに、これは2番目の疑問に対する答えだ。関数$U h$には、$U m$の複数の要素を$U n$の1つの要素へ潰す力がある。ここで、潰すことは自由モノイドのいくつかの要素を同一視することに対応する。したがって、生成元$x$を伴うモノイドは、$x$に基づく自由モノイドから、いくつかの要素を同一視することによって得られる。自由モノイドとは、最小限だけしか同一視されていないモノイドのことだ。

随伴について話すとき、自由モノイドに戻ってこよう。

## 課題

#. モノイドの準同型が単位元を保存する、という条件は（もともと私もそう思ったように）冗長だと思うかもしれない。結局のところ、すべての$a$について次が成り立つのは分かっている：

   ```haskell
   h a * h e = h (a * e) = h a
   ```

   \noindent
   したがって、$h e$は右単位元のように働く（同様に、左単位元のようにも働く）。
   問題は、$h a$は、すべての$a$を考えると、終域モノイドの一部のモノイドしかカバーできないということだ。$h$の像の外部に「真の」単位元が存在する場合がある。モノイド間で乗算を保存する同型は自動的に単位元を保存しなければならないことを示せ。

#. 連接できる整数リストから乗算できる整数へのモノイド準同型について考える。空リスト`[]`の像は何か？
   すべての単要素リストは、それが含む整数に写されるとする。たとえば、`[3]`は3に写される。`[1, 2, 3, 4]`の像は何か？
   整数12に写されるリストはいくつあるか？
   2つのモノイド間に他の準同型はあるか？

#. 単元集合によって生成される自由モノイドとは何か？　それが何と同型なのか分かるか？
