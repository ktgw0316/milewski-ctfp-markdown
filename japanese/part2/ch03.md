# 自由モノイド {#free-monoids}

モノイドは圏論とプログラミングの両方において重要な概念となる。圏は強く型付けされた言語に対応し、モノイドは型なし言語に対応する。型なしの言語で任意の2つの関数を合成できる（当然、プログラムを実行したときにランタイムエラーが発生する可能性はある）ように、モノイドでは任意の2つの射を合成できるからだ。

これまでに見てきたように、モノイドは単一の対象を持つ圏として記述され、その圏ではすべての論理が射の合成の規則として表現されている。この圏論的モデルは、より伝統的で集合論的なモノイドの定義と完全に等価だ。そこでは集合の2つの要素を「乗算」することで第3の要素が得られる。この「乗算」の過程はさらに細かく分割できる。すなわち、まず要素のペア1つを形成するという過程と、次にこのペアを既存の要素――それらの「積」と同一視するという過程だ。

乗算の2番目の部分、つまりペアと既存の要素との同一視を省くとどうなるだろうか？　たとえば、任意の集合から始めて、ペアにできる要素をすべてペアにし、それらを新しい要素と呼ぶことができる。次に、それらの新しい要素とペアにできる要素をすべてペアにしていく。以下同様だ。これは連鎖反応だ――新しい要素を永久に追加し続けられる。その結果は、無限集合であり、*ほぼ*モノイドとなる。ただし、モノイドには単位元と結合律も必要となる。しかし、問題ない。特別な単位元を追加し、生成されたペアの一部を同一視すれば、単位律 (unit law) と結合律をきちんと満たせる。

実際にどうなるかを簡単な例で見てみよう。2要素の集合$\{a, b\}$から始めることにしよう。それらの要素を自由モノイドの生成元 (generator) と呼ぶことにする。まず、単位元となる特別な要素$e$を追加する。次に、要素のすべてのペアを追加し、それらを「積」と呼ぶ。$a$と$b$の積はペア $(a, b)$ となる。$b$と$a$の積はペア $(b, a)$ となり、$a$と$a$の積は $(a, a)$ となり、$b$と$b$の積は $(b, b)$ となる。$e$とのペアも作れて、$(a, e)$ や $(e, b)$ などになるが、それらは$a$や$b$などと同一視することにする。結局このラウンドでは $(a, a)$、$(a, b)$、$(b, a)$、$(b, a)$、$(b, a)$、$(b, b)$ だけを追加して、結果として$\{e, a, b, (a, a), (a, b), (b, a), (b, b)\}$という集合が得られる。

`\begin{figure}[H] \centering`{=latex}
![](images/bunnies.jpg){width="80%"}
`\end{figure}`{=latex}

\noindent
次のラウンドでは $(a, (a, b))$ や $((a, b), a)$ といった要素を追加していく。この時点で、結合律が確実に満たされるようにする必要がある。そのため、たとえば$(a, (b, a))$ と $((a, b), a)$ を同一視する。要するに、内側の括弧は必要ないということだ。

このプロセスの最終的な結果が予想できるだろう。要素が$a$か$b$であるようなすべてのリストが作られる。実際、$e$を空リストで表せば、「乗算」はリストの連接に他ならないことが分かる。

この種の構成では、要素の組み合わせとして可能なものすべてを生成し続け、同一視は最小限に――その構造の規則を維持するのにちょうど十分なだけに留める。こういった構成は自由構成と呼ばれる。上記では、生成元の集合$\{a, b\}$から[*自由モノイド*]{.keyword #free_monoid}\index{自由モノイド}を構築した。

## Haskellにおける自由モノイド

Haskellにおける二元集合は型`Bool`と等価であり、この集合から生成される自由モノイドは型`[Bool]`（`Bool`のリスト）と等価だ。（無限リストの問題は意図的に無視している。）

Haskellのモノイドは型クラスによって定義されている。

```haskell
class Monoid m where
    mempty  :: m
    mappend :: m -> m -> m
```

\noindent
このクラスが意味しているのは、すべての`Monoid`が`mempty`と呼ばれる中立元と、`mappend`と呼ばれる二項関数（乗算）を持たなければならないということだ。Haskellでは単位律と結合律は表現できず、具体的なモノイドを与えるたびにプログラマーによって検証されなければならない。

任意の型のリストがモノイドをなすという事実は、次のインスタンス定義によって説明される。

```haskell
instance Monoid [a] where
    mempty  = []
    mappend = (++)
```

\noindent
これはリストモノイドについて、空リスト`[]`が単位元であり、リスト連接`(++)`が二項演算であることを述べている。

これまで見てきたように、型`a`のリストは集合`a`を生成元たちとする自由モノイドに対応する。その一方で、乗算を伴う自然数の集合は、多くの積が同一視されるので自由モノイドではない。次の2つを比べてみよう。

```haskell
2 * 3 = 6
[2] ++ [3] = [2, 3] -- [6]と同じではない
```

\noindent
これは簡単な例だったが、圏論では対象の中を見るのが許されないのにどうやってこの自由構成を実現できるのか、という疑問がある。そこで我々の働き者にもうひと仕事してもらうとしよう。普遍的構成だ。

2番目の興味深い疑問は、単位律と結合律が最小限必要とするよりも多くの要素を同一視すれば、ある自由モノイドから任意のモノイドを得られるのか、ということだ。これが普遍的構成から直接導かれることをお見せしよう。

## 自由モノイドの普遍的構成

普遍的構成についての経験を振り返れば、それは何かを構築するというより、特定のパターンに最もよく適合する対象を選択するものだと気付くだろう。なので、普遍的構成を使って自由モノイドを「構築」したいなら、選択肢となる多数のモノイドの全体を考慮する必要がある。つまり、選択のもととなるモノイドの圏がまるごと必要だ。だが、モノイドたちは圏をなすのだろうか^[訳注：この章の冒頭ではモノイドと単一対象の圏との対応について述べていたが、ここではモノイドが対象であるような圏について述べていることに注意。]？

まずは、単位元と二項演算による構造が加わった集合としてモノイドを見てみよう。そして、モノイドの構造を保存するような関数を射として採用する。構造を保存するそういった関数は[*準同型*]{.keyword #homomorphisms}\index{準同型} (homomorphism) と呼ばれる。モノイド準同型は2つの要素の積を2つの要素の写し先の積へと写さなければならない。

```haskell
h (a * b) = h a * h b
```

\noindent
そして、単位元を単位元に写さなければならない。

例として、整数のリストから整数への準同型を考えよう^[訳注：ここでは二項演算が乗算であるようなモノイド構造を考えている。]。`[2]`を2に写し、`[3]`を3に写すなら、`[2, 3]`を6に写す必要がある。なぜなら、連接：

```haskell
[2] ++ [3] = [2, 3]
```

\noindent
が次のような乗算に写されるからだ。

```haskell
2 * 3 = 6
```

\noindent
ここで、個々のモノイドの内部構造については忘れて、対応する射を持つ対象としてのみ見よう。すると、モノイドの圏$\cat{Mon}$が得られる。

さて、内部構造を忘れる前に、重要な性質に注目しておいた方がよいだろう。$\cat{Mon}$のどの対象も自明に集合へと写せる。写し先の集合は単にもとのモノイドの要素の集合だ。この集合は[*台*]{.keyword #underlying}\index{台}集合 (underlying set) と呼ばれる。実際には、$\cat{Mon}$の各対象を集合に写せるだけでなく、$\cat{Mon}$の各射（準同型）も関数に写せる。これも自明なだけに見えるが、すぐに役に立つ。この$\cat{Mon}$から$\Set$への対象と射の写像は、実は関手になっている。この関手はモノイドの構造を「忘れている」。いったん通常の集合の中に入ると、もはや単位元を区別したり乗算を気にしたりすることはない。こういった関手は[*忘却関手*]{.keyword #forgetful_functor}\index{忘却関手} (forgetful functor) と呼ばれる。忘却関手は圏論ではよく出てくる。

これで、2つの異なる観点から$\cat{Mon}$を見たことになる。$\cat{Mon}$は対象と射を伴う他のすべての圏と同じように扱える。この観点では、モノイドの内部構造は見えない。$\cat{Mon}$の中の特定の対象について言えるのは、それ自身や他の対象と射を通じて接続しているということだけだ。射の「乗算」表――つまり、合成の規則――は、もう一方の観点、すなわち集合としてのモノイドから導かれる。圏論に進んだことでこの観点が完全に失われたわけではない――忘却関手を通じてならアクセスできる。

普遍的構成を適用するには、モノイドの圏を探索して自由モノイドの最も優れた候補を選べるようにするための特別な性質を定義する必要がある。しかし、自由モノイドはその生成元たちによって定義される。別の生成元たちを選べば、生成される自由モノイドは変わる（`Bool`のリストと`Int`のリストは違う）。我々の構成は、生成元の集合から始めなければならない。つまり、集合に戻ってきたということだ！

ここで忘却関手が役立つことになる。忘却関手によってモノイドをレントゲン撮影できる。そして、それらのかたまりたちのレントゲン写真から生成元たちを特定できる。その仕組みは以下のとおりだ。

生成元の集合$x$から始める。この集合は$\Set$の対象だ。

マッチさせようとしているパターンは、モノイド$m$――$\cat{Mon}$の対象――と$\Set$内の関数$p$で構成されている。

```haskell
p :: x -> U m
```

\noindent
ここで、$U$は$\cat{Mon}$から$\Set$への忘却関手だ。これは奇妙な混成パターンだ――半分は$\cat{Mon}$で半分は$\Set$になっている。

意図としては、$m$のレントゲン写真に写った生成元の集合が関数$p$によって特定されるようにするということだ。関数たちが集合内の点たち^[訳注：$m$の生成元たちのこと。]をきちんと特定できない（それらを潰す）かもしれないことは問題ない。普遍的構成によってこのパターンの最も優れた代表が選ばれ、すべてが整理されるだろう[^sub-monoid]。

[^sub-monoid]: 訳注：一般の$m$について、ある$p$による$x$の像は$m$の全体を生成するとは限らず、ある部分モノイドを生成する。$m$が自由モノイド（後述の順位付けにおける最も優れた候補）ならば全体が生成される。

`\begin{figure}[H] \centering`{=latex}
![](images/monoid-pattern.jpg){width="40%"}
`\end{figure}`{=latex}

\noindent
候補間の順位付けも定義しなければならない。もう1つの候補があるとしよう。モノイド$n$と、そのレントゲン写真に写った生成元たちを特定しようとする関数だ。

```haskell
q :: x -> U n
```

\noindent
以下のような条件を満たす場合、$m$は$n$よりも優れていると言うことにしよう。その条件とは、モノイドの射（準同型なので構造を保存する）：

```haskell
h :: m -> n
```

\noindent
があり、その$U$の下の像（$U$は関手なので射を関数に写す）が$p$を通じて$q$を分解することだ。

```haskell
q = U h . p
```

\noindent
$p$が$m$内で生成元たちを選択し、$q$が$n$内で「同じ」生成元たちを選択していると見なすなら、$h$はこれらの生成元たちを2つのモノイドの間で写していると見なせる。$h$は、定義より、モノイドの構造を保存することを思い出してほしい。これは、一方のモノイドにおける2つの生成元の積が、もう一方のモノイドにおける対応する2つの生成元の積に写されることなどを意味する。

`\begin{figure}[H] \centering`{=latex}
![モノイドの順位付け](images/monoid-ranking.jpg){width="40%"}
`\end{figure}`{=latex}

\noindent
この順位付けは、最も優れた候補、すなわち自由モノイドを見つけるために使われる。定義は次のとおりだ。

>（関数$p$を伴う）$m$を生成元$x$を伴う**自由モノイド**と呼ぶのは、$m$から（関数$q$を伴う）他の任意のモノイド$n$への、前述の分解特性を満たす*一意な*射$h$が存在する場合、かつその場合に限る。

ところで、これは2番目の疑問に対する答えになっている。関数$U h$には、$U m$の複数の要素を$U n$の1つの要素へ潰す力がある。ここで、潰すことは自由モノイドのいくつかの要素を同一視することに対応する。したがって、生成元たちとして$x$を持つモノイドはどれも、$x$に基づく自由モノイドから、いくつかの要素を同一視することによって得られる。自由モノイドとは、最小限のものだけしか同一視されていないモノイドのことだ。

自由モノイドについては、随伴について話すときにまた戻ってくることにしよう。

## 課題

#. モノイドの準同型が単位元を保存する、という条件は（当初は私もそう思ったように）冗長だと思うかもしれない。何しろ、すべての$a$について次が言えるのだから。

   ```haskell
   h a * h e = h (a * e) = h a
   ```

   \noindent
   つまり、$h e$は右単位元のように働く（同様に、左単位元のようにも働く）。問題は、すべての$a$に対して$h a$を集めてきたものを考えると、余域モノイドの部分モノイドしかカバーできないということだ。$h$の像の外部に「真の」単位元が存在するかもしれない。モノイド間で乗算を保存する同型は自動的に単位元を保存することになることを示せ。

#. 連接を二項演算とする整数リストから乗算を二項演算とする整数へのモノイド準同型について考える。空リスト`[]`の像は何か？　すべての単要素リストは、それが含む整数に写されるとする。たとえば、`[3]`は3に写される。`[1, 2, 3, 4]`の像は何か？　整数12に写されるリストはいくつあるか？　2つのモノイド間に他の準同型はあるか？

#. 単元集合によって生成される自由モノイドとは何か？　それが何と同型なのか分かるか？
