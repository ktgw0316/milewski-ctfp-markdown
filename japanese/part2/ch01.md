\setcounter{part}{1}
\setcounter{chapter}{10}
\part{}

# 圏論と宣言的プログラミング

第I部では、圏論とプログラミングはどちらも合成可能性に関するものだと論じた。プログラミングでは、扱える程度の詳細さに達するまで問題を分解し続け、それぞれの部分問題を順番に解決し、それらの解決策をボトムアップで再合成する。これには大きく2つの方法がある。コンピューターに何をすべきか指示する方法と、どのようにすべきか指示する方法だ。前者は宣言的と呼ばれ、後者は命令的と呼ばれる。

このことは最も基本的なレベルでさえ見られる。合成自体は宣言的にも定義できる。たとえば、`h`は`g`を`f`の後に合成したものだ：

```haskell
h = g . f
```

\noindent
あるいは、命令的にも定義できる。まず`f`を呼び出し、その呼び出しの結果を記憶し、それからその結果を使って`g`を呼び出す：

```haskell
h x = let y = f x
      in g y
```

\noindent
命令的な方のプログラムは通常、動作を時系列で並べたものとして記述される。特に、`f`の実行が完了する前に`g`の呼び出しは起こりえない。少なくとも、概念としてはそうだ。ただし、*call-by-need*で引数が渡される遅延評価言語では、実際の実行順序は異なる可能性がある。

実際、コンパイラーの賢さによっては、宣言的コードと命令的コードの実行方法にほとんど違いがない場合もある。しかし、この2つの方法論は、問題解決へのアプローチ方法や実装コードの保守性とテスト可能性において、ときには劇的に異なる。

最大の疑問はこうだ。問題に直面したとき、解決のための選択肢として、宣言的アプローチと命令的アプローチの両方が常にあるのだろうか？　そして、宣言的な解決策があるなら、それは常にコンピューターコードに翻訳できるのだろうか？　この疑問への答えは自明とは全く言えず、もしその答えを見つけられたなら、宇宙の理解に革命が起こるだろう。

詳しく説明させてほしい。物理学にも似たような双対性がある。それは、何か深い基本原理を指し示したり、我々の心の働きについて何かを教えてくれたりする。リチャード・ファインマンはこの双対性について、自身の量子電磁力学の研究におけるインスピレーションとして言及している。

ほとんどの物理法則には2つの表現形式がある。1つは局所的すなわち無限小的な考察を用いる。我々はごく近傍の系の状態を見て、それが次の瞬間にどう変化するかを予測する。これは通常、ある期間にわたって積分すなわち合計する必要があるような微分方程式で表される。

このアプローチが命令的思考に似ていることに注目してほしい。つまり、前のステップの結果に応じた一連の小さなステップに従って最終的な解に到達する。実際、物理系のコンピューターシミュレーションの実装では、微分方程式を差分方程式に変換して反復実行するのが常道だ。小惑星ゲームの宇宙船はそのようにしてアニメーション化される。各時間ステップにおける宇宙船の位置は、速度に時間間隔を掛け算した小さな増分を加えることで変化する。同様に、速度は加速度（力を質量で割った値となる）に比例した小さな増分によって変化する。

`\begin{figure}[H] \centering`{=latex}
![](images/asteroids.png){width=50%}
`\end{figure}`{=latex}

\noindent
ニュートンの運動法則に対応する微分方程式を直接的に記述すると次のようになる：
$$
\begin{aligned}
F &= m \frac{dv}{dt} \\
v &= \frac{dx}{dt}
\end{aligned}
$$
同様の方法は、より複雑な問題にも適用できる。たとえば、電磁場の伝播はマクスウェル方程式で記述でき、陽子内部のクォークやグルーオンの挙動さえも格子量子色力学で記述できる。

この局所的な考え方と、デジタルコンピューターの使用によって促進された空間と時間の離散化とが組み合わさった最たるものは、宇宙全体の複雑さをセルオートマトンの系に縮約しようとするスティーブン・ウルフラム^[訳注：複雑系を専門とする数理物理学者で、数式処理ソフトMathematicaの作者としても知られる。]の英雄的な試みの中に表れている。

もう1つのアプローチは大域的なものだ。我々はシステムの初期状態と最終状態を見て、それらを結ぶ軌道を、特定の汎関数を最小化することで計算する。最も簡単な例はフェルマーの最小時間の原理だ。それは、光線は伝搬時間が最小となる経路に沿って伝搬すると述べている。特に、反射や屈折をする物体がない場合、点$A$から点$B$への光線は最短経路である直線を通る。しかし、水やガラスのような（透明な）高密度の媒質中では光の伝播速度は遅くなる。したがって、始点を空気中とし、終点を水中とすると、光にとって空中をより長く進んでから水中を近道する方が有利になる。最小時間の経路では光線が空気と水の境界で屈折し、スネルの屈折の法則が導かれる：
$$\frac{sin(\theta_1)}{sin(\theta_2)} = \frac{v_1}{v_2}$$
ここで、$v_1$は空気中の光速、$v_2$は水中の光速だ。

`\begin{figure}[H] \centering`{=latex}
![](images/snell.jpg){width=30%}
`\end{figure}`{=latex}

\noindent
古典力学のすべては最小作用の原理から導出できる。作用は任意の経路について、運動エネルギーからポテンシャルエネルギーを引いた差であるラグランジアンを積分することで計算できる（注：和ではなく差だ――和は全エネルギーとなる）。大砲を撃って標的に命中させようとするとき、弾はまず重力によるポテンシャルエネルギーがより高い場所へと上昇し、しばらくの間そこで作用への負の寄与を蓄積する。しかも、放物線の頂点に向けて減速することで運動エネルギーを最小限に抑える。それから加速することでポテンシャルエネルギーの低い領域を素早く通過する。

`\begin{figure}[H] \centering`{=latex}
![](images/mortar.jpg){width=35%}
`\end{figure}`{=latex}

\noindent
ファインマンの最大の功績は、最小作用の原理が量子力学に一般化できると示したことだ。ここでも、問題は初期状態と最終状態について定式化されている。ファインマン経路積分をそれらの状態間に用いると、遷移確率を計算できる。

`\begin{figure}[H] \centering`{=latex}
![](images/feynman.jpg){width=35%}
`\end{figure}`{=latex}

\noindent
重要なのは、我々が物理法則を記述できる方法には奇妙で説明のつかない双対性があるということだ。局所的な描像を採用し、物事が連続して小さな増分で起こると捉えてもよい。あるいは、大域的な描像を採用し、初期条件と最終条件を宣言し、途中のすべてはそれらにただ従うと捉えてもよい。

大域的アプローチはプログラミングでも使える。たとえば、レイトレーシングを実装する場合などだ。眼の位置と光源の位置を宣言し、それらを光線が接続できる経路を見つければよい。各光線について飛行時間を明示的には最小化しないが、実際にスネルの法則と反射の幾何学を用いて同じ効果を得ている。

局所的アプローチと大域的アプローチの大きな違いは、空間の扱いと、さらに重要なことに、時間の扱いだ。局所的なアプローチでは、いま・ここの即時的な満足を受け入れるのに対し、大域的なアプローチでは、あたかも未来があらかじめ決まっていて、我々は不変なる宇宙の性質をただ分析しているかのように、長期的で静的な見方をする。

ユーザーインタラクションに対する関数型リアクティブプログラミング (FRP) アプローチほど、これが分かりやすく説明されているものはない。想定されるすべてのユーザーアクションに対して個別のハンドラーを記述して、そのすべてが共有の可変状態にアクセスできるようにする代わりに、FRPでは外部イベントを無限リストとして扱って一連の変換を適用する。概念的には、将来のすべてのアクションのリストがそこにあり、プログラムへの入力データとして利用できる。プログラムの観点からは、$\pi$の数字のリスト、擬似乱数のリスト、コンピューターのハードウェアから得られるマウス座標のリストの間に違いはない。いずれの場合も、第$n$項を得るには最初の$n-1$個の項を先に調べる必要がある。時間的イベントについて述べる場合、この性質は*因果律* (causality) と呼ばれる。

それで、圏論と何の関係があるのだろうか？　私の主張としては、圏論は大域的アプローチを奨励しており、それゆえ宣言的プログラミングを支持している。第一に、微積分とは違って、距離・近傍・時間などの概念が組み込まれていない。あるのは抽象的な対象たちとそれらの間の抽象的な接続だけだ。$A$から$B$へ一連のステップで到達できるなら、一足飛びにも到達できる。さらに、圏論の主要なツールはまさに普遍的構成であり、それは大域的アプローチの典型だ。実際の使用例は、たとえば、圏論的な積の定義ですでに見た。それは積の性質を指定することによってなされた、まさしく宣言的なアプローチだ。積とは2つの射影を伴う対象であり、そういった対象のうち最良のものだ。つまり、ある特性を最適化している。それは、他の同様の対象の射影を分解する特性だ。

`\begin{figure}[H] \centering`{=latex}
![](images/productranking.jpg){width=35%}
`\end{figure}`{=latex}

\noindent
これをフェルマーの最短時間の原理、あるいは最小作用の原理と比較してほしい。

逆に、デカルト積の従来の定義と対比させるとどうだろう。後者の方がはるかに命令的だ。積の要素を作るには、ある集合から1つの要素を選択し、別の集合から別の要素を選択する、という説明になる。これはペアを作るためのレシピだ。また、ペアを分解するためのレシピもある。

Haskellなどの関数型言語を含め、ほとんどすべてのプログラム言語では、直積型・余積型・関数型は組み込まれており、普遍的構成で定義されるのではない。ただし、圏論的プログラム言語の作成も試みられている (たとえば、[萩野達也の博士論文](http://web.sfc.keio.ac.jp/~hagino/thesis.pdf)^[<http://web.sfc.keio.ac.jp/~hagino/thesis.pdf>]を参照)。

直接使われるかどうかにかかわらず、圏論的な定義は既存のプログラミング構成を正当なものにするとともに、新しい構成を生み出す。最も重要なのは、宣言的レベルでコンピュータープログラムについて推論するためのメタ言語を圏論が提供することだ。また、コードとして表す前に問題の仕様について推論することも奨励する。
