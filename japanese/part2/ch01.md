\part{}

# 圏論と宣言的プログラミング

第I部では、圏論とプログラミングはどちらも合成可能性に関するものだと主張した。プログラミングでは、処理できる詳細レベルに達するまで問題を分解し続け、それぞれの部分問題を順番に解決し、それらの解決策をボトムアップで再合成する。これには大きく2つの方法がある。コンピューターに何をすべきか指示する方法と、どのようにすべきか指示する方法だ。前者は宣言的と呼ばれ、後者は命令的と呼ばれる。

これは最も基本的なレベルでも見られる。合成自体は宣言的に定義できる。たとえば、`h`は`g`を`f`の後に合成したものだ：

```haskell
h = g . f
```

\noindent
あるいは、命令的に定義するなら、まず`f`を呼び出し、その呼び出しの結果を記憶し、それからその結果を使って`g`を呼び出す：

```haskell
h x = let y = f x
      in g y
```

\noindent
命令的な方のプログラムは通常、動作を時間順に並べたものとして記述される。特に、`f`の実行が完了する前に`g`を呼び出すことはできない。少なくとも、概念としてはそうだ。ただし、遅延評価言語では、*call-by-need*で引数が渡されるため、実際の実行は異なる方法で進行する可能性がある。

実際、コンパイラーの賢さによっては、宣言的コードと命令的コードの実行方法にほとんど違いがない場合もある。しかし、この2つの方法論は、問題解決へのアプローチ方法や実装コードの保守性とテスト可能性において、ときには劇的に異なる。

最大の疑問は、問題に直面したとき、解決のための選択肢として、宣言的アプローチと命令的アプローチの両方が常にあるか、ということだ。そして、宣言的な解決策があるなら、それは常にコンピューターコードに翻訳できるのだろうか？　この問いへの答えは自明とは全く言えず、もしそれを見つけられたなら、宇宙の理解に革命が起こるだろう。

詳しく説明させてほしい。物理学にも似たような双対性がある。それは、何か深い基本原理を指し示したり、我々の心の働きについて何かを教えてくれたりする。リチャード・P・ファインマンはこの双対性について、彼自身の量子電磁力学の研究におけるインスピレーションとして言及している。

ほとんどの物理法則には2つの表現形式がある。1つは局所的、あるいは無限小的な考察を用いる。我々は、ごく近傍の系の状態を見て、次の瞬間にそれがどう変化するかを予測する。これは通常、微分方程式で表され、ある期間にわたって積分すなわち合計する必要がある。

このアプローチが命令的思考に似ていることに注目してほしい。つまり、前のステップの結果に応じた一連の小さなステップに従って最終的な解に到達する。実際、物理系のコンピューターシミュレーションは、微分方程式を差分方程式に変換し、それらを反復することによって実装されるのが常道だ。小惑星ゲームでも宇宙船はこのようにしてアニメーション化される。各時間ステップにおいて、宇宙船の位置は速度に時間間隔を掛けて計算される小さな増分を加えることで変化する。また、速度は加速度に比例した小さな増分によって変化し、加速度は力を質量で割った値で与えられる。

`\begin{figure}[H] \centering`{=latex}
![](images/asteroids.png){width=50%}
`\end{figure}`{=latex}
\noindent
ニュートンの運動法則に対応する微分方程式の直接的な記述は次のとおりだ：
$$
\begin{aligned}
F &= m \frac{dv}{dt} \\
v &= \frac{dx}{dt}
\end{aligned}
$$
同様の方法は、より複雑な問題にも適用できる。たとえば、マクスウェル方程式を用いた電磁場の伝播や、量子色力学を用いた陽子内部のクォークやグルオンの挙動などだ。

この局所的な考え方の最たるものは、デジタルコンピューターの使用によって空間と時間の離散化が促進されたのと相まって、宇宙全体の複雑さをセルオートマトンの系に縮約しようとするスティーブン・ウルフラム^[訳注：複雑系を専門とする数理物理学者で、数式処理ソフトMathematicaの作者としても有名。]の英雄的な試みの中に表れている。

もう1つは大域的なアプローチだ。システムの初期状態と最終状態を見て、それらを結ぶ軌道を、特定の関数を最小化することで計算する。最も簡単な例はフェルマーの最小時間の原理だ。それは、光は伝搬時間が最小となる経路に沿って伝搬すると述べている。特に、反射も屈折もしない場合、点$A$から点$B$への光は最短経路（直線）を通る。しかし、水やガラスのような（透明な）高密度の媒質では、光の伝播速度は遅くなる。したがって、始点を空気中に、終点を水中に選択すると、光は空中をより長く進んでから水中を近道する方が有利になる。最小時間の経路は光線を空気と水の境界で屈折させ、スネルの屈折の法則が導かれる。
$$\frac{sin(\theta_1)}{sin(\theta_2)} = \frac{v_1}{v_2}$$
ここで、$v_1$は空気中の光速、$v_2$は水中の光速だ。

`\begin{figure}[H] \centering`{=latex}
![](images/snell.jpg){width=30%}
`\end{figure}`{=latex}
\noindent
古典力学はすべて最小作用の原理から導き出せる。作用は任意の経路に沿って、運動エネルギーとポテンシャルエネルギーの差であるラグランジアンを積分することで計算できる（注：和ではなく差だ――和は全エネルギーとなる）。大砲を撃って標的に命中させようとするとき、弾はまず重力によるポテンシャルエネルギーが高い場所へと上昇し、しばらくの間そこで作用への負の寄与を蓄積する。そのうえ、放物線の頂点に向けて減速して運動エネルギーを最小限に抑える。それから加速し、ポテンシャルエネルギーの低い領域を素早く通過する。

`\begin{figure}[H] \centering`{=latex}
![](images/mortar.jpg){width=35%}
`\end{figure}`{=latex}
\noindent
ファインマンの最大の功績は、最小作用の原理が量子力学に一般化できることを示したことだ。ここでも、問題は初期状態と最終状態に関して定式化されている。ファインマン経路積分を用いると、それらの状態間の遷移確率を計算できる。

`\begin{figure}[H] \centering`{=latex}
![](images/feynman.jpg){width=35%}
`\end{figure}`{=latex}
\noindent
重要なのは、物理法則を記述する方法には奇妙で説明のつかない双対性があるということだ。局所的な描像を採用し、物事が連続して小さな増分で起こると捉えてもよい。あるいは、大域的な描像を採用し、初期条件と最終条件を宣言し、途中のすべてはそれらにただ従うと捉えてもよい。

大域的アプローチは、レイトレーシングを実装する場合など、プログラミングでも使える。眼の位置と光源の位置を宣言し、それらを光線が接続できる経路を見つければよい。実際には、各光線について飛行時間を明示的に最小化したりせず、スネルの法則と反射の幾何学を用いて同じ効果を得ている。

局所的アプローチと大域的アプローチの大きな違いは、空間の扱いと、さらに重要なことに、時間の扱いだ。局所的なアプローチでは、いま・ここの即時的充足を受け入れるのに対し、大域的なアプローチは、あたかも未来があらかじめ決まっていたかのような長期的な静的な見方をとり、いわば永遠の宇宙の性質をただ分析する。

ユーザーインタラクションに対する関数型リアクティブプログラミング (FRP) アプローチほど、これが分かりやすく説明されているものはない。想定されるすべてのユーザーアクションに対して個別のハンドラーを記述して、そのすべてが共有の可変状態にアクセスできるようにする代わりに、FRPでは外部イベントを無限リストとして扱って一連の変換を適用する。概念的には、将来のすべてのアクションのリストがそこにあり、プログラムへの入力データとして利用できる。プログラムの観点から見ると、$\pi$の数字のリスト、擬似乱数のリスト、コンピューターのハードウェアから得られるマウス位置のリストの間に違いはない。いずれの場合も、第$n$項を取得する場合は最初の$n-1$項を先に調べる必要がある。時間的イベントについて述べる場合、この特性を*因果律* (causality) と呼ぶ。

それで、圏論と何の関係があるのだろうか？　私の主張としては、圏論は大域的アプローチを奨励しており、それゆえ宣言型プログラミングを支持している。第一に、微積分とは違って、距離・近傍・時間などの概念が組み込まれていない。あるのは抽象的な対象とそれらの間の抽象的な接続だけだ。$A$から$B$へ一連のステップで到達できるなら、一足飛びにも到達できる。さらに、圏論の主要なツールである普遍的構成は大域的アプローチの典型だ。実際の使用例は圏論的な積の定義などですでに見た。それは特性を指定することによる、極めて宣言的なアプローチだ。これは2つの射影を伴う対象のうち最良のものだ。つまり、ある特性を最適化する。その特性とは、他の同様の対象の射影を分解する特性だ。

`\begin{figure}[H] \centering`{=latex}
![](images/productranking.jpg){width=35%}
`\end{figure}`{=latex}
\noindent
これをフェルマーの最短時間の原理、あるいは最小作用の原理と比較してほしい。

逆に、デカルト積の従来の定義と対比させるとどうだろう。後者の方がはるかに命令的だ。積の要素を作るには、ある集合から1つの要素を選択し、別の集合から別の要素を選択する、という説明になる。これはペアを作るためのレシピだ。また、ペアを分解するためのレシピもある。

Haskellなどの関数型言語を含め、ほとんどすべてのプログラム言語では、直積型・余積型・関数型は組み込まれており、普遍的構成で定義されるのではない。ただし、圏論的プログラム言語の作成も試みられている (たとえば[萩野達也の博士論文](http://web.sfc.keio.ac.jp/~hagino/thesis.pdf)^[<http://web.sfc.keio.ac.jp/~hagino/thesis.pdf>]を参照)。

直接使われるかどうかにかかわらず、圏論的な定義は既存のプログラミング構成を正当なものにするとともに、新しい構成を生み出す。最も重要なのは、宣言的レベルでコンピュータープログラムについて推論するためのメタ言語を圏論が提供することだ。また、コードとして表す前に問題の仕様について推論することも奨励する。
