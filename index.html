<!doctype html>
<html  lang="ja-JP" >
<head>

    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />

    <!-- <link rel="stylesheet" type="text/css" href="template.css" /> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/template.css" />

    <!-- <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" /> -->

    <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script>
    <!-- <script type='text/javascript' src='menu/js/jquery.cookie.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.hoverIntent.minified.js'></script> -->
    <!-- <script type='text/javascript' src='menu/js/jquery.dcjqaccordion.2.7.min.js'></script> -->

    <!-- <link href="menu/css/skins/blue.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/graphite.css" rel="stylesheet" type="text/css" /> -->
    <!-- <link href="menu/css/skins/grey.css" rel="stylesheet" type="text/css" /> -->

    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


    <!-- <script src="script.js"></script> -->

    <!-- <script src="jquery.sticky-kit.js "></script> -->
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.cookie.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.hoverIntent.minified.js'></script>
    <script type='text/javascript' src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/blue.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/graphite.css" rel="stylesheet" type="text/css" />
    <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/grey.css" rel="stylesheet" type="text/css" />

    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/script.js"></script>

    <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/jquery.sticky-kit.js"></script>

    <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
    <script src="https://tikzjax.com/v1/tikzjax.js"></script>

    <meta name="generator" content="pandoc" />
  <meta name="author" content="バルトシュ・ミレフスキー著 北川雅裕訳" />
  <title>プログラマーのための圏論</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; } /* Alert */
code span.an { color: #008000; } /* Annotation */
code span.at { } /* Attribute */
code span.bu { } /* BuiltIn */
code span.cf { color: #0000ff; } /* ControlFlow */
code span.ch { color: #008080; } /* Char */
code span.cn { } /* Constant */
code span.co { color: #008000; } /* Comment */
code span.cv { color: #008000; } /* CommentVar */
code span.do { color: #008000; } /* Documentation */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.im { } /* Import */
code span.in { color: #008000; } /* Information */
code span.kw { color: #0000ff; } /* Keyword */
code span.op { } /* Operator */
code span.ot { color: #ff4000; } /* Other */
code span.pp { color: #ff4000; } /* Preprocessor */
code span.sc { color: #008080; } /* SpecialChar */
code span.ss { color: #008080; } /* SpecialString */
code span.st { color: #008080; } /* String */
code span.va { } /* Variable */
code span.vs { color: #008080; } /* VerbatimString */
code span.wa { color: #008000; font-weight: bold; } /* Warning */
  </style>
  <link rel="stylesheet" href="base.css" />
</head>
<body>


    <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">プログラマーのための圏論</span>
        <ul class="nav pull-right doc-info">
                    <li><p class="navbar-text">バルトシュ・ミレフスキー著　北川雅裕訳</p></li>
                                        <li><p class="navbar-text"><a href="https://github.com/ktgw0316/milewski-ctfp-markdown/">https://github.com/ktgw0316/milewski-ctfp-markdown/</a></p></li>
                  </ul>
      </div>
    </div>
  </div>
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">

        <ul>
        <li><a href="#序文" id="toc-序文">序文</a></li>
        <li><a href="#圏合成の本質" id="toc-圏合成の本質"><span
        class="toc-section-number">1</span> 圏：合成の本質</a>
        <ul>
        <li><a href="#関数としての射" id="toc-関数としての射"><span
        class="toc-section-number">1.1</span> 関数としての射</a></li>
        <li><a href="#合成の性質" id="toc-合成の性質"><span
        class="toc-section-number">1.2</span> 合成の性質</a></li>
        <li><a href="#合成はプログラミングの本質"
        id="toc-合成はプログラミングの本質"><span
        class="toc-section-number">1.3</span>
        合成はプログラミングの本質</a></li>
        <li><a href="#課題" id="toc-課題"><span
        class="toc-section-number">1.4</span> 課題</a></li>
        </ul></li>
        <li><a href="#types-and-functions"
        id="toc-types-and-functions"><span
        class="toc-section-number">2</span> 型と関数</a>
        <ul>
        <li><a href="#型を必要とするのは誰か"
        id="toc-型を必要とするのは誰か"><span
        class="toc-section-number">2.1</span>
        型を必要とするのは誰か？</a></li>
        <li><a href="#型は合成に関する" id="toc-型は合成に関する"><span
        class="toc-section-number">2.2</span> 型は合成に関する</a></li>
        <li><a href="#型とは何か" id="toc-型とは何か"><span
        class="toc-section-number">2.3</span> 型とは何か？</a></li>
        <li><a href="#なぜ数学モデルが必要なのか"
        id="toc-なぜ数学モデルが必要なのか"><span
        class="toc-section-number">2.4</span>
        なぜ数学モデルが必要なのか？</a></li>
        <li><a href="#純粋関数と非純粋関数"
        id="toc-純粋関数と非純粋関数"><span
        class="toc-section-number">2.5</span>
        純粋関数と非純粋関数</a></li>
        <li><a href="#型の例" id="toc-型の例"><span
        class="toc-section-number">2.6</span> 型の例</a></li>
        <li><a href="#課題-1" id="toc-課題-1"><span
        class="toc-section-number">2.7</span> 課題</a></li>
        </ul></li>
        <li><a href="#圏のさまざま" id="toc-圏のさまざま"><span
        class="toc-section-number">3</span> 圏のさまざま</a>
        <ul>
        <li><a href="#対象がない場合" id="toc-対象がない場合"><span
        class="toc-section-number">3.1</span> 対象がない場合</a></li>
        <li><a href="#有向グラフ" id="toc-有向グラフ"><span
        class="toc-section-number">3.2</span> 有向グラフ</a></li>
        <li><a href="#順序" id="toc-順序"><span
        class="toc-section-number">3.3</span> 順序</a></li>
        <li><a href="#集合としてのモノイド"
        id="toc-集合としてのモノイド"><span
        class="toc-section-number">3.4</span>
        集合としてのモノイド</a></li>
        <li><a href="#monoid-as-set" id="toc-monoid-as-set"><span
        class="toc-section-number">3.5</span>
        圏としてのモノイド</a></li>
        <li><a href="#課題-2" id="toc-課題-2"><span
        class="toc-section-number">3.6</span> 課題</a></li>
        </ul></li>
        <li><a href="#kleisli-categories"
        id="toc-kleisli-categories"><span
        class="toc-section-number">4</span> クライスリ圏</a>
        <ul>
        <li><a href="#writer圏" id="toc-writer圏"><span
        class="toc-section-number">4.1</span> Writer圏</a></li>
        <li><a href="#haskellにおけるwriter"
        id="toc-haskellにおけるwriter"><span
        class="toc-section-number">4.2</span>
        HaskellにおけるWriter</a></li>
        <li><a href="#クライスリ圏" id="toc-クライスリ圏"><span
        class="toc-section-number">4.3</span> クライスリ圏</a></li>
        <li><a href="#課題-3" id="toc-課題-3"><span
        class="toc-section-number">4.4</span> 課題</a></li>
        </ul></li>
        <li><a href="#products-and-coproducts"
        id="toc-products-and-coproducts"><span
        class="toc-section-number">5</span> 積と余積</a>
        <ul>
        <li><a href="#始対象" id="toc-始対象"><span
        class="toc-section-number">5.1</span> 始対象</a></li>
        <li><a href="#終対象" id="toc-終対象"><span
        class="toc-section-number">5.2</span> 終対象</a></li>
        <li><a href="#双対性" id="toc-双対性"><span
        class="toc-section-number">5.3</span> 双対性</a></li>
        <li><a href="#同型" id="toc-同型"><span
        class="toc-section-number">5.4</span> 同型</a></li>
        <li><a href="#積" id="toc-積"><span
        class="toc-section-number">5.5</span> 積</a></li>
        <li><a href="#余積" id="toc-余積"><span
        class="toc-section-number">5.6</span> 余積</a></li>
        <li><a href="#非対称性" id="toc-非対称性"><span
        class="toc-section-number">5.7</span> 非対称性</a></li>
        <li><a href="#課題-4" id="toc-課題-4"><span
        class="toc-section-number">5.8</span> 課題</a></li>
        <li><a href="#参考文献" id="toc-参考文献"><span
        class="toc-section-number">5.9</span> 参考文献</a></li>
        </ul></li>
        <li><a href="#simple-algebraic-data-types"
        id="toc-simple-algebraic-data-types"><span
        class="toc-section-number">6</span> シンプルな代数的データ型</a>
        <ul>
        <li><a href="#直積型" id="toc-直積型"><span
        class="toc-section-number">6.1</span> 直積型</a></li>
        <li><a href="#レコード" id="toc-レコード"><span
        class="toc-section-number">6.2</span> レコード</a></li>
        <li><a href="#直和型" id="toc-直和型"><span
        class="toc-section-number">6.3</span> 直和型</a></li>
        <li><a href="#型の代数" id="toc-型の代数"><span
        class="toc-section-number">6.4</span> 型の代数</a></li>
        <li><a href="#課題-5" id="toc-課題-5"><span
        class="toc-section-number">6.5</span> 課題</a></li>
        </ul></li>
        <li><a href="#functors" id="toc-functors"><span
        class="toc-section-number">7</span> 関手</a>
        <ul>
        <li><a href="#プログラミングにおける関手"
        id="toc-プログラミングにおける関手"><span
        class="toc-section-number">7.1</span>
        プログラミングにおける関手</a></li>
        <li><a href="#コンテナーとしての関手"
        id="toc-コンテナーとしての関手"><span
        class="toc-section-number">7.2</span>
        コンテナーとしての関手</a></li>
        <li><a href="#関手の合成" id="toc-関手の合成"><span
        class="toc-section-number">7.3</span> 関手の合成</a></li>
        <li><a href="#課題-6" id="toc-課題-6"><span
        class="toc-section-number">7.4</span> 課題</a></li>
        </ul></li>
        <li><a href="#functoriality" id="toc-functoriality"><span
        class="toc-section-number">8</span> 関手性</a>
        <ul>
        <li><a href="#双関手" id="toc-双関手"><span
        class="toc-section-number">8.1</span> 双関手</a></li>
        <li><a href="#product-and-coproduct-bifunctors"
        id="toc-product-and-coproduct-bifunctors"><span
        class="toc-section-number">8.2</span> 積と余積の双関手</a></li>
        <li><a href="#関手的代数的データ型"
        id="toc-関手的代数的データ型"><span
        class="toc-section-number">8.3</span>
        関手的代数的データ型</a></li>
        <li><a href="#cにおける関手-1" id="toc-cにおける関手-1"><span
        class="toc-section-number">8.4</span> C++における関手</a></li>
        <li><a href="#writer関手" id="toc-writer関手"><span
        class="toc-section-number">8.5</span> Writer関手</a></li>
        <li><a href="#共変関手と反変関手"
        id="toc-共変関手と反変関手"><span
        class="toc-section-number">8.6</span>
        共変関手と反変関手</a></li>
        <li><a href="#プロ関手" id="toc-プロ関手"><span
        class="toc-section-number">8.7</span> プロ関手</a></li>
        <li><a href="#hom関手" id="toc-hom関手"><span
        class="toc-section-number">8.8</span> Hom関手</a></li>
        <li><a href="#課題-7" id="toc-課題-7"><span
        class="toc-section-number">8.9</span> 課題</a></li>
        </ul></li>
        <li><a href="#function-types" id="toc-function-types"><span
        class="toc-section-number">9</span> 関数型</a>
        <ul>
        <li><a href="#普遍的構成" id="toc-普遍的構成"><span
        class="toc-section-number">9.1</span> 普遍的構成</a></li>
        <li><a href="#カリー化" id="toc-カリー化"><span
        class="toc-section-number">9.2</span> カリー化</a></li>
        <li><a href="#冪" id="toc-冪"><span
        class="toc-section-number">9.3</span> 冪</a></li>
        <li><a href="#デカルト閉圏" id="toc-デカルト閉圏"><span
        class="toc-section-number">9.4</span> デカルト閉圏</a></li>
        <li><a href="#冪と代数的データ型"
        id="toc-冪と代数的データ型"><span
        class="toc-section-number">9.5</span>
        冪と代数的データ型</a></li>
        <li><a href="#カリーハワード同型"
        id="toc-カリーハワード同型"><span
        class="toc-section-number">9.6</span>
        カリー・ハワード同型</a></li>
        <li><a href="#参考文献-1" id="toc-参考文献-1"><span
        class="toc-section-number">9.7</span> 参考文献</a></li>
        </ul></li>
        <li><a href="#natural-transformations"
        id="toc-natural-transformations"><span
        class="toc-section-number">10</span> 自然変換</a>
        <ul>
        <li><a href="#多相関数" id="toc-多相関数"><span
        class="toc-section-number">10.1</span> 多相関数</a></li>
        <li><a href="#自然性を越えて" id="toc-自然性を越えて"><span
        class="toc-section-number">10.2</span> 自然性を越えて</a></li>
        <li><a href="#関手圏" id="toc-関手圏"><span
        class="toc-section-number">10.3</span> 関手圏</a></li>
        <li><a href="#圏" id="toc-圏"><span
        class="toc-section-number">10.4</span> 2-圏</a></li>
        <li><a href="#おわりに" id="toc-おわりに"><span
        class="toc-section-number">10.5</span> おわりに</a></li>
        <li><a href="#課題-8" id="toc-課題-8"><span
        class="toc-section-number">10.6</span> 課題</a></li>
        </ul></li>
        <li><a href="#宣言的プログラミング"
        id="toc-宣言的プログラミング"><span
        class="toc-section-number">11</span>
        宣言的プログラミング</a></li>
        <li><a href="#limits-and-colimits"
        id="toc-limits-and-colimits"><span
        class="toc-section-number">12</span> 極限と余極限</a>
        <ul>
        <li><a href="#自然同型としての極限"
        id="toc-自然同型としての極限"><span
        class="toc-section-number">12.1</span>
        自然同型としての極限</a></li>
        <li><a href="#極限の例" id="toc-極限の例"><span
        class="toc-section-number">12.2</span> 極限の例</a></li>
        <li><a href="#余極限" id="toc-余極限"><span
        class="toc-section-number">12.3</span> 余極限</a></li>
        <li><a href="#連続性" id="toc-連続性"><span
        class="toc-section-number">12.4</span> 連続性</a></li>
        <li><a href="#課題-9" id="toc-課題-9"><span
        class="toc-section-number">12.5</span> 課題</a></li>
        </ul></li>
        <li><a href="#free-monoids" id="toc-free-monoids"><span
        class="toc-section-number">13</span> 自由モノイド</a>
        <ul>
        <li><a href="#haskellにおける自由モノイド"
        id="toc-haskellにおける自由モノイド"><span
        class="toc-section-number">13.1</span>
        Haskellにおける自由モノイド</a></li>
        <li><a href="#自由モノイドの普遍的構成"
        id="toc-自由モノイドの普遍的構成"><span
        class="toc-section-number">13.2</span>
        自由モノイドの普遍的構成</a></li>
        <li><a href="#課題-10" id="toc-課題-10"><span
        class="toc-section-number">13.3</span> 課題</a></li>
        </ul></li>
        <li><a href="#representable-functors"
        id="toc-representable-functors"><span
        class="toc-section-number">14</span> 表現可能関手</a>
        <ul>
        <li><a href="#hom関手-1" id="toc-hom関手-1"><span
        class="toc-section-number">14.1</span> Hom関手</a></li>
        <li><a href="#表現可能関手" id="toc-表現可能関手"><span
        class="toc-section-number">14.2</span> 表現可能関手</a></li>
        <li><a href="#課題-11" id="toc-課題-11"><span
        class="toc-section-number">14.3</span> 課題</a></li>
        <li><a href="#参考文献-2" id="toc-参考文献-2"><span
        class="toc-section-number">14.4</span> 参考文献</a></li>
        </ul></li>
        <li><a href="#the-yoneda-lemma" id="toc-the-yoneda-lemma"><span
        class="toc-section-number">15</span> 米田の補題</a>
        <ul>
        <li><a href="#haskellにおける米田の補題"
        id="toc-haskellにおける米田の補題"><span
        class="toc-section-number">15.1</span>
        Haskellにおける米田の補題</a></li>
        <li><a href="#余米田の補題" id="toc-余米田の補題"><span
        class="toc-section-number">15.2</span> 余米田の補題</a></li>
        <li><a href="#課題-12" id="toc-課題-12"><span
        class="toc-section-number">15.3</span> 課題</a></li>
        <li><a href="#参考文献-3" id="toc-参考文献-3"><span
        class="toc-section-number">15.4</span> 参考文献</a></li>
        </ul></li>
        <li><a href="#yoneda-embedding" id="toc-yoneda-embedding"><span
        class="toc-section-number">16</span> 米田埋め込み</a>
        <ul>
        <li><a href="#埋め込み" id="toc-埋め込み"><span
        class="toc-section-number">16.1</span> 埋め込み</a></li>
        <li><a href="#haskellへの応用" id="toc-haskellへの応用"><span
        class="toc-section-number">16.2</span> Haskellへの応用</a></li>
        <li><a href="#前順序での例" id="toc-前順序での例"><span
        class="toc-section-number">16.3</span> 前順序での例</a></li>
        <li><a href="#自然性" id="toc-自然性"><span
        class="toc-section-number">16.4</span> 自然性</a></li>
        <li><a href="#課題-13" id="toc-課題-13"><span
        class="toc-section-number">16.5</span> 課題</a></li>
        </ul></li>
        <li><a href="#射こそすべて" id="toc-射こそすべて"><span
        class="toc-section-number">17</span> 射こそすべて</a>
        <ul>
        <li><a href="#関手" id="toc-関手"><span
        class="toc-section-number">17.1</span> 関手</a></li>
        <li><a href="#可換図式" id="toc-可換図式"><span
        class="toc-section-number">17.2</span> 可換図式</a></li>
        <li><a href="#自然変換" id="toc-自然変換"><span
        class="toc-section-number">17.3</span> 自然変換</a></li>
        <li><a href="#自然同型" id="toc-自然同型"><span
        class="toc-section-number">17.4</span> 自然同型</a></li>
        <li><a href="#hom集合" id="toc-hom集合"><span
        class="toc-section-number">17.5</span> Hom集合</a></li>
        <li><a href="#hom集合同型" id="toc-hom集合同型"><span
        class="toc-section-number">17.6</span> Hom集合同型</a></li>
        <li><a href="#hom集合の非対称性"
        id="toc-hom集合の非対称性"><span
        class="toc-section-number">17.7</span>
        Hom集合の非対称性</a></li>
        <li><a href="#課題-14" id="toc-課題-14"><span
        class="toc-section-number">17.8</span> 課題</a></li>
        </ul></li>
        <li><a href="#adjunctions" id="toc-adjunctions"><span
        class="toc-section-number">18</span> 随伴</a>
        <ul>
        <li><a href="#随伴と単位余単位ペア"
        id="toc-随伴と単位余単位ペア"><span
        class="toc-section-number">18.1</span>
        随伴と単位/余単位ペア</a></li>
        <li><a href="#随伴とhom集合" id="toc-随伴とhom集合"><span
        class="toc-section-number">18.2</span> 随伴とhom集合</a></li>
        <li><a href="#随伴に基づく積" id="toc-随伴に基づく積"><span
        class="toc-section-number">18.3</span> 随伴に基づく積</a></li>
        <li><a href="#随伴に基づく冪" id="toc-随伴に基づく冪"><span
        class="toc-section-number">18.4</span> 随伴に基づく冪</a></li>
        <li><a href="#課題-15" id="toc-課題-15"><span
        class="toc-section-number">18.5</span> 課題</a></li>
        </ul></li>
        <li><a href="#freeforgetful-adjunctions"
        id="toc-freeforgetful-adjunctions"><span
        class="toc-section-number">19</span> 自由/忘却随伴</a>
        <ul>
        <li><a href="#いくつかの直観" id="toc-いくつかの直観"><span
        class="toc-section-number">19.1</span> いくつかの直観</a></li>
        <li><a href="#課題-16" id="toc-課題-16"><span
        class="toc-section-number">19.2</span> 課題</a></li>
        </ul></li>
        <li><a href="#モナドプログラマーの定義"
        id="toc-モナドプログラマーの定義"><span
        class="toc-section-number">20</span>
        モナド：プログラマーの定義</a>
        <ul>
        <li><a href="#クライスリ圏-1" id="toc-クライスリ圏-1"><span
        class="toc-section-number">20.1</span> クライスリ圏</a></li>
        <li><a href="#fishの解剖" id="toc-fishの解剖"><span
        class="toc-section-number">20.2</span> Fishの解剖</a></li>
        <li><a href="#do記法" id="toc-do記法"><span
        class="toc-section-number">20.3</span>
        <code>do</code>記法</a></li>
        </ul></li>
        <li><a href="#モナドと計算効果" id="toc-モナドと計算効果"><span
        class="toc-section-number">21</span> モナドと計算効果</a>
        <ul>
        <li><a href="#問題" id="toc-問題"><span
        class="toc-section-number">21.1</span> 問題</a></li>
        <li><a href="#解決策" id="toc-解決策"><span
        class="toc-section-number">21.2</span> 解決策</a></li>
        <li><a href="#結論" id="toc-結論"><span
        class="toc-section-number">21.3</span> 結論</a></li>
        </ul></li>
        <li><a href="#monads-categorically"
        id="toc-monads-categorically"><span
        class="toc-section-number">22</span> 圏論から見たモナド</a>
        <ul>
        <li><a href="#モノイダル圏" id="toc-モノイダル圏"><span
        class="toc-section-number">22.1</span> モノイダル圏</a></li>
        <li><a href="#モノイダル圏におけるモノイド"
        id="toc-モノイダル圏におけるモノイド"><span
        class="toc-section-number">22.2</span>
        モノイダル圏におけるモノイド</a></li>
        <li><a href="#モノイドとしてのモナド"
        id="toc-モノイドとしてのモナド"><span
        class="toc-section-number">22.3</span>
        モノイドとしてのモナド</a></li>
        <li><a href="#随伴に基づくモナド"
        id="toc-随伴に基づくモナド"><span
        class="toc-section-number">22.4</span>
        随伴に基づくモナド</a></li>
        </ul></li>
        <li><a href="#comonads" id="toc-comonads"><span
        class="toc-section-number">23</span> コモナド</a>
        <ul>
        <li><a href="#コモナドによるプログラミング"
        id="toc-コモナドによるプログラミング"><span
        class="toc-section-number">23.1</span>
        コモナドによるプログラミング</a></li>
        <li><a href="#積コモナド" id="toc-積コモナド"><span
        class="toc-section-number">23.2</span> 積コモナド</a></li>
        <li><a href="#合成の分析" id="toc-合成の分析"><span
        class="toc-section-number">23.3</span> 合成の分析</a></li>
        <li><a href="#streamコモナド" id="toc-streamコモナド"><span
        class="toc-section-number">23.4</span> Streamコモナド</a></li>
        <li><a href="#圏論から見たコモナド"
        id="toc-圏論から見たコモナド"><span
        class="toc-section-number">23.5</span>
        圏論から見たコモナド</a></li>
        <li><a href="#storeコモナド" id="toc-storeコモナド"><span
        class="toc-section-number">23.6</span> Storeコモナド</a></li>
        <li><a href="#課題-17" id="toc-課題-17"><span
        class="toc-section-number">23.7</span> 課題</a></li>
        </ul></li>
        <li><a href="#f-代数" id="toc-f-代数"><span
        class="toc-section-number">24</span>
        <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数</a>
        <ul>
        <li><a href="#再帰" id="toc-再帰"><span
        class="toc-section-number">24.1</span> 再帰</a></li>
        <li><a href="#f-代数の圏" id="toc-f-代数の圏"><span
        class="toc-section-number">24.2</span>
        <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数の圏</a></li>
        <li><a href="#自然数" id="toc-自然数"><span
        class="toc-section-number">24.3</span> 自然数</a></li>
        <li><a href="#catamorphism" id="toc-catamorphism"><span
        class="toc-section-number">24.4</span> Catamorphism</a></li>
        <li><a href="#fold" id="toc-fold"><span
        class="toc-section-number">24.5</span> fold</a></li>
        <li><a href="#余代数" id="toc-余代数"><span
        class="toc-section-number">24.6</span> 余代数</a></li>
        <li><a href="#課題-18" id="toc-課題-18"><span
        class="toc-section-number">24.7</span> 課題</a></li>
        </ul></li>
        <li><a href="#algebras-for-monads"
        id="toc-algebras-for-monads"><span
        class="toc-section-number">25</span> モナドの代数</a>
        <ul>
        <li><a href="#t-代数" id="toc-t-代数"><span
        class="toc-section-number">25.1</span>
        <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>-代数</a></li>
        <li><a href="#クライスリ圏-2" id="toc-クライスリ圏-2"><span
        class="toc-section-number">25.2</span> クライスリ圏</a></li>
        <li><a href="#コモナドの余代数" id="toc-コモナドの余代数"><span
        class="toc-section-number">25.3</span> コモナドの余代数</a></li>
        <li><a href="#レンズ" id="toc-レンズ"><span
        class="toc-section-number">25.4</span> レンズ</a></li>
        <li><a href="#課題-19" id="toc-課題-19"><span
        class="toc-section-number">25.5</span> 課題</a></li>
        </ul></li>
        <li><a href="#ends-and-coends" id="toc-ends-and-coends"><span
        class="toc-section-number">26</span> エンドとコエンド</a>
        <ul>
        <li><a href="#対角自然変換" id="toc-対角自然変換"><span
        class="toc-section-number">26.1</span> 対角自然変換</a></li>
        <li><a href="#エンド" id="toc-エンド"><span
        class="toc-section-number">26.2</span> エンド</a></li>
        <li><a href="#等化子としてのエンド"
        id="toc-等化子としてのエンド"><span
        class="toc-section-number">26.3</span>
        等化子としてのエンド</a></li>
        <li><a href="#エンドとしての自然変換"
        id="toc-エンドとしての自然変換"><span
        class="toc-section-number">26.4</span>
        エンドとしての自然変換</a></li>
        <li><a href="#コエンド" id="toc-コエンド"><span
        class="toc-section-number">26.5</span> コエンド</a></li>
        <li><a href="#忍者米田の補題" id="toc-忍者米田の補題"><span
        class="toc-section-number">26.6</span> 忍者米田の補題</a></li>
        <li><a href="#プロ関手の合成" id="toc-プロ関手の合成"><span
        class="toc-section-number">26.7</span> プロ関手の合成</a></li>
        </ul></li>
        <li><a href="#カン拡張" id="toc-カン拡張"><span
        class="toc-section-number">27</span> カン拡張</a>
        <ul>
        <li><a href="#右カン拡張" id="toc-右カン拡張"><span
        class="toc-section-number">27.1</span> 右カン拡張</a></li>
        <li><a href="#随伴としてのカン拡張"
        id="toc-随伴としてのカン拡張"><span
        class="toc-section-number">27.2</span>
        随伴としてのカン拡張</a></li>
        <li><a href="#左カン拡張" id="toc-左カン拡張"><span
        class="toc-section-number">27.3</span> 左カン拡張</a></li>
        <li><a href="#エンドとしてのカン拡張"
        id="toc-エンドとしてのカン拡張"><span
        class="toc-section-number">27.4</span>
        エンドとしてのカン拡張</a></li>
        <li><a href="#haskellにおけるカン拡張"
        id="toc-haskellにおけるカン拡張"><span
        class="toc-section-number">27.5</span>
        Haskellにおけるカン拡張</a></li>
        <li><a href="#自由関手" id="toc-自由関手"><span
        class="toc-section-number">27.6</span> 自由関手</a></li>
        </ul></li>
        <li><a href="#豊穣圏" id="toc-豊穣圏"><span
        class="toc-section-number">28</span> 豊穣圏</a>
        <ul>
        <li><a href="#なぜモノイダル圏か"
        id="toc-なぜモノイダル圏か"><span
        class="toc-section-number">28.1</span>
        なぜモノイダル圏か？</a></li>
        <li><a href="#モノイダル圏-1" id="toc-モノイダル圏-1"><span
        class="toc-section-number">28.2</span> モノイダル圏</a></li>
        <li><a href="#豊饒圏" id="toc-豊饒圏"><span
        class="toc-section-number">28.3</span> 豊饒圏</a></li>
        <li><a href="#前順序" id="toc-前順序"><span
        class="toc-section-number">28.4</span> 前順序</a></li>
        <li><a href="#距離空間" id="toc-距離空間"><span
        class="toc-section-number">28.5</span> 距離空間</a></li>
        <li><a href="#豊穣関手" id="toc-豊穣関手"><span
        class="toc-section-number">28.6</span> 豊穣関手</a></li>
        <li><a href="#自己豊穣化" id="toc-自己豊穣化"><span
        class="toc-section-number">28.7</span> 自己豊穣化</a></li>
        <li><a href="#圏との関係" id="toc-圏との関係"><span
        class="toc-section-number">28.8</span> 2-圏との関係</a></li>
        </ul></li>
        <li><a href="#トポイ" id="toc-トポイ"><span
        class="toc-section-number">29</span> トポイ</a>
        <ul>
        <li><a href="#部分対象分類子" id="toc-部分対象分類子"><span
        class="toc-section-number">29.1</span> 部分対象分類子</a></li>
        <li><a href="#トポス" id="toc-トポス"><span
        class="toc-section-number">29.2</span> トポス</a></li>
        <li><a href="#トポイと論理" id="toc-トポイと論理"><span
        class="toc-section-number">29.3</span> トポイと論理</a></li>
        <li><a href="#課題-20" id="toc-課題-20"><span
        class="toc-section-number">29.4</span> 課題</a></li>
        </ul></li>
        <li><a href="#ローヴェアセオリー"
        id="toc-ローヴェアセオリー"><span
        class="toc-section-number">30</span> ローヴェア・セオリー</a>
        <ul>
        <li><a href="#普遍代数" id="toc-普遍代数"><span
        class="toc-section-number">30.1</span> 普遍代数</a></li>
        <li><a href="#ローヴェアセオリー-1"
        id="toc-ローヴェアセオリー-1"><span
        class="toc-section-number">30.2</span>
        ローヴェア・セオリー</a></li>
        <li><a href="#ローヴェアセオリーにおけるモデル"
        id="toc-ローヴェアセオリーにおけるモデル"><span
        class="toc-section-number">30.3</span>
        ローヴェア・セオリーにおけるモデル</a></li>
        <li><a href="#モノイドのセオリー"
        id="toc-モノイドのセオリー"><span
        class="toc-section-number">30.4</span>
        モノイドのセオリー</a></li>
        <li><a href="#ローヴェアセオリーとモナド"
        id="toc-ローヴェアセオリーとモナド"><span
        class="toc-section-number">30.5</span>
        ローヴェア・セオリーとモナド</a></li>
        <li><a href="#コエンドとしてのモナド"
        id="toc-コエンドとしてのモナド"><span
        class="toc-section-number">30.6</span>
        コエンドとしてのモナド</a></li>
        <li><a href="#副作用のローヴェアセオリー"
        id="toc-副作用のローヴェアセオリー"><span
        class="toc-section-number">30.7</span>
        副作用のローヴェア・セオリー</a></li>
        <li><a href="#課題-21" id="toc-課題-21"><span
        class="toc-section-number">30.8</span> 課題</a></li>
        <li><a href="#参考文献-4" id="toc-参考文献-4"><span
        class="toc-section-number">30.9</span> 参考文献</a></li>
        </ul></li>
        <li><a href="#モナドモノイド圏" id="toc-モナドモノイド圏"><span
        class="toc-section-number">31</span> モナド・モノイド・圏</a>
        <ul>
        <li><a href="#双圏" id="toc-双圏"><span
        class="toc-section-number">31.1</span> 双圏</a></li>
        <li><a href="#モナド" id="toc-モナド"><span
        class="toc-section-number">31.2</span> モナド</a></li>
        <li><a href="#課題-22" id="toc-課題-22"><span
        class="toc-section-number">31.3</span> 課題</a></li>
        <li><a href="#参考文献-5" id="toc-参考文献-5"><span
        class="toc-section-number">31.4</span> 参考文献</a></li>
        </ul></li>
        <li><a href="#索引" id="toc-索引">索引</a></li>
        <li><a href="#謝辞" id="toc-謝辞">謝辞</a></li>
        <li><a href="#ライセンス"
        id="toc-ライセンス">ライセンス</a></li>
        </ul>

        </div>
      </div>
            <div class="span9">


      <h1 class="unnumbered" id="序文">序文</h1>
<blockquote>
<p>しばらく前から、プログラマーを対象とした圏論に関する本を書こうと考えていた。計算機科学者ではなくプログラマー、科学者ではなくエンジニア向けだということに注目してほしい。正気の沙汰ではないし、本当に恐ろしい。科学と工学の間に大きなギャップがあるのは否定できないと思う。自分自身がその分断の両側で仕事をしてきたからだ。それでも、物事を説明したいという強い衝動をいつも感じていた。簡潔な説明の達人だったリチャード・ファインマン<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>を心から尊敬している。自分がファインマンではないことは分かっているが、最善を尽くしたい。まずは、この序文――読者に圏論を学ぶ気を起こさせることを想定したもの――を公開することから始めようと思う。それによって議論を開始しフィードバックを募れることを願っている<a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>。</p>
</blockquote>
<p>ここからの数段落をかけて、この本はあなたのために書かれたものであり、数学のうちでも特に抽象的な分野を学ぶために「あり余る自由時間」を費やすことへのどんな反対意見も全く根も葉もないことを確信してもらえるように試みたい。</p>
<p>私の楽観論はいくつかの観察に基づいている。第一に、圏論は極めて有用なプログラミングのアイデアの宝庫だ。Haskellプログラマーたちは長い間この資源を利用していて、得られたアイデアは他の言語にゆっくりと浸透してきているが、進行が遅すぎる。もっとスピードを上げる必要がある。</p>
<p>第二に、いろいろな種類の数学があり、それぞれ興味を惹く人も異なる。微積分や代数にアレルギーがあったとしても、圏論を楽しめないとは限らない。私としては、圏論はプログラマーのマインドに特に合った数学であるとさえ主張したい。圏論では、個々の物事を扱うのではなく、構造を扱うからだ。圏論はプログラムを合成可能にするような構造を扱う。</p>
<p>合成は圏論の最も根本であり、圏そのものの定義の一部だ。そして私は、合成こそプログラミングの本質であると強く主張したい。我々は、偉大なエンジニアがサブルーチンのアイデアを思いつく遥か前から、ずっとものを合成してきた。かつて構造化プログラミングはプログラミングに革命をもたらした。コードのブロックを合成可能にしたからだ。続いてオブジェクト指向プログラミングが登場した。これはオブジェクトを合成することこそすべてだ。関数プログラミングは、関数や代数的データ構造を合成するだけでなく、並行性をも合成可能にする。これは他のプログラミングパラダイムでは事実上不可能だ。</p>
<p>第三に、私には秘密兵器の「肉切り包丁」がある。それを使って数学を捌いて、よりプログラマーの口に合うものにするつもりだ。プロの数学者としては、すべての仮定を確かめ、すべての命題を適切に述べ、すべての証明を厳密に構成するために細心の注意を払う必要がある。そのせいで数学の論文や書籍は門外漢には非常に読みにくくなっている。だが、私は物理学者としての教育を受けており、物理学は形式的でない推論を用いて驚くべき進歩を遂げた学問だ。かつて数学者たちはディラックのデルタ関数を嗤った。デルタ関数は偉大な物理学者であるP.A.M.
ディラックが微分方程式を解く過程で作ったものだ。数学者たちは、ディラックの洞察を形式化した微積分学の全く新しい分野として超関数理論
(distribuiton theory) を発見したとき、嗤うのをやめた。</p>
<p>当然ながら、大雑把に議論するときには明らかに間違ったことを言ってしまう危険があるので、本書では非公式な議論の背景にしっかりした数学的理論があるように気を付けたい。私のベッドサイドには、読み古したソーンダーズ・マックレーンの『圏論の基礎』が置かれている。</p>
<p>この本は<em>プログラマーのための</em>圏論なので、すべての主要な概念を説明するのにコンピューターコードを使うことにしたい。お気付きかもしれないが、より普及している命令型言語よりも関数型言語の方が数学に近い。また、より強力な抽象化能力を提供する。そのため、自然な誘惑として「圏論の恩恵に浴するにはHaskellを学ばなければならない」と言いたくなるかもしれない。しかし、それは圏論が関数プログラミング以外の用途を持たないことを意味しており、全く誤っている。そこで、C++での例を数多く載せようと思う。確かに、いくつかの醜い構文を克服しなければならず、雑然とした背景に紛れてパターンが目立たなくなったり、高度な抽象化の代わりにコピー＆ペーストに頼らなければならない場面もあるだろう。だが、それがC++プログラマーというものだ。</p>
<p>しかし、Haskellに関しては逃れられない。Haskellプログラマーになる必要はないが、C++で実装しようとしているアイデアをスケッチしたり文書化したりするための言語としてHaskellが必要になる。私もそうやってHaskellを始めた。そして、簡潔な構文と強力な型システムが、C++のテンプレート、データ構造、アルゴリズムを理解し実装する上で大きな助けになると気付いた。もっとも、読者がすでにHaskellを知っているとは期待できないので、ゆっくり紹介しながら進行に応じてすべて説明していくつもりだ。</p>
<p>プログラマーとしての経験が豊富なら、次のように自問するかもしれない。長い間ずっと圏論や関数型の手法を気にすることなくコーディングしてきたが、何が変わったのだろう？　確かにそう思わずにいられないだろうが、関数型の新機能が続々と登場し、命令型言語に侵入していることに気付いてほしい。オブジェクト指向プログラミングの牙城であるJavaでさえ、ラムダを導入した。最近のC++は数年ごとの新しい標準という激動のペースで進化し、変化する世界に追いつこうとしている。これらはすべて、破壊的な変化、すなわち物理学者である我々が相転移と呼ぶものに備えるための動きだ。お湯を温め続けると、やがて沸騰しはじめる。我々はいま、その中のカエルの立場にいる。カエルはどんどん熱くなるお湯の中で泳ぎ続けるべきなのか、それとも何か別のものを探し始めるべきなのか、決めなければならない。</p>
<p> <img src="images/img_1299.jpg" style="width:50.0%" /> </p>
<p>
大きな変化を引き起こしている力のひとつがマルチコア革命だ。広く普及しているプログラミングパラダイムであるオブジェクト指向プログラミングは、並行・並列処理の領域では何のメリットもなく、その代わりに危険でバグを生じやすい設計を奨励している。オブジェクト指向の基本的前提であるデータ隠蔽は、データの共有や改変と組み合わされると、データ競合のレシピになる。ミューテックス<a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>
とそれが保護するデータを組み合わせるというアイデアは素晴らしい。しかし、残念ながらロックは合成できないし、ロックを隠すことでデッドロックが発生しやすくなり、デバッグが難しくなる。</p>
<p>さらに、並行性が存在しないとしても、ソフトウェアシステムの複雑さが増すにつれて、命令型パラダイムのスケーラビリティは限界が試されている。簡単に言うと、副作用が手に負えなくなってきている。確かに、副作用のある関数は便利だし簡単に書ける。それらの作用は、原理的には、名前やコメントに示しておける。SetPasswordやWriteFileなどと命名された関数は、明らかに何らかの状態を変化させ副作用を発生させるが、我々はそれに対処するのには慣れている。副作用のある関数に副作用のある別の関数を合成し始めたときに初めて、物事は複雑になり始める。副作用が本質的に悪いわけではなく、隠れて見えないせいで大規模な管理が不可能になっているのだ。副作用はスケールせず、そして命令型プログラミングでは副作用こそすべてだ。</p>
<p>ハードウェアの変化とソフトウェアの複雑さが増すことで、プログラミングの基礎を再考する必要に迫られている。ヨーロッパの偉大なゴシック大聖堂の建設者と同じように、我々は材料と構造の限界まで技術を磨き続けてきた。フランスには未完成のゴシック建築の<a
href="https://en.wikipedia.org/wiki/Beauvais_Cathedral">ボーヴェ大聖堂</a><a
href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>
があり、限界との深く人間的なこの闘いの証拠となっている。それまでの高さと軽さの記録をすべて破ることを目論んでいたが、相次ぐ崩壊に見舞われた。鉄筋や木製の支柱などの応急処置で崩壊を防いでいるが、明らかに多くのことがうまくいかなかった。現代の視点から見ると、材料科学、コンピューターモデリング、有限要素解析、そして汎用的な数学と物理学の助けなしに、これほど多くのゴシック構造が成功裏に完成したことは奇跡だ。将来の世代が、複雑なオペレーティングシステム、ウェブサーバー、インターネット基盤を構築する際に我々が示してきたプログラミングのスキルを賞賛するようになるのを願っている。率直に言って、彼らはそうすべきだ。我々はそれらすべてを非常に貧弱な理論的基盤に基づいて行ってきたのだから。前進するためには、これらの基盤を修復しなければならない。</p>
<figure>
<img src="images/beauvais_interior_supports.jpg"
title="ボーヴェ大聖堂の崩壊を阻止するための応急処置" style="width:50.0%"
alt="ボーヴェ大聖堂の崩壊を阻止するための応急処置" />
<figcaption
aria-hidden="true">ボーヴェ大聖堂の崩壊を阻止するための応急処置</figcaption>
</figure>
<aside id="footnotes" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol>
<li
id="fn1"><p>訳注：理論物理学者。量子電磁力学での業績により1965年のノーベル物理学賞を朝永振一郎、ジュリアン・シュウィンガーと共同受賞した。<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>著者がこの内容を講義している映像も<a
href="https://goo.gl/GT2UWU"
class="uri">https://goo.gl/GT2UWU</a>（またはYouTubeで “bartosz milewski
category theory” を検索）で観られる。<a href="#fnref2"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn3"><p>訳注：排他制御機構のひとつ。同時に1つの所有者（スレッドまたはプロセス）だけが共有資源にアクセス可能とする仕組みで、所有者だけがロックを解除できる。<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a
href="https://en.wikipedia.org/wiki/Beauvais_Cathedral"
class="uri">https://en.wikipedia.org/wiki/Beauvais_Cathedral</a><a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 data-number="1" id="圏合成の本質"><span
class="header-section-number">1</span> 圏：合成の本質</h1>
<p>圏は、戸惑ってしまうほど単純な概念だ。圏 (category) は複数の<span
id="object" class="keyword"><em>対象</em></span> (object)
とそれらをつなぐ<span id="arrow" class="keyword"><em>射</em></span>
(arrow, morphism) で構成される<a href="#fn5" class="footnote-ref"
id="fnref5"
role="doc-noteref"><sup>5</sup></a>。そのため、圏は図で簡単に表せる。対象は円または点として、射は矢印として描ける。（変化を付けるために、私は対象を子豚、射をロケット花火として描くことがある。）
しかし、圏の本質は<em>合成</em> (composition)
にある。あるいは、お好みなら、合成の本質は圏だと言っても構わない。射は合成できるので、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>から対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>への射があって、さらに対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>から対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>への別の射があるなら、それらを合成した<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>への射が必ずある。</p>
<figure>
<img src="images/img_1330.jpg"
title="圏では、$A$から$B$への射と$B$から$C$への射があるなら、それらを合成した$A$から$C$へ直接向かう射が必ずある。この図には恒等射（後述）がないため、完全な圏ではない。"
style="width:80.0%"
alt="圏では、AからBへの射とBからCへの射があるなら、それらを合成したAからCへ直接向かう射が必ずある。この図には恒等射（後述）がないため、完全な圏ではない。" />
<figcaption
aria-hidden="true">圏では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>への射と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>への射があるなら、それらを合成した<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>へ直接向かう射が必ずある。この図には恒等射（後述）がないため、完全な圏ではない。</figcaption>
</figure>
<h2 data-number="1.1" id="関数としての射"><span
class="header-section-number">1.1</span> 関数としての射</h2>
<p>すでに抽象的ナンセンスでいっぱいだろうか<a href="#fn6"
class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a>？　絶望しないでほしい。具体的な話をしよう。射を関数として考えよう。関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>が型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>の引数を取って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>を返すとする。また、別の関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>を取って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>を返すとする。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>の結果を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>に渡せばそれらを合成できる。つまり<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>を取って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>C</mi><annotation encoding="application/x-tex">C</annotation></semantics></math>を返す新たな関数を定義したことになる。</p>
<p>数学では、このような合成を関数同士の間に小さな丸を書いて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">g \circ f</annotation></semantics></math>のように表す。合成の順序が右から左であることに注意してほしい。これが紛らわしいと感じる人もいるだろう。読者の中には、Unixのパイプ記法</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">lsof</span> <span class="kw">|</span> <span class="fu">grep</span> Chrome</span></code></pre></div>
<p>
や、F#の前方合成演算子<code>&gt;&gt;</code>を見慣れている人もいるかもしれない。どちらも左から右の向きだ。ところが、数学やHaskellの関数は右から左に合成する<a
href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a>。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">g \circ f</annotation></semantics></math>を「<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>の後に（“g
after f”）」合成する、と読めば理解しやすくなる。</p>
<p>もっとはっきりさせるために、C言語のコードを少々書こう。型<code>A</code>の引数を取って型<code>B</code>を返す関数<code>f</code></p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>B f<span class="op">(</span>A a<span class="op">);</span></span></code></pre></div>
<p> と、別の関数</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>C g<span class="op">(</span>B b<span class="op">);</span></span></code></pre></div>
<p> の合成は次のとおりだ。</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>C <span class="va">g_after_f</span><span class="op">(</span>A a<span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g<span class="op">(</span>f<span class="op">(</span>a<span class="op">));</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
ここで再び、右から左への合成<code>g(f(a))</code>が、今回はC言語で現れた。</p>
<p>C++の標準ライブラリーには2つの関数を取って合成関数を返すテンプレートがある、と言えたら良かったのだが、そんなものはない。そこで、気分を変えるためにHaskellを少し試してみよう。ここにAからBへの関数の宣言がある。</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">B</span></span></code></pre></div>
<p> 同様に</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">C</span></span></code></pre></div>
<p> これらの合成は次のとおりだ。</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">.</span> f</span></code></pre></div>
<p>
Haskellの簡潔さを知ると、C++で単純明快な関数の概念を表現できないのには少し当惑させられる。実際、HaskellではUnicode文字を使えるので、合成を次のようにも書ける。</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>g ∘ f</span></code></pre></div>
<p> Unicodeの二重コロンと矢印さえ使える<a href="#fn8"
class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a>。</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>f ∷ <span class="dt">A</span> → <span class="dt">B</span></span></code></pre></div>
<p>
ここで、第1回目のHaskellのレッスンだ。二重コロンは「……という型を持つ」を意味する。関数型
(function type)
は2つの型の間に矢印を挿入することで作成される。2つの関数を合成するには、間にピリオド（あるいはUnicodeの丸）を置く。</p>
<aside id="footnotes-2" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="5">
<li
id="fn5"><p>訳注：arrowを矢、morphismを射として訳し分けている文献もあるが、本書では『圏論の基礎』にならってどちらも射と訳した。<a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>訳注：抽象的ナンセンス (abstract nonsense)
は圏論およびその抽象化能力を指す言葉で、数学者が圏論的議論を割愛するときに「……は抽象的ナンセンスによって示される」などのように自虐を込めて使われる。<a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn7"><p>訳注：もっとも、F#には後方合成演算子<code>&lt;&lt;</code>もあり、Haskellで<code>&gt;&gt;&gt;</code>を使うこともあるので、必ずしも常に本文中の向きで合成するわけではない。<a
href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>訳注：ここでの合成演算子はRing Operator
(U+2218)、二重コロンはProportion (U+2237)、矢印はRightwards Arrow
(U+2192) を指す。<a href="#fnref8" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="1.2" id="合成の性質"><span
class="header-section-number">1.2</span> 合成の性質</h2>
<p>どんな圏においても合成が満たすべき非常に重要な性質が2つある。</p>
<ol type="1">
<li><p>合成は結合的 (associative)
である。3つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>があり、それらが合成できる（つまり端同士の対象が一致している）なら、合成するときに括弧は要らない。このことは数学の記法では次のように表される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>∘</mo><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo>∘</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>∘</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>∘</mo><mi>f</mi><mo>=</mo><mi>h</mi><mo>∘</mo><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">h \circ (g \circ f) = (h \circ g) \circ f = h \circ g \circ f</annotation></semantics></math>
（擬似的な）Haskellでは次のように書ける。</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">B</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">C</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">h ::</span> <span class="dt">C</span> <span class="ot">-&gt;</span> <span class="dt">D</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>h <span class="op">.</span> (g <span class="op">.</span> f) <span class="op">==</span> (h <span class="op">.</span> g) <span class="op">.</span> f <span class="op">==</span> h <span class="op">.</span> g <span class="op">.</span> f</span></code></pre></div>
<p>
（ここで「擬似的」と呼んだのは、関数に等しさが定義されていないからだ。）</p>
<p>関数を扱うなら結合性は全く自明だが、その他の圏では自明ではないこともある。</p></li>
<li><p>どんな対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>にも、合成の単位元
(unit)
となる射が1つずつ存在する。その射は対象から対象自身へとループを描く。合成の単位元となるというのは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>から始まるか<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>で終わるどんな射と合成しても、もとと同じ射になるという意味だ。対象Aについて単位元となる射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>A</mi></msub><annotation encoding="application/x-tex">%
\mathbf{id}_{A}%
</annotation></semantics></math>（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>上の<span
id="identity"
class="keyword"><em>恒等射</em></span>、identity）と呼ばれる。数学の表記法では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>へ向かうなら
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∘</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>A</mi></msub><mo>=</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">f \circ %
\mathbf{id}_{A}%
 = f</annotation></semantics></math> かつ
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>B</mi></msub><mo>∘</mo><mi>f</mi><mo>=</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">%
\mathbf{id}_{B}%
 \circ f = f</annotation></semantics></math> となる。</p></li>
</ol>
<p>
関数を扱うとき、恒等射は引数をそのまま返す恒等関数として実装される。この実装はどの型でも同じであり、この関数は普遍的に多相
(universally polymorphic)
であることを意味する。これはC++ではテンプレートとして定義できる。</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> T id<span class="op">(</span>T x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>
もちろん、C++ではそれほど単純ではない。何を渡すかだけでなく、どのように渡すか（値渡し・参照渡し・const参照渡し・ムーブなど）も考慮する必要があるからだ。</p>
<p>Haskellの恒等関数は、（Preludeと呼ばれる）標準ライブラリーの一部だ。宣言と定義は以下のとおりだ。</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre></div>
<p>
ご覧のとおり、Haskellの多相関数は朝飯前だ。宣言において、型を型変数に置き換えるだけでよい。トリックは次のとおりだ。具体的な型の名前は常に大文字で始まり、型変数の名前は小文字で始まる。ここで<code>a</code>はすべての型を表している。</p>
<p>Haskellの関数定義は、関数の名前とそれに続く仮引数 (formal parameter)
――ここでは<code>x</code>ただひとつ――で構成される。関数の本体は等号の後に続く。この簡潔さは、多くの初心者には衝撃的だが、すぐに完全に理にかなっていることが分かるだろう。関数定義と関数呼び出しは関数プログラミングの必需品なので、構文は最小限に抑えられている。引数リストを括弧で囲まないだけでなく、引数間のコンマさえない（これについては後ほど複数の引数の関数を定義するときに説明する）。</p>
<p>関数の本体は常に式 (expression) であり、関数内に文 (statement)
はない。関数の結果はその式だ――ここでは単に<code>x</code>だ。</p>
<p>これでHaskellのレッスンの第2回は終了だ。</p>
<p>恒等条件は、（再び疑似Haskellで）次のように書ける。</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">.</span> <span class="fu">id</span> <span class="op">==</span> f</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> <span class="op">.</span> f <span class="op">==</span> f</span></code></pre></div>
<p>
誰が恒等関数――何もしない関数――をわざわざ気にするのか、と疑問に思うかもしれない。では、なぜ0という数をわざわざ気にするのだろうか？　0は無の象徴だ。古代ローマ人は0のない数値体系を使っていたが、優れた道路や水路を建設でき、その一部は今日まで残っている。</p>
<p>0や<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><annotation encoding="application/x-tex">\mathbf{id}</annotation></semantics></math>のような中立の値は、記号変数を扱うときに非常に便利だ。これこそが、ローマ人は代数があまり得意ではなく、0の概念に精通していたアラビア人やペルシア人は得意だった理由だ。そのため、恒等関数は、高階関数
(higher-order function)
の引数あるいは戻り値として非常に便利になる。高階関数は関数の記号的操作を可能にする。それらは関数の代数だ。</p>
<p>要約すると、圏は対象と射で構成されている。射は合成でき、その合成は結合性を持つ。すべての対象には、合成の単位元として機能する恒等射がある。</p>
<h2 data-number="1.3" id="合成はプログラミングの本質"><span
class="header-section-number">1.3</span> 合成はプログラミングの本質</h2>
<p>関数プログラマーは、問題に独特の方法でアプローチする。彼らはまるで禅のような問いから始める。たとえば、対話型プログラムを設計するときは「対話とは何か？」と問うだろう。コンウェイのライフゲームを実行するときには、生命の意味について思索するだろう。そのような精神で「プログラミングとは何か？」と問いかけたい。最も基本的なレベルでは、プログラミングとはコンピューターに何をすべきかを指示することだ。「メモリーアドレス<code>x</code>の内容を取り、レジスタ<code>EAX</code>の内容に加えよ」のように。しかし、アセンブリー言語でプログラムを作成する場合でも、コンピューターに与える命令はもっと意味のあるものを表現している。解こうとしているのは自明な問題ではないのだ（自明ならコンピューターの助けは不要だろう）。どうすれば問題を解けるだろうか？　大きな問題を小さな問題に分解すればよい。小さくした問題がまだ大きすぎる場合は、それらをさらに分解する。最後に、小さな問題すべてについて、解決するコードを書く。そうしてプログラミングの本質が現れる。すなわち、それらのコードを合成し、より大きな問題に対する解決策を創造する。分解は、断片をもとの状態に戻せなければ意味がない。</p>
<p>この階層的な分解と再合成のプロセスは、コンピューターによって強制されているわけではない。それは人間の精神の限界を反映しているのだ。脳は一度に少しの概念しか扱えない。心理学で最も引用された論文の1つ、<a
href="https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two"><em>The
Magical Number Seven, Plus or Minus Two</em></a><a href="#fn9"
class="footnote-ref" id="fnref9"
role="doc-noteref"><sup>9</sup></a>は、我々は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>±</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">7 \pm 2</annotation></semantics></math>の「チャンク」の情報しか保持できないと仮定した。人間の短期記憶に関する我々の理解の詳細は変化しているかもしれないが、限界があるのは確実に分かっている。要するに、我々はオブジェクトのスープやコードのスパゲッティを扱えないということだ。構造が必要なのは、よく構造化されたプログラムが見やすいからではなく、そうでなければ脳が効率的に処理できないからだ。あるコード断片について、エレガントだ、あるいは美しいと形容することがよくある。だが、本当に意味しているのは、人間の限界ある精神で処理するのが簡単だということだ。エレガントなコードは、ちょうど適切なサイズのチャンクを作成し、精神の消化器系がそれらを消化するのにちょうど適切な数だけ生成する。</p>
<p>では、プログラムの合成にとって適切なチャンクとは何だろうか。チャンクの表面積は体積よりも必ずゆっくりと増加する。（私がこのたとえを気に入っているのは、幾何学的な対象の表面積はその大きさの2乗に比例して増加する――体積が大きさの3乗に比例して増加するのよりも遅い――という直観による。）表面積は、チャンクを合成するために必要な情報だ。体積は、それらを実装するために必要な情報だ。そのこころは、ひとたびチャンクが実装されると、その実装の詳細を忘れて他のチャンクとの相互作用に集中できる、ということだ。オブジェクト指向プログラミングでは、表面はオブジェクトのクラス宣言、あるいはその抽象インターフェイスだ。関数プログラミングでは、それは関数の宣言だ<a
href="#fn10" class="footnote-ref" id="fnref10"
role="doc-noteref"><sup>10</sup></a>。（ここでは少し単純化しているが、要点はこれだ。）</p>
<p>圏論は、対象の中を見ることを積極的に思いとどまらせるという意味で極端だ。圏論における対象は抽象的で漠然とした存在だ。対象について知り得るのは、他の対象たちとどのように関連しているか、つまり、どのように射で接続しているかだけだ。これは、インターネット検索エンジンが流入リンクと流出リンクを分析してウェブサイトを順位付けするやり方だ（不正行為がある場合は除く）。オブジェクト指向プログラミングでは、理想化されたオブジェクトを見られるのは抽象インターフェイス（純粋な表面なので体積なし）を通してだけで、メソッドが射の役割を果たす。他のオブジェクトと合成する方法を理解するためにオブジェクトの実装を掘り下げなければならなくなった瞬間、このプログラミングパラダイムの利点は失われてしまう。</p>
<aside id="footnotes-3" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="9">
<li id="fn9"><p><a
href="https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two"
class="uri">https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two</a></p>
<p>訳注：論文は<a href="https://doi.org/10.1037%2Fh0043158"
class="uri">https://doi.org/10.1037%2Fh0043158</a>を参照。<a
href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>訳注：ここでは型シグネチャーのこと。<a href="#fnref10"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="1.4" id="課題"><span
class="header-section-number">1.4</span> 課題</h2>
<ol type="1">
<li><p>恒等関数を、好きな言語で（それがたまたまHaskellなら2番目に好きな言語で）できるだけうまく実装せよ。</p></li>
<li><p>合成関数を好きな言語で実装せよ。このメソッドは2つの関数を引数として受け取り、その合成である関数を返す。</p></li>
<li><p>合成関数が恒等関数と整合しているかテストするプログラムを作成せよ。</p></li>
<li><p>ワールドワイドウェブは、何らかの意味で圏だろうか？　リンクは射だろうか？</p></li>
<li><p>Facebookは人を対象とし友達関係を射とする圏だろうか？</p></li>
<li><p>有向グラフが圏になるのはどのような場合だろうか？</p></li>
</ol>
<h1 data-number="2" id="types-and-functions"><span
class="header-section-number">2</span> 型と関数</h1>
<p>型と関数の圏はプログラミングにおいて重要な役割を果たす。そこで、型とは何か、なぜ型が必要なのかについて説明しよう。</p>
<h2 data-number="2.1" id="型を必要とするのは誰か"><span
class="header-section-number">2.1</span> 型を必要とするのは誰か？</h2>
<p>静的型付けと動的型付け、および強い型付けと弱い型付けの利点については、議論があるようだ。これらの選択肢を思考実験で説明しよう。コンピューターのキーボードを操作する何百万匹もの猿が喜んでランダムにキーを打ち、プログラムを作成したり、コンパイルしたり、実行したりする様子を想像してみてほしい。</p>
<p> <img src="images/img_1329.jpg" style="width:30.0%" /> </p>
<p>
機械語では、猿が生成するバイトの組み合わせはどれでも受け入れられて実行される。しかし、より高級な言語ではコンパイラーが語彙や文法上の誤りを検出できるという事実を我々は理解している。多くの猿はバナナなしで去るだろうが、残されたプログラムは役に立つ可能性が高いだろう。型検査も、無意味なプログラムに対するもう1つの防御壁となる。さらに、型の不一致は動的型付け言語では実行時に発見されるのに対し、強く型付けされ静的に型検査される言語ではコンパイル時に発見されるので、多くの不正なプログラムが実行される機会を得る前に排除される。</p>
<p>そこで、問題は次のようになる。猿を幸せにしたいのか、それとも正しいプログラムを作りたいのか？</p>
<p>タイピング猿の思考実験における通常の目標はシェークスピア全集を作ることだ。スペルチェッカーと文法チェッカーをループに含めれば、勝算は大幅に上昇するだろう。型検査器に類するものを含めれば、さらなる前進が見込める。ロミオは人間である、と宣言されていれば、彼は決して葉を発芽したり自身の強力な重力場に光子を閉じ込めたりはしない。</p>
<h2 data-number="2.2" id="型は合成に関する"><span
class="header-section-number">2.2</span> 型は合成に関する</h2>
<p>圏論は射を合成することに関する。しかし、2本の射なら何でも合成できるわけではない。ある射の終点
(target) となる対象は、次の射の始点 (source)
となる対象と同じでなくてはならない。プログラミングでは、ある関数の結果を別の関数に渡す。後段の関数が前段の関数によって生成されたデータを正しく解釈できない場合、プログラムは機能しない。合成が機能するためには両端が適合しなければならない。言語の型システムが強力であればあるほど、この一致はよりよく記述され、機械的に検証される。</p>
<p>強力な静的型検査に対して私が耳にする唯一の重要な反対意見は、意味的に正しいプログラムを排除する可能性がある、というものだ。実際には、そうなることは極めてまれで、いずれにしても、どの言語にも、本当に必要な場合に型システムを迂回するための何らかのバックドアが用意されている。Haskellにさえ<code>unsafeCoerce</code>がある。しかし、このような装備は思慮深く使うべきだ。フランツ・カフカの小説の主人公グレゴール・ザムザが、巨大なバグに変身したとき型システムを破壊し、どんな結末を迎えたかは誰もが知っている。</p>
<p>私がよく耳にするもう1つの意見は、型を扱うのはプログラマーにとって負担が大きすぎる、というものだ。私もC++でイテレーターの宣言をいくつか自分で書かなければならなかったら共感するだろう。もっとも、<span
id="type_inference" class="keyword"><em>型推論</em></span> (type
inference)
と呼ばれる技術があり、コンパイラーはほとんどの型を文脈から推論できるようになっている。C++では、変数を<code>auto</code>で宣言してコンパイラーにその型を発見させられるようになった。</p>
<p>Haskellでは、稀な場合を除いて、型注釈は純粋にオプションだ。プログラマーはどのみち型注釈を使う傾向がある。なぜなら、コードの意味について多くを伝えられ、コンパイルエラーを理解しやすくできるからだ。Haskellでは、型を設計することからプロジェクトを始めるのが一般的な慣習だ。後々、型注釈は実装を駆動し、コンパイラーによって強制されるコメントになる。</p>
<p>強力な静的型付けはコードをテストしない言い訳としてよく使われる。Haskellのプログラマーが「コンパイルが通るなら正しいはずだ」と言っているのを耳にすることがあるだろう。しかし、型が正しいプログラムなら正しい出力を生成する、などという保証は当然ない。そのような無頓着な態度の結果、いくつかの研究では、Haskellのコード品質は予想ほど群を抜いて高くはなかった<a
href="#fn11" class="footnote-ref" id="fnref11"
role="doc-noteref"><sup>11</sup></a>。商用の環境では、バグを修正する圧力はある品質レベルまでしか働かないようだ。そのレベルは、ソフトウェア開発の経済的状況とエンドユーザーの許容度に深く関係し、プログラミング言語や方法論にはほとんど関係しないのだろう。より良い基準は、スケジュールより遅れているプロジェクトや、大幅に機能が削減されたプロジェクトの数を調べることだろう。</p>
<p>単体テストによって強い型付けを置き換えられる、という意見に関しては、強く型付けされた言語で一般的に行われているリファクタリング手法として、関数の引数の型の変更について考えてみてほしい。強く型付けされた言語では、その関数の宣言を変更してから、すべてのビルドブレークを修正すれば十分だ。弱く型付けされた言語では、関数が異なるデータを要求するようになったという事実は呼び出し側に伝わらない。単体テストはミスマッチのいくつかを捉えるかもしれないが、テストはほとんどすべての場合において、確率論的なプロセスにすぎず、決定論的なプロセスではない。テストは証明の代わりにはならないのだ。</p>
<aside id="footnotes-4" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="11">
<li id="fn11"><p>訳注：下記の文献を参照。</p>
<ul>
<li>Baishakhi Ray, Daryl Posnett, Premkumar Devanbu, and Vladimir
Filkov, <em>A large-scale study of programming languages and code
quality in GitHub.</em> Commun. ACM 60, 10 (October 2017), pp. 91–100.
<a href="https://doi.org/10.1145/3126905"
class="uri">https://doi.org/10.1145/3126905</a></li>
<li>S. Nanz and C. A. Furia, <em>A Comparative Study of Programming
Languages in Rosetta Code.</em> IEEE/ACM 37th IEEE International
Conference on Software Engineering, 2015, pp. 778-788. <a
href="https://doi.org/10.1109/ICSE.2015.90"
class="uri">https://doi.org/10.1109/ICSE.2015.90</a></li>
</ul>
<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></li>
</ol>
</aside>
<h2 data-number="2.3" id="型とは何か"><span
class="header-section-number">2.3</span> 型とは何か？</h2>
<p>型とは、最も単純な直観としては、値の集合だ。型<code>Bool</code>は<code>True</code>と<code>False</code>の二元集合だ（Haskellでは具体的な型は大文字で始まることを思い出してほしい）。<code>Char</code>型は<code>a</code>や<code>ą</code>のようなUnicode文字すべてからなる集合だ。</p>
<p>集合は有限の場合も無限の場合もあり得る。<code>String</code>型は、<code>Char</code>のリストの同義語で、無限集合の例だ。</p>
<p>以下のように<code>x</code>を<code>Integer</code>として宣言すること</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">x ::</span> <span class="dt">Integer</span></span></code></pre></div>
<p>
は、<code>x</code>が整数の集合の要素だと言っていることになる。Haskellの<code>Integer</code>は無限集合であり、任意精度の演算が可能だ。また、C++の<code>int</code>と同様の、マシンネイティブの型に対応する有限集合<code>Int</code>もある。</p>
<p>いくつか微妙な点があるせいで、こうした型と集合の同一視はトリッキーなものになっている。多相関数には循環定義の問題があり、すべての集合の集合が存在しないことも問題だ。だが、約束したとおり、私は数学にこだわるつもりはない。ありがたいことに、集合の圏が存在する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>と呼ばれるその圏をここでは扱う。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>では、対象は集合であり、射は関数だ。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>は非常に特別な圏だ。対象の内部を実際に見られ、そうすることで多くの直観が得られるからだ。たとえば、空集合には要素がないと分かっている。単元集合という特別な集合たちが存在するのも分かっている。関数が1つの集合の要素を別の集合の要素に写すのも分かっている。関数は、2つの要素を1つに写すことはできるが、1つの要素を2つに写すことはできない。恒等関数が集合の各要素を自身に写すことなども分かっている。予定としては、これらすべての情報を徐々に忘れ、すべての概念を純粋に圏論の言葉、つまり対象と射によって表していく。</p>
<p>理想的な世界では、Haskellの型は集合であり、Haskellの関数は集合間の数学的関数であると言えば済んだだろう。だが、1つだけ小さな問題がある。数学関数はコードを実行せず、単に解を知っているだけなのだ。Haskellの関数は解を計算する必要がある。有限のステップ数で解が得られるなら、何ステップかかっても問題はない。ところが、計算のなかには再帰を伴うものもあり、ずっと停止しないことがあり得る。Haskellで停止しない関数をただ単に禁止はできない。なぜなら、停止する関数と停止しない関数の区別は決定不能だからだ。これは停止性問題
(halting problem)
として有名だ。そのため計算機科学者たちは素晴らしいアイデアを考案した。それは捉え方によっては大きなハッキングとも言えるだろう。そのアイデアとは、<span
id="bottom" class="keyword"><em>ボトム</em></span> (bottom)
と呼ばれる、記号<code>_|_</code>またはUnicodeの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">\bot</annotation></semantics></math>で<a
href="#fn12" class="footnote-ref" id="fnref12"
role="doc-noteref"><sup>12</sup></a>表される特別な値を用いてすべての型を拡張する、というものだ。この「値」は停止しない計算に対応する。したがって、次のように宣言される関数</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>
は<code>True</code>か<code>False</code>か<code>_|_</code>を返し、ボトムの場合は決して停止しないことを意味する。</p>
<p>興味深いことに、ひとたび型システムの一部としてボトムを受け入れたなら、すべての実行時エラーをボトムとして扱い、さらには関数からボトムを明示的に返せるようにするのが便利になる。後者は通常、<code>undefined</code>という式を使って行われる。</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>
この定義が型検査を通るのは、<code>undefined</code>が評価されるとボトムになるからだ。ボトムは<code>Bool</code>も含むすべての型のメンバーだ。さらに</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>
のように（<code>x</code>なしで）書くことさえできる。ボトムが<code>Bool -&gt; Bool</code>型のメンバーでもあるためだ。</p>
<p>取りうるすべての引数に対して有効な結果を返す関数が全域関数 (total
function) と呼ばれるのに対し、ボトムを返す可能性のある関数は部分関数
(partial function) と呼ばれる。</p>
<p>ボトムがあるため、Haskellの型と関数の圏は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>ではなく<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐇</mi><mi>𝐚</mi><mi>𝐬</mi><mi>𝐤</mi></mrow><annotation encoding="application/x-tex">\mathbf{Hask}</annotation></semantics></math>と呼ばれる。理論的な観点から見ると、これは果てしない複雑さの原因となる。だから、この時点で一連の推論を肉切り包丁で捌いて終わらせよう。実用的な観点からは、停止しない関数とボトムを無視し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐇</mi><mi>𝐚</mi><mi>𝐬</mi><mi>𝐤</mi></mrow><annotation encoding="application/x-tex">\mathbf{Hask}</annotation></semantics></math>を正真正銘の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>として扱うことは問題ない<a
href="#fn13" class="footnote-ref" id="fnref13"
role="doc-noteref"><sup>13</sup></a>。</p>
<aside id="footnotes-5" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="12">
<li id="fn12"><p>訳注：Up Tack (U+22A5) を指す。<a href="#fnref12"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13"><p>Nils Anders Danielsson, John Hughes, Patrik Jansson,
Jeremy Gibbons, <em>Fast and Loose Reasoning is Morally Correct</em>. <a
href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf"
class="uri">https://www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf</a>
この論文は、ほとんどの文脈でボトムを無視することの正当性を説明している。<a
href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="2.4" id="なぜ数学モデルが必要なのか"><span
class="header-section-number">2.4</span>
なぜ数学モデルが必要なのか？</h2>
<p>プログラマーであるあなたは、自分が使っているプログラミング言語の構文と文法に精通している。言語のそれらの側面は、通常、言語仕様の冒頭で形式的な表記法によって記述される。一方で、言語の意味、すなわちセマンティクスを記述するのははるかに困難だ。より多くのページを必要とし、十分に形式的であることはほとんどなく、完全であることもほとんどない。それゆえ、言語法律家たちの間では終わりのない議論が交わされ、言語標準の細かい解釈を目的とした書籍が家内工業的に出版されている。</p>
<p>言語のセマンティクスを記述するための形式手法ツールは存在するが、複雑なため、ほとんどの場合は簡略化された学術言語で使われ、実用される巨大なプログラミング言語ではあまり使われない<a
href="#fn14" class="footnote-ref" id="fnref14"
role="doc-noteref"><sup>14</sup></a>。そのようなツールのうち<span
id="operational_semantics" class="keyword"><em>操作的意味論</em></span>
(operational semantics)
と呼ばれるものは、プログラム実行の仕方を記述する。それは形式化され理想化されたインタープリターを定義する。C++のような産業用言語のセマンティクスは通常、操作的挙動に関する非形式的な議論により「抽象機械」として述べられることが多い。</p>
<p>問題は、操作的意味論を使ってプログラムに関することを証明するのが非常に難しいことだ。プログラムの性質を示すには、基本的には理想化されたインタープリターを通して「実行」しなければならない<a
href="#fn15" class="footnote-ref" id="fnref15"
role="doc-noteref"><sup>15</sup></a>。</p>
<p>プログラマーが正しさを形式的に証明しないことは問題ではない。我々はいつも正しいプログラムを書いていると「思っている」。キーボードの前に座って、「さて、コードを数行打ち込んで、何が起こるか見てみよう」と言う人はいない。我々は、作成するコードが望ましい結果を生み出す特定のアクションを実行すると考えている。そうならない場合、たいていかなり驚くことになる。つまり、我々は自分が書いたプログラムについて推論していて、通常は頭の中でインタープリターを走らせることでそうしている。すべての変数を追跡するのは極めて難しい。コンピューターはプログラムを実行するのが得意だが、人間は不得意だ！　もし得意だったら、コンピューターは必要ないだろう。</p>
<p>しかし、別の選択肢もある。それは<span id="denotational_semantics"
class="keyword"><em>表示的意味論</em></span> (denotational semantics)
と呼ばれ、数学に基づいている。表示的意味論では、すべてのプログラム要素に数学的解釈が与えられる。それを使えば、プログラムの性質を証明したいときは数学的定理を証明するだけでよい<a
href="#fn16" class="footnote-ref" id="fnref16"
role="doc-noteref"><sup>16</sup></a>。定理を証明するのは難しいと思うかもしれないが、実際には、人類は数千年にわたって数学的手法を構築してきたので、利用できる知識が豊富に蓄積されている。また、プロの数学者が証明する定理と比べると、プログラミングで遭遇する問題は、自明ではないにせよ、通常は極めて単純なものだ。</p>
<p>表示的意味論ととても相性が良い言語であるHaskellで階乗関数の定義を考えてみよう。</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>fact n <span class="ot">=</span> <span class="fu">product</span> [<span class="dv">1</span><span class="op">..</span>n]</span></code></pre></div>
<p>
式<code>[1..n]</code>は、<code>1</code>から<code>n</code>までの整数のリストだ。関数<code>product</code>は、リストのすべての要素を乗算する。これは数学の教科書に載っている階乗の定義と同じだ。これをCと比較してほしい。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fact<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        result <span class="op">*=</span> i<span class="op">;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p> これ以上言う必要があるだろうか？</p>
<p>確かに、不当な批判だったのは真っ先に認めよう！　そもそも階乗関数には自明な数学的解釈がある。鋭い読者なら「キーボードから文字を読み取ったり、ネットワークを介してパケットを送信したりするための数学的モデルは何か？」と尋ねるだろう。長きに渡って、それはかなり複雑な説明につながる面倒な質問だった。有用なプログラムを書くために不可欠な多くの重要なタスクには、表示的意味論は最適でないように思われたが、操作的意味論では容易に解決できた。突破口は圏論からもたらされた。エウジニオ・モッジ
(Eugenio Moggi)
によって、計算作用をモナドに写せることが発見された。これは表示的意味論に新たな生命を与え、純粋関数プログラムをより使いやすくするだけでなく、従来のプログラミングに新たな光を当てる重要な観察となった。モナドについては後ほど、より多くの圏論的な道具立てを説明するときに述べる。</p>
<p>プログラミングに数学的モデルがあることの重要な利点の1つは、ソフトウェアの正しさを形式的に証明できることだ<a
href="#fn17" class="footnote-ref" id="fnref17"
role="doc-noteref"><sup>17</sup></a>。消費者向けのソフトウェアを書く際にはそれほど重要でないように思えるだろうが、失敗の代償が法外なものになったり人命が危険にさらされたりするようなプログラミングの領域もある。もっとも、医療システム用のウェブアプリケーションを作成する場合でさえ、Haskell標準ライブラリーの関数やアルゴリズムが正しさの証明を伴うというアイデアに価値を見出すだろう。</p>
<aside id="footnotes-6" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="14">
<li id="fn14"><p>監訳注：注目に値する例外のひとつがWebAssemblyである。<a
href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn15"><p>監訳注：こちらは言いすぎであるように思われる。監訳者の感覚的には、操作的意味論に基づくプログラムの性質の証明を指して「（プログラムを）『実行』しなければならない」と言うことは、多くの場合そういった証明が操作に関する数学的帰納法に基づいて行われることを考えると、自然数の上の数学的帰納法に基づく証明を指して「（数を）『数え』なければならない」と言っているように聞こえる。また、表示的意味論については、しばしばそれそのものの記述に比較的高度な数学的道具が必要となる。たとえば、停止しない関数を扱うためには、ボトムを追加するだけでは十分ではなく、止まらないかもしれないループや再帰定義を数学的に解釈するための構造も必要となる。<a
href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn16"><p>監訳注：操作的意味論を用いた場合もプログラムの性質を証明するのは数学的定理を証明することになる。<a
href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17"><p>監訳注：繰り返すが、操作的意味論でも可能である。<a
href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="2.5" id="純粋関数と非純粋関数"><span
class="header-section-number">2.5</span> 純粋関数と非純粋関数</h2>
<p>C++やその他の命令型言語で関数と呼ぶものは、数学者が関数と呼ぶものとは異なる。数学関数は値から値への写像にすぎない。</p>
<p>数学関数はプログラミング言語で実装できる。そのような関数は、入力値が与えられると、出力値を計算する。数の2乗を生成する関数は、入力値をそれ自身で乗算するはずだ。この関数は呼び出すたびに同じことを行い、同じ入力で呼び出されるたびに同じ出力を生成することが保証されている。数の2乗は月の満ち欠けによって変化しない。</p>
<p>また、数の2乗を計算することで犬においしい餌を出すという副作用があってはならない。それを行う「関数」は数学関数として簡単にモデル化できない。</p>
<p>プログラミング言語では、同じ入力に対して常に同じ結果を生成し副作用のない関数は<span
id="pure_function" class="keyword"><em>純粋関数</em></span> (pure
function)
と呼ばれる。Haskellのような純粋関数型言語では、すべての関数が純粋だ<a
href="#fn18" class="footnote-ref" id="fnref18"
role="doc-noteref"><sup>18</sup></a>。そのため、これらの言語に表示的意味論を与え、圏論でモデル化することが容易になる。他の言語の場合は、純粋なサブセットだけを使うように制限したり、副作用を切り分けて扱ったりすることは常に可能だ。モナドによって、純粋関数のみを使ってあらゆる種類の作用をモデル化する方法については、後ほど説明する。数学的関数だけという制約を課しても何も失われないのだ。</p>
<aside id="footnotes-7" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="18">
<li
id="fn18"><p>監訳注：この言明の背景として、停止しない場合（作用のひとつ）を無視していることに注意されたい。<a
href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="2.6" id="型の例"><span
class="header-section-number">2.6</span> 型の例</h2>
<p>型が集合であることを理解すれば、ややエキゾチックな型を考えられる。たとえば、空集合に対応するのはどんな型だろう？　それは決してC++の<code>void</code>ではないが、Haskellでは<code>Void</code>と呼ばれている。その型には値が存在しない。<code>Void</code>を引数に取る関数は、定義はできるが呼び出せない。呼び出すには<code>Void</code>型の値を提供する必要があるが、それは存在しないからだ。この関数が返す内容に関しては、何ら制限はない。それは任意の型を返せる（ただし、呼び出せないため、返すことはない）。言い換えると、戻り値の型が多相な関数だ。Haskell使いたちはこう呼ぶ。</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">absurd ::</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>
（<code>a</code>は任意の型を表せる型変数なのを覚えておいてほしい。）この名前は偶然ではない<a
href="#fn19" class="footnote-ref" id="fnref19"
role="doc-noteref"><sup>19</sup></a>。
型と関数を論理の言葉でより深く解釈したカリー・ハワード同型と呼ばれるものが存在する。型<code>Void</code>は矛盾を表し、関数<code>absurd</code>の型は「矛盾からは何でも導ける」というラテン語の格言
“ex falso sequitur quodlibet” に対応している<a href="#fn20"
class="footnote-ref" id="fnref20"
role="doc-noteref"><sup>20</sup></a>。</p>
<p>次は、単元集合に対応する型だ。これが持てる値は1つしかない。その値は「唯一存在する」。すぐには分からないかもしれないが、これがC++の<code>void</code>だ。この型を引数に取る関数と、この型を返す関数を考えてみてほしい。<code>void</code>を取る関数は常に呼び出せる。それが純粋関数なら、常に同じ結果を返す。そのような関数の例を示そう。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> f44<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">44</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>
この関数は引数に取るものが「何もない」のだと思うかもしれないが、先ほど見たように、「何もない」を取る関数ならば決して呼び出せない。「何もない」を表す値がないからだ。この関数は何を取るのだろうか？　概念的には、インスタンスが1つしか存在しないダミー値を取る。そのため、その値に明示的に言及する必要はない。しかしHaskellでは、その値を表す記号として、空の括弧のペア<code>()</code>がある。こうして、奇妙な偶然（これは偶然なのか？）によって、voidに対する関数の呼び出しはC++とHaskellで同じように見える。また、Haskellは簡潔さを好むので、同じシンボル<code>()</code>が型、コンストラクター、そして単元集合に対応する唯一の値に使われる。この関数をHaskellで書くとこうなる。</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f44 ::</span> () <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>f44 () <span class="ot">=</span> <span class="dv">44</span></span></code></pre></div>
<p> 1行目は、<code>f44</code>が “unit”
と発音される<code>()</code>型を<code>Integer</code>型に写すことを宣言している。2行目は<code>f44</code>を、unitの唯一のコンストラクター<code>()</code>に対してパターンマッチングを行い、44という数を返すことによって定義している。この関数を呼び出すにはunitの値<code>()</code>を与える。</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>f44 ()</span></code></pre></div>
<p>
unitのどの関数も、結果の型から1つの要素を選択するのと等価であることに注意してほしい（ここでは<code>Integer</code>である44を選択する）。実際、<code>f44</code>は数44の別の表現と見なせる。これは、集合の要素への明示的な言及の代わりに関数（射）についての議論に置き換える方法の例だ。unitからどんな型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>へのどんな関数も、その集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>の要素と1対1で対応している。</p>
<p><code>void</code>型を返す関数や、Haskellでunit型を返す関数はどうだろうか？　C++ではそのような関数が副作用を目的として使われるものの、数学的な意味での本当の関数ではないのは分かっている。unitを返す純粋関数は何もせず、引数を破棄する。</p>
<p>数学的には、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>から単元集合への関数は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>のすべての要素をその単元集合の単一の要素に写す。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>ごとに、そのような関数が1つだけ存在する。<code>Integer</code>に対するこの関数は次のとおりだ。</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fInt ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> ()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>fInt x <span class="ot">=</span> ()</span></code></pre></div>
<p>
任意の整数を与えると、unitが返される。簡潔さの精神で、Haskellでは、破棄する引数をワイルドカードパターンであるアンダースコアで示せる。この方法なら引数に名前を付ける必要はない。よって、上記は次のように書き直せる。</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fInt ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> ()</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>fInt _ <span class="ot">=</span> ()</span></code></pre></div>
<p>
この関数の実装は、渡された値に依存しないだけでなく、引数の型にも依存しないことに注目してほしい。</p>
<p>どの型に対しても同じ式で実装できる関数は、パラメトリック多相関数
(parametrically polymorphic function) と呼ばれる。そのような関数の族
(family)
はすべて、具体的な型の代わりに型パラメーターを使う1つの等式によって実装できる。任意の型からunit型への多相関数を何と呼ぶべきだろう？　もちろん<code>unit</code>と呼ぶ。</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unit ::</span> a <span class="ot">-&gt;</span> ()</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>unit _ <span class="ot">=</span> ()</span></code></pre></div>
<p> C++では、この関数を次のように記述する。</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> unit<span class="op">(</span>T<span class="op">)</span> <span class="op">{}</span></span></code></pre></div>
<p>
型の類型学における次のものは二元集合だ。C++では<code>bool</code>と呼ばれ、Haskellでは予想どおり<code>Bool</code>と呼ばれる。違いは、C++の<code>bool</code>は組み込みの型であるのに対して、Haskellでは次のように定義できることだ。</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bool</span> <span class="ot">=</span> <span class="dt">True</span> <span class="op">|</span> <span class="dt">False</span></span></code></pre></div>
<p> （この定義の読み方は<code>Bool</code> is <code>True</code> or
<code>False</code>だ。）
原理的には、C++でもBoolean型を列挙型として定義できるはずだ。</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">true</span><span class="op">,</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">false</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p> しかし、C++の<code>enum</code>は密かに整数だ<a href="#fn21"
class="footnote-ref" id="fnref21"
role="doc-noteref"><sup>21</sup></a>。C++11の “<code>enum class</code>”
を代わりに使うこともできたが、その場合は、<code>bool::true</code>や<code>bool::false</code>のように、クラス名で値を修飾する必要がある。そして、言うまでもなく、それを使うすべてのファイルに適切なヘッダを含める必要がある。</p>
<p><code>Bool</code>を取る純粋関数は、結果の型から2つの値を選択するだけだ。1つは<code>True</code>に対応し、もう1つは<code>False</code>に対応する。</p>
<p><code>Bool</code>を返す関数は<span id="predicate"
class="keyword"><em>述語</em></span> (predicate)
と呼ばれる。たとえば、Haskellの<code>Data.Char</code>ライブラリーは<code>isAlpha</code>や<code>isDigit</code>のような述語でいっぱいだ。C++には<code>isalpha</code>や<code>isdigit</code>などを定義する同様のライブラリーがあるが、これらはブール値ではなく<code>int</code>を返す。実際の述語は<code>std::ctype</code>で定義され、<code>ctype::is(alpha, c)</code>、<code>ctype::is(digit, c)</code>などの形式がある。</p>
<aside id="footnotes-8" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="19">
<li
id="fn19"><p>訳注：absurdは「理屈に合わない・不条理な」を表す形容詞。その名詞形absurdityは特に論理学においては矛盾を指す。<a
href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20"><p>訳注：この格言の内容は論理学では爆発律 (principle of
explosion) と呼ばれる。<a href="#fnref20" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn21"><p>訳注：そのため、この実装例を<code>false, true</code>の順に変えれば条件文でそのまま使えただろう。また、Haskellでも実際の定義は<code>False</code>が先になっている。しかし、著者によると、暗黙の型変換に頼るのはバグの温床であり、高品質なプログラムは実装の詳細からは独立して機能すべきだという意図でここでは<code>true</code>が先に書かれている。<a
href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="2.7" id="課題-1"><span
class="header-section-number">2.7</span> 課題</h2>
<ol type="1">
<li><p>好きな言語で高階関数（または関数オブジェクト）<code>memoize</code>を定義せよ。この関数は純粋関数<code>f</code>を引数として受け取り、次の点を除いて<code>f</code>と同じ動作をする関数を返す。すなわち、<code>momoize</code>の結果として返される関数は、もとの関数を引数ごとに1回だけ呼び出し、結果を内部に格納し、その後は同じ引数で呼び出されるたびに格納済みの結果を返す。メモ化
(memoize)
された関数ともとの関数は、パフォーマンスを見れば区別できる。たとえば、評価に時間のかかる関数のメモ化を試みること。最初に呼び出したときは結果を待つ必要があるが、同じ引数を使って次に呼び出したときは結果をすぐ得られるだろう。</p></li>
<li><p>乱数を生成するためにあなたが普段使う標準ライブラリー関数をメモ化してみよ。うまくいくか？</p></li>
<li><p>ほとんどの乱数発生器はシードで初期化できる。シードを受け取り、そのシードで乱数発生器を呼び出し、結果を返す関数を実装せよ。その関数をメモ化せよ。うまくいくか？</p></li>
<li><p>以下のC++関数のうち、純粋なのはどれか？　これらをメモ化してみて、何度も呼び出したときに何が起こるかを、メモ化した場合とそうでない場合について観察せよ。</p>
<ol type="1">
<li><p>本文中で例示した階乗関数。</p></li>
<li><div class="sourceCode" id="cb30"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>getchar<span class="op">()</span></span></code></pre></div></li>
<li><div class="sourceCode" id="cb31"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Hello!&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><div class="sourceCode" id="cb32"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">int</span> y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    y <span class="op">+=</span> x<span class="op">;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> y<span class="op">;</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol></li>
<li><p><code>Bool</code>を取り<code>Bool</code>を返す関数は何種類あるか？　それらすべてを自分で実装できるか？</p></li>
<li><p><code>Void</code>型、<code>()</code> (unit)
型、<code>Bool</code>型だけを対象とする圏の絵を描け。ただし、射についてはこれらの型の間のすべての可能な関数に対応するようにせよ。射には関数名のラベルを付けよ。</p></li>
</ol>
<h1 data-number="3" id="圏のさまざま"><span
class="header-section-number">3</span> 圏のさまざま</h1>
<p>様々な例を調べれば圏の真価が理解できる。圏にはさまざまな形やサイズがあり、予期しない場所によく現れる。ごくシンプルなものから始めよう。</p>
<h2 data-number="3.1" id="対象がない場合"><span
class="header-section-number">3.1</span> 対象がない場合</h2>
<p>最も自明な圏は、対象が0個で、したがって射が0本のものだ。それ自体は非常に哀しい圏だが、他の圏との関連、たとえば、すべての圏の圏（そう、そういうものが存在する）において重要になるだろう。空集合に意味があると思うなら、空圏
(empty category) が無意味だとは思わないだろう？</p>
<h2 data-number="3.2" id="有向グラフ"><span
class="header-section-number">3.2</span> 有向グラフ</h2>
<p>対象を射で接続するだけで圏を作成できる。任意の有向グラフから始めて、単に射を追加するだけで圏になるのは想像できるだろう。最初に、各ノードに恒等射を追加する。次に、一方の終点が他方の始点と一致するような2つの射（つまり、2つの<span
id="composable"
class="keyword"><em>合成可能な</em></span>射）に対して、それらの合成として機能する新しい射を追加する。新しい射を追加するたびに、（恒等射を除く）他の射との合成も考慮する必要がある。たいていは射が無限に多くなるが、問題ない。</p>
<p>このプロセスを別の方法で見ると、グラフ内の各ノードを対象とし、合成可能なグラフの辺からなるすべての<span
id="chain" class="keyword"><em>チェイン</em></span><a href="#fn22"
class="footnote-ref" id="fnref22"
role="doc-noteref"><sup>22</sup></a>を射とする圏を作成していることになる。（恒等射はチェインの長さが0の特殊な場合とも見なせる。）</p>
<p>このような圏は、与えられたグラフによって生成される<span
id="free_category" class="keyword"><em>自由圏</em></span> (free
category) と呼ばれる。これは自由構成 (free construction)
の例であり、任意の構造を、その規則（ここでは圏の規則）を満たせる最少の項目で拡張して完成させるプロセスだ。今後さらに多くの例について見ていく。</p>
<aside id="footnotes-9" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="22">
<li id="fn22"><p>訳注：グラフ理論で歩道 (walk) と呼ばれるもの。<a
href="#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="3.3" id="順序"><span
class="header-section-number">3.3</span> 順序</h2>
<p>さて、全く別のものを見てみよう！　射が対象間の関係、具体的には小なりイコール（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≤</mo><annotation encoding="application/x-tex">\leqslant</annotation></semantics></math>）であるような圏だ。これが本当に圏かどうか調べてみよう。恒等射はあるだろうか？　すべての対象はそれ自身以下だろうか？　良し！　合成はあるだろうか？　<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant b</annotation></semantics></math>かつ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">b \leqslant c</annotation></semantics></math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \leqslant c</annotation></semantics></math>である。良し！　合成は結合的か？　良し！　このような関係は<span
id="preorder" class="keyword"><em>前順序</em></span> (preorder)
と呼ばれる。前順序は確かに圏だ。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant b</annotation></semantics></math>かつ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≤</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">b \leqslant a</annotation></semantics></math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>と等しくなければならないという追加の条件も満たす、より強い関係も考えられる。これを<span
id="partial_order" class="keyword"><em>半順序</em></span> (partial
order) と呼ぶ。</p>
<p>最後に、任意の2つの対象が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≤</mo><annotation encoding="application/x-tex">\leqslant</annotation></semantics></math>またはその逆で関係しているという条件も課せる。そうすると、<span
id="linear_order" class="keyword"><em>線形順序</em></span> (linear
order) または<span id="total_order"
class="keyword"><em>全順序</em></span> (total order)
と呼ばれる関係が得られる。</p>
<p>これらの関係を満たす順序集合を圏として特徴づけよう。前順序は、任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>に向かう射が高々1つ存在する圏となる。そのような圏は別名「細い圏」(thin
category) と呼ばれる。前順序圏は細い圏だ。</p>
<p>圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>における対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への射の集合は<span
id="hom-set" class="keyword"><em>hom集合</em></span>と呼ばれ<a
href="#fn23" class="footnote-ref" id="fnref23"
role="doc-noteref"><sup>23</sup></a>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
と書かれる（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐇</mi><mi>𝐨</mi><mi>𝐦</mi></mrow><mi>𝐂</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Hom}_{\mathbf{C}}(a, b)</annotation></semantics></math>
とも書かれる）。したがって、前順序のhom集合はどれも空集合か単元集合になる。これはhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>、つまり<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>への射の集合にも当てはまる。その場合はどの前順序においても必ず単元集合になり、恒等射だけを含む。ただし、前順序では循環が起こりうる。半順序では循環は禁止されている。</p>
<p>整列（ソーティング）においては前順序・半順序・全順序を区別できることが非常に重要だ。クイックソート・バブルソート・マージソートなどの整列アルゴリズムは全順序に対してのみ正しく機能する。半順序にはトポロジカルソートが使える。</p>
<aside id="footnotes-10" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="23">
<li
id="fn23"><p>訳注：後述のように、本書ではこれが一般には集合にならないということは敢えて無視している。<a
href="#fnref23" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="3.4" id="集合としてのモノイド"><span
class="header-section-number">3.4</span> 集合としてのモノイド</h2>
<p>モノイドは非常にシンプルにもかかわらず驚くほど強力な概念だ。それは基礎的な計算の背景にある概念であり、加算と乗算は両方ともモノイドをなす。モノイドはプログラミングの世界では至るところにある。それは、文字列、リスト、foldできるデータ構造、並行プログラミングのfuture、関数型リアクティブプログラミングのイベントなどとして現れる。</p>
<p>伝統的に、モノイドは二項演算を持つ集合として定義される。この演算に要求されるのは、結合律を満たすことと、単位元のように振る舞う特別な要素が1つあることだけだ。</p>
<p>たとえば、0を含む自然数は加算についてモノイドをなす。結合律は次のことを意味する。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mi>c</mi><mo>=</mo><mi>a</mi><mo>+</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a + b) + c = a + (b + c)</annotation></semantics></math>
（言い換えると、数を加算するときは括弧を無視できる。）</p>
<p>中立元<a href="#fn24" class="footnote-ref" id="fnref24"
role="doc-noteref"><sup>24</sup></a>は0だ。なぜなら
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>+</mo><mi>a</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">0 + a = a</annotation></semantics></math>
かつ
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mn>0</mn><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a + 0 = a</annotation></semantics></math>
だからだ。2つ目の等式は冗長だ。加算は可換
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a + b = b + a)</annotation></semantics></math>
だからだ。ただし、可換律はモノイドの定義の一部ではない。たとえば、文字列連接は可換ではないが、モノイドをなす。ちなみに、文字列連接の中立元は空文字列であり、文字列を変更せずに文字列の両側に付加できる。</p>
<p>Haskellではモノイドに対して型クラスを定義できる。その型クラスに属する型は、<code>mempty</code>と呼ばれる中立元と<code>mappend</code>と呼ばれる二項演算を持つ<a
href="#fn25" class="footnote-ref" id="fnref25"
role="doc-noteref"><sup>25</sup></a>。</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="kw">where</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    mempty  ::</span> m</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    mappend ::</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m</span></code></pre></div>
<p>
この2引数関数の型シグネチャーでの<code>m -&gt; m -&gt; m</code>という型は、最初は奇妙に見えるかもしれないが、カリー化を知った後には完全に理にかなったものだと思えるようになるだろう。複数の矢印を含むシグネチャーには、2つの基本的な解釈がある。複数の引数を取る関数とみなして右端の型を戻り値の型とする解釈と、1引数（左端の引数）の関数とみなして関数を返すという解釈だ。後者の解釈は、<code>m -&gt; (m -&gt; m)</code>のように括弧（矢印が右結合であるため冗長）を追加することによって強調できる。この解釈については後で説明する。</p>
<p>Haskellでは、<code>mempty</code>と<code>mappend</code>のモノイド性（monoidal
properties、すなわち、<code>mempty</code>は中立で、<code>mappend</code>は結合律を満たすという事実）を表現する方法がないことに注意してほしい。それらを満たすことを確認するのはプログラマーの責任だ。</p>
<p>HaskellのクラスはC++のクラスほど押し付けがましくはない。新しい型を定義するときに事前にクラスを指定する必要はない。先延ばしして、与えられた型を後からあるクラスのインスタンスであると宣言してよい。例として、<code>mempty</code>と<code>mappend</code>の実装を提供することで<code>String</code>をモノイドとして宣言しよう（実際には、これは標準のPreludeですでにやってくれている）。</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">String</span> <span class="kw">where</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mappend</span> <span class="ot">=</span> (<span class="op">++</span>)</span></code></pre></div>
<p>
ここで、<code>String</code>の値は単に文字のリストなので、リスト連接演算子<code>(++)</code>を再利用した。</p>
<p>Haskellの構文に関する注：中置演算子は括弧で囲うことで2つの引数を取る関数に変換できる。与えられた2つの文字列を連接するには、それらの間に<code>++</code>を挟んでもよい。</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Hello &quot;</span> <span class="op">++</span> <span class="st">&quot;world!&quot;</span></span></code></pre></div>
<p>
あるいは、括弧付きの<code>(++)</code>に2つの文字列を引数として渡してもよい。</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">++</span>) <span class="st">&quot;Hello &quot;</span> <span class="st">&quot;world!&quot;</span></span></code></pre></div>
<p>
関数の引数がコンマで区切られたり括弧で囲まれたりしていないことに注意してほしい。（これはおそらく、Haskellを学ぶときに慣れるのが一番難しい部分だろう。）</p>
<p>Haskellでは関数の等しさを次のように表現できることは、強調しておく価値がある。</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mappend</span> <span class="ot">=</span> (<span class="op">++</span>)</span></code></pre></div>
<p>
概念的には、これは関数によって生成される値の等しさを次のように表現するのとは異なる。</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mappend</span> s1 s2 <span class="ot">=</span> (<span class="op">++</span>) s1 s2</span></code></pre></div>
<p>
前者は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐇</mi><mi>𝐚</mi><mi>𝐬</mi><mi>𝐤</mi></mrow><annotation encoding="application/x-tex">\mathbf{Hask}</annotation></semantics></math>圏（または、終わりのない計算を指すボトムを無視するなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>）の射の等しさに変換される。このような等式はより簡潔であるだけでなく、しばしば他の圏にも一般化できる。後者は<span
id="extensional" class="keyword"><em>外延的</em></span>等価性
(extensional equivalence)
と呼ばれ、どんな2つの入力文字列に対しても<code>mappend</code>と<code>(++)</code>の出力は同じであることを述べている。引数の値は<span
id="point" class="keyword"><em>点</em></span> (point)
と呼ばれることが（「点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>における<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>の値」という言い回しのように）あるため、これは点ごとの等しさ
(point-wise equality) と呼ばれる。引数を指定しない関数の等しさは<span
id="point-free" class="keyword"><em>ポイントフリー</em></span>
(point-free)
と表現される。（ちなみに、ポイントフリーの式は関数合成を含むことが多く、これは点記号<code>.</code>で表されるため、初心者は少し混乱するかもしれない。）</p>
<p>C++でモノイドを宣言するのに最も近い方法は、C++20標準のコンセプト機能を使うことだ。</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> mempty<span class="op">;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  T mappend<span class="op">(</span>T<span class="op">,</span> T<span class="op">)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> M<span class="op">&gt;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">concept</span> Monoid <span class="op">=</span> <span class="kw">requires</span> <span class="op">(</span>M m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> mempty<span class="op">&lt;</span>M<span class="op">&gt;::</span>value<span class="op">()</span> <span class="op">}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span>M<span class="op">&gt;;</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> mappend<span class="op">(</span>m<span class="op">,</span> m<span class="op">);</span> <span class="op">}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>same_as<span class="op">&lt;</span>M<span class="op">&gt;;</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span></code></pre></div>
<p> 最初の定義は、各特殊化で中立元を保持するための構造だ。</p>
<p>キーワード<code>delete</code>は、デフォルト値が定義されていないことを意味する。これはケースバイケースで指定する必要がある。同様に、<code>mappend</code>にもデフォルトはない。</p>
<p><code>Monoid</code>というコンセプトは、与えられた型<code>M</code>に対して<code>mempty</code>と<code>mappend</code>の適切な定義が存在するかをテストする。</p>
<p>このMonoidコンセプトのインスタンス化は、適切な特殊化とオーバーロードを提供することで実現できる。</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> mempty<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="bu">std::</span>string value<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;&quot;</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string mappend<span class="op">(</span><span class="bu">std::</span>string s1<span class="op">,</span> <span class="bu">std::</span>string s2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s1 <span class="op">+</span> s2<span class="op">;</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<aside id="footnotes-11" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="24">
<li id="fn24"><p>訳注：単位元に同じ。<a href="#fnref24"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn25"><p>訳注：現在のHaskellでは<code>Monoid</code>は<code>Semigroup</code>の派生クラス。<code>Semigroup</code>では<code>(&lt;&gt;) :: a -&gt; a -&gt; a</code>が定義されており、<code>Monoid</code>で<code>mappend = (&lt;&gt;)</code>以外の定義をすると警告が表示される。<code>mapppend</code>は将来廃止される予定。<a
href="#fnref25" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="3.5" id="monoid-as-set"><span
class="header-section-number">3.5</span> 圏としてのモノイド</h2>
<p>ここまではモノイドの「おなじみの」定義として、集合の要素に基づくものを見た。しかし、ご存知のように、圏論では集合とその要素から逃れようとし、代わりに対象と射について述べる。そこで、少し視点を変えて、二項演算子を適用すると集合の周りで何かを「移動」したり「シフト」したりすると考えてみよう。</p>
<p>たとえば、各自然数に5を加算する演算を考える。これは0を5、1を6
、2を7のように写す。これは関数で、自然数の集合上で定義されている。良い感じだ。関数と集合がある。一般に、任意の数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>を加算する関数が存在する。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>の「加算器」だ。</p>
<p>加算器はどのように合成すればよいだろう？　5を加算する関数と7を加算する関数の合成は、12を加算する関数だ。これにより、加算器の合成を加算ルールと等価にできる。これまた良い感じだ。加算を関数合成に置き換えられる。</p>
<p>ちょっと待った。それだけではない。中立元0の加算器もある。0を加算しても何も写されないので、これは自然数の集合における恒等関数だ。</p>
<p>従来の加算の規則を与える代わりに、情報を失うことなく加算器を構成する規則を与えることもできる。加算器の合成は結合律を満たすことに注目してほしい。これは、関数の合成が結合律を満たし、恒等関数に対応する0加算器があるからだ。</p>
<p>鋭い読者なら、整数から加算器への写像が<code>mappend</code>の型シグネチャーを<code>m -&gt; (m -&gt; m)</code>と解釈した結果であることに気付いただろう。これは<code>mappend</code>がモノイド集合の要素を、その集合に作用する関数に写すことを表している。</p>
<p>さて、自然数の集合を扱っていることを忘れて、たくさんの射――加算器たちをひとかたまりにした、単一の対象だと考えてほしい。モノイドは単一対象の圏だ。実際、monoidという名前は、ギリシャ語で単一を意味する<em>mono</em>に由来する。すべてのモノイドは、適切な合成規則に従う射の集合を持つ単一対象の圏として表せる。</p>
<p> <img src="images/monoid.jpg" style="width:35.0%" /> </p>
<p> 文字列の連接は興味深いケースだ。なぜなら、右連接器（right
appender）と左連接器（left
appender、あるいはお好みなら前置器prepender）<a href="#fn26"
class="footnote-ref" id="fnref26"
role="doc-noteref"><sup>26</sup></a>を定義する選択肢があるからだ。2つのモデルの合成表は互いに鏡像反転している。「foo」に「bar」を後置するのと「bar」に「foo」を前置するのが同じなのは簡単に納得できるだろう。</p>
<p>圏論的モノイド――単一対象の圏――はどれも二項演算を伴う集合としてのモノイドを一意に定義するのか、という疑問を持つかもしれない。単一対象の圏からは常に集合を抽出できることが分かる。その集合は射――この例では加算器――の集合だ。言い換えれば、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐌</mi><annotation encoding="application/x-tex">\mathbf{M}</annotation></semantics></math>内の単一対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>についてhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{M}(m, m)</annotation></semantics></math>
が得られるということだ。この集合における二項演算は簡単に定義できる。2つの集合要素のモノイド的な積は、それらに対応する射を合成したものに対応する要素だ。つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{M}(m, m)</annotation></semantics></math>
の2つの要素が与えられ、それらに対応する射が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>だとすると、それらの積は合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f \circ g</annotation></semantics></math>に対応する要素となる。この合成は常に存在する。なぜなら、射の始点と終点が同じ対象だからだ。また、圏の規則より、結合律も満たす。恒等射はこの積の中立元だ。このように、圏論的モノイドからは常に集合論的モノイドを復元できる。どこからどう見てもそれらは同一だ。</p>
<figure>
<img src="images/monoidhomset.jpg"
title="射あるいは集合内の点として見たモノイドhom集合"
style="width:40.0%"
alt="射あるいは集合内の点として見たモノイドhom集合" />
<figcaption
aria-hidden="true">射あるいは集合内の点として見たモノイドhom集合</figcaption>
</figure>
<p>
数学者が補足すべき箇所は、射は必ずしも集合をなさないということだけだ。圏の世界には集合よりも大きなものがある。任意の2つの対象間の射が集合をなす圏は、局所的に小さい、と呼ばれる。約束どおり、私はそのような些細なことはほとんど無視するが、念のため言及すべきだと考えた。</p>
<p>hom集合の要素は、合成律に従う射とも、ある集合内の点とも見なせる。圏論における多くの興味深い現象はこの事実に根ざしている。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐌</mi><annotation encoding="application/x-tex">\mathbf{M}</annotation></semantics></math>の射の合成は、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{M}(m, m)</annotation></semantics></math>
でのモノイド的な積に変換される。</p>
<aside id="footnotes-12" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="26">
<li
id="fn26"><p>訳注：appendは後ろにくっつけることなので、前（左）にappendするのは英語話者には違和感があるのだろう。<a
href="#fnref26" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="3.6" id="課題-2"><span
class="header-section-number">3.6</span> 課題</h2>
<ol type="1">
<li><p>以下から自由圏を生成せよ。</p>
<ol type="1">
<li>1つのノードを持ち、辺のないグラフ</li>
<li>1つのノードと1つの（有向）辺を持つグラフ（ヒント：この辺は自身と合成できる）</li>
<li>2つのノードと、それらの間の（有向）辺を1つ持つグラフ</li>
<li>1つのノードと、アルファベットa, b, c
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>…</mi><annotation encoding="application/x-tex">\ldots</annotation></semantics></math>
zでマークされた26個の（有向）辺を持つグラフ</li>
</ol></li>
<li><p>以下はどんな順序だろうか？</p>
<ol type="1">
<li>複数の集合を要素とする集合と、その上の包含関係。なお、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>に包含されるとは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>の全要素が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>の要素でもあることを指す。</li>
<li>C++の型の集合とその上の部分型関係。なお、<code>T1</code>が<code>T2</code>の部分型であるとは、<code>T2</code>へのポインターを期待する関数に<code>T1</code>をコンパイルエラーを発生させずに渡せることを指す。</li>
</ol></li>
<li><p><code>Bool</code>が2つの値<code>True</code>と<code>False</code>の集合であることを踏まえて、それが2つの演算子<code>&amp;&amp;</code>
(AND) と<code>||</code> (OR)
のそれぞれについて（集合論的）モノイドをなすことを示せ。</p></li>
<li><p>AND演算子を伴う<code>Bool</code>モノイドを圏として表せ。射と合成の規則を列挙せよ。</p></li>
<li><p>モジュロ3加算<a href="#fn27" class="footnote-ref" id="fnref27"
role="doc-noteref"><sup>27</sup></a>をモノイドの圏として表せ。</p></li>
</ol>
<aside id="footnotes-13" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="27">
<li id="fn27"><p>訳注：加算して3で割った余りを取る演算。<a
href="#fnref27" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 data-number="4" id="kleisli-categories"><span
class="header-section-number">4</span> クライスリ圏</h1>
<!-- ## ログの合成 -->
<p>型と純粋関数を圏としてモデル化する方法についてはすでに見た。また、圏論には副作用、つまり純粋でない関数をモデル化する方法があることにも触れた。その例として、実行をロギングやトレースする関数を見てみよう。命令型言語では、次のように、何らかのグローバルな状態を変更することによって実装される場合が多い。</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>string logger<span class="op">;</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> negate<span class="op">(</span><span class="dt">bool</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>     logger <span class="op">+=</span> <span class="st">&quot;Not so! &quot;</span><span class="op">;</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> <span class="op">!</span>b<span class="op">;</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
これは純粋関数ではない。メモ化版ではログを生成できないからだ。この関数には<span
id="side_effect" class="keyword"><em>副作用</em></span>がある。</p>
<p>現代のプログラミングでは、グローバルな可変状態をできる限り避ける。並行性を複雑にするというだけでも理由として十分だ。それに、こんなコードをライブラリーに加えたくはないだろう。</p>
<p>我々にとって幸いなことに、この関数は純粋にできる。ログを明示的に受け渡しするだけでよい。文字列引数を追加し、通常の出力に更新されたログを含む文字列を付け加えたペアを返すようにすることで、これを実現しよう。</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>pair<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> string<span class="op">&gt;</span> negate<span class="op">(</span><span class="dt">bool</span> b<span class="op">,</span> string logger<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> make_pair<span class="op">(!</span>b<span class="op">,</span> logger <span class="op">+</span> <span class="st">&quot;Not so! &quot;</span><span class="op">);</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
この関数は純粋で、副作用はなく、同じ引数で呼び出されるたびに同じペアを返し、必要ならメモ化できる。ただし、ログには累積的な性質があるので、特定の呼び出しにつながる可能性のあるすべての履歴をメモ化する必要があるだろう。別々のメモエントリーになるのは</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>negate<span class="op">(</span><span class="kw">true</span><span class="op">,</span> <span class="st">&quot;It was the best of times. &quot;</span><span class="op">);</span></span></code></pre></div>
<p> と</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>negate<span class="op">(</span><span class="kw">true</span><span class="op">,</span> <span class="st">&quot;It was the worst of times. &quot;</span><span class="op">);</span></span></code></pre></div>
<p> などだ。</p>
<p>これもライブラリー関数のインターフェイスとしてはあまり適していない。戻り値が文字列を含むことについては、呼び出し元は無視してよいので、大きな負担ではない。一方で、入力として文字列を渡す必要があるのについては、不便かもしれない。</p>
<p>同じことをもっと面倒なしにやる方法はないのだろうか？　関心事を分離する方法はあるだろうか？　この単純な例では、関数<code>negate</code>の主な目的は、あるブール値を別のブール値に変換することだ。ログ生成は二次的なものだ。確かに、ログに記録されるメッセージは関数固有だが、それらのメッセージを1つの連続したログに集約する作業は別の関心事だ。この関数には文字列を生成してほしいが、ログの生成とは分離したい。妥協案はこうだ。</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>pair<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> string<span class="op">&gt;</span> negate<span class="op">(</span><span class="dt">bool</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> make_pair<span class="op">(!</span>b<span class="op">,</span> <span class="st">&quot;Not so! &quot;</span><span class="op">);</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
このアイデアは、ログを関数呼び出しの<em>間で</em>集約する、というものだ。</p>
<p>どうすればこうできるか確認するために、もう少し現実的な例に切り替えよう。小文字を大文字に変換するような、文字列を取って文字列を返す関数があるとする。</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>string toUpper<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    string result<span class="op">;</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">(*</span>toupperp<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> <span class="op">&amp;</span>toupper<span class="op">;</span> <span class="co">// toupperはオーバーロードされている</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    transform<span class="op">(</span>begin<span class="op">(</span>s<span class="op">),</span> end<span class="op">(</span>s<span class="op">),</span> back_inserter<span class="op">(</span>result<span class="op">),</span> toupperp<span class="op">);</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
さらに、文字列を空白区切りで分割して文字列のvectorにする別の関数があるとする。</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>string<span class="op">&gt;</span> toWords<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> words<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p> 実際の作業は補助関数<code>words</code>で行われる。</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>string<span class="op">&gt;</span> words<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>string<span class="op">&gt;</span> result<span class="op">{</span><span class="st">&quot;&quot;</span><span class="op">};</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i <span class="op">=</span> begin<span class="op">(</span>s<span class="op">);</span> i <span class="op">!=</span> end<span class="op">(</span>s<span class="op">);</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>isspace<span class="op">(*</span>i<span class="op">))</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span>push_back<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span>back<span class="op">()</span> <span class="op">+=</span> <span class="op">*</span>i<span class="op">;</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
関数<code>toUpper</code>と<code>toWords</code>を修正して、通常の戻り値の上にメッセージ文字列を背負わせるようにしたい。</p>
<p> <img src="images/piggyback.jpg" style="width:30.0%" /> </p>
<p>
これらの関数の戻り値を「装飾」していこう。総称的な方法で、テンプレート<code>Writer</code>を定義しよう。このテンプレートは、1番目の成分が任意の型<code>A</code>の値で、2番目の成分が文字列であるペアをカプセル化する。</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">&gt;</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Writer <span class="op">=</span> pair<span class="op">&lt;</span>A<span class="op">,</span> string<span class="op">&gt;;</span></span></code></pre></div>
<p> 装飾された関数は次のとおりだ。</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>Writer<span class="op">&lt;</span>string<span class="op">&gt;</span> toUpper<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    string result<span class="op">;</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">(*</span>toupperp<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> <span class="op">&amp;</span>toupper<span class="op">;</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    transform<span class="op">(</span>begin<span class="op">(</span>s<span class="op">),</span> end<span class="op">(</span>s<span class="op">),</span> back_inserter<span class="op">(</span>result<span class="op">),</span> toupperp<span class="op">);</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> make_pair<span class="op">(</span>result<span class="op">,</span> <span class="st">&quot;toUpper &quot;</span><span class="op">);</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>Writer<span class="op">&lt;</span>vector<span class="op">&lt;</span>string<span class="op">&gt;&gt;</span> toWords<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> make_pair<span class="op">(</span>words<span class="op">(</span>s<span class="op">),</span> <span class="st">&quot;toWords &quot;</span><span class="op">);</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
この2つの関数を合成することで、文字列を大文字にして単語に分割し、また同時にそれらのログを生成するという、別の装飾された関数にしたい。その方法は次のとおりだ。</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>Writer<span class="op">&lt;</span>vector<span class="op">&lt;</span>string<span class="op">&gt;&gt;</span> process<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> p1 <span class="op">=</span> toUpper<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> p2 <span class="op">=</span> toWords<span class="op">(</span>p1<span class="op">.</span>first<span class="op">);</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> make_pair<span class="op">(</span>p2<span class="op">.</span>first<span class="op">,</span> p1<span class="op">.</span>second <span class="op">+</span> p2<span class="op">.</span>second<span class="op">);</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
目標は達成された。ログの集約はもはや個々の関数の関心事ではなくなった。それら個々の関数は独自のメッセージを生成し、それらのメッセージが外部で連接されてより大きなログになる。</p>
<p>このスタイルで書かれたプログラム全体を想像してみてほしい。重複が多くエラーが発生しやすいコードという悪夢だ。しかし、我々はプログラマーだ。重複の多いコードの扱い方は知っている――それを抽象化することだ！　ただし、ありきたりの抽象化ではだめだ――<span
id="function_composition"
class="keyword"><em>関数合成</em></span>自体を抽象化する必要がある。しかし、合成は圏論の本質なので、さらにコードを書く前に、圏論の観点から問題を分析してみよう。</p>
<h2 data-number="4.1" id="writer圏"><span
class="header-section-number">4.1</span> Writer圏</h2>
<p>いくつかの追加機能を背負わせるために関数群の戻り値の型を装飾するというアイデアは、非常に実りの多いものだと分かった。さらに多くの例をこれから見ることになるだろう。その出発点は、いつもの型と関数の圏だ。対象は型のままにしておくが、射は装飾された関数になるように再定義する。</p>
<p>たとえば、<code>int</code>から<code>bool</code>への関数<code>isEven</code>を装飾したいとする。それを装飾された関数で表される射に変換する。重要なのは、装飾された関数は次のようなペアを返すにもかかわらず、この射は相変わらず対象<code>int</code>と<code>bool</code>の間の射と見なされる、ということだ。</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>pair<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> string<span class="op">&gt;</span> isEven<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> make_pair<span class="op">(</span>n <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">,</span> <span class="st">&quot;isEven &quot;</span><span class="op">);</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
圏の規則によれば、この射は対象<code>bool</code>から何かに向かう別の射と合成できるはずだ。具体的には、先ほどの<code>negate</code>と合成できるはずだ。</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>pair<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> string<span class="op">&gt;</span> negate<span class="op">(</span><span class="dt">bool</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> make_pair<span class="op">(!</span>b<span class="op">,</span> <span class="st">&quot;Not so! &quot;</span><span class="op">);</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
明らかに、入力と出力の不一致のせいで、これら2つの射は通常の関数合成と同じようには合成できない。それらの合成はもっとこんな風になるはずだ。</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>pair<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> string<span class="op">&gt;</span> isOdd<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    pair<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> string<span class="op">&gt;</span> p1 <span class="op">=</span> isEven<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    pair<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> string<span class="op">&gt;</span> p2 <span class="op">=</span> negate<span class="op">(</span>p1<span class="op">.</span>first<span class="op">);</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> make_pair<span class="op">(</span>p2<span class="op">.</span>first<span class="op">,</span> p1<span class="op">.</span>second <span class="op">+</span> p2<span class="op">.</span>second<span class="op">);</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
こうして、我々が構築している新しい圏における2つの射の合成のレシピができる。</p>
<ol type="1">
<li><p>1番目の射に対応する装飾された関数を実行する。</p></li>
<li><p>その結果のペアから第一成分を取り出し、2番目の射に対応する装飾された関数に渡す。</p></li>
<li><p>1番目の結果の第二成分（文字列）と2番目の結果の第二成分（文字列）を連接する。</p></li>
<li><p>2番目の結果の第一成分と連接された文字列を組み合わせた新しいペアを返す。</p></li>
</ol>
<p>この合成をC++の高階関数として抽象化したい場合、いま考えている圏での3つの対象に対応する3つの型でパラメーター化されたテンプレートを使わなければならない。そのテンプレートでは、ルール上合成可能な2つの装飾された関数を受け取り、3番目の装飾された関数を返す必要がある。</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">,</span> <span class="kw">class</span> C<span class="op">&gt;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>function<span class="op">&lt;</span>Writer<span class="op">&lt;</span>C<span class="op">&gt;(</span>A<span class="op">)&gt;</span> compose<span class="op">(</span>function<span class="op">&lt;</span>Writer<span class="op">&lt;</span>B<span class="op">&gt;(</span>A<span class="op">)&gt;</span> m1<span class="op">,</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>                               function<span class="op">&lt;</span>Writer<span class="op">&lt;</span>C<span class="op">&gt;(</span>B<span class="op">)&gt;</span> m2<span class="op">)</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">[</span>m1<span class="op">,</span> m2<span class="op">](</span>A x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> p1 <span class="op">=</span> m1<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> p2 <span class="op">=</span> m2<span class="op">(</span>p1<span class="op">.</span>first<span class="op">);</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> make_pair<span class="op">(</span>p2<span class="op">.</span>first<span class="op">,</span> p1<span class="op">.</span>second <span class="op">+</span> p2<span class="op">.</span>second<span class="op">);</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
ここで、前の例に戻り、この新しいテンプレートを使って<code>toUpper</code>と<code>toWords</code>の合成を実装できる。</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>Writer<span class="op">&lt;</span>vector<span class="op">&lt;</span>string<span class="op">&gt;&gt;</span> process<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> compose<span class="op">&lt;</span>string<span class="op">,</span> string<span class="op">,</span> vector<span class="op">&lt;</span>string<span class="op">&gt;&gt;(</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>       toUpper<span class="op">,</span> toWords<span class="op">)(</span>s<span class="op">);</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
<code>compose</code>テンプレートへの型の受け渡しにはまだ多くのノイズがある。これは、戻り値型推論を持つ総称ラムダ関数をサポートするC++14準拠のコンパイラーがあれば回避できる。（このコードはEric
Nieblerによる。）</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="at">const</span> compose <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span> m1<span class="op">,</span> <span class="kw">auto</span> m2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">[</span>m1<span class="op">,</span> m2<span class="op">](</span><span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> p1 <span class="op">=</span> m1<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> p2 <span class="op">=</span> m2<span class="op">(</span>p1<span class="op">.</span>first<span class="op">);</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> make_pair<span class="op">(</span>p2<span class="op">.</span>first<span class="op">,</span> p1<span class="op">.</span>second <span class="op">+</span> p2<span class="op">.</span>second<span class="op">);</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>
この新しい定義では、<code>process</code>の実装は次のように簡略化される。</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>Writer<span class="op">&lt;</span>vector<span class="op">&lt;</span>string<span class="op">&gt;&gt;</span> process<span class="op">(</span>string s<span class="op">){</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> compose<span class="op">(</span>toUpper<span class="op">,</span> toWords<span class="op">)(</span>s<span class="op">);</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
しかし、まだ完成ではない。この新しい圏における合成を定義したが、恒等射は何だろう？　それらは通常の恒等関数ではない！　それらは、型Aから型Aに戻る射でなければならず、つまり、それらは次の形の装飾された関数であることを意味する。</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>Writer<span class="op">&lt;</span>A<span class="op">&gt;</span> identity<span class="op">(</span>A<span class="op">);</span></span></code></pre></div>
<p>
それらは合成に関する単位元として振る舞う必要がある。合成の定義を見ると、恒等射は引数を変更せずに渡し、ログには空文字列だけを与える必要があるのが分かる。</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">&gt;</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>Writer<span class="op">&lt;</span>A<span class="op">&gt;</span> identity<span class="op">(</span>A x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> make_pair<span class="op">(</span>x<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
ここで定義した圏が本当に正当な圏であることは簡単に納得できる。特に、ここでの合成が結合性を持つのは自明だ。各ペアの1番目の成分で何が起こっているかを見ると、それは単なる通常の関数合成であり、結合的だ。2番目の成分は連接されており、連接も結合的だ。</p>
<p>鋭い読者なら、この構成を文字列モノイドだけでなく、どんなモノイドにも容易に一般化できると気付くだろう。<code>compose</code>の中では<code>mappend</code>を、<code>identity</code>の中では<code>mempty</code>を（<code>+</code>と<code>""</code>の代わりに）使おう。ログ生成を文字列だけに限定する理由はない。優れたライブラリー作成者は、ライブラリーを機能させられる最小限の制約を見抜けなくてはならない。ここで、ログ生成ライブラリーの唯一の要件は、ログがモノイド性を持つことだ。</p>
<h2 data-number="4.2" id="haskellにおけるwriter"><span
class="header-section-number">4.2</span> HaskellにおけるWriter</h2>
<p>Haskellでは同じことを少し簡潔にやれて、コンパイラーからも多くの支援を受けられる。<code>Writer</code>型を定義することから始めよう。</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Writer</span> a <span class="ot">=</span> (a, <span class="dt">String</span>)</span></code></pre></div>
<p>
ここでは単にC++の<code>typedef</code>（または<code>using</code>）に相当する型エイリアスを定義している。型<code>Writer</code>は型変数<code>a</code>によってパラメーター化され、<code>a</code>と<code>String</code>のペアと等価だ。ペアの構文は最小限だ。2つの項目を括弧で囲み、コンマで区切るだけだ。</p>
<p>射は任意の型から<code>Writer</code>型への関数だ。</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> <span class="dt">Writer</span> b</span></code></pre></div>
<p>
合成を中置演算子として宣言する。この風変わりな演算子は「魚」と呼ばれることもある。</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">&gt;=&gt;</span>) <span class="ot">::</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>  (a <span class="ot">-&gt;</span> <span class="dt">Writer</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> <span class="dt">Writer</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Writer</span> c)</span></code></pre></div>
<p>
この関数は、それら自体も関数である2つの引数を取り、1つの関数を返す。1番目の引数の型は<code>(a -&gt; Writer b)</code>、2番目の引数は<code>(b -&gt; Writer c)</code>、結果は<code>(a -&gt; Writer c)</code>となる。</p>
<p>この中置演算子の定義は次のとおりだ<a href="#fn28"
class="footnote-ref" id="fnref28"
role="doc-noteref"><sup>28</sup></a>。2つの引数<code>m1</code>と<code>m2</code>は魚型シンボルの両側に現れる。</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>m1 <span class="op">&gt;=&gt;</span> m2 <span class="ot">=</span> \x <span class="ot">-&gt;</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (y, s1) <span class="ot">=</span> m1 x</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>        (z, s2) <span class="ot">=</span> m2 y</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> (z, s1 <span class="op">++</span> s2)</span></code></pre></div>
<p>
結果は、1つの引数<code>x</code>を取るラムダ関数だ。ラムダはバックスラッシュで書かれる――ギリシャ文字の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">\lambda</annotation></semantics></math>を片脚にしたものと考えてほしい。</p>
<p><code>let</code>式では補助変数を宣言できる。ここで<code>m1</code>を呼び出した結果は変数のペア<code>(y, s1)</code>にパターンマッチングされ、最初のパターンからの引数<code>y</code>で<code>m2</code>を呼び出した結果は<code>(z, s2)</code>にマッチングされる。</p>
<p>Haskellでは、C++でアクセッサーが使われるのとは違って、ペアをパターンマッチするのが一般的だ。それ以外は、2つの実装はほぼ直接的に対応している。</p>
<p><code>let</code>式全体の値は<code>in</code>節で指定される。ここでは、1番目の要素が<code>z</code>で、2番目の要素が2つの文字列の連接<code>s1 ++ s2</code>であるペアだ。</p>
<p>この圏の恒等射も定義し、<code>return</code>と呼ぶことにする<a
href="#fn29" class="footnote-ref" id="fnref29"
role="doc-noteref"><sup>29</sup></a>。そう呼ぶ理由は後で明らかになる。</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Writer</span> a</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> x <span class="ot">=</span> (x, <span class="st">&quot;&quot;</span>)</span></code></pre></div>
<p>
完全を期すために、装飾された関数<code>upCase</code>と<code>toWords</code>のHaskell版を用意しよう。</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="ot">upCase ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> <span class="dt">String</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>upCase s <span class="ot">=</span> (<span class="fu">map</span> <span class="fu">toUpper</span> s, <span class="st">&quot;upCase &quot;</span>)</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="ot">toWords ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> [<span class="dt">String</span>]</span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>toWords s <span class="ot">=</span> (<span class="fu">words</span> s, <span class="st">&quot;toWords &quot;</span>)</span></code></pre></div>
<p>
関数<code>map</code>はC++の<code>transform</code>に対応する。式<code>map toUpper</code>は文字関数<code>toUpper</code>を文字列<code>s</code>に適用する。補助関数<code>words</code>は標準のPreludeライブラリーで定義されている。</p>
<p>最後に、2つの関数の合成はfish演算子の助けを借りて達成される。</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="ot">process ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> [<span class="dt">String</span>]</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>process <span class="ot">=</span> upCase <span class="op">&gt;=&gt;</span> toWords</span></code></pre></div>
<aside id="footnotes-14" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="28">
<li
id="fn28"><p>訳注：前節の末尾で述べられているとおり、ここでの<code>++</code>は<code>mappend</code>とする方が好ましい。<a
href="#fnref28" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn29"><p>訳注：同様に、<code>""</code>は<code>mempty</code>とするのが好ましい。<a
href="#fnref29" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="4.3" id="クライスリ圏"><span
class="header-section-number">4.3</span> クライスリ圏</h2>
<p>この圏は私がこの場で発明したのではないことに、もう気付いているかもしれない。これはいわゆるクライスリ圏の一例で、モナドに基づく圏だ。モナドについてはまだ議論する準備ができていないが、モナドで何ができるのかを少しあなたに伝えたかったのだ。我々の限定された目的に関しては、クライスリ圏は、背後にあるプログラム言語の型を対象として持っている<a
href="#fn30" class="footnote-ref" id="fnref30"
role="doc-noteref"><sup>30</sup></a>。型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>から型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>への射は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>を取る関数であり、特定の装飾によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>から派生した型を返す。個々のクライスリ圏は、そのような射を合成する個別の方法や、その合成に関する恒等射を定義している。（不正確な用語である「装飾」は、圏論における自己関手という概念に対応していることが後で分かるだろう。）</p>
<p>この章でクライスリ圏の基礎として使ったモナドは<span id="writer_monad"
class="keyword"><em>writerモナド</em></span>と呼ばれ、関数の実行をログに記録したりトレースしたりするために使われる。また、純粋な計算に副作用を埋め込むための、より汎用的なメカニズムの例でもある。これまで見てきたように、プログラミング言語の型と関数は、（いつもどおりボトムは無視して）集合の圏でモデル化できる。ここでは、そのモデルをわずかに異なる圏へと拡張した。すなわち、装飾された関数によって射が表現され、それらを合成した関数がひとつの関数の出力を別の関数の入力に渡す以上のことを行う圏だ。このクライスリ圏ではもうひとつ使える自由度がある。合成そのものだ。それはまさに、命令型言語においては副作用を用いて従来は実装されてきたようなプログラムに、簡潔な表示的意味を与えられるようにする自由度だと分かる。</p>
<aside id="footnotes-15" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="30">
<li
id="fn30"><p>訳注：本書が『プログラマーのための圏論』であることに留意されたい。なお、モナドについては第20章で詳しく述べられる。<a
href="#fnref30" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="4.4" id="課題-3"><span
class="header-section-number">4.4</span> 課題</h2>
<p>引数が取り得る値のすべてに対して定義されているわけではない関数は、部分関数と呼ばれる。これは実際には数学的な意味での関数ではないので、標準的な圏の枠組みには合わない。しかし、装飾された型<code>optional</code>を返す関数でなら表せる。</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">&gt;</span> <span class="kw">class</span> optional <span class="op">{</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> _isValid<span class="op">;</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>    A    _value<span class="op">;</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>    optional<span class="op">()</span>    <span class="op">:</span> _isValid<span class="op">(</span><span class="kw">false</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>    optional<span class="op">(</span>A v<span class="op">)</span> <span class="op">:</span> _isValid<span class="op">(</span><span class="kw">true</span><span class="op">),</span> _value<span class="op">(</span>v<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> isValid<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> _isValid<span class="op">;</span> <span class="op">}</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>    A value<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> _value<span class="op">;</span> <span class="op">}</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p> たとえば、以下は装飾された関数<code>safe_root</code>の実装だ。</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>optional<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> safe_root<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> optional<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;{</span>sqrt<span class="op">(</span>x<span class="op">)};</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">return</span> optional<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;{};</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p> 課題は以下のとおりだ。</p>
<ol type="1">
<li><p>部分関数についてクライスリ圏を構築せよ（合成と恒等射を定義せよ）。</p></li>
<li><p>引数が0でない場合にその逆数を返す装飾された関数<code>safe_reciprocal</code>を実装せよ。</p></li>
<li><p>関数<code>safe_root</code>と<code>safe_reciprocal</code>を合成して、可能なすべての場合に<code>sqrt(1/x)</code>を計算する<code>safe_root_reciprocal</code>を実装せよ。</p></li>
</ol>
<h1 data-number="5" id="products-and-coproducts"><span
class="header-section-number">5</span> 積と余積</h1>
<p>古代ギリシアの劇作家のエウリーピデースは「人間は、喜んで交際している仲間たちと異なるところがない」と言った<a
href="#fn31" class="footnote-ref" id="fnref31"
role="doc-noteref"><sup>31</sup></a>。我々は人間関係によって定義される。これほど圏論に当てはまる言葉はない。圏の中の特定の対象を選び出すには、他の対象（およびそれ自身）との関係性のパターンを記述するしかない。それらの関係性は射によって定義される。</p>
<p>圏論では、<span id="universal_construction"
class="keyword"><em>普遍的構成</em></span> (universal construction)
と呼ばれる、対象をその関係性によって定義するための構成法がよく現れる。そのための方法の1つとしては、対象と射から構成された特定の形のパターンを選び、圏に出現するそのパターンをすべて探すことが挙げられる。そのパターンが十分に一般的で、圏が大きい場合、該当するものが山ほど出てくるだろう。秘訣は、該当したものに対するある種の順位付けを確立し、最適と考えられるものを選択することだ。</p>
<p>このプロセスはウェブ検索のやり方を思い起こさせる。クエリはパターンのようなものだ。非常に一般的なクエリなら、<em>再現率</em>
(recall)
が高く、すなわちヒットする数が多い。関連性があるものもあれば、そうでないものもあるだろう。無関係なヒットを削除するには、クエリを絞り込む。これにより<em>精度</em>
(precision)
が向上する。最終的に、検索エンジンは検索結果を順位付けして、うまくいけば、あなたが興味のある結果がリストの一番上に表示される。</p>
<h2 data-number="5.1" id="始対象"><span
class="header-section-number">5.1</span> 始対象</h2>
<p>最も単純な形は単一の対象だ。明らかに、この形の実例は、特定の圏にある対象と同じ数だけ存在する。それでは候補が多すぎる。ある種の順位付けを確立し、この階層のトップにある対象を見つける必要がある。我々が自由に使える唯一の手段は射だ。射を矢印として捉えるなら、矢印の全体的な総フローが、圏の一方の端から他方の端へと存在しうる。これは半順序などの順序付けられた圏に当てはまる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>へ向かう矢印（射）が存在するなら、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>は対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>よりも「始め」だとして、対象の優先順位の概念を一般化できる。次に、<em>唯一の</em>始対象を、他のすべての対象に向かう射を持つものとして定義する。もちろん、そのような対象が存在する保証はない。だが、それについては大丈夫だ。より大きな問題は、そのような対象が多すぎるかもしれないことだ。再現率は高いが、精度を欠いている。解決策は、順序圏からヒントを得ることだ。それらの圏では、任意の2つの対象の間に高々1つの射しかない。そのため、別の対象以下となる方法は1つしかない。これは始対象の次のような定義につながる。</p>
<blockquote>
<p><strong>始対象</strong> (the initial object)
とは、圏内の任意の対象に対し、そこへ向かう射をちょうど1つだけ持つ対象である。</p>
</blockquote>
<p> <img src="images/initial.jpg" style="width:40.0%" /> </p>
<p>
それでも、始対象が（存在するにしても）一意だとは保証されない。しかし、それは次善のものを保証する。<span
id="up_to_isomorphism" class="keyword"><em>同型を除いて</em></span>一意
(uniqueness up to isomorphism)
という性質だ。同型は圏論では非常に重要なので、すぐに説明する。差し当たっては、同型を除いて一意という性質が始対象の定義における
“the” の使用を正当化するのを認めることにしよう。</p>
<p>以下にいくつかの例を示す。半順序集合（partially ordered
set、しばしばposetとも）では最小元が始対象となる。始対象を持たない半順序集合もある。たとえば、すべての整数の集合（正の数も負の数も含む）で、小なりイコール関係を射とするものだ。</p>
<p>集合と関数の圏では、始対象は空集合だ。空集合はHaskellの型<code>Void</code>に対応し（C++には対応する型は存在しない）、<code>Void</code>から他の型への一意な多相関数は<code>absurd</code>と呼ばれていたのを思い出してほしい。</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="ot">absurd ::</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>
<code>Void</code>を型の圏における始対象にしているのは、この射の族なのだ。</p>
<aside id="footnotes-16" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="31">
<li id="fn31"><p>訳注：『ポイニクス』812番の台詞に基づく。英訳の “Every
man is like the company he is wont to keep.”
が格言として広まったものと考えられる。この日本語訳は『ギリシア悲劇全集
(12) エウリーピデース断片』（岩波書店、1993）に従った。<a
href="#fnref31" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="5.2" id="終対象"><span
class="header-section-number">5.2</span> 終対象</h2>
<p>引き続き単一対象パターンを扱うが、対象の順位付け方法を変更しよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>への射がある場合、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>は対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>よりも「終わりの側」と言える（方向が逆になっていることに注意してほしい）。探したいのは、圏のどの対象よりも終わりの側となる対象だ。再び、一意性を主張することになる。</p>
<blockquote>
<p><strong>終対象</strong> (the terminal object)
とは、圏内のどの対象からもちょうど1つの射しか来ない対象である。</p>
</blockquote>
<p> <img src="images/final.jpg" style="width:40.0%" /> </p>
<p>
繰り返しになるが、終対象は同型を除いて一意だ。これについてはすぐ後で説明する。まずは、いくつかの例を見てみよう。半順序集合では、終対象があれば、それが最大元だ。集合の圏では、終対象は単元集合だ。単元集合についてはすでに説明した。単元集合は、C++では<code>void</code>型に対応し、Haskellではunit型<code>()</code>に対応する。この型が持つ唯一の値は、C++では暗黙的だが、Haskellでは明示的に<code>()</code>で表される。また、任意の型からunit型へのちょうど1つの純粋関数が存在することも確認した。</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unit ::</span> a <span class="ot">-&gt;</span> ()</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>unit _ <span class="ot">=</span> ()</span></code></pre></div>
<p> これで、終対象のすべての条件が満たされた。</p>
<p>この例では、射の一意性という条件が決定的に重要であることに注意してほしい。なぜなら、すべての集合から入ってくる射を持つ他の集合（実際には、空集合を除くすべての集合）が存在するからだ。たとえば、すべての型に対して定義されたブール値関数（述語）がある。</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="ot">yes ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>yes _ <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>
しかし、<code>Bool</code>は終対象ではない。すべての型に対して、少なくとももう1つの<code>Bool</code>値関数がある（<code>Void</code>に対してはどちらの関数も<code>absurd</code>と等しくなるので除く）。</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="ot">no ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>no _ <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>
一意性を主張することで、終対象の定義を1つの型だけに絞り込むのにちょうど良い精度が得られる。</p>
<h2 data-number="5.3" id="双対性"><span
class="header-section-number">5.3</span> 双対性</h2>
<p>始対象と終対象の定義の対称性には注目せずにいられないだろう。両者の唯一の違いは、射の方向だった。どの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>に対しても、すべての射を反転させるだけで<span
id="opposite_category" class="keyword"><em>反対圏</em></span> (opposite
category)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}</annotation></semantics></math>を定義できると分かる。
反対圏は、同時に合成を再定義しさえすれば、圏としての要件をすべて自動的に満たす。もとの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to b</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∷</mo><mi>b</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">g \Colon b \to c</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">h=g \circ f</annotation></semantics></math>によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">h \Colon a \to c</annotation></semantics></math>へと合成される場合、逆の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>∷</mo><mi>b</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">f^\mathit{op} \Colon b \to a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>∷</mo><mi>c</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">g^\mathit{op} \Colon c \to b</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>h</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>=</mo><msup><mi>f</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>∘</mo><msup><mi>g</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup></mrow><annotation encoding="application/x-tex">h^\mathit{op} = f^\mathit{op} \circ g^\mathit{op}</annotation></semantics></math>によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>h</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>∷</mo><mi>c</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">h^\mathit{op} \Colon c \to a</annotation></semantics></math>へと合成される<a
href="#fn32" class="footnote-ref" id="fnref32"
role="doc-noteref"><sup>32</sup></a>。
そして、恒等射を反転させることは、（駄洒落に注意！）no-opだ。</p>
<p>双対性は圏の非常に重要な特性だ。圏論を扱うすべての数学者の生産性を倍増させるからだ。思いつくすべての構成にはその反対があり、そして、証明するすべての定理について無料でもう1つ付いてくる。反対圏の構成にはしばしば「余」(co)
が前置され、積と余積、モナドとコモナド、錐と余錐、極限と余極限などがある。ただし、射を2回反転させればもとの状態に戻るので、ココモナドはない。</p>
<p>そのため、終対象は反対圏の始対象だと言える。</p>
<aside id="footnotes-17" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="32">
<li
id="fn32"><p>訳注：本書ではHaskellの記法にならってか、射についても<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>:</mo><annotation encoding="application/x-tex">\colon</annotation></semantics></math>でなく<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∷</mo><annotation encoding="application/x-tex">\Colon</annotation></semantics></math>が用いられている。<a
href="#fnref32" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="5.4" id="同型"><span
class="header-section-number">5.4</span> 同型</h2>
<p>プログラマーである我々は、等しさを定義することが簡単な作業ではないことをよく知っている。2つのオブジェクトが等しいとはどういう意味だろう？　メモリー内の同じ場所を占有する必要があるだろうか（ポインターの等しさ）。あるいは、すべての要素の値が同じであれば十分だろうか？　2つの複素数の一方を実部と虚部で表し、もう一方を絶対値と偏角で表すしたとき、それらは等しいだろうか？　数学者たちが等しさの意味を解明済みだろう、と思うかもしれないが、そうではない。数学においても、等しさには複数の競合する定義があるという、同じ問題がある。命題として表される等しさ
(propositional equality)、内包的な 等しさ (intensional
equality)、外延的な等しさ (extensional
equality)、ホモトピー型理論における道 (path)
としての等しさがある。そして同型 (isomorphism)
のより弱い概念、さらには等価性 (equivalence) のより弱い概念もある。</p>
<p>直観としては、同型の対象は同じように見える。つまり、同じ形をしている。これは、1対1写像により、ある対象のどの一部も別の対象のどこか一部に対応することを意味する。我々の道具で調べうる限り、2つの対象はお互いの完全なコピーだ。数学的には、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への写像があり、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>から対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>への写像があり、それらが互いの逆であることを意味する。圏論では、写像を射に置き換える。同型射は可逆な射、つまり一方が他方の逆になっているような射のペアだ。</p>
<p>逆であるということは合成と恒等射によって理解できる。射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>が射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>の逆であるのは、それらの合成が恒等射となる場合だ。それら2つの射は、合成する方法が2つあるので、実際には2つの等式で表される。</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">.</span> g <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>g <span class="op">.</span> f <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<p>
始（終）対象が同型を除いて一意だと言ったとき、2つの始（終）対象は同型だということを意味していた。これは簡単に理解できる。2つの始対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>1</mn></msub><annotation encoding="application/x-tex">i_{1}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>2</mn></msub><annotation encoding="application/x-tex">i_{2}</annotation></semantics></math>があるとしよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>1</mn></msub><annotation encoding="application/x-tex">i_{1}</annotation></semantics></math>が始対象であるため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>1</mn></msub><annotation encoding="application/x-tex">i_{1}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>2</mn></msub><annotation encoding="application/x-tex">i_{2}</annotation></semantics></math>への一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>が存在する。同様に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>2</mn></msub><annotation encoding="application/x-tex">i_{2}</annotation></semantics></math>が始対象であるため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>2</mn></msub><annotation encoding="application/x-tex">i_{2}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>1</mn></msub><annotation encoding="application/x-tex">i_{1}</annotation></semantics></math>への一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>が存在する。これらの2つの射を合成すると何になるだろう？</p>
<figure>
<img src="images/uniqueness.jpg" title="この図中のすべての射は一意だ"
style="width:40.0%" alt="この図中のすべての射は一意だ" />
<figcaption aria-hidden="true">この図中のすべての射は一意だ</figcaption>
</figure>
<p>
合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">g \circ f</annotation></semantics></math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>1</mn></msub><annotation encoding="application/x-tex">i_{1}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>1</mn></msub><annotation encoding="application/x-tex">i_{1}</annotation></semantics></math>への射でなければならない。しかし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>1</mn></msub><annotation encoding="application/x-tex">i_{1}</annotation></semantics></math>は始対象なので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>1</mn></msub><annotation encoding="application/x-tex">i_{1}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>1</mn></msub><annotation encoding="application/x-tex">i_{1}</annotation></semantics></math>へ向かう射は1つだけだ。圏の中なので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>1</mn></msub><annotation encoding="application/x-tex">i_{1}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>1</mn></msub><annotation encoding="application/x-tex">i_{1}</annotation></semantics></math>への恒等射があるのは分かっている。候補は1つだけなので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">g \circ f</annotation></semantics></math>はそれでなければならない。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">g \circ f</annotation></semantics></math>は恒等射と等しくなる。同様に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f \circ g</annotation></semantics></math>は恒等射と等しくなければならない。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>2</mn></msub><annotation encoding="application/x-tex">i_{2}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mn>2</mn></msub><annotation encoding="application/x-tex">i_{2}</annotation></semantics></math>に戻る射は1つしかないからだ。これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>が互いの逆でなければならないことを証明している。したがって、任意の2つの始対象は同型だ。</p>
<p>この証明では、始対象からそれ自体への射の一意性を用いたことに注意してほしい。そうしなければ「同型を除いて」の部分は証明できない。しかし、なぜ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>の一意性が必要なのだろうか。始対象は同型を除いて一意なだけでなく、<em>一意な</em>同型を除いて一意だからだ。原則として、2つの対象間には複数の同型が存在する可能性があるが、ここではそうではない。この「一意な同型を除いて一意という性質」は、すべての普遍的構成の重要な特性だ。</p>
<h2 data-number="5.5" id="積"><span
class="header-section-number">5.5</span> 積</h2>
<p>次の普遍的構成は積 (product) に関するものだ。2つの集合のデカルト積
(Cartesian product)
が何なのかは知っている。ペアからなる集合だ。しかし、集合の積とそれを構成する集合を結びつけるパターンは何だろう？　それが分かれば、他の圏にも一般化できるはずだ。</p>
<p>唯一言えるのは、積から各構成要素への射影 (projection)
という関数が2つある、ということだ。Haskellでは、これら2つの関数は<code>fst</code>と<code>snd</code>と呼ばれ、それぞれペアの第一要素と第二要素を抜き出す。</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fst</span><span class="ot"> ::</span> (a, b) <span class="ot">-&gt;</span> a</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fst</span> (x, y) <span class="ot">=</span> x</span></code></pre></div>
<div class="sourceCode" id="cb76"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="fu">snd</span><span class="ot"> ::</span> (a, b) <span class="ot">-&gt;</span> b</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="fu">snd</span> (x, y) <span class="ot">=</span> y</span></code></pre></div>
<p>
ここで、関数は引数に対するパターンマッチングによって定義されている。パターン<code>(x, y)</code>は任意のペアにマッチし、要素を変数<code>x</code>と<code>y</code>に抽出する。</p>
<p>これらの定義はワイルドカードを使ってさらに単純化できる。</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fst</span> (x, _) <span class="ot">=</span> x</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="fu">snd</span> (_, y) <span class="ot">=</span> y</span></code></pre></div>
<p> C++では、たとえば次のようなテンプレート関数が使われるだろう。</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>A fst<span class="op">(</span>pair<span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">&gt;</span> <span class="at">const</span> <span class="op">&amp;</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> p<span class="op">.</span>first<span class="op">;</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
この非常に限られているように一見思える知識をもって、2つの集合（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>）の積の構成につながる、集合の圏における対象と射のパターンを定義してみよう。このパターンは対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>と、それぞれ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>に接続される2つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>とで構成される。</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> c <span class="ot">-&gt;</span> a</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="ot">q ::</span> c <span class="ot">-&gt;</span> b</span></code></pre></div>
<p> <img src="images/productpattern.jpg" style="width:30.0%" /> </p>
<p>
このパターンに一致するすべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>が積の候補となる。それは大量にあるかもしれない。</p>
<p> <img src="images/productcandidates.jpg" style="width:40.0%" /> </p>
<p>
たとえば、構成要素として、2つのHaskellの型<code>Int</code>と<code>Bool</code>を選択してみて、それらの積の候補を挙げてみよう。</p>
<p>1番目の候補は<code>Int</code>だ。<code>Int</code>は<code>Int</code>と<code>Bool</code>の積の候補となるだろうか？　そう、候補となる――その射影はこうなる。</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>p x <span class="ot">=</span> x</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a><span class="ot">q ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>q _ <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p> これはかなり酷いが、基準を満たしている。</p>
<p>2番目の候補は<code>(Int, Int, Bool)</code>だ。要素が3つの組、すなわち3つ組だ。これを正当な候補にする2つの射を以下に示す（ここでは3つ組に対してパターンマッチングを使っている）。</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>p (x, _, _) <span class="ot">=</span> x</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="ot">q ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>q (_, _, b) <span class="ot">=</span> b</span></code></pre></div>
<p>
1番目の候補は狭すぎ、積の<code>Int</code>の次元だけをカバーしている。一方で、2番目の候補は大きすぎ、<code>Int</code>の次元が重複してしまっている。</p>
<p>しかし、この普遍的構成の別の部分である順位付けについてはまだ調べていない。そこで、パターンの2つの例を比較できるようにしたい。つまり、対象の1つの候補<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>とその2つの射影<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>および<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>を、別の対象の候補<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>とその2つの射影<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>′</mo></msup><annotation encoding="application/x-tex">p&#39;</annotation></semantics></math>および<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>q</mi><mo>′</mo></msup><annotation encoding="application/x-tex">q&#39;</annotation></semantics></math>と比較したい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>がある場合に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>よりも「優れている」と言いたいのだが、それではあまりにも弱い。それに加えて、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>の射影たちが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>の射影たちよりも「優れている」、すなわち「より普遍的」であってほしい。つまり、射影<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>′</mo></msup><annotation encoding="application/x-tex">p&#39;</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>q</mi><mo>′</mo></msup><annotation encoding="application/x-tex">q&#39;</annotation></semantics></math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>を使って再構成できるということだ。</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>p&#39; <span class="ot">=</span> p <span class="op">.</span> m</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>q&#39; <span class="ot">=</span> q <span class="op">.</span> m</span></code></pre></div>
<p> <img src="images/productranking.jpg" style="width:40.0%" /> </p>
<p>
別の観点でこれらの等式を見ると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>′</mo></msup><annotation encoding="application/x-tex">p&#39;</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>q</mi><mo>′</mo></msup><annotation encoding="application/x-tex">q&#39;</annotation></semantics></math>を<em>分解</em>
(factorize)
している。これらの等式が自然数について成り立ち、ドットが乗算であると仮定すると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>′</mo></msup><annotation encoding="application/x-tex">p&#39;</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>q</mi><mo>′</mo></msup><annotation encoding="application/x-tex">q&#39;</annotation></semantics></math>に共通な因数だ。</p>
<p>ある種の直観を築くために、ペア型<code>(Int, Bool)</code>およびそのカノニカルな<a
href="#fn33" class="footnote-ref" id="fnref33"
role="doc-noteref"><sup>33</sup></a>射影<code>fst</code>と<code>snd</code>が、前に提示した2つの候補より本当に<em>優れている</em>ことを示そう。</p>
<p> <img src="images/not-a-product.jpg" style="width:40.0%" /> </p>
<p> 1番目の候補に対する写像<code>m</code>は次のようになる。</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="ot">m ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>)</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>m x <span class="ot">=</span> (x, <span class="dt">True</span>)</span></code></pre></div>
<p>
実際、2つの射影<code>p</code>と<code>q</code>は次のように再構成できる。</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>p x <span class="ot">=</span> <span class="fu">fst</span> (m x) <span class="ot">=</span> x</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>q x <span class="ot">=</span> <span class="fu">snd</span> (m x) <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p> 2番目の例の<code>m</code>も同様に一意に定まる。</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>m (x, _, b) <span class="ot">=</span> (x, b)</span></code></pre></div>
<p>
<code>(Int, Bool)</code>が2つの候補のどちらよりも優れていることを示せた。その逆がなぜ真ではないのかを見てみよう。<code>p</code>と<code>q</code>から<code>fst</code>と<code>snd</code>を再構築するのに役立つ<code>m'</code>を見つけられるだろうか？</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fst</span> <span class="ot">=</span> p <span class="op">.</span> m&#39;</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="fu">snd</span> <span class="ot">=</span> q <span class="op">.</span> m&#39;</span></code></pre></div>
<p>
1番目の例では、<code>q</code>は常に<code>True</code>を返す。しかし、第2要素が<code>False</code>であるペアが存在するのは分かっている。したがって、<code>q</code>からは<code>snd</code>を再構築できない。</p>
<p>2番目の例は別物だ。<code>p</code>または<code>q</code>を経た後でも十分な情報が保持される。しかし、<code>fst</code>と<code>snd</code>を分解する方法が複数ある。<code>p</code>と<code>q</code>はどちらも3つ組の第2要素を無視するので、<code>m'</code>はそこに何でも入れられる。たとえば</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>m&#39; (x, b) <span class="ot">=</span> (x, x, b)</span></code></pre></div>
<p> あるいは</p>
<div class="sourceCode" id="cb88"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>m&#39; (x, b) <span class="ot">=</span> (x, <span class="dv">42</span>, b)</span></code></pre></div>
<p> などを定義できる。</p>
<p>以上すべてをまとめると、2つの射影<code>p</code>と<code>q</code>を持つ任意の型<code>c</code>について、それらの射影を分解する一意な<code>m</code>が<code>c</code>からデカルト積<code>(a, b)</code>へと存在する。実際には、<code>p</code>と<code>q</code>を組み合わせてペアにしているだけだ。</p>
<div class="sourceCode" id="cb89"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="ot">m ::</span> c <span class="ot">-&gt;</span> (a, b)</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>m x <span class="ot">=</span> (p x, q x)</span></code></pre></div>
<p>
これによってデカルト積<code>(a, b)</code>がベストマッチとなり、すなわち、この普遍的構成が集合の圏で機能することを意味する。この構成は任意の2つの集合の積を選ぶ。</p>
<p>さて、集合のことは忘れて、同じ普遍的構成を使って任意の圏にある2つの対象の積を定義しよう。そのような積が必ず存在するわけではないが、存在する場合は、一意な同型を除いて一意だ。</p>
<blockquote>
<p>2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の<strong>積</strong>とは、2つの射影を伴う対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>であり、別の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>が伴う2つの射影について、それらを分解する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>への一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>が存在するものを言う。</p>
</blockquote>
<p>2つの候補から分解関数<code>m</code>を生成する（高階）関数は、<span
id="factorizer"
class="keyword"><em>factorizer</em></span>と呼ばれることもある。この例では、次の関数になる。</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorizer ::</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> (a, b))</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>factorizer p q <span class="ot">=</span> \x <span class="ot">-&gt;</span> (p x, q x)</span></code></pre></div>
<aside id="footnotes-18" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="33">
<li id="fn33"><p>訳注：カノニカル (canonical)
とは、恣意性なしに標準的・規準的・当然に定まることを表す。<a
href="#fnref33" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="5.6" id="余積"><span
class="header-section-number">5.6</span> 余積</h2>
<p>圏論のすべての構成と同じく、積にも双対があり、余積 (coproduct)
と呼ばれる。積のパターンの射を反転させると、2つの<em>入射</em>
(injection) <code>i</code>と<code>j</code>を伴う対象<em>c</em>になる<a
href="#fn34" class="footnote-ref" id="fnref34"
role="doc-noteref"><sup>34</sup></a>。すなわち、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>への射だ。</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="ot">i ::</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="ot">j ::</span> b <span class="ot">-&gt;</span> c</span></code></pre></div>
<p> <img src="images/coproductpattern.jpg" style="width:40.0%" /> </p>
<p>
順位付けも逆転している。対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>は、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>が伴う入射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>i</mi><mo>′</mo></msup><annotation encoding="application/x-tex">i&#39;</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>j</mi><mo>′</mo></msup><annotation encoding="application/x-tex">j&#39;</annotation></semantics></math>を分解するような<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>が存在するなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>よりも「優れて」いる。</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>i&#39; <span class="ot">=</span> m <span class="op">.</span> i</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>j&#39; <span class="ot">=</span> m <span class="op">.</span> j</span></code></pre></div>
<p> <img src="images/coproductranking.jpg" style="width:40.0%" /> </p>
<p>
「最も優れた」対象は、そこから他のどのパターンへも一意な射を持つもので、余積と呼ばれ、存在する場合は、一意な同型を除いて一意だ。</p>
<blockquote>
<p>2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の<strong>余積</strong>とは、2つの入射を伴う対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>であり、別の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>が伴う2つの入射について、それらを分解する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>への一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>が存在するものを言う。</p>
</blockquote>
<p>集合の圏では、余積は2つの集合の<em>非交和</em> (disjoint union)
だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の非交和の要素は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の要素か<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の要素のどちらかだ。2つの集合が重なる場合、非交和には共通部分のコピーが2つ含まれる。非交和の要素は起源を示す識別子でタグ付けされていると見なせる。</p>
<p>プログラマーにとっては、型の観点から余積を理解する方が簡単だ。それは2つの型からなるタグ付き和
(tagged union) だ。C++がサポートしている共用体 (union)
はタグ付けされていない。つまり、プログラム内では共用体のどのメンバーが有効であるかを何らかの方法で追跡しなければならないということだ。タグ付き共用体を作成するには、タグ――列挙型――を定義して共用体と結びつける必要がある。たとえば、<code>int</code>と<code>char const*</code>のタグ付き共用体は次のように実装できる。</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Contact <span class="op">{</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="op">{</span> isPhone<span class="op">,</span> isEmail <span class="op">}</span> tag<span class="op">;</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">union</span> <span class="op">{</span> <span class="dt">int</span> phoneNum<span class="op">;</span> <span class="dt">char</span> <span class="at">const</span> <span class="op">*</span> emailAddr<span class="op">;</span> <span class="op">};</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>
これに対する2つの入射は、コンストラクターとしても、関数としても実装できる。たとえば、1番目の入射を関数<code>PhoneNum</code>として実装するとこうなる。</p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>Contact PhoneNum<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    Contact c<span class="op">;</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>    c<span class="op">.</span>tag <span class="op">=</span> isPhone<span class="op">;</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>    c<span class="op">.</span>phoneNum <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c<span class="op">;</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p> これは<code>Contact</code>に整数を注入 (inject) する。</p>
<p>タグ付き共用体は<span id="variant"
class="keyword"><em>variant</em></span>とも呼ばれ、boostライブラリーに非常に汎用的な<code>boost::variant</code>という実装がある<a
href="#fn35" class="footnote-ref" id="fnref35"
role="doc-noteref"><sup>35</sup></a>。</p>
<p>Haskellでは、データ構成子を縦棒で区切ることで、任意のデータ型をタグ付き和にまとめられる。<code>Contact</code>の例だと次のような宣言になる。</p>
<div class="sourceCode" id="cb95"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Contact</span> <span class="ot">=</span> <span class="dt">PhoneNum</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">EmailAddr</span> <span class="dt">String</span></span></code></pre></div>
<p>
ここで、<code>PhoneNum</code>と<code>EmailAddr</code>は、構成子（入射）としても、パターンマッチングのタグとしても機能する（これについては後で詳しく説明する）。たとえば、電話番号を使って連絡先を構成する方法はこうなる。</p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="ot">helpdesk ::</span> <span class="dt">Contact</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>helpdesk <span class="ot">=</span> <span class="dt">PhoneNum</span> <span class="dv">2222222</span></span></code></pre></div>
<p>
標準的な実装では、積がプリミティブなペアとしてHaskellに組み込まれているのに対し、余積は<code>Either</code>と呼ばれるデータ型であり、標準のPreludeで次のように定義されている。</p>
<div class="sourceCode" id="cb97"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Either</span> a b <span class="ot">=</span> <span class="dt">Left</span> a <span class="op">|</span> <span class="dt">Right</span> b</span></code></pre></div>
<p>
これは<code>a</code>と<code>b</code>の2つの型によってパラメーター化され、2つの構成子を持つ。すなわち、型<code>a</code>の値を取る<code>Left</code>と、型<code>b</code>の値を取る<code>Right</code>だ。</p>
<p>積についてfactorizerを定義したのと同様に、余積についても定義できる。余積の型の候補<code>c</code>と2つの入射の候補<code>i</code>と<code>j</code>について、<code>Either</code>に対するfactorizerは次の分解関数を生成する。</p>
<div class="sourceCode" id="cb98"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorizer ::</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> c</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>factorizer i j (<span class="dt">Left</span> a)  <span class="ot">=</span> i a</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>factorizer i j (<span class="dt">Right</span> b) <span class="ot">=</span> j b</span></code></pre></div>
<aside id="footnotes-19" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="34">
<li
id="fn34"><p>訳注：関数としての単射もinjectionだが、混乱を避けるために別の訳語をあてた。<a
href="#fnref34" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn35"><p>訳注：C++17以降では<code>std::variant</code>が利用できる。<a
href="https://cpprefjp.github.io/reference/variant/variant.html"
class="uri">https://cpprefjp.github.io/reference/variant/variant.html</a>を参照。<a
href="#fnref35" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="5.7" id="非対称性"><span
class="header-section-number">5.7</span> 非対称性</h2>
<p>これまでに2組の双対の定義を見てきた。終対象の定義は、始対象の定義から射の方向を反転させることで得られ、余積の定義は積の定義から得られる。しかし、集合の圏では、始対象と終対象は大きく異なり、余積と積は大きく異なる。後述するように、積は乗算のように振る舞い、終対象は1の役割を果たし、余積は和のように振る舞い、始対象は0の役割を果たす。特に、有限集合の場合、積のサイズは個々の集合のサイズの積であり、余積のサイズはサイズの合計だ。</p>
<p>これは集合の圏が射の反転に関して対称でないことを示している。</p>
<p>空集合については、どの集合に対しても一意な射（<code>absurd</code>関数）がある一方で、戻ってくる射はないことに注意してほしい<a
href="#fn36" class="footnote-ref" id="fnref36"
role="doc-noteref"><sup>36</sup></a>。
単元集合では、どの集合からも一意な射が来るうえに、（空集合を除く）すべての集合へ向かう外向きの射<em>も</em>ある。これまで見てきたように、終対象から発するこれらの射<a
href="#fn37" class="footnote-ref" id="fnref37"
role="doc-noteref"><sup>37</sup></a>は、他の集合の要素を選択するのに非常に重要な役割を果たしている（空集合には要素がないので、選択するものは何もない）。</p>
<p>単元集合と積の関係は、余積とは全く違う。unit型<code>()</code>で表される単元集合を、積パターンのもう1つの――非常に劣った――候補として使うことを考えてみてほしい。それを2つの射影<code>p</code>と<code>q</code>、すなわち単元集合から各構成要素の集合への関数として実装してみよう。それらは具体的な要素をそれぞれの集合から選択する。積は普遍的なので、ここでの候補の単元集合から積への（一意な）射<code>m</code>も存在する。この射は積の集合から要素を選択する。つまり、具体的なペアを選択する。さらに、次の2つの射影を分解する。</p>
<div class="sourceCode" id="cb99"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> <span class="fu">fst</span> <span class="op">.</span> m</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>q <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> m</span></code></pre></div>
<p>
単元集合の唯一の要素である値<code>()</code>に作用させると、これら2つの式は次のようになる。</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>p () <span class="ot">=</span> <span class="fu">fst</span> (m ())</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>q () <span class="ot">=</span> <span class="fu">snd</span> (m ())</span></code></pre></div>
<p>
<code>m ()</code>は<code>m</code>によって選択された積の要素なので、これらの式は、第1の集合から<code>p</code>によって選択された要素<code>p ()</code>が、<code>m</code>によって選択されたペアの第1要素であることを示す。同様に、<code>q ()</code>は第2要素に等しい。これは、積の要素は構成要素の集合からの要素のペアであるという理解と完全に一致している。</p>
<p>余積にはそのような単純な解釈はない。単元集合を余積での候補として要素を抽出しようと試みることもできるが、2つの射影がそこから出てくるのではなく、2つの入射がそこに入ることになる。それらはその起源について何も教えてくれないだろう（実際、入力パラメーターが無視されるのを見てきた）。また、余積から単元集合への一意な射についても同様だろう。集合の圏は、始対象の向きから見たときと終対象から見たときとでは全く違って見える。</p>
<p>これは集合の固有の特性ではなく、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>で射として使う関数の特性だ。関数は（一般に）非対称だ。説明しよう。</p>
<p>関数は、その域 (domain)
のすべての要素に対して定義する必要がある（プログラミングでは<span
id="total" class="keyword"><em>全</em></span>関数 (total function)
と呼ぶ）。しかし、余域 (codomain)
全体を網羅する必要はない。すでにその極端な例をいくつか見てきた。単元集合からの関数たち――余域内の1つの要素だけを選択する関数たちのことだ。（実際に、空集合からの関数は本当に極端だ。）
域のサイズが余域のサイズよりもずっと小さい場合、我々はよく、域を余域に埋め込むような関数を思い浮かべる。たとえば、単元集合からの関数は、その1つの要素を余域に埋め込むものだと考えられる。私はそれらを<span
id="embedding" class="keyword"><em>埋め込み</em></span> (embedding)
関数と呼んでいるが、数学者は反対のものに名前を付ける方を好む。つまり、余域をきっちり満たす関数を<span
id="surjective" class="keyword"><em>全射</em></span> (surjective)
または<span id="onto" class="keyword"><em>上への</em></span> (onto)
関数と呼ぶ。</p>
<p>非対称性のもう1つの原因は、関数が域の複数の要素を余域の1つの要素に写せることだ。そういった関数はそれらの要素を潰す
(collapse)
ことができる。極端な例としては、集合全体を単元集合に写す関数が挙げられる。これまでに、まさにそれを行う多相<code>unit</code>関数を見てきた。合成すると、より酷く潰すことにしかならない。潰す関数2つの合成は、個々の関数よりもさらに潰すことになる。数学者は潰さない関数を<span
id="injective" class="keyword"><em>単射</em></span> (injective)
または<span id="one-to-one" class="keyword"><em>1対1</em></span>
(one-to-one) という名前で呼ぶ。</p>
<p>当然、埋め込みも潰しもしない関数もある。それらは<span id="bijections"
class="keyword"><em>全単射</em></span> (bijection)
と呼ばれ、可逆なので真に対称だ。集合の圏では、同型は全単射と同じだ。</p>
<aside id="footnotes-20" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="36">
<li
id="fn36"><p>訳注：ただし、空集合自身から戻ってくる恒等射（これも<code>absurd</code>関数）は存在する。<a
href="#fnref36" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn37"><p>訳注：終対象の定義では終対象へ向かう射についてしか述べていないので、終対象から他の対象へ向かう射が存在するのは何の問題もない。<a
href="#fnref37" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="5.8" id="課題-4"><span
class="header-section-number">5.8</span> 課題</h2>
<ol type="1">
<li><p>終対象が一意な同型を除いて一意であることを示せ。</p></li>
<li><p>半順序集合において2つの対象の積は何か？　ヒント：積の普遍的構成を使う。</p></li>
<li><p>半順序集合において2つの対象の余積は何か？</p></li>
<li><p>Haskellの<code>Either</code>に相当するものを、（Haskell以外の）好きな言語で総称型として実装せよ。</p></li>
<li><p><code>Either</code>が、次の2つの入射を伴う<code>int</code>よりも「優れた」余積であることを示せ。</p>
<div class="sourceCode" id="cb101"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> n<span class="op">;</span> <span class="op">}</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> j<span class="op">(</span><span class="dt">bool</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> b<span class="op">?</span> <span class="dv">0</span><span class="op">:</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p> ヒント：関数</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> m<span class="op">(</span>Either <span class="at">const</span> <span class="op">&amp;</span> e<span class="op">);</span></span></code></pre></div>
<p>
を、<code>i</code>と<code>j</code>を分解するように定義する。</p></li>
<li><p>前の問題の続き。<code>i</code>と<code>j</code>という2つの入射を伴う<code>int</code>が<code>Either</code>よりも「優れている」ことはあり得ないと主張するにはどうすればよいか？</p></li>
<li><p>さらに続き。次の入射についてはどうか？</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> j<span class="op">(</span><span class="dt">bool</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> b<span class="op">?</span> <span class="dv">0</span><span class="op">:</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div></li>
<li><p><code>int</code>と<code>bool</code>の余積の候補として、<code>Either</code>への射を複数許容するという理由で<code>Either</code>より劣るものを挙げよ。</p></li>
</ol>
<h2 data-number="5.9" id="参考文献"><span
class="header-section-number">5.9</span> 参考文献</h2>
<ol type="1">
<li>Catstersの<a
href="https://www.youtube.com/watch?v=upCSDIO9pjc">Products and
Coproducts</a><a href="#fn38" class="footnote-ref" id="fnref38"
role="doc-noteref"><sup>38</sup></a>の動画</li>
</ol>
<aside id="footnotes-21" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="38">
<li id="fn38"><p><a href="https://www.youtube.com/watch?v=upCSDIO9pjc"
class="uri">https://www.youtube.com/watch?v=upCSDIO9pjc</a><a
href="#fnref38" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 data-number="6" id="simple-algebraic-data-types"><span
class="header-section-number">6</span> シンプルな代数的データ型</h1>
<p>型を組み合わせる2つの基本的な方法として、積と余積を使う方法を見たところだ。日常のプログラミングにおける多くのデータ構造は、実はこの2つのメカニズムだけを使って構築できる。この事実は重要かつ有用な帰結をもたらす。データ構造の性質の多くは合成可能だということだ。たとえば、基本型の値が等しいかどうか比較する方法を知っていて、それらの比較を積と余積に相当する型に一般化する方法を知っていれば、自動的に複合型の等値演算子を導出できる。Haskellでは、等しさの検査、大小比較、文字列への変換、文字列からの変換などを、複合型の大きな部分集合に対して自動的に導出できる。</p>
<p>次に、直積型 (product type)<a href="#fn39" class="footnote-ref"
id="fnref39" role="doc-noteref"><sup>39</sup></a> と直和型 (sum type)
がプログラミングに現れる様子を詳しく見てみよう。</p>
<h2 data-number="6.1" id="直積型"><span
class="header-section-number">6.1</span> 直積型</h2>
<p>2つの型の直積（直積型）のプログラム言語における標準的な実装はペアだ。Haskellではペアはプリミティブな型構成子
(type constructor)
だ。C++では比較的複雑なテンプレートとして標準ライブラリーで定義されている。</p>
<p> <img src="images/pair.jpg" style="width:35.0%" /> </p>
<p>
ペアは厳密には可換ではない。<code>(Int, Bool)</code>型のペアは、同じ情報を保持していても、ペア<code>(Bool, Int)</code>型のペアには置き換えられない。しかし、それらは同型を除いて可換だ。同型写像は<code>swap</code>関数（それ自身の逆関数）によって与えられる。</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="ot">swap ::</span> (a, b) <span class="ot">-&gt;</span> (b, a)</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>swap (x, y) <span class="ot">=</span> (y, x)</span></code></pre></div>
<p>
これら2つのペア型は、単に同じデータを格納するために異なるフォーマットを使っていると見なせる。ビッグエンディアンとリトルエンディアンのようなものだ。</p>
<p>ペアの中にペアをネストすれば任意の個数の型の直積を作れるが、もっと簡単な方法がある。ネストされたペアは組
(tuple)
と等価なのだ。これは、ペアをネストする様々な方法が同型であるという事実からの帰結だ。3つの型<code>a</code>、<code>b</code>、<code>c</code>を順に積にする場合、次の2つの方法がある。</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>((a, b), c)</span></code></pre></div>
<p> あるいは</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>(a, (b, c))</span></code></pre></div>
<p>
これらは型が異なる。つまり、一方の型の引数を期待する関数に他方の型の値を渡すことはできない。しかし、これらの要素は1対1で対応している。そのため、一方を他方に写す関数</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> ((a, b), c) <span class="ot">-&gt;</span> (a, (b, c))</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>alpha ((x, y), z) <span class="ot">=</span> (x, (y, z))</span></code></pre></div>
<p> が存在し、その関数は次のような逆関数を持つ。</p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha_inv ::</span> (a, (b, c)) <span class="ot">-&gt;</span> ((a, b), c)</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>alpha_inv  (x, (y, z)) <span class="ot">=</span> ((x, y), z)</span></code></pre></div>
<p>
したがって、この関数は同型写像だ。データは同じで再パッケージ化するための方法が違うにすぎない。</p>
<p>直積型の生成は、型上の二項演算として解釈できる。この観点から見ると、上記の同型は、モノイドで見た結合律
(associativity law) に非常によく似ている。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>*</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>*</mo><mi>c</mi><mo>=</mo><mi>a</mi><mo>*</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>*</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a * b) * c = a * (b * c)</annotation></semantics></math>
ただし、モノイドの場合は積を合成する2つの方法が等しかったのに対して、ここでは「同型を除いて」等価であるにすぎない。</p>
<p>同型を認めて、厳密な等しさに固執しないならば、さらに進んで、1が乗算の単位元であるのと同じようにunit型<code>()</code>が積の単位元であるのを示せる。実際、ある型<code>a</code>の値とunit型の値を組み合わせても何の情報も追加されない。次の型</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>(a, ())</span></code></pre></div>
<p> は<code>a</code>と同型だ。対応する同型写像はこのようになる。</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rho ::</span> (a, ()) <span class="ot">-&gt;</span> a</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>rho (x, ()) <span class="ot">=</span> x</span></code></pre></div>
<div class="sourceCode" id="cb111"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rho_inv ::</span> a <span class="ot">-&gt;</span> (a, ())</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>rho_inv x <span class="ot">=</span> (x, ())</span></code></pre></div>
<p>
これらの観察は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>（集合の圏）は<span
id="monoidal_category" class="keyword"><em>モノイダル圏</em></span>
(monoidal category)
である、と述べることによって形式化できる。それは、対象を（ここではデカルト積で）乗算できるという意味で、モノイドでもある圏だ。モノイダル圏についてさらに説明しよう。完全な定義は将来的に示す。</p>
<p>Haskellには直積型を定義するもっと一般的な方法がある。特に、すぐ後で説明するとおり、直和型と組み合わされたときにはっきりする。その方法は複数の引数を持つ名前付き構成子を使うというものだ。たとえば、ペアは次のようにも定義できる。</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Pair</span> a b <span class="ot">=</span> <span class="dt">P</span> a b</span></code></pre></div>
<p>
ここで、<code>Pair a b</code>は他の2つの型<code>a</code>と<code>b</code>によってパラメーター化された型の名前であり、<code>P</code>はデータ構成子の名前だ。ペア型を定義するには型構成子<code>Pair</code>に2つの型を渡す。適切な型の2つの値を構成子<code>P</code>に渡すことで、ペア値を構成する。たとえば、値<code>stmt</code>を<code>String</code>と<code>Bool</code>のペアとして定義したとする。</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stmt ::</span> <span class="dt">Pair</span> <span class="dt">String</span> <span class="dt">Bool</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>stmt <span class="ot">=</span> <span class="dt">P</span> <span class="st">&quot;This statements is&quot;</span> <span class="dt">False</span></span></code></pre></div>
<p> 1行目は型シグネチャーだ<a href="#fn40" class="footnote-ref"
id="fnref40"
role="doc-noteref"><sup>40</sup></a>。そこでは、型構成子<code>Pair</code>が、その<code>Pair</code>の総称定義の<code>a</code>と<code>b</code>をそれぞれ<code>String</code>と<code>Bool</code>で置き換えた形で使われている。2行目では、具体的な文字列と具体的なブール値をデータ構成子<code>P</code>に渡すことで、実際の値を定義している。型構成子は型を構成するために使われ、データ構成子は値を構成するために使われる。</p>
<p>Haskellでは型構成子とデータ構成子の名前空間が分離されているため、次のように両方に同じ名前が使われていることがよくある。</p>
<div class="sourceCode" id="cb114"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Pair</span> a b <span class="ot">=</span> <span class="dt">Pair</span> a b</span></code></pre></div>
<p>
さらに目を細めれば、組み込みのペア型をこの種の宣言のバリエーションとして見ることもできる。組み込みのペア型においては、<code>Pair</code>という名前が<code>(,)</code>という二項演算子で置き換わっている。実際、<code>(,)</code>を他の名前付き構成子と同じように扱い、前置記法を使ってペアを作成できる。</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>stmt <span class="ot">=</span> (,) <span class="st">&quot;This statement is&quot;</span> <span class="dt">False</span></span></code></pre></div>
<p> 同様に、<code>(,,)</code>を使って3つ組を作成する、などもできる。</p>
<p>総称ペアや組を使う代わりに、次のように特定の名前を付けた直積型を定義してもよい。</p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stmt</span> <span class="ot">=</span> <span class="dt">Stmt</span> <span class="dt">String</span> <span class="dt">Bool</span></span></code></pre></div>
<p>
これは単に<code>String</code>と<code>Bool</code>の積だが、独自の名前と構成子が与えられている。このスタイルの宣言の利点は、内容は同じでも意味と機能が異なる互いに置き換えられない型を多数定義できることだ。</p>
<p>組や複数の引数を持つ構成子を使ってプログラミングすると、ぐちゃぐちゃになり間違いが生じやすくなる。どの成分が何を表しているかを追うのが大変になるからだ。成分に名前を付ける方が望ましい場合はよくある。名前付きフィールドを持つ直積型は、Haskellでは<span
id="record" class="keyword"><em>record</em></span><a href="#fn41"
class="footnote-ref" id="fnref41"
role="doc-noteref"><sup>41</sup></a>、Cでは<code>struct</code>と呼ばれる。</p>
<aside id="footnotes-22" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="39">
<li id="fn39"><p>訳注：直積 (direct product) は、具体圏（concrete
category、集合に何らかの構造を追加したものの圏）においては積と同じ。プログラミングの文脈においては一般的にproductは直積と訳される。<a
href="#fnref39" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn40"><p>訳注：原文はtype declarationとあるが、type
signatureの誤りであろう。<a href="#fnref40" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn41"><p>訳注：厳密に言えばHaskellに存在するレコード記法（構成子の引数に名前を付ける機能）であり、型そのものは通常のデータ型と相違ない。<a
href="#fnref41" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="6.2" id="レコード"><span
class="header-section-number">6.2</span> レコード</h2>
<p>簡単な例を見てみよう。化学元素を記述するために、2つの文字列（名前と元素記号）と整数（原子番号）を組み合わせて1つのデータ構造にしたい。組<code>(String, String, Int)</code>を使い、どの成分が何を表しているかを覚えておくという方法がある。そして、成分はパターンマッチングによって、以下の関数のように抽出することにしよう。この関数は元素記号が元素名の接頭辞かを（<strong>He</strong>は<strong>Helium</strong>の接頭辞だというように）チェックする。</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="ot">startsWithSymbol ::</span> (<span class="dt">String</span>, <span class="dt">String</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>startsWithSymbol (name, symbol, _) <span class="ot">=</span> isPrefixOf symbol name</span></code></pre></div>
<p>
このコードは間違いが生じやすく、読むのもメンテナンスするのも困難だ。レコードを定義する方がはるかに良い。</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Element</span> <span class="ot">=</span> <span class="dt">Element</span> {<span class="ot"> name         ::</span> <span class="dt">String</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>                       ,<span class="ot"> symbol       ::</span> <span class="dt">String</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>                       ,<span class="ot"> atomicNumber ::</span> <span class="dt">Int</span> }</span></code></pre></div>
<p>
これら2つの表現は同型だ。そのことは、互いに逆になっている2つの変換関数から分かる。</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tupleToElem ::</span> (<span class="dt">String</span>, <span class="dt">String</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Element</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>tupleToElem (n, s, a) <span class="ot">=</span> <span class="dt">Element</span> { name <span class="ot">=</span> n</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>                                , symbol <span class="ot">=</span> s</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>                                , atomicNumber <span class="ot">=</span> a }</span></code></pre></div>
<div class="sourceCode" id="cb120"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="ot">elemToTuple ::</span> <span class="dt">Element</span> <span class="ot">-&gt;</span> (<span class="dt">String</span>, <span class="dt">String</span>, <span class="dt">Int</span>)</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>elemToTuple e <span class="ot">=</span> (name e, symbol e, atomicNumber e)</span></code></pre></div>
<p>
レコードのフィールド名は、それらのフィールドにアクセスするための関数としても機能することに注意してほしい。たとえば、<code>atomicNumber</code>は<code>e</code>から<code>atomicNumber</code>フィールドを取得する。つまり、<code>atomicNumber</code>は次のような型の関数として使われる。</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="ot">atomicNumber ::</span> <span class="dt">Element</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>
<code>Element</code>についてのレコード構文によって、関数<code>startsWithSymbol</code>はより読みやすくなる。</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="ot">startsWithSymbol ::</span> <span class="dt">Element</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>startsWithSymbol e <span class="ot">=</span> isPrefixOf (symbol e) (name e)</span></code></pre></div>
<p>
関数<code>isPrefixOf</code>をバッククォーテーションで囲んで中置演算子に変換するというHaskellの小技を使えば、まるで英文のように読めるようにさえできる。</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>startsWithSymbol e <span class="ot">=</span> symbol e <span class="ot">`isPrefixOf`</span> name e</span></code></pre></div>
<p>
中置演算子は関数呼び出しよりも優先順位が低いため、この場合は括弧を省略できる。</p>
<h2 data-number="6.3" id="直和型"><span
class="header-section-number">6.3</span> 直和型</h2>
<p>集合の圏の積が直積型のもととなるのと同じように、余積は直和型のもととなる。Haskellにおける直和型の標準的な実装は次のようなものだ。</p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Either</span> a b <span class="ot">=</span> <span class="dt">Left</span> a <span class="op">|</span> <span class="dt">Right</span> b</span></code></pre></div>
<p>
また、ペアと同様に、<code>Either</code>は（同型を除いて）可換であり、ネストでき、ネストの順序は（同型を除いて）無関係だ。したがって、たとえば、3つ組に相当する和</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">OneOfThree</span> a b c <span class="ot">=</span> <span class="dt">Sinistral</span> a <span class="op">|</span> <span class="dt">Medial</span> b <span class="op">|</span> <span class="dt">Dextral</span> c</span></code></pre></div>
<p> などを定義できる。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>は余積に関する（対称）モノイダル圏でもあることが分かる。二項演算の役割を演じるのは非交和であり、単位元の役割を演じるのは始対象だ。型に関しては、モノイダル演算子として<code>Either</code>があり、その中立元として住人<a
href="#fn42" class="footnote-ref" id="fnref42"
role="doc-noteref"><sup>42</sup></a>がいない型 (uninhabited type)
である<code>Void</code>がある。
<code>Either</code>は加算、<code>Void</code>は0と見なせる。実際、直和型に<code>Void</code>を足しても内容は変わらない。例として</p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Either</span> a <span class="dt">Void</span></span></code></pre></div>
<p>
は<code>a</code>と同型だ。これは、この型の<code>Right</code>版を構成する方法がないためだ。型<code>Void</code>に値は存在しない。
<code>Either a Void</code>の唯一の要素は、<code>Left</code>構成子を使って構築されたものであり、単純に型<code>a</code>の値をカプセル化したものだ。したがって、記号的に表すと、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mn>0</mn><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a + 0 = a</annotation></semantics></math>となる。</p>
<p>直和型がHaskellではごく普通に使われるのに対し、C++で同等のものである共用体やvariantはあまり使われない。その理由はいくつかある。</p>
<p>まず、最も単純な直和型は単なる列挙であり、C++では<code>enum</code>を使って実装できる。Haskellの直和型</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Color</span> <span class="ot">=</span> <span class="dt">Red</span> <span class="op">|</span> <span class="dt">Green</span> <span class="op">|</span> <span class="dt">Blue</span></span></code></pre></div>
<p> にC++で相当するものは</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="op">{</span> Red<span class="op">,</span> Green<span class="op">,</span> Blue <span class="op">};</span></span></code></pre></div>
<p> だ。もっとシンプルな直和型</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bool</span> <span class="ot">=</span> <span class="dt">True</span> <span class="op">|</span> <span class="dt">False</span></span></code></pre></div>
<p> は、C++ではプリミティブ<code>bool</code>だ。</p>
<p>値の有無を表す単純な直和型は、C++では、特殊なトリックや「不可能な」値（空文字列・負の数・ヌルポインターなど）を使ってさまざまに実装される。この種のオプション性は、意図的な場合、Haskellでは<code>Maybe</code>型を使って表現される。</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre></div>
<p>
<code>Maybe</code>型は2つの型の直和だ。このことは構成子の2つの部分を個々の型に分けると分かる。1つ目は次のようになる。</p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NothingType</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>
これは<code>Nothing</code>という名前の1つの値を持つ列挙だ。言い換えると、これは単元集合であり、unit型<code>()</code>と等価だ。2つ目の部分</p>
<div class="sourceCode" id="cb132"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">JustType</span> a <span class="ot">=</span> <span class="dt">Just</span> a</span></code></pre></div>
<p>
は、型<code>a</code>を単にカプセル化したものだ。<code>Maybe</code>を次のように書いてもよかっただろう。</p>
<div class="sourceCode" id="cb133"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Either</span> () a</span></code></pre></div>
<p>
より複雑な直和型は、C++ではポインターを使って模擬することが多い。ポインターはヌルとなるか、あるいは特定の型の値を指し示す。たとえば、Haskellで（再帰的な）直和型として定義できるリスト型</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span></code></pre></div>
<p>
をC++に変換するには、ヌルポインターのトリックを使って空のリストを実装する。</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">&gt;</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> List <span class="op">{</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">*</span> _head<span class="op">;</span></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>    List<span class="op">()</span> <span class="op">:</span> _head<span class="op">(</span><span class="kw">nullptr</span><span class="op">)</span> <span class="op">{}</span>  <span class="co">// Nil</span></span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a>    List<span class="op">(</span>A a<span class="op">,</span> List<span class="op">&lt;</span>A<span class="op">&gt;</span> l<span class="op">)</span>        <span class="co">// Cons</span></span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a>      <span class="op">:</span> _head<span class="op">(</span><span class="kw">new</span> Node<span class="op">&lt;</span>A<span class="op">&gt;(</span>a<span class="op">,</span> l<span class="op">))</span></span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{}</span></span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>
Haskellでの2つの構成子<code>Nil</code>と<code>Cons</code>が、よく似た引数（<code>Nil</code>は空、<code>Cons</code>は値1つとリスト1つ）でオーバーロードされた2つの<code>List</code>構成子へと変換されたことに注目してほしい。この<code>List</code>クラスには、直和型の2つの成分を区別するためのタグは必要ない。その代わり、<code>_head</code>に特別な<code>nullptr</code>値を使って<code>Nil</code>を表現する。</p>
<p>だが、HaskellとC++の型の主な違いは、Haskellではデータ構造が不変であることだ。ある特定の構成子を使ってオブジェクトを作成する場合、オブジェクトはどの構成子が使われ、どの引数が渡されたかを永久に記憶する。したがって、<code>Just "energy"</code>として作成された<code>Maybe</code>オブジェクトが<code>Nothing</code>に変わることはない。同様に、空のリストは永久に空であり、3つの要素のリストは常に同じ3つの要素を持つことになる。</p>
<p>この不変性こそが構成を可逆的にする。オブジェクトがあれば、いつでも構成で使われた部品に分解できる。この分解はパターンマッチングで行われ、構成子をパターンとして再利用する。構成子の引数がある場合は、変数（またはその他のパターン）に置き換えられる。</p>
<p><code>List</code>データ型には2つの構成子があるため、どんな<code>List</code>を分解するときもそれらの構成子に対応する2つのパターンを使う。1つは空である<code>Nil</code>リストにマッチし、もう1つは<code>Cons</code>で構成されたリストにマッチする。たとえば、複数の<code>List</code>に対する単純な関数の定義は次のとおりだ。</p>
<div class="sourceCode" id="cb136"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="ot">maybeTail ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">List</span> a)</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>maybeTail <span class="dt">Nil</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>maybeTail (<span class="dt">Cons</span> _ t) <span class="ot">=</span> <span class="dt">Just</span> t</span></code></pre></div>
<p>
<code>maybeTail</code>の定義の1番目の部分は、<code>Nil</code>構成子をパターンとして使い、<code>Nothing</code>を返す。2番目の部分では、<code>Cons</code>構成子をパターンとして使っている。構成子の1番目の引数には興味がないため、ワイルドカードに置き換わっている。<code>Cons</code>の2番目の引数は、変数<code>t</code>に束縛される（厳密に言えば一度式に束縛されたら決して変化しないものの、変数と呼ぶことにする）。戻り値は<code>Just t</code>だ。こうして、<code>List</code>の作成方法に応じて、節の1つに一致するようになった<a
href="#fn43" class="footnote-ref" id="fnref43"
role="doc-noteref"><sup>43</sup></a>。作成に<code>Cons</code>が使われるときは、作成時に渡した2つの引数が取得される（1番目の引数は破棄される）。</p>
<p>さらに複雑な直和型は、C++では多相クラス階層を使って実装されている。共通の祖先を持つクラスたちは、1つのバリアント型として理解でき、その中では仮想関数テーブルが隠しタグとして機能する。Haskellでは構成子に対するパターンマッチングおよびパターンごとに特化したコードで行っていることを、C++では仮想関数テーブルのポインターに基づいて仮想関数呼び出しをディスパッチすることで実現している。</p>
<p>C++で共用体が直和型として使われることはめったにない。含められるものに厳しい制限があるからだ。<code>std::string</code>でさえ、コピーコンストラクターを持っているので、共用体に入れられない。</p>
<aside id="footnotes-23" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="42">
<li id="fn42"><p>訳注：大雑把には、その型を持つ式のこと。<a
href="#fnref42" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn43"><p>訳注：ここでの節 (clause)
とは定義の一部で大雑把には<code>…… = ……</code>の形のもののこと。<a
href="#fnref43" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="6.4" id="型の代数"><span
class="header-section-number">6.4</span> 型の代数</h2>
<p>直積型と直和型を別々に用いても有用なデータ構造をいろいろ定義できるが、真の強みはこの2つを組み合わせることで得られる。合成の力が再び発揮される時がきた。</p>
<p>これまでに分かったことをまとめておこう。型システムの下にある2つの可換モノイド構造を見た。中立元として<code>Void</code>を持つ直和型と、中立元として<code>()</code>というunit型を持つ直積型だ。それらを加法や乗法から類推したい。この類推では、<code>Void</code>は0に対応し、<code>()</code>は1に対応する。</p>
<p>この類推をどこまで拡張できるか見てみよう。例として、0を掛けると0になるだろうか？　言い換えれば、1つの成分が<code>Void</code>である直積型は、<code>Void</code>と同型だろうか？　たとえば、<code>Int</code>と<code>Void</code>のペアを作成できるだろうか？</p>
<p>ペアを作成するには2つの値が必要だ。整数なら簡単だが、型<code>Void</code>には値がない。したがって、型<code>(a, Void)</code>は、すべての型<code>a</code>について住人がいない――値を持たない――ので<code>Void</code>と等価になる。言い換えれば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mn>0</mn><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a \times 0 = 0</annotation></semantics></math>ということだ。</p>
<p>また別の、加算と乗算をつなぐものとして、分配則 (distributive
property) がある。</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">*</span> (b <span class="op">+</span> c) <span class="ot">=</span> a <span class="op">*</span> b <span class="op">+</span> a <span class="op">*</span> c</span></code></pre></div>
<p>
これは直積型と直和型にも当てはまるだろうか？　そう、当てはまる――いつものように同型を除いて。左辺は次の型に相当する。</p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a>(a, <span class="dt">Either</span> b c)</span></code></pre></div>
<p> また、右辺は次の型に相当する。</p>
<div class="sourceCode" id="cb139"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Either</span> (a, b) (a, c)</span></code></pre></div>
<p> これらをある向きで変換する関数は次のとおりだ。</p>
<div class="sourceCode" id="cb140"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prodToSum ::</span> (a, <span class="dt">Either</span> b c) <span class="ot">-&gt;</span> <span class="dt">Either</span> (a, b) (a, c)</span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>prodToSum (x, e) <span class="ot">=</span></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Left</span>  y <span class="ot">-&gt;</span> <span class="dt">Left</span>  (x, y)</span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Right</span> z <span class="ot">-&gt;</span> <span class="dt">Right</span> (x, z)</span></code></pre></div>
<p> また、その逆向きの変換は次のとおりだ。</p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sumToProd ::</span> <span class="dt">Either</span> (a, b) (a, c) <span class="ot">-&gt;</span> (a, <span class="dt">Either</span> b c)</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>sumToProd e <span class="ot">=</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Left</span>  (x, y) <span class="ot">-&gt;</span> (x, <span class="dt">Left</span>  y)</span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Right</span> (x, z) <span class="ot">-&gt;</span> (x, <span class="dt">Right</span> z)</span></code></pre></div>
<p>
<code>case of</code>式は、関数の内部でパターンマッチングを行うために使われる。各パターンの後には矢印と、パターンが一致したときに評価される式が続く。たとえば、次の値を引数として<code>prodToSum</code>を呼び出すとする。</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prod1 ::</span> (<span class="dt">Int</span>, <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Float</span>)</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>prod1 <span class="ot">=</span> (<span class="dv">2</span>, <span class="dt">Left</span> <span class="st">&quot;Hi!&quot;</span>)</span></code></pre></div>
<p>
<code>case e of</code>内の<code>e</code>は<code>Left "Hi!"</code>と等しくなる。これはパターン<code>Left y</code>とマッチし、<code>y</code>に<code>"Hi!"</code>を代入する。<code>x</code>はすでに<code>2</code>とマッチしているので、<code>case of</code>式の結果と関数全体は、期待どおり<code>Left (2, "Hi!")</code>となる。</p>
<p>この2つの関数が互いの逆関数であることの証明は省くが、よく考えれば分かるだろう。これらは2つのデータ構造の内容を単に再パックしている。データは同じで、フォーマットが異なるだけだ。</p>
<p>数学者たちは、このような絡み合った2つのモノイドに<span id="semiring"
class="keyword"><em>半環</em></span> (semiring)
という名前をつけている。これは完全な<span id="ring"
class="keyword"><em>環</em></span> (ring)
ではない。型の減算は定義できないからだ。そのため、半環は「<em>n</em>
(negative) がない環 (ring)」をかけて<span id="rig"
class="keyword"><em>リグ</em></span> (rig)
と呼ばれることがある。しかし、そのことを除けば、リグをなす自然数などに関する命題を型に関する命題に変換することによる多くのメリットが得られる。興味深い項目を含む変換表を以下に示す。</p>
<table>
<thead>
<tr>
<th style="text-align: left;">数値</th>
<th style="text-align: left;">型</th>
</tr>
</thead>
<tbody>
<tr>
<td
style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math></td>
<td style="text-align: left;"><code>Void</code></td>
</tr>
<tr>
<td
style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math></td>
<td style="text-align: left;"><code>()</code></td>
</tr>
<tr>
<td
style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a + b</annotation></semantics></math></td>
<td
style="text-align: left;"><code>data Either a b = Left a | Right b</code></td>
</tr>
<tr>
<td
style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \times b</annotation></semantics></math></td>
<td
style="text-align: left;"><code>(a, b)</code>または<code>data Pair a b = Pair a b</code></td>
</tr>
<tr>
<td
style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>=</mo><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 = 1 + 1</annotation></semantics></math></td>
<td style="text-align: left;"><code>data Bool = True | False</code></td>
</tr>
<tr>
<td
style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">1 + a</annotation></semantics></math></td>
<td
style="text-align: left;"><code>data Maybe a = Nothing | Just a</code></td>
</tr>
</tbody>
</table>
<p>リスト型は、非常に興味深いことに、方程式の解として定義される。定義しようとしている型は等式の両辺に現れる。</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span></code></pre></div>
<p>
いつもの置換を行い、さらに<code>List a</code>を<code>x</code>に置き換えると、次の式が得られる。</p>
<div class="sourceCode" id="cb144"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a <span class="op">*</span> x</span></code></pre></div>
<p>
型の減算や除算はできないので、これは従来の代数的方法では解けない。しかし、置換の連続なら試せる。つまり、ひたすら右辺の<code>x</code>を<code>(1 + a*x)</code>に置き換えては分配則を使う。これによって次の列が得られる。</p>
<div class="sourceCode" id="cb145"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a<span class="op">*</span>x</span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a<span class="op">*</span>(<span class="dv">1</span> <span class="op">+</span> a<span class="op">*</span>x) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a <span class="op">+</span> a<span class="op">*</span>a<span class="op">*</span>x</span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a <span class="op">+</span> a<span class="op">*</span>a<span class="op">*</span>(<span class="dv">1</span> <span class="op">+</span> a<span class="op">*</span>x) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a <span class="op">+</span> a<span class="op">*</span>a <span class="op">+</span> a<span class="op">*</span>a<span class="op">*</span>a<span class="op">*</span>x</span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a <span class="op">+</span> a<span class="op">*</span>a <span class="op">+</span> a<span class="op">*</span>a<span class="op">*</span>a <span class="op">+</span> a<span class="op">*</span>a<span class="op">*</span>a<span class="op">*</span>a<span class="op">...</span></span></code></pre></div>
<p>
最終的には積（組）の和が無限に続くことになった。これは次のように解釈できる。リストは空集合<code>1</code>か、単元集合<code>a</code>か、ペア<code>a*a</code>か、3つ組<code>a*a*a</code>か、などなど……。まさにそれがリストだ。つまり、<code>a</code>の列だ！</p>
<p>リストについては語るべきことがまだまだある。関手や不動点について学んだ後で、リストやその他の再帰的なデータ構造について再び説明する。</p>
<p>記号変数を使って方程式を解く――これぞ代数だ！　それゆえ、これらの型は代数的データ型と呼ばれる。</p>
<p>最後に、型の代数の非常に重要な解釈について述べなければならない。<code>a</code>と<code>b</code>の2つの型の直積には、型<code>a</code><em>および</em>型<code>b</code>の両方の値が含まれている必要があることに注意してほしい。これは、［訳注：2つの型の直積が居住されているためには］両方の型が居住されている
(inhabited) 必要があることを意味する<a href="#fn44" class="footnote-ref"
id="fnref44"
role="doc-noteref"><sup>44</sup></a>。一方、2つの型の直和には、型<code>a</code>
<em>または</em>型<code>b</code>のいずれかの値が含まれるので、［訳注：2つの型の直和が居住されているためには］どちらかが居住されていれば十分だ。<em>論理積</em>
(logical and) と<em>論理和</em> (logical or)
も半環をなし、型理論の言葉に写せる。</p>
<table>
<thead>
<tr>
<th style="text-align: left;">論理</th>
<th style="text-align: left;">型</th>
</tr>
</thead>
<tbody>
<tr>
<td
style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">false</annotation></semantics></math></td>
<td style="text-align: left;"><code>Void</code></td>
</tr>
<tr>
<td
style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">true</annotation></semantics></math></td>
<td style="text-align: left;"><code>()</code></td>
</tr>
<tr>
<td
style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mspace width="0.167em"></mspace><mo stretchy="false" form="prefix">|</mo><mo stretchy="false" form="prefix">|</mo><mspace width="0.167em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">a\,||\,b</annotation></semantics></math></td>
<td
style="text-align: left;"><code>data Either a b = Left a | Right b</code></td>
</tr>
<tr>
<td
style="text-align: left;"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mspace width="0.167em"></mspace><mi>&amp;</mi><mi>&amp;</mi><mspace width="0.167em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">a\,\&amp;\&amp;\,b</annotation></semantics></math></td>
<td style="text-align: left;"><code>(a, b)</code></td>
</tr>
</tbody>
</table>
<p>この類推はさらに深く、論理と型理論を結ぶカリー・ハワード同型の基礎となっている。それについては関数型について説明するときに再び取り上げる。</p>
<aside id="footnotes-24" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="44">
<li
id="fn44"><p>訳注：居住とは、ここでは（非停止性を含む副作用のない世界を考えているので）値を持つことを意味する。<a
href="#fnref44" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="6.5" id="課題-5"><span
class="header-section-number">6.5</span> 課題</h2>
<ol type="1">
<li><p><code>Maybe a</code>と<code>Either () a</code>の間の同型を示せ。</p></li>
<li><p>円と長方形の直和型をHaskellで定義する。</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Shape</span> <span class="ot">=</span> <span class="dt">Circle</span> <span class="dt">Float</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">Rect</span> <span class="dt">Float</span> <span class="dt">Float</span></span></code></pre></div>
<p>
面積を求めるための関数<code>area</code>のような<code>Shape</code>に作用する関数を定義したい場合は、これら2つの構成子に関するパターンマッチングにより行う。</p>
<div class="sourceCode" id="cb147"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="ot">area ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>area (<span class="dt">Circle</span> r) <span class="ot">=</span> <span class="fu">pi</span> <span class="op">*</span> r <span class="op">*</span> r</span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>area (<span class="dt">Rect</span> d h) <span class="ot">=</span> d <span class="op">*</span> h</span></code></pre></div>
<p>
C++またはJavaで<code>Shape</code>をインタフェースとして実装し、<code>Circle</code>と<code>Rect</code>という2つのクラスを作成せよ。<code>area</code>は仮想関数として実装せよ。</p></li>
<li><p>先ほどの例を続ける。<code>Shape</code>の周の長さを求める新しい関数<code>circ</code>は簡単に追加できる。<code>Shape</code>の定義に触れる必要はない。</p>
<div class="sourceCode" id="cb148"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="ot">circ ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a>circ (<span class="dt">Circle</span> r) <span class="ot">=</span> <span class="fl">2.0</span> <span class="op">*</span> <span class="fu">pi</span> <span class="op">*</span> r</span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>circ (<span class="dt">Rect</span> d h) <span class="ot">=</span> <span class="fl">2.0</span> <span class="op">*</span> (d <span class="op">+</span> h)</span></code></pre></div>
<p>
C++またはJavaの実装に<code>circ</code>を追加せよ。もとのコードのどの部分に触れる必要があったか？</p></li>
<li><p>さらに続ける。新しい図形として正方形<code>Square</code>を<code>Shape</code>に追加し、必要なすべてを更新する。HaskellならびにC++およびJavaでは、コードのどこに触れる必要があったか<a
href="#fn45" class="footnote-ref" id="fnref45"
role="doc-noteref"><sup>45</sup></a>？（Haskellプログラマーでないとしても、変更箇所はごく自明なはずだ。）</p></li>
<li><p>型について<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>+</mo><mi>a</mi><mo>=</mo><mn>2</mn><mo>×</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a + a = 2 \times a</annotation></semantics></math>が（同型を除いて）成り立つことを示せ。前掲の変換表によれば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>は<code>Bool</code>に対応する。</p></li>
</ol>
<aside id="footnotes-25" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="45">
<li id="fn45"><p>監訳注：興味のある読者はさらに “expression problem”
について調べてみるとよい。<a href="#fnref45" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 data-number="7" id="functors"><span
class="header-section-number">7</span> 関手</h1>
<p>壊れたレコードのように聞こえるかもしれないが、関手についてこう述べておきたい。関手は非常に単純だが強力な概念だ。圏論はこのような単純だが強力な概念であふれている。関手は圏の間の写像だ。2つの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>について、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の対象を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の対象に写す。これは対象についての関数だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象である場合に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>内の像を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>と（括弧なしで）書くことにする。しかし、圏は単に対象の集まりではない――対象とそれらを接続する射からなる。関手は射も写す――射についての関数だ。ただし、射を行きあたりばったりに写すわけではない――接続を維持して写す。
つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>が対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>に接続する場合、
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to b</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>の像<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">F f</annotation></semantics></math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の像を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の像に接続する。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>f</mi><mo>∷</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>F</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">F f \Colon F a \to F b</annotation></semantics></math>
（これは数学的記法とHaskellの記法を組み合わせたものであり、ここでは理にかなっているだろう。対象や射に関数を適用するときは括弧を使わないことにする。）</p>
<p> <img src="images/functor.jpg" style="width:30.0%" /> </p>
<p>
ご覧のとおり、関手は圏の構造を保存している。一方の圏で接続されているものは、もう一方の圏でも接続されている。しかし、圏の構造にはそれ以上の何かがある。それは射の合成だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>の合成
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">h = g \circ f</annotation></semantics></math>
である場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>による<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>の像が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>の像の合成になるようにしたい。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>h</mi><mo>=</mo><mi>F</mi><mi>g</mi><mo>∘</mo><mi>F</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">F h = F g \circ F f</annotation></semantics></math></p>
<p> <img src="images/functorcompos.jpg" style="width:30.0%" /> </p>
<p>
最後に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内のすべての恒等射が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>内の恒等射に写されるようにしたい。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub><mo>=</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mrow><mi>F</mi><mi>a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">F %
\mathbf{id}_{a}%
 = %
\mathbf{id}_{F a}%
</annotation></semantics></math>
ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub><annotation encoding="application/x-tex">%
\mathbf{id}_{a}%
</annotation></semantics></math>は対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>における恒等射を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mrow><mi>F</mi><mi>a</mi></mrow></msub><annotation encoding="application/x-tex">%
\mathbf{id}_{F a}%
</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>における恒等射を表す。</p>
<p> <img src="images/functorid.jpg" style="width:30.0%" /> </p>
<p>
これらの条件によって、関手は通常の関数よりもはるかに制約が厳しくなることに注意してほしい。関手は圏の構造を保存しなければならない。圏を射のネットワークによって織りなされた対象の集まりと見なすなら、関手がこの織物に裂け目を入れることは許されない。対象を潰してまとめたり、複数の射を1つにくっつけたりすることはあるが、何かを引き裂くことは決してない。この引き裂きなしという制約は、微積分学において知られる連続性条件に似ている。この意味では、関手は「連続的」である（もっとも、関手にはさらに制約が厳しい連続性の概念が存在する）。関数と同じように、関手にも潰すものと埋め込むものがある。埋め込みの傾向がより顕著なのは、もとの圏が行き先の圏よりずっと小さいときだ。極端な場合、域は自明な単元圏
(singleton category)
であり得る。すなわち、ただ1つの対象とただ1つの射（恒等射）を持つ圏だ。単元圏から他の圏への関手は、単にその圏内の対象を選択するだけだ。これは、単元集合からの射は余域内の要素を選択する、という特性と完全に類似している。最も潰す関手は定関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>と呼ばれる。それはもとの圏内のすべての対象を、行き先の圏内で選択された1つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>に写す。また、もとの圏のすべての射を恒等射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>c</mi></msub><annotation encoding="application/x-tex">%
\mathbf{id}_{c}%
</annotation></semantics></math>に写す。まるでブラックホールのように働き、すべてを1つの特異点に圧縮する。この関手については極限と余極限について議論するときに詳しく見よう。</p>
<h2 data-number="7.1" id="プログラミングにおける関手"><span
class="header-section-number">7.1</span> プログラミングにおける関手</h2>
<p>地に足をつけてプログラミングについて話をしよう。我々には型と関数の圏がある。この圏をそれ自体に写す関手について話そう。そのような関手は自己関手
(endofunctor)
と呼ばれる。型の圏での自己関手とは何だろうか？　まず、それは型を型に写す。そのような写像の例はすでに見たが、おそらくそれとは気付かなかったのだろう。別の型によってパラメーター化されているような型の定義のことだ。いくつか例を見てみよう。</p>
<h3 data-number="7.1.1" id="maybe関手"><span
class="header-section-number">7.1.1</span> Maybe関手</h3>
<p><code>Maybe</code>の定義は型<code>a</code>から型<code>Maybe a</code>への写像だ。</p>
<div class="sourceCode" id="cb149"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre></div>
<p>
ここで重要な注意点がある。<code>Maybe</code>自体は型ではなく、<em>型構成子</em>だ。型に変換するには、<code>Int</code>や<code>Bool</code>のような型引数を与える必要がある。引数のない<code>Maybe</code>は、型上の関数を表す。だが、<code>Maybe</code>は関手に変えられるだろうか？
（これ以降、私がプログラミングの文脈で関手と言うとき、ほとんどの場合は自己関手を意味する。）
関手は、対象（ここでは型）を写すだけでなく、射（ここでは関数）も写す。<code>a</code>から<code>b</code>への任意の関数</p>
<div class="sourceCode" id="cb150"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> a <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>
について<code>Maybe a</code>から<code>Maybe b</code>への関数を生成したい。そのような関数を定義するには、<code>Maybe</code>の2つの構成子それぞれに対応する2つの場合を考慮する必要がある。<code>Nothing</code>の場合は単純で、<code>Nothing</code>を返すだけでよい。そして引数が<code>Just</code>の場合は、関数<code>f</code>をその中身に適用すればよい。したがって、<code>Maybe</code>の下での<code>f</code>の像は次の関数だ。</p>
<div class="sourceCode" id="cb151"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f&#39; ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>f&#39; <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>f&#39; (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div>
<p>
（ところで、Haskellでは変数名でアポストロフィーを使えるため、いまのような場合にとても便利だ。）
Haskellでは、関手における射の写像の部分は<code>fmap</code>と呼ばれる高階関数として実装されている。<code>Maybe</code>の場合、そのシグネチャーは次のとおりだ。</p>
<div class="sourceCode" id="cb152"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b)</span></code></pre></div>
<p> <img src="images/functormaybe.jpg" style="width:35.0%" /> </p>
<p> <code>fmap</code>は関数を<em>持ち上げる</em> (lift)
という言い方がよく使われる。持ち上げられた関数は<code>Maybe</code>値に対して作用する。いつものように、カリー化のため、このシグネチャーには次の2通りの解釈がある。ひとつは、<code>fmap</code>は1引数関数であり、それ自体が関数である<code>(a -&gt; b)</code>型の引数を取って、<code>(Maybe a -&gt; Maybe b)</code>型の関数を返すという解釈だ。もうひとつは、2つの引数を取り、<code>Maybe b</code>を返すという解釈だ。</p>
<div class="sourceCode" id="cb153"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span></code></pre></div>
<p>
これまでの議論に基づいて、<code>Maybe</code>に対して<code>fmap</code>を実装する方法は次のとおりだ。</p>
<div class="sourceCode" id="cb154"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> _ <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div>
<p>
型構成子<code>Maybe</code>に関数<code>fmap</code>を合わせたものが関手をなすことを示すには、<code>fmap</code>が恒等射と合成を保存することを証明する必要がある。これらは「関手則」(functor
laws) と呼ばれているが、単に圏の構造の保存を保証するだけのものだ。</p>
<h3 data-number="7.1.2" id="等式による推論"><span
class="header-section-number">7.1.2</span> 等式による推論</h3>
<p>関手則を証明するために、Haskellでの一般的な証明テクニックである<span
id="equational_reasoning" class="keyword"><em>等式による推論</em></span>
(equational reasoning)
を使う。これは、Haskellの関数が等式、つまり左辺が右辺に等しいものである、として定義されているという事実を利用している。左辺と右辺はいつでも入れ替えられる。ただし、名前の競合を避けるために変数名を変更する必要はあるかもしれない。これは、関数をインライン化するか、あるいは逆に式を関数にリファクタリングすることと考えてほしい。例として恒等関数を考えてみよう。</p>
<div class="sourceCode" id="cb155"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre></div>
<p>
たとえば、ある式の中に<code>id y</code>があるなら、<code>y</code>に置き換えられる（インライン化）。さらに、（たとえば<code>id (y + 2)</code>のように）式に<code>id</code>が適用されているなら、<code>(y + 2)</code>のように式そのものに置き換えられる。そして、この置換は両方向に機能する。つまり、任意の式<code>e</code>を<code>id e</code>で置き換えられる（リファクタリング）。関数がパターンマッチングによって定義されている場合は、各サブ定義を独立して使える。たとえば、上記の<code>fmap</code>の定義では、<code>fmap f Nothing</code>を<code>Nothing</code>に置き換えることも、その逆を行うこともできる。これが実際にどのように機能するか見てみよう。まずは恒等射の保存から始めよう。</p>
<div class="sourceCode" id="cb156"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> <span class="fu">id</span> <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<p>
<code>Nothing</code>と<code>Just</code>の2つの場合を考慮する必要がある。1つ目の場合は次のようになる（Haskell疑似コードを使って左辺を右辺に変換している）。</p>
<div class="sourceCode" id="cb157"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> <span class="fu">id</span> <span class="dt">Nothing</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { fmapの定義 }</span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { idの定義 }</span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>
最後のステップで<code>id</code>の定義を逆向きに使ったことに注目してほしい。式<code>Nothing</code>を<code>id Nothing</code>に置き換えた。実際には、このような証明は、真ん中の同じ式に辿り着くまで「ロウソクを両端から燃やす」ことで成される。今回については真ん中に残るのは<code>Nothing</code>だ。2つ目の場合も簡単だ。</p>
<div class="sourceCode" id="cb158"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> <span class="fu">id</span> (<span class="dt">Just</span> x)</span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { fmapの定義 }</span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> (<span class="fu">id</span> x)</span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { idの定義 }</span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> x</span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { idの定義 }</span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> (<span class="dt">Just</span> x)</span></code></pre></div>
<p> では、<code>fmap</code>が合成を保存することを示そう。</p>
<div class="sourceCode" id="cb159"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> (g <span class="op">.</span> f) <span class="ot">=</span> <span class="fu">fmap</span> g <span class="op">.</span> <span class="fu">fmap</span> f</span></code></pre></div>
<p> まずは<code>Nothing</code>のケースだ。</p>
<div class="sourceCode" id="cb160"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> (g <span class="op">.</span> f) <span class="dt">Nothing</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { fmapの定義 }</span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { fmapの定義 }</span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> g <span class="dt">Nothing</span></span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { fmapの定義 }</span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> g (<span class="fu">fmap</span> f <span class="dt">Nothing</span>)</span></code></pre></div>
<p> 次は<code>Just</code>のケースだ。</p>
<div class="sourceCode" id="cb161"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> (g <span class="op">.</span> f) (<span class="dt">Just</span> x)</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { fmapの定義 }</span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> ((g <span class="op">.</span> f) x)</span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { 合成の定義 }</span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> (g (f x))</span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { fmapの定義 }</span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> g (<span class="dt">Just</span> (f x))</span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { fmapの定義 }</span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> g (<span class="fu">fmap</span> f (<span class="dt">Just</span> x))</span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { 合成の定義 }</span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a>  (<span class="fu">fmap</span> g <span class="op">.</span> <span class="fu">fmap</span> f) (<span class="dt">Just</span> x)</span></code></pre></div>
<p>
等式による推論はC++スタイルの副作用のある「関数」では使えないことは、強調しておく価値がある。次のコードを考えてみよう。</p>
<div class="sourceCode" id="cb162"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> square<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">*</span> x<span class="op">;</span></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> counter<span class="op">()</span> <span class="op">{</span></span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">int</span> c <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c<span class="op">++;</span></span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> y <span class="op">=</span> square<span class="op">(</span>counter<span class="op">());</span></span></code></pre></div>
<p>
等式による推論を使うと、<code>square</code>をインライン展開して次のようにできる。</p>
<div class="sourceCode" id="cb163"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> y <span class="op">=</span> counter<span class="op">()</span> <span class="op">*</span> counter<span class="op">();</span></span></code></pre></div>
<p>
明らかにこれは有効な変換ではなく、同じ結果は生成されない。それにもかかわらず、マクロとして<code>square</code>を実装すると、C++コンパイラーは等式による推論を使おうとし、悲惨な結果になる。</p>
<h3 data-number="7.1.3" id="optional"><span
class="header-section-number">7.1.3</span> Optional</h3>
<p>関手はHaskellで簡単に表現できるが、総称プログラミングや高階関数をサポートする言語ならどれでも定義できる。<code>Maybe</code>のC++版であるテンプレート型<code>optional</code>について考えてみよう。以下に実装の概略を示す（実際の実装ははるかに複雑で、C++に特有の引数のさまざまな渡し方やコピーセマンティクスやリソース管理の問題を扱わなくてはならない）。</p>
<div class="sourceCode" id="cb164"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> optional <span class="op">{</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> _isValid<span class="op">;</span> <span class="co">// the tag</span></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a>    T    _v<span class="op">;</span></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a>    optional<span class="op">()</span>    <span class="op">:</span> _isValid<span class="op">(</span><span class="kw">false</span><span class="op">)</span> <span class="op">{}</span>         <span class="co">// Nothing</span></span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a>    optional<span class="op">(</span>T x<span class="op">)</span> <span class="op">:</span> _isValid<span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">,</span> _v<span class="op">(</span>x<span class="op">)</span> <span class="op">{}</span>  <span class="co">// Just</span></span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> isValid<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> _isValid<span class="op">;</span> <span class="op">}</span></span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>    T val<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> _v<span class="op">;</span> <span class="op">}</span></span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>
このテンプレートは、関手の定義の一部である型の写像を提供する。これは任意の型<code>T</code>を新しい型<code>optional&lt;T&gt;</code>に写す。関数に対するその関手の作用を定義しよう。</p>
<div class="sourceCode" id="cb165"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>function<span class="op">&lt;</span>optional<span class="op">&lt;</span>B<span class="op">&gt;(</span>optional<span class="op">&lt;</span>A<span class="op">&gt;)&gt;</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>fmap<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;</span> f<span class="op">)</span></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">[</span>f<span class="op">](</span>optional<span class="op">&lt;</span>A<span class="op">&gt;</span> opt<span class="op">)</span> <span class="op">{</span></span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>opt<span class="op">.</span>isValid<span class="op">())</span></span>
<span id="cb165-7"><a href="#cb165-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> optional<span class="op">&lt;</span>B<span class="op">&gt;{};</span></span>
<span id="cb165-8"><a href="#cb165-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb165-9"><a href="#cb165-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> optional<span class="op">&lt;</span>B<span class="op">&gt;{</span> f<span class="op">(</span>opt<span class="op">.</span>val<span class="op">())</span> <span class="op">};</span></span>
<span id="cb165-10"><a href="#cb165-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb165-11"><a href="#cb165-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
これは高階関数で、引数として関数を受け取り、関数を返す。非カリー化版はこうなる。</p>
<div class="sourceCode" id="cb166"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>optional<span class="op">&lt;</span>B<span class="op">&gt;</span> fmap<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;</span> f<span class="op">,</span> optional<span class="op">&lt;</span>A<span class="op">&gt;</span> opt<span class="op">)</span> <span class="op">{</span></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>opt<span class="op">.</span>isValid<span class="op">())</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> optional<span class="op">&lt;</span>B<span class="op">&gt;{};</span></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> optional<span class="op">&lt;</span>B<span class="op">&gt;{</span> f<span class="op">(</span>opt<span class="op">.</span>val<span class="op">())</span> <span class="op">};</span></span>
<span id="cb166-7"><a href="#cb166-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
<code>fmap</code>を<code>optional</code>のテンプレートメソッドにするという選択肢もある。このように選択肢に迷うことになるため、C++で関手パターンを抽象化するのは問題となる。関手は継承元となるインターフェイスにすべきだろうか？（残念ながら、テンプレート仮想関数は作れない。）
フリーテンプレート関数は、カリー化版と非カリー化版のどちらにすべきだろうか？　不足した型情報を、C++コンパイラーは正しく推論してくれるだろうか、それとも明示的に指定しなければならないだろうか？　入力関数<code>f</code>が<code>int</code>から<code>bool</code>への関数である状況を考えてみよう。コンパイラーに<code>g</code>の型が分かるだろうか。</p>
<div class="sourceCode" id="cb167"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> g <span class="op">=</span> fmap<span class="op">(</span>f<span class="op">);</span></span></code></pre></div>
<p>
特に将来、複数の関手が<code>fmap</code>をオーバーロードするようになった場合は？
（近いうちにさらに多くの関手について見てみよう。）</p>
<h3 data-number="7.1.4" id="型クラス"><span
class="header-section-number">7.1.4</span> 型クラス</h3>
<p>では、Haskellは関手の抽象化にどのように対処するのだろうか？　それには型クラスの機構を使う。型クラスは、共通のインターフェイスをサポートする型の族を定義する。たとえば、等しさの検査をサポートする対象についてのクラスは次のように定義される。</p>
<div class="sourceCode" id="cb168"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>
この定義は、型<code>a</code>の引数を2つ取り<code>Bool</code>を返す演算子<code>(==)</code>がサポートされる場合、型<code>a</code>はクラス<code>Eq</code>であることを示している。特定の型が<code>Eq</code>であることをHaskellに伝えたい場合は、その型をこのクラスの<span
id="instance"
class="keyword"><em>インスタンス</em></span>であると宣言し、<code>(==)</code>の実装を提供する必要がある。たとえば、2次元空間における点を表す型<code>Point</code>（2つの<code>Float</code>の直積型）が定義されているとする。</p>
<div class="sourceCode" id="cb169"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Point</span> <span class="ot">=</span> <span class="dt">Pt</span> <span class="dt">Float</span> <span class="dt">Float</span></span></code></pre></div>
<p> 点の等しさは次のように定義できる。</p>
<div class="sourceCode" id="cb170"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Point</span> <span class="kw">where</span></span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Pt</span> x y) <span class="op">==</span> (<span class="dt">Pt</span> x&#39; y&#39;) <span class="ot">=</span> x <span class="op">==</span> x&#39; <span class="op">&amp;&amp;</span> y <span class="op">==</span> y&#39;</span></code></pre></div>
<p>
ここでは演算子<code>(==)</code>（いま定義しようとしているもの）を2つのパターン<code>(Pt x y)</code>と<code>(Pt x'y Pt x y)</code>の間に中置した。関数の本体は、単一の等号の後に続く。いったん<code>Point</code>が<code>Eq</code>のインスタンスであると宣言されると、点同士の等しさを直接比較できるようになる。C++やJavaとは異なり、<code>Point</code>を定義するときに<code>Eq</code>クラス（またはインターフェイス）を指定する必要はなく、クライアントコード内で後から指定できることに注目してほしい。また、型クラスは関数（および演算子）をオーバーロードするためのHaskellにおける唯一の機構でもある。型クラスは<code>fmap</code>を異なる関数（や演算子）についてオーバーロードするために必要となる。ただし、1つ複雑な点がある。関手は型として定義されるのではなく、型の写像、つまり型構成子として定義される。必要な型クラスは、<code>Eq</code>の場合のような型の族ではなく、型構成子の族だ。幸い、Haskellの型クラスは型だけでなく型構成子に対しても使える。以下に<code>Functor</code>クラスの定義を示す。</p>
<div class="sourceCode" id="cb171"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>
これは、指定された型シグネチャーを持つ関数<code>fmap</code>が存在する場合、<code>f</code>は<code>Functor</code>だと規定している。小文字の<code>f</code>は型変数であり、型変数<code>a</code>や<code>b</code>と似ている。しかし、コンパイラーはそれが型ではなく型構成子を表していることを、その使われ方から推論できる。つまり、<code>f a</code>や<code>f b</code>のように他の型に作用していることから推論できる。したがって、<code>Functor</code>のインスタンスを宣言するときは型構成子を考える必要がある。例として<code>Maybe</code>の場合を示す。</p>
<div class="sourceCode" id="cb172"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> _ <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div>
<p>
ちなみに、<code>Functor</code>クラスや、<code>Maybe</code>を含む多くの単純なデータ型のインスタンス定義は、標準のPreludeライブラリーの一部となっている。</p>
<h3 data-number="7.1.5" id="cにおける関手"><span
class="header-section-number">7.1.5</span> C++における関手</h3>
<p>C++でも同じアプローチを試せるだろうか？　型構成子は、<code>optional</code>のようなテンプレートクラスに対応しているので、同様に<code>fmap</code>を<span
id="template_template_parameter"
class="keyword"><em>テンプレート・テンプレート引数</em></span> (template
template parameter) でパラメーター化しよう。構文は次のとおりだ。</p>
<div class="sourceCode" id="cb173"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">&gt;</span> F<span class="op">,</span> <span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>F<span class="op">&lt;</span>B<span class="op">&gt;</span> fmap<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;,</span> F<span class="op">&lt;</span>A<span class="op">&gt;);</span></span></code></pre></div>
<p>
このテンプレートをさまざまな関手に特殊化できるようにしたい。残念ながら、C++ではテンプレート関数の部分的な特殊化は禁止されている。そのため、次のような記述はできない。</p>
<div class="sourceCode" id="cb174"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a>optional<span class="op">&lt;</span>B<span class="op">&gt;</span> fmap<span class="op">&lt;</span>optional<span class="op">&gt;(</span></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;</span> f<span class="op">,</span> optional<span class="op">&lt;</span>A<span class="op">&gt;</span> opt<span class="op">)</span></span></code></pre></div>
<p>
代わりに関数のオーバーロードに頼る必要がある。結局、もとのカリー化されていない<code>fmap</code>の定義に戻る。</p>
<div class="sourceCode" id="cb175"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>optional<span class="op">&lt;</span>B<span class="op">&gt;</span> fmap<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;</span> f<span class="op">,</span> optional<span class="op">&lt;</span>A<span class="op">&gt;</span> opt<span class="op">)</span></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>opt<span class="op">.</span>isValid<span class="op">())</span></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> optional<span class="op">&lt;</span>B<span class="op">&gt;{};</span></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> optional<span class="op">&lt;</span>B<span class="op">&gt;{</span> f<span class="op">(</span>opt<span class="op">.</span>val<span class="op">())</span> <span class="op">};</span></span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
この定義は機能するが、どのオーバーロードが使われるかを<code>fmap</code>の2番目の引数が選択しているからにすぎない。より汎用的な<code>fmap</code>の定義を完全に無視している。</p>
<h3 data-number="7.1.6" id="リスト関手"><span
class="header-section-number">7.1.6</span> リスト関手</h3>
<p>プログラミングにおける関手の役割についてある程度の直観を育むには、もっといろいろな例を見る必要がある。別の型によってパラメーター化される型はどれも関手の候補だ。総称コンテナーも格納する要素の型によってパラメーター化されているる。では、ごく単純なコンテナーであるリストを見てみよう。</p>
<div class="sourceCode" id="cb176"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span></code></pre></div>
<p>
型構成子<code>List</code>がある。これは、任意の型<code>a</code>から型<code>List a</code>への写像だ。<code>List</code>が関手だと示すには、関数の持ち上げを定義する必要がある。つまり、関数<code>a -&gt; b</code>について関数<code>List a -&gt; List b</code>を定義する。</p>
<div class="sourceCode" id="cb177"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b)</span></code></pre></div>
<p>
<code>List a</code>に作用する関数は、リストの2つのコンストラクターに対応する2つの場合を考慮する必要がある。<code>Nil</code>の場合は自明で、単に<code>Nil</code>を返す。空のリストに対してできることはあまりない。<code>Cons</code>の場合は、再帰を伴うため、ややトリッキーだ。そこで、少し前に戻って、何をしようとしているのか考えてみよう。<code>a</code>のリストと、<code>a</code>を<code>b</code>に変換する関数<code>f</code>があり、<code>b</code>のリストを生成したい。自明なのは、<code>f</code>を使ってリストの各要素を<code>a</code>から<code>b</code>に変換することだ。（空でない）リストが先頭要素headと先頭を除いた残りのリストtailの<code>Cons</code>として定義されている場合、実際にはどうやるのだろうか？　<code>f</code>をheadに適用し、持ち上げられた（<code>fmap</code>された）<code>f</code>をtailに適用すればよい。これは再帰的な定義だ。持ち上げられた<code>f</code>を持ち上げられた<code>f</code>を用いて定義しているからだ。</p>
<div class="sourceCode" id="cb178"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (<span class="dt">Cons</span> x t) <span class="ot">=</span> <span class="dt">Cons</span> (f x) (<span class="fu">fmap</span> f t)</span></code></pre></div>
<p>
定義をリスト［訳注：左辺の<code>Cons x t</code>］に対して行おうとしているが、右辺の<code>fmap f</code>がそれより短いリスト――そのtail――に適用されていることに注意してほしい。再帰的に処理されるにつれてリストが短くなるため、最終的には空リスト、つまり<code>Nil</code>に到達することになる。しかし、先ほど決めたとおり、<code>fmap f</code>が<code>Nil</code>に作用すると<code>Nil</code>を返すため、再帰は停止する。最終的な結果を得るために、<code>Cons</code>コンストラクターを使って、新しいheadの<code>(f x)</code>と新しいtailの<code>(fmap f t)</code>を結合する。すべてをまとめると、リスト関手のインスタンス宣言はこうなる。</p>
<div class="sourceCode" id="cb179"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">List</span> <span class="kw">where</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> _ <span class="dt">Nil</span> <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Cons</span> x t) <span class="ot">=</span> <span class="dt">Cons</span> (f x) (<span class="fu">fmap</span> f t)</span></code></pre></div>
<p>
C++の方が慣れているなら、<code>std::vector</code>の場合を考えてみてほしい。これは最も汎用的なC++コンテナーと見なせるだろう。<code>fmap</code>の<code>std::vector</code>用の実装は単に<code>std::transform</code>を薄く包んだものだ。</p>
<div class="sourceCode" id="cb180"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>B<span class="op">&gt;</span> fmap<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;</span> f<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>A<span class="op">&gt;</span> v<span class="op">)</span></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>B<span class="op">&gt;</span> w<span class="op">;</span></span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>transform<span class="op">(</span> <span class="bu">std::</span>begin<span class="op">(</span>v<span class="op">)</span></span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a>                  <span class="op">,</span> <span class="bu">std::</span>end<span class="op">(</span>v<span class="op">)</span></span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a>                  <span class="op">,</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>w<span class="op">)</span></span>
<span id="cb180-8"><a href="#cb180-8" aria-hidden="true" tabindex="-1"></a>                  <span class="op">,</span> f<span class="op">);</span></span>
<span id="cb180-9"><a href="#cb180-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> w<span class="op">;</span></span>
<span id="cb180-10"><a href="#cb180-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p> これを使えば、たとえば次のように数列の要素を2乗できる<a href="#fn46"
class="footnote-ref" id="fnref46"
role="doc-noteref"><sup>46</sup></a>。</p>
<div class="sourceCode" id="cb181"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span> <span class="op">};</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> w <span class="op">=</span> fmap<span class="op">([](</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> i<span class="op">*</span>i<span class="op">;</span> <span class="op">},</span> v<span class="op">);</span></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>copy<span class="op">(</span> <span class="bu">std::</span>begin<span class="op">(</span>w<span class="op">)</span></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> <span class="bu">std::</span>end<span class="op">(</span>w<span class="op">)</span></span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> <span class="bu">std::</span>ostream_iterator<span class="op">(</span><span class="bu">std::</span>cout<span class="op">,</span> <span class="st">&quot;, &quot;</span><span class="op">));</span></span></code></pre></div>
<p>
ほとんどのC++コンテナーは関手だと言える。それらは<code>std::transform</code>に渡せるイテレーターを実装していて、<code>std::transform</code>は<code>fmap</code>のより原始的な従兄弟だからだ。残念ながら、関手の単純さは、イテレーターや一時変数（上記の<code>fmap</code>の実装を参照）でいつも煩雑になるため失われてしまう。新しく提案されたC++の範囲
(range)
ライブラリー[^訳注：C++20標準で`std::ranges`として導入された。]によって範囲の関手的な性質がより顕著になったのは喜ばしい。</p>
<aside id="footnotes-26" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="46">
<li
id="fn46"><p>訳注：2乗するだけでなく、結果を標準出力にコンマ区切りで出力している。<a
href="#fnref46" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h3 data-number="7.1.7" id="reader関手"><span
class="header-section-number">7.1.7</span> Reader関手</h3>
<p>さて、直観が育ってきただろう。たとえば、関手をある種のコンテナーと見なせるようになった。では、一見非常に異なる例をお見せしよう。型<code>a</code>からの、<code>a</code>を返す関数の型への写像を考えてみよう。関数型についてはあまり詳しく述べていない（完全に圏論的な扱いはこれからだ）が、プログラマーならある程度理解している。Haskellでは、関数型はアロー型構成子<code>(-&gt;)</code>を使って構成され、引数の型と結果の型の2つの型を取る。すでに中置記法<code>a -&gt; b</code>で見たことがあるが、括弧で括れば前置記法でも同様に使える。</p>
<div class="sourceCode" id="cb182"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a>(<span class="ot">-&gt;</span>) a b</span></code></pre></div>
<p>
通常の関数と同様に、複数の引数を取る型関数も部分適用できる。したがって、矢印に対して型引数を1つだけ与えた後もなお、もう1つの型引数が期待される。それが</p>
<div class="sourceCode" id="cb183"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a>(<span class="ot">-&gt;</span>) a</span></code></pre></div>
<p>
が型構成子である理由だ。完全な型<code>a -&gt; b</code>を生成するには、もう1つの型<code>b</code>が必要だ。いまのところは、<code>a</code>によってパラメーター化された型構成子の族の全体を定義していると言える。これが関手の族でもあるかどうか見てみよう。2つの型パラメーターを扱うのは混乱を招くかもしれないので、名前を変更しておこう。前の関手の型定義に従って、引数の型を<code>r</code>
、結果の型を<code>a</code>と呼ぼう。そうすると、この型構成子は任意の型<code>a</code>を取り、それを型<code>r -&gt; a</code>に写す。これが関手であることを示すために、関数<code>a -&gt; b</code>を、<code>r -&gt; a</code>を受け取って<code>r -&gt; b</code>を返す関数に持ち上げたい。これらの型は<code>a</code>と<code>b</code>のそれぞれに型構成子<code>(-&gt;) r</code>を作用させて作られたものだ。この場合における<code>fmap</code>の型シグネチャーは次のとおりだ。</p>
<div class="sourceCode" id="cb184"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> b)</span></code></pre></div>
<p>
ここでパズルを解かなくてはならない。関数<code>f :: a -&gt; b</code>と関数<code>g :: r -&gt; a</code>が与えられるとき、関数<code>r -&gt; b</code>を作成せよ。2つの関数を合成する方法は1つしかなく、その結果はまさに必要なものだ。<code>fmap</code>の実装は次のようになる。</p>
<div class="sourceCode" id="cb185"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> ((<span class="ot">-&gt;</span>) r) <span class="kw">where</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f g <span class="ot">=</span> f <span class="op">.</span> g</span></code></pre></div>
<p>
うまくいった！　簡潔な表記が好みなら、さらに短く定義できる。そのためには、合成を前置記法で</p>
<div class="sourceCode" id="cb186"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f g <span class="ot">=</span> (<span class="op">.</span>) f g</span></code></pre></div>
<p>
と書き直せることと、そのときの引数を省略できることに着目し、2つの関数の間の等式を得る。</p>
<div class="sourceCode" id="cb187"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> <span class="ot">=</span> (<span class="op">.</span>)</span></code></pre></div>
<p> 型構成子
<code>(-&gt;) r</code>と上記の<code>fmap</code>の実装の組み合わせは、reader関手と呼ばれる。</p>
<h2 data-number="7.2" id="コンテナーとしての関手"><span
class="header-section-number">7.2</span> コンテナーとしての関手</h2>
<p>汎用コンテナーを定義できるか、オブジェクトをそれが含む値の型によってパラメーター化して定義できるプログラミング言語において、関手の例をいくつか見た。Reader関手は異端に思える。我々は関数をデータとは見なさないからだ。しかし、純粋関数はメモ化でき、関数の実行はテーブル参照に変えられるのをすでに見た。テーブルはデータだ。逆に、Haskellは遅延評価を採用しているため、リストのような従来のコンテナーは、実際には関数として実装されうる。たとえば、次のように簡潔に定義できる自然数の無限リストを考えてみよう。</p>
<div class="sourceCode" id="cb188"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nats ::</span> [<span class="dt">Integer</span>]</span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a>nats <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span>]</span></code></pre></div>
<p>
1行目では、一対の角括弧はHaskellの組み込みリスト用の型構成子だ。2行目では、角括弧はリストを作成するために使われている。明らかに、このような無限リストはメモリーに格納できない。コンパイラーはこれを、必要に応じて<code>Integer</code>を生成する関数として実装する。Haskellは効果的にデータとコードの区別を曖昧にしている。リストは関数と見なせて、関数は引数を結果に写すテーブルと見なせる。後者は関数の領域が有限かつ大きすぎない場合なら現実的だ。しかし、<code>strlen</code>をテーブル参照として実装するのは現実的でない。無限に多くの異なる文字列が存在するからだ。プログラマーとして、我々は無限大は好きではないが、圏論では朝食に無限大を食べるのを学ぶことになる。すべての文字列の集合であっても、過去・現在・未来の宇宙のすべての可能な状態の集まりであっても、対処できる！　そこで、関手オブジェクト（自己関手によって生成された型のオブジェクト）はパラメーター化される型の値を含むと考えたい。それらの値が物理的にそこに存在しない場合でもだ。関手の一例はC++の<code>std::future</code>で、ある時点で値を含みうるが、必ず含む保証はない。また、その値にアクセスしたいとき、別スレッドの実行終了を待つためにブロックされることがある。別の例としてはHaskellの<code>IO</code>オブジェクトがあり、ユーザー入力を含んだり、画面に「Hello
World!」と表示されているような未来版の宇宙を含んだりできる。この解釈によれば、関手オブジェクトとは、パラメーター化された型の値を含みうるものだ。あるいは、これらの値を生成するためのレシピも含みうる。値にアクセスできるかは全く気にしない――それは完全にオプショナルであり、関手の守備範囲外だ。関心があるのは、これらの値を関数を使って操作できるかだけだ。値にアクセスできるなら、操作の結果を確認できるはずだ。アクセスできないなら、操作が正しく合成され、恒等関数による操作が何も変更しないことに注意するだけでよい。関手オブジェクト内の値へのアクセスを全く気にしていないことを明示するために、引数<code>a</code>を完全に無視する型構成子を例に挙げよう。</p>
<div class="sourceCode" id="cb189"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Const</span> c a <span class="ot">=</span> <span class="dt">Const</span> c</span></code></pre></div>
<p>
<code>Const</code>型構成子は<code>c</code>と<code>a</code>の2つの型を取る。アローコンストラクターで行ったように、部分適用で関手を作成しよう。<code>Const</code>型のデータ構成子（これも<code>Const</code>と呼ばれる）は型<code>c</code>の値を1つだけ取る。これは<code>a</code>には依存しない。この型構成子の<code>fmap</code>の型は次のようになる。</p>
<div class="sourceCode" id="cb190"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Const</span> c a <span class="ot">-&gt;</span> <span class="dt">Const</span> c b</span></code></pre></div>
<p>
この関手は型引数を無視するので、<code>fmap</code>の実装はその関数引数を無視してよい――その関数は作用するものがない。</p>
<div class="sourceCode" id="cb191"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Const</span> c) <span class="kw">where</span></span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> _ (<span class="dt">Const</span> v) <span class="ot">=</span> <span class="dt">Const</span> v</span></code></pre></div>
<p>
これはC++ではもう少し明確かもしれない（この言葉を口にするとは思わなかった！）。コンパイル時に決まる型引数と実行時に決まる値がよりはっきり区別されるからだ。</p>
<div class="sourceCode" id="cb192"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> C<span class="op">,</span> <span class="kw">class</span> A<span class="op">&gt;</span></span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Const <span class="op">{</span></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a>    Const<span class="op">(</span>C v<span class="op">)</span> <span class="op">:</span> _v<span class="op">(</span>v<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a>    C _v<span class="op">;</span></span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>
<code>fmap</code>のC++実装も、関数の引数を無視し、<code>Const</code>の引数を値は変更せず実質的に再キャストする。</p>
<div class="sourceCode" id="cb193"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> C<span class="op">,</span> <span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>Const<span class="op">&lt;</span>C<span class="op">,</span> B<span class="op">&gt;</span> fmap<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;</span> f<span class="op">,</span> Const<span class="op">&lt;</span>C<span class="op">,</span> A<span class="op">&gt;</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Const<span class="op">&lt;</span>C<span class="op">,</span> B<span class="op">&gt;{</span>c<span class="op">.</span>_v<span class="op">};</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
その奇妙さにもかかわらず、<code>Const</code>関手は多くの構成で重要な役割を果たしている。圏論では、これは先に述べた<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>関手の特殊なケースであり、ブラックホールの自己関手版だ。今後もっと詳しく知ることになるだろう。</p>
<h2 data-number="7.3" id="関手の合成"><span
class="header-section-number">7.3</span> 関手の合成</h2>
<p>圏の間の関手が合成できることは、集合の間の関数が合成できるのと同様だと考えれば、納得するのは難しくない。2つの関手の合成は、対象に作用するときは、それぞれの対象の写像の合成にすぎず、射に作用するときも同様だ。2つの関手を飛び越えた後で、恒等射は恒等射となり、射の合成は射の合成となる。ただそれだけだ。特に、自己関手を合成するのは簡単だ。関数<code>maybeTail</code>を覚えているだろうか？　ここではHaskellの組み込みのリスト実装を使って書き直そう。</p>
<div class="sourceCode" id="cb194"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="ot">maybeTail ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [a]</span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a>maybeTail [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>maybeTail (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Just</span> xs</span></code></pre></div>
<p>
（<code>Nil</code>と呼んでいた空リストコンストラクターは空の角括弧のペア<code>[]</code>に置き換えられる。<code>Cons</code>コンストラクターは中置演算子<code>:</code>（コロン）に置き換えられる。）
<code>maybeTail</code>の結果は、<code>Maybe</code>と<code>[]</code>という2つの関手の合成が<code>a</code>に作用するような型だ。これらの関数はそれぞれ独自版の<code>fmap</code>を備えているが、もし何らかの関数<code>f</code>を合成の内容、つまり<code>Maybe</code>リストに適用したい場合はどうなるだろう？　2層の関手を突破しなければならない。<code>fmap</code>を使えば外側の<code>Maybe</code>は突破できる。しかし、<code>f</code>はリストに対しては動作しないので、<code>Maybe</code>内に<code>f</code>を単に送ることはできない。内側のリストを操作するには<code>(fmap f)</code>を送る必要がある。たとえば、整数の<code>Maybe</code>リストの要素を2乗するにはどうするか見てみよう。</p>
<div class="sourceCode" id="cb195"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a>square x <span class="ot">=</span> x <span class="op">*</span> x</span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a><span class="ot">mis ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]</span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a>mis <span class="ot">=</span> <span class="dt">Just</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a>mis2 <span class="ot">=</span> <span class="fu">fmap</span> (<span class="fu">fmap</span> square) mis</span></code></pre></div>
<p>
コンパイラーは、型を分析した後、外側の<code>fmap</code>に対しては<code>Maybe</code>インスタンスからの実装を、内側のものに対してはリスト関手の実装を使う必要があることを理解する。上記のコードを次のように書き換えられるのは、すぐには自明に思えないかもしれない。</p>
<div class="sourceCode" id="cb196"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a>mis2 <span class="ot">=</span> (<span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span>) square mis</span></code></pre></div>
<p>
だが、<code>fmap</code>は引数が1つだけの関数と見なせることを思い出してほしい。</p>
<div class="sourceCode" id="cb197"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</span></code></pre></div>
<p>
この例では、<code>(fmap . fmap)</code>内の2番目の<code>fmap</code>は引数として次のものを取る。</p>
<div class="sourceCode" id="cb198"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="ot">square ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p> そして、次の型の関数を返す。</p>
<div class="sourceCode" id="cb199"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a>[<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span></code></pre></div>
<p>
1番目の<code>fmap</code>がこの関数を受け取り、次の型の関数を返す。</p>
<div class="sourceCode" id="cb200"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Maybe</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]</span></code></pre></div>
<p>
最後に、この関数は<code>mis</code>に適用される。したがって、2つの関手を合成すると、対応する2つの<code>fmap</code>を合成した<code>fmap</code>を持つ関手になる。圏論に話を戻すと、関手の合成が結合性を持つのはごく自明だ（対象の写像が結合性を持ち、射の写像も結合性を持つ）。また、すべての圏には自明な恒等関手がある。すなわち、どの対象もその対象自身へ写し、どの射もその射自身へ写すような関手だ。つまり、関手はある圏の射と全く同じ性質を持っている。しかし、それはどのような圏だろうか？　対象が圏であり射が関手である圏でなければならない。すなわち、圏の圏だ。ところが、<em>すべての</em>圏の圏はそれ自体を含まなければならず、すべての集合の集合を不可能にしたのと同じ種類の矛盾にぶつかることになる。しかし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>と呼ばれる、すべての<em>小さい</em>圏の圏がある（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>自体は大きい圏なので、それ自体のメンバーにはなれない）。小さい圏とは、対象が集合よりも大きな何かではなく集合をなすような圏のことだ。圏論では、非可算無限集合であっても「小さい」と見なされることに注意してほしい。これらに言及しようと思ったのは、同じ構造が抽象化の多くのレベルで繰り返されているのを認識できることが、非常に驚くべきことだからだ。関手が圏をなすことについても後で説明する。</p>
<h2 data-number="7.4" id="課題-6"><span
class="header-section-number">7.4</span> 課題</h2>
<ol type="1">
<li><p>次のように定義することで、<code>Maybe</code>型構成子を関手に変換できるか？</p>
<div class="sourceCode" id="cb201"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> _ _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>
これは両方の引数を無視する。（ヒント：関手則をチェックする。）</p></li>
<li><p>Reader関手について関手則を証明せよ。ヒント：本当に単純だ。</p></li>
<li><p>2番目に好きな言語でReader関手を実装せよ（1番目はHaskell、それ一択だ）。</p></li>
<li><p>リスト関手について関手則を証明せよ。その際は、<code>fmap f</code>を適用するリストのtailについて規則が真であると仮定せよ（言い換えると、<em>帰納法</em>を使用せよ）。</p></li>
</ol>
<h1 data-number="8" id="functoriality"><span
class="header-section-number">8</span> 関手性</h1>
<p>関手とは何かを学び、いくつかの例を見てきたのに続いて、小さい関手からより大きい関手を作る方法を見てみよう。特に興味深いのは、（圏内の対象間の写像に対応する）どの型構成子を、（射の間の写像を含む）関手に拡張できるのかという点だ。</p>
<h2 data-number="8.1" id="双関手"><span
class="header-section-number">8.1</span> 双関手</h2>
<p>関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>（圏の圏）の射であるため、射――典型的には関数――に関する直観の多くは関手にも当てはまる。たとえば、2つの引数を取る関数があるのと同じように、2つの引数を取る関手、すなわち<span
id="bifunctor" class="keyword"><em>双関手</em></span> (bifunctor)
もある。対象については、1つは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から、もう1つは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>からの対象からなるペアを、双関手はすべて圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐄</mi><annotation encoding="application/x-tex">\mathbf{E}</annotation></semantics></math>の対象へと写す。これは単に、圏の<span
id="Cartesian_product" class="keyword"><em>デカルト積</em></span><a
href="#fn47" class="footnote-ref" id="fnref47"
role="doc-noteref"><sup>47</sup></a><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐃</mi></mrow><annotation encoding="application/x-tex">\mathbf{C} \times{} \mathbf{D}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐄</mi><annotation encoding="application/x-tex">\mathbf{E}</annotation></semantics></math>への写像だと言っているだけであることに注意してほしい。</p>
<p> <img src="images/bifunctor.jpg" style="width:30.0%" /> </p>
<p>
実に直截的だ。だが、関手性によると、双関手は射も写さなければならない。ただし、今回は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の射と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の射のペアを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐄</mi><annotation encoding="application/x-tex">\mathbf{E}</annotation></semantics></math>の射に写す必要がある。</p>
<p>ここでも、射のペアは積圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐃</mi></mrow><annotation encoding="application/x-tex">\mathbf{C} \times{} \mathbf{D}</annotation></semantics></math>内の1つの射に相当する。圏のデカルト積における射は、ある対象のペアから別の対象のペアへ向かう射のペアと定義される<a
href="#fn48" class="footnote-ref" id="fnref48"
role="doc-noteref"><sup>48</sup></a>。これらの射のペアは、自明な方法で合成できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>∘</mo><mo stretchy="false" form="prefix">(</mo><msup><mi>f</mi><mo>′</mo></msup><mo>,</mo><msup><mi>g</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>∘</mo><msup><mi>f</mi><mo>′</mo></msup><mo>,</mo><mi>g</mi><mo>∘</mo><msup><mi>g</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(f, g) \circ (f&#39;, g&#39;) = (f \circ f&#39;, g \circ g&#39;)</annotation></semantics></math>
合成は結合的であり、恒等射のペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mo>,</mo><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{id}, \mathbf{id})</annotation></semantics></math>
を恒等射として持つ。圏のデカルト積は確かに圏だ。</p>
<p>双関手についてもっと簡単に考えたいなら、両方の引数を取る関手だと見なせばよい。そうすれば、関手則――結合性と恒等射の保存――を関手から双関手へ翻訳するのではなく、引数ごとに個別にチェックすれば十分だろう。ただし、一般には、個別の関手性は統合した関手性の証明としては不十分だ。統合した関手性が成り立たない［訳注：ような積を持つ］圏は<em>前モノイダル圏</em>
(premonoidal category) と呼ばれる。</p>
<p>Haskellで双関手を定義しよう。この場合の3つの圏はすべて同じで、Haskellの型の圏だ。双関手は2つの型引数を取る型構成子だ。型クラス<code>Bifunctor</code>の定義を<code>Control.Bifunctor</code>ライブラリーから採ると、次のとおりだ。</p>
<div class="sourceCode" id="cb202"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Bifunctor</span> f <span class="kw">where</span></span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    bimap ::</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a b <span class="ot">-&gt;</span> f c d</span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>    bimap g h <span class="ot">=</span> first g <span class="op">.</span> second h</span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    first ::</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a b <span class="ot">-&gt;</span> f c b</span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a>    first g <span class="ot">=</span> bimap g <span class="fu">id</span></span>
<span id="cb202-6"><a href="#cb202-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    second ::</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a b <span class="ot">-&gt;</span> f a d</span>
<span id="cb202-7"><a href="#cb202-7" aria-hidden="true" tabindex="-1"></a>    second <span class="ot">=</span> bimap <span class="fu">id</span></span></code></pre></div>
<figure>
<img src="images/bimap.jpg" title="bimap" style="width:30.0%"
alt="bimap" />
<figcaption aria-hidden="true">bimap</figcaption>
</figure>
<p>
型変数<code>f</code>は双関手を表す。どの型シグネチャーにおいても<code>f</code>は常に2つの型引数に適用されている。最初の型シグネチャーは、<code>bimap</code>が2つの関数を同時に写すものであることを規定<a
href="#fn49" class="footnote-ref" id="fnref49"
role="doc-noteref"><sup>49</sup></a>している。その結果は持ち上げられた関数<code>(f a b -&gt; f c d)</code>であり、双関手の型構成子<code>f</code>が生成する型に対して作用する。
<code>bimap</code>には<code>first</code>と<code>second</code>によるデフォルト実装がある（前述のとおり、これは常に機能するわけではなく、2つの写像が可換でない場合<a
href="#fn50" class="footnote-ref" id="fnref50"
role="doc-noteref"><sup>50</sup></a>には<code>first g . second h</code>と<code>second h . first g</code>は同じではない）。</p>
<p>他の2つの型シグネチャー<code>first</code>と<code>second</code>は、2つの<code>fmap</code>であり、それぞれ1番目と2番目の引数について<code>f</code>の関手性を示す<a
href="#fn51" class="footnote-ref" id="fnref51"
role="doc-noteref"><sup>51</sup></a>。</p>
<table>
<tbody>
<tr>
<td style="text-align: center;"><img src="images/first.jpg"
title="first" style="width:30.0%" alt="first" /></td>
<td style="text-align: center;"><img src="images/second.jpg"
title="second" style="width:30.0%" alt="second" /></td>
</tr>
<tr>
<td style="text-align: center;">first</td>
<td style="text-align: center;">second</td>
</tr>
</tbody>
</table>
<p>型クラス定義は、この両方のデフォルト実装を<code>bimap</code>に基づいて提供する。</p>
<p><code>Bifunctor</code>のインスタンスを宣言するときには、<code>bimap</code>を実装してデフォルトの<code>first</code>と<code>second</code>を受け入れるか、<code>first</code>と<code>second</code>の両方を実装してデフォルトの<code>bimap</code>を受け入れるか、どちらかを選べる（もちろん3つすべてを実装してもよいが、それらが相互に正しく関連付けられているのを確認するのはプログラマーの責任になる）。</p>
<aside id="footnotes-27" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="47">
<li
id="fn47"><p>訳注：圏のデカルト積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mi>𝐃</mi></mrow><annotation encoding="application/x-tex">\mathbf{C} \times \mathbf{D}</annotation></semantics></math>とは、その対象たちが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の対象と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の対象のペアすべての集まりであり、その射たちが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の射と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の射のペアすべての集まりであるような圏である。<a
href="#fnref47" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn48"><p>訳注：つまり、積圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐃</mi></mrow><annotation encoding="application/x-tex">\mathbf{C} \times{} \mathbf{D}</annotation></semantics></math>における射は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>における射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to c</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>における射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∷</mo><mi>b</mi><mo>→</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">g \Colon b \to d</annotation></semantics></math>のペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>∷</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>×</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>×</mo><mi>d</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(f, g) \Colon (a \times b) \to (c \times d)</annotation></semantics></math>である。<a
href="#fnref48" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn49"><p>訳注：原文にはdefineとあるが、「定義」は<code>bimap = ...</code>の部分を指すように思われる。<a
href="#fnref49" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn50"><p>訳注：<code>f</code>が双関手ならばこのようなことは起こらない。章末の課題1も参照。<a
href="#fnref50" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn51"><p>訳注：<code>Functor</code>のときと同様に、関手則を確認するのはプログラマーの責任である。また、前述のとおり、<code>first</code>と<code>second</code>が関手的であるからといって<code>f</code>が双関手となるとは限らない。<a
href="#fnref51" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="8.2" id="product-and-coproduct-bifunctors"><span
class="header-section-number">8.2</span> 積と余積の双関手</h2>
<p>双関手の重要な例として、圏論的な積、つまり<a
href="#products-and-coproducts">普遍的構成</a>によって定義される2つの対象の積がある。対象の任意のペアに対して積が存在する場合、これらの対象から積への写像は双関手的だ。これは一般に真であり、特にHaskellについてもそうだ。最も単純な直積型である、ペア型の型構成子に対する<code>Bifunctor</code>インスタンスはこうなる。</p>
<div class="sourceCode" id="cb203"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Bifunctor</span> (,) <span class="kw">where</span></span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a>    bimap f g (x, y) <span class="ot">=</span> (f x, g y)</span></code></pre></div>
<p>
選択の余地はあまりない。<code>bimap</code>では単に、1番目の関数をペアの第一成分に適用し、2番目の関数を第二成分に適用するだけだ。その型から、このコードが何をするかは一目瞭然だ。</p>
<div class="sourceCode" id="cb204"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bimap ::</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> (a, b) <span class="ot">-&gt;</span> (c, d)</span></code></pre></div>
<p> ここでの双関手の作用は、たとえば次のような型のペアを作ることだ。</p>
<div class="sourceCode" id="cb205"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a>(,) a b <span class="ot">=</span> (a, b)</span></code></pre></div>
<p>
双対性より、余積も、圏内の対象のすべてのペアに対して定義されているなら双関手だ。Haskellにおいては、型構成子<code>Either</code>が<code>Bifunctor</code>のインスタンスであることが良い例だ。</p>
<div class="sourceCode" id="cb206"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Bifunctor</span> <span class="dt">Either</span> <span class="kw">where</span></span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a>    bimap f _ (<span class="dt">Left</span> x)  <span class="ot">=</span> <span class="dt">Left</span> (f x)</span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a>    bimap _ g (<span class="dt">Right</span> y) <span class="ot">=</span> <span class="dt">Right</span> (g y)</span></code></pre></div>
<p> このコードも何をするか一目瞭然だ。</p>
<p>モノイダル圏について述べたときのことを覚えているだろうか？　モノイダル圏は、対象に作用する二項演算子と単位対象とを定義する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>について、デカルト積に関して単元集合を単位元とするモノイダル圏だと述べた。また、非交和に関しても空集合を単位元とするモノイダル圏だ。しかし、モノイダル圏の要件の1つとして、二項演算子が双関手でなければならないことは述べていなかった。これは非常に重要な要件だ。射によって定義される圏の構造とモノイド的な積とを両立させたいからだ。我々はいま、モノイダル圏の完全な定義に一歩近づいている（そこに到達するまでには、まだ自然性について学ぶ必要がある）。</p>
<h2 data-number="8.3" id="関手的代数的データ型"><span
class="header-section-number">8.3</span> 関手的代数的データ型</h2>
<p>これまでに、パラメーター化されたデータ型が関手であるような例、つまりそれについて<code>fmap</code>を定義できるような型をいくつか見てきた。複雑なデータ型は単純なデータ型から構成される。特に、代数的データ型
(ADT)
は、和と積を使って作成される。和と積が関手的なのは先ほど見た。関手が合成可能であることもすでに知っている。したがって、ADTの基本的な構成要素が関手的であると示せれば、パラメーター化されたADTも関手的だと分かる。</p>
<p>では、パラメーター化された代数的データ型の構成要素は何だろうか？　まず、<code>Maybe</code>における<code>Nothing</code>や<code>List</code>における<code>Nil</code>のように、関手の型パラメーターに依存しない要素がある。それらは<code>Const</code>関手と等価だ。<code>Const</code>関手は型パラメーターを無視することを思い出してほしい（いま述べているのは<strong>2番目の</strong>型パラメーターのことで、1番目のパラメーターはそのままにされる）。</p>
<p>次に、<code>Maybe</code>における<code>Just</code>のように、単に型パラメーター自体をそのままカプセル化する要素がある。これらは恒等関手と等価だ。以前、恒等関手について<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>の恒等射として言及したが、Haskellでの定義は説明しなかった。それをここに示す。</p>
<div class="sourceCode" id="cb207"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span> a</span></code></pre></div>
<div class="sourceCode" id="cb208"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Identity</span> <span class="kw">where</span></span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Identity</span> x) <span class="ot">=</span> <span class="dt">Identity</span> (f x)</span></code></pre></div>
<p>
<code>Identity</code>は、型<code>a</code>の（不変な）値を常に1つだけ格納する、最も単純なコンテナーと見なせる。</p>
<p>代数的データ構造の他のすべては、これら2つのプリミティブから積と和を使って構成される。</p>
<p>この新しい知識に基づいて、<code>Maybe</code>型構成子を改めて見てみよう。</p>
<div class="sourceCode" id="cb209"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre></div>
<p>
これは2つの型の和だ。和が関手的なのは知っている。1つ目の部分である<code>Nothing</code>は、<code>Const ()</code>の<code>a</code>に対する作用として表せる（<code>Const</code>の最初の型パラメーターはunit型に設定されている――後で<code>Const</code>のさらに興味深い使い方を説明する）。2つ目の部分は、恒等関手の別名だ。<code>Maybe</code>は、同型を除いて、次のようにも定義できる。</p>
<div class="sourceCode" id="cb210"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Either</span> (<span class="dt">Const</span> () a) (<span class="dt">Identity</span> a)</span></code></pre></div>
<p>
したがって、<code>Maybe</code>は双関手<code>Either</code>を2つの関手<code>Const ()</code>と<code>Identity</code>に合成したものだ。（<code>Const</code>は実際には双関手だが、ここでは常に部分適用で使う。）</p>
<p>関手の合成が関手であることはすでに見た。同じことが双関手にも当てはまるのは簡単に納得できる。必要なのは、2つの関手との双関手の合成が、射にどのように作用するかを理解することだけだ。2つの射が与えられたとき、まず片方の関手で片方の射を、もう1つの関手でもう1つの射をそれぞれ単に持ち上げる。次に、そのようにして得られる持ち上げられた射のペアを、双関手で持ち上げる。</p>
<p>この合成はHaskellで表現できる。双関手<code>bf</code>（2つの型を引数に取る双関手コンストラクターである型変数）と、2つの関手<code>fu</code>と<code>gu</code>（それぞれ1つの型変数を取る型構成子）と、2つの通常の型<code>a</code>と<code>b</code>とによってパラメーター化されるデータ型を定義しよう。<code>fu</code>を<code>a</code>に適用し、<code>gu</code>を<code>b</code>に適用し、それから<code>bf</code>を結果の2つの型に適用する。</p>
<div class="sourceCode" id="cb211"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">BiComp</span> bf fu gu a b <span class="ot">=</span> <span class="dt">BiComp</span> (bf (fu a) (gu b))</span></code></pre></div>
<p>
これが対象、つまり型の合成だ。Haskellで型構成子を型に適用する方法が、関数を引数に適用するのと同じであることに注目してほしい<a
href="#fn52" class="footnote-ref" id="fnref52"
role="doc-noteref"><sup>52</sup></a>。それらは同じ構文だ。</p>
<p>少し迷ったなら、<code>BiComp</code>を、<code>Either</code>、<code>Const ()</code>、<code>Identity</code>、<code>a</code>、<code>b</code>の順に適用してみてほしい。<code>Maybe b</code>のベアボーン版を復元できるだろう（<code>a</code>は無視される）。</p>
<p><code>bf</code>自体が<code>Bifunctor</code>であり<code>fu</code>および<code>gu</code>が<code>Functor</code>である場合については、新しいデータ型<code>BiComp</code>は<code>a</code>および<code>b</code>について双関手だ。そのため、<code>BiComp bf fu gu</code>を<code>Bifunctor</code>のインスタンスにするためには、<code>bf</code>に対する<code>bimap</code>の定義と、<code>fu</code>と<code>gu</code>に対する<code>fmap</code>の定義とが存在することをコンパイラーが認識している必要がある。Haskellでは、これはインスタンス宣言の前提条件として表現される。つまり、以下においてクラス制約のセットとして二重矢印の前に書かれた部分だ。</p>
<div class="sourceCode" id="cb212"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Bifunctor</span> bf, <span class="dt">Functor</span> fu, <span class="dt">Functor</span> gu) <span class="ot">=&gt;</span></span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Bifunctor</span> (<span class="dt">BiComp</span> bf fu gu) <span class="kw">where</span></span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a>    bimap f1 f2 (<span class="dt">BiComp</span> x) <span class="ot">=</span> <span class="dt">BiComp</span> (bimap (<span class="fu">fmap</span> f1) (<span class="fu">fmap</span> f2) x)</span></code></pre></div>
<p>
<code>BiComp</code>に対する<code>bimap</code>の実装は、<code>bf</code>に対する<code>bimap</code>と、<code>fu</code>および<code>gu</code>に対する2つの<code>fmap</code>によって与えられる。コンパイラーは、<code>BiComp</code>が使われるたびに、すべての型を自動的に推測し、適切なオーバーロード関数を選択する。</p>
<p><code>bimap</code>の定義内の<code>x</code>は次のような型だ。</p>
<div class="sourceCode" id="cb213"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a>bf (fu a) (gu b)</span></code></pre></div>
<p>
これについて述べると長くなる。外側の<code>bimap</code>は外側の<code>bf</code>の層を貫通しており、2つの<code>fmap</code>はそれぞれ<code>fu</code>と<code>gu</code>の下まで掘り下げている。<code>f1</code>と<code>f2</code>の型が</p>
<div class="sourceCode" id="cb214"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f1 ::</span> a <span class="ot">-&gt;</span> a&#39;</span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a><span class="ot">f2 ::</span> b <span class="ot">-&gt;</span> b&#39;</span></code></pre></div>
<p> の場合、最終結果の型は<code>bf (fu a') (gu b')</code>となる。</p>
<div class="sourceCode" id="cb215"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bimap ::</span>(fu a <span class="ot">-&gt;</span> fu a&#39;) <span class="ot">-&gt;</span> (gu b <span class="ot">-&gt;</span> gu b&#39;)</span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> bf (fu a) (gu b) <span class="ot">-&gt;</span> bf (fu a&#39;) (gu b&#39;)</span></code></pre></div>
<p>
ジグソーパズルが好きな人なら、この種の型操作で何時間も楽しめるだろう。</p>
<p><code>Maybe</code>が関手だと証明する必要はなかったと分かった。この事実は、<code>Maybe</code>が2つの関手的プリミティブの和として構築できることから導かれたものだ。</p>
<p>鋭い読者なら次のように尋ねるだろう。代数的データ型に対する<code>Functor</code>インスタンスをそれほど機械的に導出できるのなら、コンパイラーによって自動化して実行できないのか？　実際、可能であり、行われている。ただし、特定のHaskell拡張を、ソースファイルの先頭に次の行を含めることで有効にする必要がある。</p>
<div class="sourceCode" id="cb216"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span></code></pre></div>
<p> そして、データ構造に<code>deriving Functor</code>を追加する。</p>
<div class="sourceCode" id="cb217"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p> すると、対応する<code>fmap</code>が自動的に実装される。</p>
<p>代数的データ構造の規則性により、<code>Functor</code>だけでなく、前に述べた<code>Eq</code>型クラスを含む、いくつかの型クラスのインスタンスを導出できる。コンパイラーに独自の型クラスのインスタンスを派生させるように教えるという選択肢もあるが、それはもう少し高度だ。もっとも、基本的な構成要素と和と積とに対する動作を提供し、残りの部分はコンパイラーに計算させるというアイデアは変わらない。</p>
<aside id="footnotes-28" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="52">
<li
id="fn52"><p>訳注：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">\bot</annotation></semantics></math>を無視するならば、<code>newtype</code>は<code>data</code>の特殊版。1引数構成子をちょうど1つ持つ型しか定義できないが、その構成子の適用やその構成子によるパターンマッチは実行コストがかからない。<a
href="#fnref52" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="8.4" id="cにおける関手-1"><span
class="header-section-number">8.4</span> C++における関手</h2>
<p>C++プログラマーなら、関手の実装に関しては、明らかに自分でやることになる。しかし、C++でもある種の代数的データ構造は見つかるはずだ。そのようなデータ構造を総称テンプレートにすれば、<code>fmap</code>を素早く実装できるだろう。</p>
<p>データ木構造を見てみよう。Haskellでは再帰的な直和型として定義される。</p>
<div class="sourceCode" id="cb218"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Leaf</span> a <span class="op">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>
前にも述べたように、C++で直和型を実装する方法の1つは、クラス階層を使うことだ。オブジェクト指向言語では、<code>fmap</code>を基底クラス<code>Functor</code>の仮想関数として実装し、それをすべての派生クラスでオーバーライドするのが自然だ。残念ながらこれは不可能だ。なぜなら、<code>fmap</code>はテンプレートであり、それが作用する対象の型（<code>this</code>ポインター）だけでなく、それに適用された関数の戻り型によってもパラメーター化されているからだ。C++では仮想関数はテンプレート化できない。<code>fmap</code>を総称フリー関数として実装し、パターンマッチングを<code>dynamic_cast</code>に置き換えよう。</p>
<p>基底クラスでは、動的キャストをサポートするために少なくとも1つの仮想関数を定義する必要があるため、デストラクターを仮想関数にする（いずれにしても良い考えだ<a
href="#fn53" class="footnote-ref" id="fnref53"
role="doc-noteref"><sup>53</sup></a>）。</p>
<div class="sourceCode" id="cb219"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Tree <span class="op">{</span></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>Tree<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb219-4"><a href="#cb219-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p> <code>Leaf</code>は単なる変装した<code>Identity</code>関手だ。</p>
<div class="sourceCode" id="cb220"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Leaf <span class="op">:</span> <span class="kw">public</span> Tree<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a>    T _label<span class="op">;</span></span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a>    Leaf<span class="op">(</span>T l<span class="op">)</span> <span class="op">:</span> _label<span class="op">(</span>l<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb220-5"><a href="#cb220-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p> <code>Node</code>は直積型だ。</p>
<div class="sourceCode" id="cb221"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">:</span> <span class="kw">public</span> Tree<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a>    Tree<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span> _left<span class="op">;</span></span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true" tabindex="-1"></a>    Tree<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span> _right<span class="op">;</span></span>
<span id="cb221-5"><a href="#cb221-5" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">(</span>Tree<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span> l<span class="op">,</span> Tree<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span> r<span class="op">)</span> <span class="op">:</span> _left<span class="op">(</span>l<span class="op">),</span> _right<span class="op">(</span>r<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb221-6"><a href="#cb221-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>
<code>fmap</code>を実装するときには、<code>Tree</code>の型で動的ディスパッチを利用する。<code>Leaf</code>の場合は<code>Identity</code>版の<code>fmap</code>を適用し、<code>Node</code>の場合は2つの<code>Tree</code>関手に合成された双関手のように扱う。C++プログラマーとしては、これらの用語を使ってコードを分析することに慣れていないかもしれないが、圏論的な考え方の良いエクササイズになる。</p>
<div class="sourceCode" id="cb222"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a>Tree<span class="op">&lt;</span>B<span class="op">&gt;</span> <span class="op">*</span> fmap<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;</span> f<span class="op">,</span> Tree<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">*</span> t<span class="op">)</span></span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true" tabindex="-1"></a>    Leaf<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">*</span> pl <span class="op">=</span> <span class="kw">dynamic_cast</span> <span class="op">&lt;</span>Leaf<span class="op">&lt;</span>A<span class="op">&gt;*&gt;(</span>t<span class="op">);</span></span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pl<span class="op">)</span></span>
<span id="cb222-6"><a href="#cb222-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">new</span> Leaf<span class="op">&lt;</span>B<span class="op">&gt;(</span>f <span class="op">(</span>pl<span class="op">-&gt;</span>_label<span class="op">));</span></span>
<span id="cb222-7"><a href="#cb222-7" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">*</span> pn <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>Node<span class="op">&lt;</span>A<span class="op">&gt;*&gt;(</span>t<span class="op">);</span></span>
<span id="cb222-8"><a href="#cb222-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pn<span class="op">)</span></span>
<span id="cb222-9"><a href="#cb222-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">new</span> Node<span class="op">&lt;</span>B<span class="op">&gt;(</span> fmap<span class="op">&lt;</span>A<span class="op">&gt;(</span>f<span class="op">,</span> pn<span class="op">-&gt;</span>_left<span class="op">)</span></span>
<span id="cb222-10"><a href="#cb222-10" aria-hidden="true" tabindex="-1"></a>                          <span class="op">,</span> fmap<span class="op">&lt;</span>A<span class="op">&gt;(</span>f<span class="op">,</span> pn<span class="op">-&gt;</span>_right<span class="op">));</span></span>
<span id="cb222-11"><a href="#cb222-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb222-12"><a href="#cb222-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
簡単のため、メモリーとリソース管理の問題は無視することにしたが、本番コードではおそらくスマートポインターを使うことになるだろう（<code>unique_ptr</code>か<code>shared_ptr</code>かはポリシーによる）。</p>
<p><code>fmap</code>のHaskell実装と比較してほしい。</p>
<div class="sourceCode" id="cb223"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Tree</span> <span class="kw">where</span></span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Leaf</span> a) <span class="ot">=</span> <span class="dt">Leaf</span> (f a)</span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Node</span> t t&#39;) <span class="ot">=</span> <span class="dt">Node</span> (<span class="fu">fmap</span> f t) (<span class="fu">fmap</span> f t&#39;)</span></code></pre></div>
<p> この実装は、コンパイラーによって自動的に導出することもできる。</p>
<aside id="footnotes-29" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="53">
<li
id="fn53"><p>訳注：派生クラスのインスタンスを基底クラスとして扱うとき、基底クラスのデストラクターが仮想関数でないと、派生クラスのデストラクターが実行されなくなる。<a
href="#fnref53" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="8.5" id="writer関手"><span
class="header-section-number">8.5</span> Writer関手</h2>
<p>前に<a
href="#kleisli-categories">クライスリ圏</a>を説明したとき、戻ってくることを約束した。クライスリ圏の射は、<code>Writer</code>データ構造を返す「装飾された」関数として表現されていた。</p>
<div class="sourceCode" id="cb224"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Writer</span> a <span class="ot">=</span> (a, <span class="dt">String</span>)</span></code></pre></div>
<p>
すでに述べたように、装飾は自己関手と何らかの関係にある。そして実際、<code>Writer</code>の型構成子は、<code>a</code>について関手的だ。単純な直積型なので、<code>fmap</code>を実装する必要すらない。</p>
<p>しかし、クライスリ圏と関手の間には、どのような一般的な関係があるのだろうか？　クライスリ圏は圏なので、合成と恒等射が定義されている。合成はfish演算子によって与えられるのを思い出してほしい。</p>
<div class="sourceCode" id="cb225"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;=&gt;) ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Writer</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> <span class="dt">Writer</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Writer</span> c)</span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a>m1 <span class="op">&gt;=&gt;</span> m2 <span class="ot">=</span> \x <span class="ot">-&gt;</span></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (y, s1) <span class="ot">=</span> m1 x</span>
<span id="cb225-4"><a href="#cb225-4" aria-hidden="true" tabindex="-1"></a>        (z, s2) <span class="ot">=</span> m2 y</span>
<span id="cb225-5"><a href="#cb225-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> (z, s1 <span class="op">++</span> s2)</span></code></pre></div>
<p> また、恒等射は<code>return</code>という関数によって計算される。</p>
<div class="sourceCode" id="cb226"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Writer</span> a</span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> x <span class="ot">=</span> (x, <span class="st">&quot;&quot;</span>)</span></code></pre></div>
<p>
この2つの関数の型を十分に長く見れば（つまり、十分に<em>長く</em>見れば）、それらを組み合わせて、<code>fmap</code>として機能するための適切な型シグネチャーを持つ関数を作成する方法が見つかる。それは次のようになる。</p>
<div class="sourceCode" id="cb227"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f <span class="ot">=</span> <span class="fu">id</span> <span class="op">&gt;=&gt;</span> (\x <span class="ot">-&gt;</span> <span class="fu">return</span> (f x))</span></code></pre></div>
<p>
この例では、fish演算子は2つの関数を組み合わせている。1つはおなじみの<code>id</code>であり、もう1つは、引数に<code>f</code>を適用した結果に<code>return</code>を適用するラムダ関数だ。理解するのが最も難しいのは<code>id</code>を使うところだろう。Fish演算子の引数となる関数は、「通常の」型を受け取って装飾された型を返す関数ではないのだろうか？　実は、そんなことはない。<code>a -&gt; Writer b</code>の<code>a</code>が「普通の」型でなければならないとは誰も言っていない。これは型変数なので何でも良く、特に、<code>Writer b</code>のような装飾された型でも構わない。</p>
<p>そういうわけで、この<code>id</code>は<code>Writer a</code>を受け取り、<code>Writer a</code>に変換する。Fish演算子は<code>a</code>の値を取り出し、<code>x</code>としてラムダに渡す。ここで、<code>f</code>はそれを<code>b</code>に変換し、<code>return</code>はそれを装飾して<code>Writer b</code>にする。これらすべてをまとめると、<code>Writer a</code>を受け取り、<code>Writer b</code>を返す関数が完成する。これは、<code>fmap</code>が生成するはずのものと全く同じだ。</p>
<p>注目してほしいのは、この議論が非常に汎用的であることだ。つまり、<code>Writer</code>は任意の型構成子で置き換えられる。Fish演算子と<code>return</code>をサポートしていれば、<code>fmap</code>も定義できる。したがってクライスリ圏での装飾は常に関手となる。（ただし、すべての関手からクライスリ圏を構成できるわけではない。）</p>
<p>先ほど定義した<code>fmap</code>は、<code>derivating Functor</code>を使ってコンパイラーによって導出された<code>fmap</code>と同じものだろうかと疑問に思うかもしれない。とても興味深いことに、同じものだ。そうなっているのは、Haskellが多相関数を実装する方法に由来する。それは<span
id="parametric_polymorphism"
class="keyword"><em>パラメトリック多相</em></span>と呼ばれ、いわゆる<span
id="theorems_for_free" class="keyword"><em>theorems for
free</em></span><a href="#fn54" class="footnote-ref" id="fnref54"
role="doc-noteref"><sup>54</sup></a>の根源となっている。それらの定理の1つは、ある型構成子に対して恒等射を保存するような<code>fmap</code>の実装があるなら、それは一意である、と述べている<a
href="#fn55" class="footnote-ref" id="fnref55"
role="doc-noteref"><sup>55</sup></a>。</p>
<aside id="footnotes-30" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="54">
<li id="fn54"><p>訳注：P. Wadler: <em>Theorems fore free!</em> FPCA 89,
pp. 347-359.<a href="#fnref54" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn55"><p>監訳注：ものすごく大雑把に説明すると次のようになる。ユーザー定義の<code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>を<code>fmap1</code>と書いたとし、<code>deriving Functor</code>で得られるような<code>fmap</code>を<code>fmap0</code>と書いたとする。ここで、パラメトリック多相性から<code>fmap1</code>は</p>
<p><code>fmap1 (f . g) = fmap1 f . fmap0 g</code></p>
<p>
を満たすことが分かる。気持ちとしては、<code>fmap1</code>は<code>a</code>型の値によって挙動を変えることはできないので、<code>a</code>型の箇所を<code>fmap1</code>の入力においてあらかじめ変換（<code>. g</code>）しておいたもの（左辺）と、後で<code>fmap1</code>の出力を変換（<code>. fmap0 g</code>）したもの（右辺）とが同じになるということである。ここで<code>f = id</code>とすると、<code>fmap1</code>は恒等射を保存するという仮定から<code>fmap1 id = id</code>となるため、<code>fmap1 g = fmap0 g</code>が得られる。つまり、どんなユーザ定義の<code>fmap1</code>も<code>deriving Functor</code>で得られる<code>fmap0</code>と等しくなる。また、上記の議論から<code>fmap</code>がパラメトリック多相的であれば関手性を示すのに<code>fmap id = id</code>のみ示せばよいことも分かる。</p>
<p>型からどのような定理が得られるかについては、J.
Breitner氏によるウェブアプリ<a href="https://free-theorems.nomeata.de/"
class="uri">https://free-theorems.nomeata.de/</a>を試してみるとよいかもしれない。<a
href="#fnref55" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="8.6" id="共変関手と反変関手"><span
class="header-section-number">8.6</span> 共変関手と反変関手</h2>
<p>Writer関手を振り返り終えたのでReader関手に戻ろう。それは部分適用されたアロー（関数）型構成子に基づいていた。</p>
<div class="sourceCode" id="cb228"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a>(<span class="ot">-&gt;</span>) r</span></code></pre></div>
<p> これは型シノニム<a href="#fn56" class="footnote-ref" id="fnref56"
role="doc-noteref"><sup>56</sup></a>で書き直せる。</p>
<div class="sourceCode" id="cb229"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Reader</span> r a <span class="ot">=</span> r <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>
これに対する<code>Functor</code>インスタンスは、これまで見てきたように、次のようになる<a
href="#fn57" class="footnote-ref" id="fnref57"
role="doc-noteref"><sup>57</sup></a>。</p>
<div class="sourceCode" id="cb230"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Reader</span> r) <span class="kw">where</span></span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f g <span class="ot">=</span> f <span class="op">.</span> g</span></code></pre></div>
<p>
だが、ペア型構成子や<code>Either</code>型構成子と同じく、この関数型構成子は2つの型引数を取る。ペアや<code>Either</code>は両方の引数について関手的であり、すなわち双関手だった。この関数のコンストラクターも双関手だろうか？</p>
<p>最初の引数で関手的にすることを試みてみよう。<code>Reader</code>とは引数が反転している、よく似た型シノニムから始めることにする。</p>
<div class="sourceCode" id="cb231"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Op</span> r a <span class="ot">=</span> a <span class="ot">-&gt;</span> r</span></code></pre></div>
<p>
今回は、戻り値の型<code>r</code>を固定し、引数の型<code>a</code>を変化させる。次のような型シグネチャーを持つ<code>fmap</code>を実装するために、何らかの方法で型を一致させられるか見てみよう。</p>
<div class="sourceCode" id="cb232"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> r)</span></code></pre></div>
<p>
<code>a</code>を取りそれぞれ<code>b</code>と<code>r</code>を返す2つの関数だけでは、<code>b</code>を取り<code>r</code>を返す関数を作成する方法が全くない。代わりに1つ目の関数を逆にして、<code>b</code>を受け取り<code>a</code>を返すようにできれば、状況は違ってくるだろう。任意の関数について逆関数が存在するわけではないが、反対圏に行くことはできる。</p>
<p>要点を再掲すると、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>ごとに反対圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}</annotation></semantics></math>が存在する。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と同じ対象を持つ圏だが、すべての射が逆になっている。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}</annotation></semantics></math>から他の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>への関手を考えてみよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∷</mo><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>→</mo><mi>𝐃</mi></mrow><annotation encoding="application/x-tex">F \Colon \mathbf{C}^\mathit{op} \to \mathbf{D}</annotation></semantics></math>
このような関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}</annotation></semantics></math>の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f^\mathit{op} \Colon a \to b</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msup><mi>f</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>∷</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>F</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">F f^\mathit{op} \Colon F a \to F b</annotation></semantics></math>に写す。しかし、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>f</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">f^\mathit{op}</annotation></semantics></math>は、もとの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>のある射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>b</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">f \Colon b \to a</annotation></semantics></math>と密かに対応している。反転に注意してほしい。</p>
<p>さて、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>は通常の関手だが、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>に基づいて定義できる別の写像があり、それは関手ではない。それを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>と呼ぼう。この<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>への写像だ。対象は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>と同じ方法で写すが、射は反転させる。つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>b</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">f \Colon b \to a</annotation></semantics></math>を取り、それをまず逆向きの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f^\mathit{op} \Colon a \to b</annotation></semantics></math>に写し、次に関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>を使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><msup><mi>f</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>∷</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>F</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">F f^\mathit{op} \Colon F a \to F b</annotation></semantics></math>を得る。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">G a</annotation></semantics></math>と同じで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">F b</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">G b</annotation></semantics></math>と同じであることを考慮すると、この旅の全体は
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>f</mi><mo>∷</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>→</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>G</mi><mi>a</mi><mo>→</mo><mi>G</mi><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">G f \Colon (b \to a) \to (G a \to G b)</annotation></semantics></math>
のように記述できる。
これは「ひねりのある関手」だ。このように射の方向を反転させる圏の写像は、<em>反変</em>
(contravariant)
関手と呼ばれる。反変関手は、反対圏からの通常の関手にすぎないことに注意してほしい。その一方で、これまでに学んできた通常の関手は<em>共変</em>
(covariant) 関手と呼ばれる。</p>
<p> <img src="images/contravariant.jpg" style="width:30.0%"
alt="反変" /> </p>
<p>
以下の型クラスは、Haskellにおける反変関手（実のところ、反変<em>自己</em>関手）を定義している。</p>
<div class="sourceCode" id="cb233"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Contravariant</span> f <span class="kw">where</span></span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    contramap ::</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</span></code></pre></div>
<p> 前述の型構成子<code>Op</code>はこのインスタンスだ。</p>
<div class="sourceCode" id="cb234"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> (<span class="dt">Op</span> r) <span class="kw">where</span></span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- (b -&gt; a) -&gt; Op r a -&gt; Op r b</span></span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a>    contramap f g <span class="ot">=</span> g <span class="op">.</span> f</span></code></pre></div>
<p>
関数<code>f</code>が、<code>Op</code>の内容、つまり関数<code>g</code>より<em>前</em>（つまり右側）に挿入されることに注意してほしい。</p>
<p><code>Op</code>に対する<code>contramap</code>の定義は、単に引数を反転した関数合成演算子であることに注意すれば、さらに簡潔にできるだろう。引数を反転するためには<code>flip</code>という専用の関数がある。</p>
<div class="sourceCode" id="cb235"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a><span class="fu">flip</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c)</span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a><span class="fu">flip</span> f y x <span class="ot">=</span> f x y</span></code></pre></div>
<p> これを使うと次のようになる。</p>
<div class="sourceCode" id="cb236"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a>contramap <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">.</span>)</span></code></pre></div>
<aside id="footnotes-31" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="56">
<li id="fn56"><p>訳注：型に付けた別名のこと。<a href="#fnref56"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn57"><p>訳注：細かい話をすると、Haskellでは型シノニムは部分適用できないので、以下のコードはエラーとなる。<a
href="#fnref57" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="8.7" id="プロ関手"><span
class="header-section-number">8.7</span> プロ関手</h2>
<p>これまで見てきたように、アロー型演算子<code>-&gt;</code>は、1番目の引数では反変、2番目の引数では共変だ。このような怪物に名前はあるのだろうか？　行き先の圏が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>の場合、この怪物は<span
id="profunctor" class="keyword"><em>プロ関手</em></span> (profunctor)
と呼ばれる。反変関手は反対圏からの共変関手と等価なので、プロ関手は次のように定義される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>×</mo><mi>𝐃</mi><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{C}^\mathit{op} \times \mathbf{D} \to \mathbf{Set}</annotation></semantics></math>
Haskellの型は一次近似的には集合と見なせるので、引数が2つの型構成子<code>p</code>で、1番目の引数について反関手的で、2番目について関手的であるようなものを<code>Profunctor</code>と呼んでしまうことにする。<code>Data.Profunctor</code>ライブラリーから適切な型クラスを引用しよう。</p>
<div class="sourceCode" id="cb237"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Profunctor</span> p <span class="kw">where</span></span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  dimap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p b c <span class="ot">-&gt;</span> p a d</span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a>  dimap f g <span class="ot">=</span> lmap f <span class="op">.</span> rmap g</span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  lmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p b c <span class="ot">-&gt;</span> p a c</span>
<span id="cb237-5"><a href="#cb237-5" aria-hidden="true" tabindex="-1"></a>  lmap f <span class="ot">=</span> dimap f <span class="fu">id</span></span>
<span id="cb237-6"><a href="#cb237-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  rmap ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p a c</span>
<span id="cb237-7"><a href="#cb237-7" aria-hidden="true" tabindex="-1"></a>  rmap <span class="ot">=</span> dimap <span class="fu">id</span></span></code></pre></div>
<p>
これら3つの関数すべてにデフォルト実装がある。<code>Bifunctor</code>と同じように、<code>Profunctor</code>のインスタンスを宣言するとき、<code>dimap</code>を実装してデフォルトの<code>lmap</code>と<code>rmap</code>を受け入れるか、<code>lmap</code>と<code>rmap</code>の両方を実装してデフォルトの<code>dimap</code>を受け入れるか、どちらかを選択できる。</p>
<figure>
<img src="images/dimap.jpg" title="dimap" style="width:40.0%"
alt="dimap" />
<figcaption aria-hidden="true">dimap</figcaption>
</figure>
<p>
ここで、関数アロー演算子は<code>Profunctor</code>のインスタンスだと確認しておく。</p>
<div class="sourceCode" id="cb238"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true" tabindex="-1"></a>  dimap ab cd bc <span class="ot">=</span> cd <span class="op">.</span> bc <span class="op">.</span> ab</span>
<span id="cb238-3"><a href="#cb238-3" aria-hidden="true" tabindex="-1"></a>  lmap <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">.</span>)</span>
<span id="cb238-4"><a href="#cb238-4" aria-hidden="true" tabindex="-1"></a>  rmap <span class="ot">=</span> (<span class="op">.</span>)</span></code></pre></div>
<p> プロ関手の応用としてはHaskellの<code>lens</code>ライブラリーがある<a
href="#fn58" class="footnote-ref" id="fnref58"
role="doc-noteref"><sup>58</sup></a>。また、プロ関手についてはエンドとコエンドについて述べるときに再び触れる。</p>
<aside id="footnotes-32" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="58">
<li id="fn58"><p>訳注：参考：M. Pickering, J. Gibbons, N. Wu:
<em>Profunctor Optics: Modular Data Accessors</em>. The Art, Science,
and Engineering of Programming 1(2): Article No. 7.<a href="#fnref58"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="8.8" id="hom関手"><span
class="header-section-number">8.8</span> Hom関手</h2>
<p>上記の例は、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>のペアを取ってそれらの間の射の集合を割り当てる写像、すなわちhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
が関手であるという、より一般的な命題を反映している。それは積圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>×</mo><mrow></mrow><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}\times{}\mathbf{C}</annotation></semantics></math>から集合の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への関手だ。</p>
<p>射に対する作用を定義してみよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>×</mo><mrow></mrow><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}\times{}\mathbf{C}</annotation></semantics></math>の射は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>における射のペアだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>f</mi><mo>∷</mo><msup><mi>a</mi><mo>′</mo></msup><mo>→</mo><mi>a</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>g</mi><mo>∷</mo><mi>b</mi><mo>→</mo><msup><mi>b</mi><mo>′</mo></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
f \Colon a&#39; \to a \\
g \Colon b \to b&#39;
\end{gathered}
</annotation></semantics></math>
このペアを持ち上げたものは集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
から集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>a</mi><mo>′</mo></msup><mo>,</mo><msup><mi>b</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a&#39;, b&#39;)</annotation></semantics></math>
への射（関数）になる必要がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
の任意の要素<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への射）を選んで、それを
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>h</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">g \circ h \circ f</annotation></semantics></math>
に写せば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>a</mi><mo>′</mo></msup><mo>,</mo><msup><mi>b</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a&#39;, b&#39;)</annotation></semantics></math>
の要素となる。</p>
<p>ご覧のとおり、hom関手はプロ関手の特殊なケースだ。</p>
<h2 data-number="8.9" id="課題-7"><span
class="header-section-number">8.9</span> 課題</h2>
<ol type="1">
<li><p>次のデータ型</p>
<div class="sourceCode" id="cb239"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Pair</span> a b <span class="ot">=</span> <span class="dt">Pair</span> a b</span></code></pre></div>
<p>
が双関手であることを示せ。追加の課題として、<code>Bifunctor</code>の3つのメソッド［訳注：<code>bimap</code>と<code>first</code>と<code>second</code>］の実装をすべて与え、それらの定義が、デフォルトの実装（それが適用できる場合には）と整合していることを等式変形によって示せ。</p></li>
<li><p><code>Maybe</code>の標準的な定義と次の脱糖との同型性を示せ。</p>
<div class="sourceCode" id="cb240"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Maybe&#39;</span> a <span class="ot">=</span> <span class="dt">Either</span> (<span class="dt">Const</span> () a) (<span class="dt">Identity</span> a)</span></code></pre></div>
<p>
ヒント：2つの実装の間に2つの写像を定義する。追加の課題として、等式変形により、それらが互いに逆であることを示せ。</p></li>
<li><p>別のデータ構造を試してみよう。私はこれを<code>PreList</code>と呼んでいる。<code>List</code>の前身だからだ。<code>List</code>における再帰が型パラメーター<code>b</code>に置き換わっている。</p>
<div class="sourceCode" id="cb241"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">PreList</span> a b <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a b</span></code></pre></div>
<p>
<code>PreList</code>をそれ自体に再帰的に適用すれば、<code>List</code>の以前の定義を復元できる（具体的にどうするかは不動点について述べるときに説明する）。</p>
<p><code>PreList</code>が<code>Bifunctor</code>のインスタンスであることを示せ。</p></li>
<li><p>次のデータ型が<code>a</code>および<code>b</code>についての双関手を定義していることを示せ。</p>
<div class="sourceCode" id="cb242"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">K2</span> c a b <span class="ot">=</span> <span class="dt">K2</span> c</span></code></pre></div>
<p></p>
<div class="sourceCode" id="cb243"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Fst</span> a b <span class="ot">=</span> <span class="dt">Fst</span> a</span></code></pre></div>
<p></p>
<div class="sourceCode" id="cb244"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Snd</span> a b <span class="ot">=</span> <span class="dt">Snd</span> b</span></code></pre></div>
<p> 追加の課題として、Conor McBrideの論文<a
href="http://strictlypositive.org/CJ.pdf">Clowns to the Left of me,
Jokers to the Right</a><a href="#fn59" class="footnote-ref" id="fnref59"
role="doc-noteref"><sup>59</sup></a>と照らし合わせて解答を確認せよ。</p></li>
<li><p>Haskell以外の言語で双関手を定義せよ。その言語で<code>bimap</code>を総称ペアに対して実装せよ。</p></li>
<li><p><code>std::map</code>は、2つのテンプレート引数<code>Key</code>と<code>T</code>について双関手またはプロ関手と見なすべきか？　そう見なせるようにするには、このデータ型をどう再設計すればよいだろう？</p></li>
</ol>
<aside id="footnotes-33" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="59">
<li id="fn59"><p><a href="http://strictlypositive.org/CJ.pdf"
class="uri">http://strictlypositive.org/CJ.pdf</a></p>
<p>訳注：C. McBride: <em>Clowns to the left of me, jokers to the right
(pearl): dissecting data structures</em>. POPL 2008. pp. 287-295. <a
href="https://doi.org/10.1145/1328438.1328474"
class="uri">https://doi.org/10.1145/1328438.1328474</a><a
href="#fnref59" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 data-number="9" id="function-types"><span
class="header-section-number">9</span> 関数型</h1>
<p>ここまでは、関数型の意味について言い繕ってきた。関数型は他の型とは異なる。</p>
<p>たとえば<code>Integer</code>を考えてみる。これは単に整数の集合だ。<code>Bool</code>は2要素の集合だ。しかし、関数型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \to b</annotation></semantics></math>はそれ以上のもので、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の間の射の集合だ。任意の圏における2つの対象間の射の集合はhom集合と呼ばれる。たまたま<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>圏では、どのhom集合もそれ自体がまさにその圏の対象だ。結局それは<em>集合</em>だからだ。</p>
<figure>
<img src="images/set-hom-set.jpg"
title="Set圏のなかのhom集合は単なる集合だ。" style="width:35.0%"
alt="Set圏のなかのhom集合は単なる集合だ。" />
<figcaption
aria-hidden="true">Set圏のなかのhom集合は単なる集合だ。</figcaption>
</figure>
<p>
同じことは、hom集合が圏の外にあるような他の圏には言えない。それらは<em>外部</em>
(external) hom集合と呼ばれることもある。</p>
<figure>
<img src="images/hom-set.jpg" title="この圏Cのhom集合は外部集合だ。"
style="width:35.0%" alt="この圏Cのhom集合は外部集合だ。" />
<figcaption
aria-hidden="true">この圏Cのhom集合は外部集合だ。</figcaption>
</figure>
<p>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>圏の自己参照的な性質によって、関数型は特殊なものになっている。しかし、少なくともいくつかの圏では、hom集合を表す対象を構成する方法がある。そういった対象は<span
id="internal" class="keyword"><em>内部</em></span> (internal)
hom集合と呼ばれる。</p>
<h2 data-number="9.1" id="普遍的構成"><span
class="header-section-number">9.1</span> 普遍的構成</h2>
<p>関数型が集合であることをいったん忘れて、ゼロから関数型を、というより一般的に言えば内部hom集合を構成してみよう。いつものように、ここでは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>圏からヒントを得る。ただし、集合の性質に一切頼らないように気を付けることで、その構成が他の圏でも自動的に機能するようにする。</p>
<p>関数型は、引数の型と結果の型の関係性から複合型と見なせる。複合型の構成のうち、対象間の関係性が関わっているものについてはすでに見た。<a
href="#products-and-coproducts">積と余積に相当する型</a>を定義するのに普遍的構成を使った。同じトリックを使って関数型を定義できる。そのためには3つの対象が関わるパターンが必要になる。すなわち、構成しようとする関数型自体と、その関数型における引数の型と結果の型だ。</p>
<p>これら3つの型を結びつける自明なパターンは<span
id="function_application" class="keyword"><em>関数適用</em></span>
(function application) あるいは<span id="evaluation"
class="keyword"><em>評価</em></span> (evaluation)
と呼ばれる。ある関数型の候補を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>と呼ぼう（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>圏でない場合、これは他の対象と同様の単なる対象であることに注意）。また、引数の型を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と呼ぼう（これは対象だ）。関数適用はこれらのペアを結果の型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>（つまり対象）に写す。対象が3つあり、そのうち（引数の型と結果の型を表す）2つはすでに決まっている。</p>
<p>関数適用は写像だ。どうすればその写像をパターンに組み込めるだろう？　対象の内部を見ることが許されていたなら、関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>の要素）と引数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の要素）をペアにした後でそれを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">f x</annotation></semantics></math>（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>へ適用したものであり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の要素）に写せただろう。</p>
<figure>
<img src="images/functionset.jpg"
title="Setでは、関数の集合zから関数fを選び、集合（型）aから引数xを選べる。その結果、集合（型）bの中の要素f xが得られる。"
style="width:35.0%"
alt="Setでは、関数の集合zから関数fを選び、集合（型）aから引数xを選べる。その結果、集合（型）bの中の要素f xが得られる。" />
<figcaption
aria-hidden="true">Setでは、関数の集合zから関数fを選び、集合（型）aから引数xを選べる。その結果、集合（型）bの中の要素f
xが得られる。</figcaption>
</figure>
<p> しかし、個々のペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(f, x)</annotation></semantics></math>
を扱う代わりに、関数型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>と引数の型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の<em>積</em>全体について述べることもできる。積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>×</mo><mrow></mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">z\times{}a</annotation></semantics></math>は対象であり、関数適用を表す射として、その対象から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>を選べる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>は任意のペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(f, x)</annotation></semantics></math>
を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">f x</annotation></semantics></math>に写す関数となるだろう。</p>
<p>したがって、関数適用のパターンは、2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の積が別の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>に射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>で接続されている、というものになる。</p>
<figure>
<img src="images/functionpattern.jpg"
title="普遍的構成の出発点である対象と射のパターン" style="width:40.0%"
alt="普遍的構成の出発点である対象と射のパターン" />
<figcaption
aria-hidden="true">普遍的構成の出発点である対象と射のパターン</figcaption>
</figure>
<p>
このパターンは、普遍的構成を使って関数型を一意に特定できるほど十分に具体的だろうか？　すべての圏でそうだとは言えない。しかし、我々が関心を持っている圏ではそうだ。さらに、別の疑問もある。積を先に定義することなく関数対象
(function object)
を定義できるだろうか？　積が全く存在しない圏や、対象のすべてのペアに対しては積が存在しない圏もある。答えはノーだ。直積型がなければ関数型はない。これについては、後で冪について述べるときに再び説明する。</p>
<p>普遍的構成をおさらいしよう。まず対象と射のパターンから始める。これは粗い検索であり、通常はヒットするものが多すぎる。特に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>では、ほとんどすべてのものがすべてに接続されている。任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>を選んで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>との積を作れば、そこから<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への関数を作れる（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>が空集合の場合を除く）。</p>
<p>そこで秘密兵器の出番となる。順位付けだ。それを行うには通常、候補となる対象たちの間に（構成を何らかの形で分解する）一意な写像が存在することが必要となる。今回の場合においては、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>×</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">z \times a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>を伴う<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>がそれ自身の関数適用<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>g</mi><mo>′</mo></msup><annotation encoding="application/x-tex">g&#39;</annotation></semantics></math>を伴う別の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>z</mi><mo>′</mo></msup><annotation encoding="application/x-tex">z&#39;</annotation></semantics></math>よりも<em>優れて</em>いるとして選別するのは、関数適用<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>g</mi><mo>′</mo></msup><annotation encoding="application/x-tex">g&#39;</annotation></semantics></math>が関数適用<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>を通じて分解するような、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>z</mi><mo>′</mo></msup><annotation encoding="application/x-tex">z&#39;</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>への一意な写像<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>が存在する場合、かつその場合に限る（ヒント：この文は図を見ながら読むこと）。</p>
<figure>
<img src="images/functionranking.jpg"
title="関数対象の候補間の順位付けの確立" style="width:40.0%"
alt="関数対象の候補間の順位付けの確立" />
<figcaption
aria-hidden="true">関数対象の候補間の順位付けの確立</figcaption>
</figure>
<p>
ここでトリッキーな点がある。それが、この特定の普遍的構成の説明をいままで延期した主な理由だ。射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>∷</mo><msup><mi>z</mi><mo>′</mo></msup><mo>→</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">h \Colon z&#39;\to z</annotation></semantics></math>が与えられたときに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>z</mi><mo>′</mo></msup><annotation encoding="application/x-tex">z&#39;</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>をそれぞれ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と掛けた図式を閉じたい。だが、与えられているのは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>z</mi><mo>′</mo></msup><annotation encoding="application/x-tex">z&#39;</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>への写像<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>なのに、本当に必要なのは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>z</mi><mo>′</mo></msup><mo>×</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">z&#39;\times a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>×</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">z\times a</annotation></semantics></math>への写像だ。そしていま、<a
href="#product-and-coproduct-bifunctors">積の関手性</a>についてすでに第8章2節で議論したので、そのやり方は分かっている。積自体が関手（正確には自己双関手）なので射のペアを持ち上げられる。言い換えると、対象の積だけでなく、射の積も定義できる。</p>
<p>積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>z</mi><mo>′</mo></msup><mo>×</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">z&#39; \times a</annotation></semantics></math>の2番目の要素には触れていないので、射のペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>,</mo><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(h, \mathbf{id})</annotation></semantics></math>
を持ち上げよう。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><annotation encoding="application/x-tex">\mathbf{id}</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>についての恒等射だ。</p>
<p>そして、ある関数適用<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>で別の関数適用<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>g</mi><mo>′</mo></msup><annotation encoding="application/x-tex">g&#39;</annotation></semantics></math>を分解する（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>g</mi><mo>′</mo></msup><annotation encoding="application/x-tex">g&#39;</annotation></semantics></math>からくくり出す）とこうなる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mo>′</mo></msup><mo>=</mo><mi>g</mi><mo>∘</mo><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>×</mo><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">g&#39; = g \circ (h \times \mathbf{id})</annotation></semantics></math>
ここで鍵となるのは、射に対する積の作用だ。</p>
<p>普遍的構成の第3の部分は、普遍的に最も優れた対象を選ぶことだ。その対象を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⇒</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \Rightarrow b</annotation></semantics></math>と呼ぶことにしよう（これは1つの対象に対する記号的な名前だと考えてほしい。Haskellの型クラス制約と混同しないように。後で別の命名方法について議論する）。この対象は独自の関数適用を伴う。それは
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">(a \Rightarrow b) \times a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への射だ。これを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑒</mi><mi>𝑣</mi><mi>𝑎</mi><mi>𝑙</mi></mrow><annotation encoding="application/x-tex">\mathit{eval}</annotation></semantics></math>と呼ぶことにしよう。対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⇒</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \Rightarrow b</annotation></semantics></math>は、他のどの関数対象の候補も、その関数適用の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑒</mi><mi>𝑣</mi><mi>𝑎</mi><mi>𝑙</mi></mrow><annotation encoding="application/x-tex">\mathit{eval}</annotation></semantics></math>を通じて分解するようなかたちでその対象へと一意に写せる場合、最も優れている。我々の順位付けにおいてこの対象は他のどの対象よりも優れている。</p>
<figure>
<img src="images/universalfunctionobject.jpg"
title="普遍的な関数対象の定義。これは上記と同じ図式だが、対象$a \Rightarrow b$は*普遍*だ。"
style="width:40.0%"
alt="普遍的な関数対象の定義。これは上記と同じ図式だが、対象a \Rightarrow bは普遍だ。" />
<figcaption
aria-hidden="true">普遍的な関数対象の定義。これは上記と同じ図式だが、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⇒</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \Rightarrow b</annotation></semantics></math>は<em>普遍</em>だ。</figcaption>
</figure>
<p> 形式的には、</p>
<blockquote>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への<em>関数対象</em>は、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⇒</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \Rightarrow b</annotation></semantics></math>に射
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑒</mi><mi>𝑣</mi><mi>𝑎</mi><mi>𝑙</mi></mrow><mo>∷</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\mathit{eval} \Colon ((a \Rightarrow b) \times a) \to b</annotation></semantics></math>
を伴ったものであり、他の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>に射
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∷</mo><mi>z</mi><mo>×</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">g\Colon z \times a \to b</annotation></semantics></math>
を伴ったものに対して、一意な射
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>∷</mo><mi>z</mi><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">h \Colon z \to (a \Rightarrow b)</annotation></semantics></math>
が存在して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑒</mi><mi>𝑣</mi><mi>𝑎</mi><mi>𝑙</mi></mrow><annotation encoding="application/x-tex">\mathit{eval}</annotation></semantics></math>を通じて分解する:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><mrow><mi>𝑒</mi><mi>𝑣</mi><mi>𝑎</mi><mi>𝑙</mi></mrow><mo>∘</mo><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>×</mo><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">g=\mathit{eval} \circ (h \times \mathbf{id})</annotation></semantics></math></p>
</blockquote>
<p>
当然、このような対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⇒</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \Rightarrow b</annotation></semantics></math>が、与えられた圏内の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>について存在する保証はない。しかし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>では常に存在する。さらに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>では、この対象はhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Set}(a, b)</annotation></semantics></math>
と同型だ。</p>
<p>そのため、Haskellにおいて我々は、関数型<code>a -&gt; b</code>を圏論の関数対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⇒</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \Rightarrow b</annotation></semantics></math>として解釈する。</p>
<h2 data-number="9.2" id="カリー化"><span
class="header-section-number">9.2</span> カリー化</h2>
<p>関数対象の全候補を見てみよう。ただし今回は、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>を2つの引数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の関数として考えてみよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∷</mo><mi>z</mi><mo>×</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">g \Colon z \times a \to b</annotation></semantics></math>
積からの射であることと2引数関数であることは極めて近い。特に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>では<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>は値のペアを取る関数であり、そのペアの片方は集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>から、もう片方は集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>からの値だ。</p>
<p>一方、普遍性 (universal property)
は、このような<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>ごとに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>を関数対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⇒</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \Rightarrow b</annotation></semantics></math>に写す一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>が存在することを示している。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>∷</mo><mi>z</mi><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">h \Colon z \to (a \Rightarrow b)</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>において、これは単に関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>型の引数を1つ受け取って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への関数を返すことを意味する。これによって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>は高階関数になる。したがって、普遍的構成は、2引数関数と、関数を返す1引数関数との間に1対1の対応を確立する。この対応は<span
id="currying" class="keyword"><em>カリー化</em></span> (currying)
と呼ばれ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>をカリー化したものと言える。</p>
<p>これは1対1の対応だ。任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>に対し一意な<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>が存在し、任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>に対して次の式を使って引数2つの関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>を常に再生成できるからだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><mrow><mi>𝑒</mi><mi>𝑣</mi><mi>𝑎</mi><mi>𝑙</mi></mrow><mo>∘</mo><mo stretchy="false" form="prefix">(</mo><mi>h</mi><mo>×</mo><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">g = \mathit{eval} \circ (h \times \mathbf{id})</annotation></semantics></math>
関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>の<em>非カリー化</em>
(uncurrying) したものと言える。</p>
<p>カリー化はHaskellの構文に本質的に組み込まれている。関数を返す関数</p>
<div class="sourceCode" id="cb245"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c)</span></code></pre></div>
<p>
は2引数関数と見なされることが多い。実際に我々は括弧を外した型をそのように読む。</p>
<div class="sourceCode" id="cb246"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</span></code></pre></div>
<p>
この解釈は、複数の引数を取る関数を定義する方法において明確だ。たとえば</p>
<div class="sourceCode" id="cb247"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a><span class="ot">catstr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb247-2"><a href="#cb247-2" aria-hidden="true" tabindex="-1"></a>catstr s s&#39; <span class="ot">=</span> s <span class="op">++</span> s&#39;</span></code></pre></div>
<p>
と同じ関数を、関数を返す1引数関数、すなわちラムダとして記述できる。</p>
<div class="sourceCode" id="cb248"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a>catstr&#39; s <span class="ot">=</span> \s&#39; <span class="ot">-&gt;</span> s <span class="op">++</span> s&#39;</span></code></pre></div>
<p>
これら2つの定義は等価であり、どちらも1つの引数だけに部分適用でき、次のような1引数関数が得られる。</p>
<div class="sourceCode" id="cb249"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a><span class="ot">greet ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true" tabindex="-1"></a>greet <span class="ot">=</span> catstr “<span class="dt">Hello</span> “</span></code></pre></div>
<p>
厳密に言えば、2引数関数というのはペア（直積型）を取る関数のことだ。</p>
<div class="sourceCode" id="cb250"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a>(a, b) <span class="ot">-&gt;</span> c</span></code></pre></div>
<p>
2つの表現の間の変換は自明であり、それを行う2つの（高階）関数は、もちろん、<code>curry</code>と<code>uncurry</code>と呼ばれる。</p>
<div class="sourceCode" id="cb251"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a><span class="fu">curry</span><span class="ot"> ::</span> ((a, b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c)</span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true" tabindex="-1"></a><span class="fu">curry</span> f a b <span class="ot">=</span> f (a, b)</span></code></pre></div>
<p> および</p>
<div class="sourceCode" id="cb252"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a><span class="fu">uncurry</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> ((a, b) <span class="ot">-&gt;</span> c)</span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a><span class="fu">uncurry</span> f (a, b) <span class="ot">=</span> f a b</span></code></pre></div>
<p>
<code>curry</code>は、関数対象の普遍的構成の<em>factorizer</em>であることに注目してほしい。これは、次の形に書き直した場合に特に顕著だ<a
href="#fn60" class="footnote-ref" id="fnref60"
role="doc-noteref"><sup>60</sup></a>。</p>
<div class="sourceCode" id="cb253"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorizer ::</span> ((a, b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c))</span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a>factorizer g <span class="ot">=</span> \a <span class="ot">-&gt;</span> (\b <span class="ot">-&gt;</span> g (a, b))</span></code></pre></div>
<p> （備忘録：factorizerは候補から分解関数を生成する。）</p>
<p>C++のような非関数型言語でもカリー化は可能だが、簡単ではない。C++の複数引数関数は、Haskellでの組を取る関数に対応すると見なせる（ただし、さらに混乱を招くことに、C++では明示的な<code>std::tuple</code>を取る関数や、可変長引数関数や、初期化子リストを取る関数も定義できる）。</p>
<p>テンプレート<code>std::bind</code>を使えばC++でも関数を部分適用できる。たとえば、文字列2つを取る関数があるとする。</p>
<div class="sourceCode" id="cb254"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string catstr<span class="op">(</span><span class="bu">std::</span>string s1<span class="op">,</span> <span class="bu">std::</span>string s2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s1 <span class="op">+</span> s2<span class="op">;</span></span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p> 文字列1つを取る関数は次のように定義できる。</p>
<div class="sourceCode" id="cb255"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>placeholders<span class="op">;</span></span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> greet <span class="op">=</span> <span class="bu">std::</span>bind<span class="op">(</span>catstr<span class="op">,</span> <span class="st">&quot;Hello &quot;</span><span class="op">,</span> _1<span class="op">);</span></span>
<span id="cb255-4"><a href="#cb255-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> greet<span class="op">(</span><span class="st">&quot;Haskell Curry&quot;</span><span class="op">);</span></span></code></pre></div>
<p>
ScalaはC++やJavaよりも関数型寄りで、中間的な立場に立っている。定義したい関数が部分適用されると予想されるときは、複数引数のリストを使って定義する。</p>
<div class="sourceCode" id="cb256"><pre
class="sourceCode scala"><code class="sourceCode scala"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">catstr</span><span class="op">(</span>s1<span class="op">:</span> <span class="ex">String</span><span class="op">)(</span>s2<span class="op">:</span> <span class="ex">String</span><span class="op">)</span> <span class="op">=</span> s1 <span class="op">+</span> s2</span></code></pre></div>
<p>
当然、これにはある程度の先見の明や予測がライブラリーの作者に求められる。</p>
<aside id="footnotes-34" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="60">
<li id="fn60"><p>訳注：変数の名前をこの節の冒頭のものに対応させて</p>
<p><code>factorizer :: ((z, a) -&gt; b) -&gt; (z -&gt; (a -&gt; b))</code></p>
<p><code>factorizer g = \z -&gt; (\a -&gt; g (z, a))</code></p>
<p>と書き直すと圏論的概念との対応が分かりやすいかもしれない。<a
href="#fnref60" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="9.3" id="冪"><span
class="header-section-number">9.3</span> 冪</h2>
<p>数学の文献では、関数対象、すなわち2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の間の内部hom対象を<span
id="exponential" class="keyword"><em>冪</em></span> (exponential)
と呼んで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>b</mi><mi>a</mi></msup><annotation encoding="application/x-tex">b^{a}</annotation></semantics></math>と記すことが多い。引数の型が指数に含まれていることに注目してほしい。この記法は一見奇妙に思えるかもしれないが、関数と積の関係を考えると完全に理にかなっている。内部hom対象の普遍的構成で積を使わなければならないことはすでに見たが、つながりはそれよりも深い。</p>
<p>関数と積の密接なつながりは、有限型の間の関数を考えるときに最もよく見える。有限型とは、<code>Bool</code>、<code>Char</code>、さらには<code>Int</code>や<code>Double</code>など、有限個の値しか持たない型のことだ。それらの間の関数は、少なくとも原理的には、完全にメモ化したり、データ構造に変換してルックアップしたりできる。そしてこれが、射である関数と、対象である関数型との等価性の本質だ。</p>
<p>たとえば、<code>Bool</code>を取る（純粋）関数は、<code>False</code>に対応する値と<code>True</code>に対応する値のペアによって完全に決まる。<code>Bool</code>から、たとえば<code>Int</code>へのすべての可能な関数の集合は<code>Int</code>のすべてのペアの集合だ。これは積<code>Int</code>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>×</mi><mrow></mrow></mrow><annotation encoding="application/x-tex">\times{}</annotation></semantics></math>
<code>Int</code>と同じ集合であり、記法を少し創意工夫するなら<code>Int</code><sup>2</sup>とも書ける。</p>
<p>別の例として、256種類の値を含むC++の型<code>char</code>を見てみよう（Haskellの<code>Char</code>はUnicodeを使っているのでもっと多い<a
href="#fn61" class="footnote-ref" id="fnref61"
role="doc-noteref"><sup>61</sup></a>）。
C++標準ライブラリーの一部には、実装に通常はルックアップが使われる関数がいくつかある。<code>isupper</code>や<code>isspace</code>のような関数はテーブルを使って実装される。テーブルは256個のブール値の組と等価だ。組は直積型であるため、256個のブーリアンの積<code>bool × bool × bool × ... × bool</code>を扱っていることになる。算術で学んだとおり、積を繰り返したものが冪乗だった。<code>bool</code>を256（つまり<code>char</code>）回「掛ける」と、<code>bool</code>の<code>char</code>乗、つまり<code>bool</code><sup><code>char</code></sup>になる。</p>
<p><code>bool</code>の256個の組として定義される型には何通りの値が含まれているだろう？　ちょうど<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>2</mn><mn>256</mn></msup><annotation encoding="application/x-tex">2^{256}</annotation></semantics></math>通りだ。これはまた、<code>char</code>から<code>bool</code>への関数の種類の数でもあり、各関数は一意な256要素の組に対応する。同様に、<code>bool</code>から<code>char</code>への関数の数は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>256</mn><mn>2</mn></msup><annotation encoding="application/x-tex">256^{2}</annotation></semantics></math>と計算できる。以下同様だ。このような場合には、関数型の冪記法が完全に理にかなっている。</p>
<p><code>int</code>や<code>double</code>を取る関数を完全にメモ化したいとは思わないだろう。だが、関数とデータ型の間には、常に実用的だとは限らないにしても、等価性がある。（有限型だけでなく）リスト・文字列・木などの無限型もある。それらの型を取る関数の積極的
(eager)
なメモ化には、無限のストレージが必要になるだろう。しかし、Haskellは遅延評価言語であるため、遅延評価された（無限）データ構造と関数の境界は曖昧だ。この関数とデータの双対性は、Haskellの関数型と圏論の冪対象との同一視を説明している。冪対象の方が<em>データ</em>という概念によく対応している。</p>
<aside id="footnotes-35" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="61">
<li
id="fn61"><p>訳注：Unicodeのコードポイントの数である1,114,112種類。<a
href="#fnref61" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="9.4" id="デカルト閉圏"><span
class="header-section-number">9.4</span> デカルト閉圏</h2>
<p>私はこれ以降も型や関数のモデルとして集合の圏を使うが、同じ目的に使えるような、圏のより大きな族があることは言及する価値がある。それらは<span
id="Cartesian_closed" class="keyword"><em>デカルト閉</em></span>
(Cartesian closed)
圏と呼ばれ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>はそのような圏の一例だ。</p>
<p>デカルト閉圏は以下のものを含む必要がある。</p>
<ol type="1">
<li>終対象</li>
<li>任意の対象のペアの積</li>
<li>対象の任意のペアの冪</li>
</ol>
<p>
冪を（無限に繰り返される可能性がある）積の反復と見なすなら、デカルト閉圏は任意のアリティ<a
href="#fn62" class="footnote-ref" id="fnref62"
role="doc-noteref"><sup>62</sup></a>の積をサポートするものと見なせる。特に、終対象は0個の対象の積、すなわち対象の0乗と見なせる。</p>
<p>コンピューター科学の観点から興味深いのは、デカルト閉圏が単純型付きラムダ計算（simply
typed lambda
calculus）のモデルを提供し、あらゆる型付きプログラミング言語の基礎をなしていることだ。</p>
<p>終対象と積には、始対象と余積という双対がある。それら2つも含むデカルト閉圏では、余積に対し積を分配できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>a</mi><mo>×</mo><mrow></mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi><mo>×</mo><mrow></mrow><mi>b</mi><mo>+</mo><mi>a</mi><mo>×</mo><mrow></mrow><mi>c</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>+</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>a</mi><mo>=</mo><mi>b</mi><mo>×</mo><mrow></mrow><mi>a</mi><mo>+</mo><mi>c</mi><mo>×</mo><mrow></mrow><mi>a</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
a\times{}(b + c) = a\times{}b + a\times{}c \\
(b + c)\times{}a = b\times{}a + c\times{}a
\end{aligned}
</annotation></semantics></math> そのような圏は<span
id="bicartesian_closed" class="keyword"><em>双デカルト閉</em></span>
(bicartesian closed)
圏と呼ばれる。次の節では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>に代表される双デカルト閉圏の興味深い特性について説明する。</p>
<aside id="footnotes-36" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="62">
<li id="fn62"><p>訳注：関数や演算が取る引数の個数。<a href="#fnref62"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="9.5" id="冪と代数的データ型"><span
class="header-section-number">9.5</span> 冪と代数的データ型</h2>
<p>関数型を冪として解釈すると、代数的データ型の体系に非常にうまく適合する。高校で習う代数における数0と1や和・積・冪に関する基本的な恒等式はどれも、双デカルト閉圏においてそれぞれ始対象と終対象や余積・積・冪を考えれば、ほとんどそのまま使えることが分かる。それらについて、証明する手段（随伴や米田の補題など）はまだ得ていないが、価値ある直観の源としてここに挙げておこう。</p>
<h3 data-number="9.5.1" id="乗"><span
class="header-section-number">9.5.1</span> 0乗</h3>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mn>0</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a^{0} = 1</annotation></semantics></math>
圏論的解釈では、0を始対象に、1を終対象に、等しさを同型に置き換える。冪は内部hom対象だ。ここに示した冪は、始対象から任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>への射の集合を表している。始対象の定義によれば、そのような射は1つだけ存在するので、hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(0, a)</annotation></semantics></math>
は単元集合となる。単元集合は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内の終対象なので、この恒等式は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内で自明に成り立つ。言いたいことは、これがどんな双デカルト閉圏でも成り立つということだ。</p>
<p>Haskellでは、0を<code>Void</code>で、1をunit型<code>()</code>で、冪を関数型でそれぞれ置き換える。これは、<code>Void</code>から任意の型<code>a</code>への関数の集合と、単元集合であるunit型が等価だと主張している。言い換えると、関数<code>Void -&gt; a</code>は1つしかない。この関数は以前見た。<code>absurd</code>と呼ばれる関数だ。</p>
<p>2つの理由から、これは少しトリッキーだ。1つは、Haskellは実際には住人がいない型を持たないことだ――すべての型には「終わりのない計算の結果」、つまりボトムが含まれている。第2の理由は、<code>absurd</code>のすべての実装は等価であるということだ<a
href="#fn63" class="footnote-ref" id="fnref63"
role="doc-noteref"><sup>63</sup></a>。なぜなら、それらが何をしようと、誰も実行できないからだ。<code>absurd</code>に渡せる値はない。（そして、終わりのない計算を渡せたとしても、決して値は返らない！）</p>
<aside id="footnotes-37" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="63">
<li
id="fn63"><p>監訳注：ここでは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">\bot</annotation></semantics></math>は考慮に入れているが<code>seq :: a -&gt; b -&gt; b</code>は考慮に入れていないことに注意する。ここで<code>seq a b</code>は、直観的には（それ自身を評価する際に）<code>a</code>を評価してから<code>b</code>を評価することを表し、<code>a</code>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">\bot</annotation></semantics></math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">\bot</annotation></semantics></math>と、そうでなければ<code>b</code>と等価である。詳細は省くが、<code>seq</code>があることで、9.6節で定義されるような<code>absurd</code>と、<code>absurd = absurd</code>で定義される<code>absurd</code>とを区別できる（区別できてしまう）。<a
href="#fnref63" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h3 data-number="9.5.2" id="の冪乗"><span
class="header-section-number">9.5.2</span> 1の冪乗</h3>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>1</mn><mi>a</mi></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1^{a} = 1</annotation></semantics></math>
この恒等式を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>で解釈すると、終対象の定義である「どの対象にも終対象への一意な射がある」を言い換えている。一般に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から終対象への内部hom対象は、終対象そのものと同型だ。</p>
<p>Haskellでは、型<code>a</code>からunit型への関数は1つしかない<a
href="#fn64" class="footnote-ref" id="fnref64"
role="doc-noteref"><sup>64</sup></a>。この関数は以前にも見たことがある。<code>unit</code>と呼ばれる関数だ。<code>()</code>に部分適用された<code>const</code>関数とも見なせる。</p>
<aside id="footnotes-38" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="64">
<li id="fn64"><p>訳注：ここから再びボトムを無視している。<a
href="#fnref64" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h3 data-number="9.5.3" id="乗-1"><span
class="header-section-number">9.5.3</span> 1乗</h3>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mn>1</mn></msup><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a^{1} = a</annotation></semantics></math>
これは、終対象からの射が対象<code>a</code>の「要素」を選ぶのに利用できるという観点を言い換えたものだ。このような射の集合は対象そのものと同型だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>とHaskellでは、集合<code>a</code>の要素と、それらの要素を選択する関数<code>() -&gt; a</code>との間に同型が成り立つ。</p>
<h3 data-number="9.5.4" id="和による冪"><span
class="header-section-number">9.5.4</span> 和による冪</h3>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mrow><mi>b</mi><mo>+</mo><mi>c</mi></mrow></msup><mo>=</mo><msup><mi>a</mi><mi>b</mi></msup><mo>×</mo><msup><mi>a</mi><mi>c</mi></msup></mrow><annotation encoding="application/x-tex">a^{b+c} = a^{b} \times a^{c}</annotation></semantics></math>
これは、圏論では2つの対象の余積による冪が2つの冪の積と同型だと明示している。Haskellでは、この代数的恒等式に非常に実用的な解釈がある。これは、2つの型の直和型を取る関数が、それら個々の型を取る関数のペアと等価だと示している。直和型を取る関数を定義するときに使う場合分け
(case analysis)
そのものだ。<code>case</code>式で1つの関数定義を記述する代わりに、通常はそれを2つ（またはそれ以上）の関数に分割して、それぞれの構成子を別々に処理する。たとえば、直和型
<code>(Either Int Double)</code> を取る関数を考えよう。</p>
<div class="sourceCode" id="cb257"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
<p>
これは、それぞれ<code>Int</code>と<code>Double</code>を取る2つの関数のペアとして定義できる。</p>
<div class="sourceCode" id="cb258"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a>f (<span class="dt">Left</span> n) <span class="ot">=</span></span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> n <span class="op">&lt;</span> <span class="dv">0</span></span>
<span id="cb258-3"><a href="#cb258-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="st">&quot;Negative int&quot;</span></span>
<span id="cb258-4"><a href="#cb258-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="st">&quot;Positive int&quot;</span></span>
<span id="cb258-5"><a href="#cb258-5" aria-hidden="true" tabindex="-1"></a>f (<span class="dt">Right</span> x) <span class="ot">=</span></span>
<span id="cb258-6"><a href="#cb258-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> x <span class="op">&lt;</span> <span class="fl">0.0</span></span>
<span id="cb258-7"><a href="#cb258-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="st">&quot;Negative double&quot;</span></span>
<span id="cb258-8"><a href="#cb258-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="st">&quot;Positive double&quot;</span></span></code></pre></div>
<p>
ここで、<code>n</code>は<code>Int</code>で、<code>x</code>は<code>Double</code>だ。</p>
<h3 data-number="9.5.5" id="冪の冪"><span
class="header-section-number">9.5.5</span> 冪の冪</h3>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>a</mi><mi>b</mi></msup><msup><mo stretchy="false" form="postfix">)</mo><mi>c</mi></msup><mo>=</mo><msup><mi>a</mi><mrow><mi>b</mi><mo>×</mo><mi>c</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(a^{b})^{c} = a^{b \times c}</annotation></semantics></math>
これは単にカリー化を純粋に冪対象の観点で表現したものだ。関数を返す関数は、積を引数に取る関数（2引数の関数）と等価だ。</p>
<h3 data-number="9.5.6" id="積の冪"><span
class="header-section-number">9.5.6</span> 積の冪</h3>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>×</mo><mi>b</mi><msup><mo stretchy="false" form="postfix">)</mo><mi>c</mi></msup><mo>=</mo><msup><mi>a</mi><mi>c</mi></msup><mo>×</mo><msup><mi>b</mi><mi>c</mi></msup></mrow><annotation encoding="application/x-tex">(a \times b)^{c} = a^{c} \times b^{c}</annotation></semantics></math>
Haskellでは、ペアを返す関数は、それぞれがペアの1つの要素を生成する関数のペアと等価だ。</p>
<p>これらの高校数学の単純な代数的恒等式が、このように圏論に持ち上げられ、関数プログラミングで実用的な応用があるのは、実に驚くべきことだ。</p>
<h2 data-number="9.6" id="カリーハワード同型"><span
class="header-section-number">9.6</span> カリー・ハワード同型</h2>
<p>論理と代数的データ型の対応についてはすでに述べた。<code>Void</code>型とunit型<code>()</code>は、偽と真に対応する。直積型と直和型は、論理積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>∧</mi><annotation encoding="application/x-tex">\wedge</annotation></semantics></math>
(AND)
と論理和<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>∨</mi><annotation encoding="application/x-tex">\vee</annotation></semantics></math>
(OR)
に対応する。この図式では、先ほど定義した関数型は論理包含<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⇒</mo><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math>に対応する。つまり、型<code>a -&gt; b</code>は「aならばb」と読める。</p>
<p>カリー・ハワード同型 (Curry-Howard isomorphism)
によれば、すべての型は命題として解釈できる。命題とは、真または偽に定まる言明や判断だ。そのような命題は、型が居住されているならば真とされ、そうでなければ偽とされる。論理包含では、対応する関数型が居住されている（その型の関数が存在する）ならば真となる。したがって、関数の実装は定理の証明になる。プログラムを書くのは定理を証明するのと等価だ。いくつか例を見てみよう。</p>
<p>関数対象の定義で導入した関数<code>eval</code>を取り上げよう。シグネチャーは次のとおりだ。</p>
<div class="sourceCode" id="cb259"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> ((a <span class="ot">-&gt;</span> b), a) <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>
これは関数とその引数のペアを取り、適切な型の結果を生成する。つまり、次の射をHaskellで実装したものだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑒</mi><mi>𝑣</mi><mi>𝑎</mi><mi>𝑙</mi></mrow><mo>∷</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\mathit{eval} \Colon (a \Rightarrow b) \times a \to b</annotation></semantics></math>
この射は関数型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⇒</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \Rightarrow b</annotation></semantics></math>（すなわち冪対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>b</mi><mi>a</mi></msup><annotation encoding="application/x-tex">b^{a}</annotation></semantics></math>）を定義する。この型を、カリー・ハワード同型を使って論理の命題に変換しよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>∧</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>⇒</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">((a \Rightarrow b) \wedge a) \Rightarrow b</annotation></semantics></math>
この命題の読み方はこうだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>が真であり、かつ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>が真ならば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>は必ず真である。これは完全に直観に適っていて、古代から<span
id="modus_ponen" class="keyword"><em>modus
ponens</em></span>として知られていた。次の関数を実装することで、この定理を証明できる。</p>
<div class="sourceCode" id="cb260"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> ((a <span class="ot">-&gt;</span> b), a) <span class="ot">-&gt;</span> b</span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true" tabindex="-1"></a>eval (f, x) <span class="ot">=</span> f x</span></code></pre></div>
<p>
<code>a</code>を取り<code>b</code>を返す関数<code>f</code>と、型<code>a</code>の具体的な値<code>x</code>とのペアがあれば、<code>f</code>を<code>x</code>に適用するだけで型<code>b</code>の具体的な値を得られる。この関数を実装することで、型<code>((a -&gt; b), a) -&gt; b</code>が居住されていることが示せた。modus
ponensは我々の論理では真だ。</p>
<p>では、あからさまに間違っている命題ではどうだろうか？　例：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>が真ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>は真でなければならない。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∨</mo><mi>b</mi><mo>⇒</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a \vee b \Rightarrow a</annotation></semantics></math>
これは明らかに間違っている。なぜなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>が偽で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>が真の場合が反例となるからだ。</p>
<p>この命題をカリー・ハワード同型を使って関数型に写すと、次のようになる。</p>
<div class="sourceCode" id="cb261"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Either</span> a b <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>
いくらやってみても、この関数は実装できない――<code>Right</code>の形の値で呼び出された場合、型<code>a</code>の値は生成できない（ここでは<em>純粋</em>関数について説明していることを思い出してほしい）。</p>
<p>最終的に、<code>absurd</code>関数が意味するものに辿り着く。</p>
<div class="sourceCode" id="cb262"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a><span class="ot">absurd ::</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> a</span></code></pre></div>
<p> <code>Void</code>が偽に変換されることを考えると、次のようになる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑓</mi><mi>𝑎</mi><mi>𝑙</mi><mi>𝑠</mi><mi>𝑒</mi></mrow><mo>⇒</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">\mathit{false} \Rightarrow a</annotation></semantics></math>
虚偽からは何でも導ける (<em>ex falso
quodlibet</em>)。Haskellにおけるこの命題（関数）の証明（実装）として可能なものを以下に1つ示す。</p>
<div class="sourceCode" id="cb263"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a>absurd (<span class="dt">Void</span> a) <span class="ot">=</span> absurd a</span></code></pre></div>
<p> ここで、<code>Void</code>は次のように定義される。</p>
<div class="sourceCode" id="cb264"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Void</span> <span class="ot">=</span> <span class="dt">Void</span> <span class="dt">Void</span></span></code></pre></div>
<p>
いつものように、型<code>Void</code>はトリッキーだ。この定義により、値を構成するには値を提供する必要があるため、値を構成できない<a
href="#fn65" class="footnote-ref" id="fnref65"
role="doc-noteref"><sup>65</sup></a>。したがって、この関数<code>absurd</code>は決して呼び出せない。</p>
<p>いずれも興味深い例だが、カリー・ハワード同型に実用面はあるのだろうか？　おそらく日々のプログラミングではないだろう。しかし、AgdaやCoqのようなプログラミング言語では、定理を証明するためにカリー・ハワード同型が利用されている。</p>
<p>コンピューターは数学者の仕事を助けている<a href="#fn66"
class="footnote-ref" id="fnref66"
role="doc-noteref"><sup>66</sup></a>だけでなく、数学の基礎そのものに革命をもたらしている。この分野の注目の最新のホットな研究テーマはホモトピー型理論
(Homotopy Type Theory, HoTT)
と呼ばれ、型理論の派生物だ。ブーリアン、整数、積と余積、関数型などでいっぱいだ。そして、疑念を払拭するかのように、その理論はCoqとAgdaで定式化されようとしている。コンピューターは世界にさまざまな形で革命を起こしている。</p>
<aside id="footnotes-39" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="65">
<li
id="fn65"><p>訳注：ここで構成しようとしている値も提供されるべき値もともにVoid型である。<a
href="#fnref65" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn66"><p>訳注：実際にこの種の言語のひとつであるLeanは、Scholze（フィールズ賞受賞者）が定理を確認するのに役立った。参考：</p>
<ul>
<li><a href="https://www.microsoft.com/en-us/research/project/lean/"
class="uri">https://www.microsoft.com/en-us/research/project/lean/</a></li>
<li><a href="https://github.com/leanprover-community/lean-liquid/"
class="uri">https://github.com/leanprover-community/lean-liquid/</a></li>
</ul>
<a href="#fnref66" class="footnote-back" role="doc-backlink">↩︎</a></li>
</ol>
</aside>
<h2 data-number="9.7" id="参考文献-1"><span
class="header-section-number">9.7</span> 参考文献</h2>
<ol type="1">
<li>Ralf Hinze, Daniel W. H. James, <a
href="http://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf">Reason
Isomorphically!</a><a href="#fn67" class="footnote-ref" id="fnref67"
role="doc-noteref"><sup>67</sup></a>.
この論文には、この章で述べた圏論におけるすべての高校数学の代数的恒等式の証明が含まれている。</li>
</ol>
<aside id="footnotes-40" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="67">
<li id="fn67"><p><a
href="http://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf"
class="uri">http://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf</a>
訳注：<a href="https://doi.org/10.1145/1863495.1863507"
class="uri">https://doi.org/10.1145/1863495.1863507</a><a
href="#fnref67" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 data-number="10" id="natural-transformations"><span
class="header-section-number">10</span> 自然変換</h1>
<p>関手については圏と圏との間で構造を保存する写像としてすでに述べた。</p>
<p>関手はある圏を別の圏に「埋め込む」。複数のものが1つに潰されることはあっても、接続が切断されることはない。関手は、それによって1つの圏を別の圏の中でモデル化していると捉えられる。もとの圏は、行き先の圏の一部である構造物のモデル、あるいは青写真として機能する。</p>
<p> <img src="images/1_functors.jpg" style="width:40.0%" /> </p>
<p>
1つの圏を別の圏に埋め込む方法はいろいろある。それらは等価なこともあれば、大きく異なることもある。もとの圏全体を1つの対象に潰すこともあれば、すべての対象を異なる対象に写し、すべての射を異なる射に写すこともある。同じ青写真を実現する方法はいろいろある。自然変換は、それらの実現方法を比較するのに役立つ。自然変換は関手間の写像であり、その関手的性質を保存する特別な写像だ。</p>
<p>圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の間に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>という2つの関手があるとする。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の1つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>だけに注目すると、それが2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">G a</annotation></semantics></math>に写されているのが分かる。したがって、関手の写像は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">G a</annotation></semantics></math>に写すべきだ。</p>
<p> <img src="images/2_natcomp.jpg" style="width:30.0%" /> </p>
<p>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">G a</annotation></semantics></math>は同じ圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>内の対象であることに注意してほしい。同じ圏内の対象間の写像は、圏の特性に反するものであってはならない。対象同士の間に取ってつけたような接続を作成したくはない。したがって、既存の接続、つまり射を使用するのは<em>自然</em>だ。自然変換は射たちを選択することであり、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>ごとに<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">G a</annotation></semantics></math>への射を1つ選択する。その自然変換を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>と呼ぶとき、この射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>における<span
id="component" class="keyword"><em>成分</em></span> (component)
と呼ばれ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\alpha_a</annotation></semantics></math>と表記される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub><mo>∷</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>G</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\alpha_a \Colon F a \to G a</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の対象であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\alpha_a</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の射であることに注意してほしい。</p>
<p>ある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">G a</annotation></semantics></math>の間に射がない場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>の間に自然変換はない。</p>
<p>もちろん、これは話の半分にすぎない。なぜなら、関手は対象だけでなく射も写すからだ。では自然変換はこれらの射の写像をどうするのだろうか？　実は射の写像は固定されていて、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>の間の自然変換では<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">F f</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">G f</annotation></semantics></math>に変換されなければならない。さらに、2つの関手による射の写像は、それに適合する自然変換を定義する際の選択肢を大幅に制限する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の間に射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>があるとする。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>内の2つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">F f</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">G f</annotation></semantics></math>に写される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>F</mi><mi>f</mi><mo>∷</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>F</mi><mi>b</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>G</mi><mi>f</mi><mo>∷</mo><mi>G</mi><mi>a</mi><mo>→</mo><mi>G</mi><mi>b</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
F f \Colon F a \to F b \\
G f \Colon G a \to G b
\end{gathered}
</annotation></semantics></math>
自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>内の追加の射を2つ与え、図式を完成させる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>α</mi><mi>a</mi></msub><mo>∷</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>G</mi><mi>a</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>α</mi><mi>b</mi></msub><mo>∷</mo><mi>F</mi><mi>b</mi><mo>→</mo><mi>G</mi><mi>b</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
\alpha_a \Colon F a \to G a \\
\alpha_b \Colon F b \to G b
\end{gathered}
</annotation></semantics></math></p>
<p> <img src="images/3_naturality.jpg" style="width:40.0%" /> </p>
<p>
いま、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">G b</annotation></semantics></math>への移行には2つの方法がある。これらが等しいことを確認するには、任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>に対して成り立つような<span
id="naturality_condition" class="keyword"><em>自然性条件</em></span>
(naturality condition) を課す必要がある。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>f</mi><mo>∘</mo><msub><mi>α</mi><mi>a</mi></msub><mo>=</mo><msub><mi>α</mi><mi>b</mi></msub><mo>∘</mo><mi>F</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">G f \circ \alpha_a = \alpha_b \circ F f</annotation></semantics></math>
自然性条件はかなり厳しい要件だ。たとえば、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">F f</annotation></semantics></math>が可逆である場合、自然性は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\alpha_a</annotation></semantics></math>に基づいて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>b</mi></msub><annotation encoding="application/x-tex">\alpha_b</annotation></semantics></math>を決定する。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>に沿って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\alpha_a</annotation></semantics></math>を<em>トランスポート</em>
(transport) する。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>b</mi></msub><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>G</mi><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo>∘</mo><msub><mi>α</mi><mi>a</mi></msub><mo>∘</mo><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>f</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mi>−</mi><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\alpha_b = (G f) \circ \alpha_a \circ (F f)^{-1}</annotation></semantics></math></p>
<p> <img src="images/4_transport.jpg" style="width:40.0%" /> </p>
<p>
2つの対象間に2つ以上の可逆な射がある場合、トランスポートはすべて一致する必要がある<a
href="#fn68" class="footnote-ref" id="fnref68"
role="doc-noteref"><sup>68</sup></a>。もっとも、一般には射は可逆ではない。しかし、2つの関手間に自然変換が存在するとは全く保証されていないことは理解できる。したがって、自然変換によって関連する関手が多いか少ないかは、それらが作用する圏の構造について多くのことを教えてくれるだろう。極限と米田の補題について話すときに、いくつかの例を見ることになる。</p>
<p>自然変換を成分ごとに見ると、対象を射に写していると言える。自然性条件があるので、射を可換正方図式に写しているとも言えるだろう――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>のすべての射に対して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>内に四角い自然性の可換図式が1つ存在する。</p>
<p> <img src="images/naturality.jpg" style="width:40.0%" /> </p>
<p>
自然変換のこの性質は、多くの圏論的構成で非常に便利になる。それらは可換図式を伴うことが多いからだ。関手を適切に選択すれば、それらの可換性条件の多くは自然性条件に変換できる。その例は、極限・余極限・随伴に辿り着いたときに見ることになるだろう。</p>
<p>最後に、自然変換を使って関手の同型を定義できる。2つの関手が自然に同型であると言うのは、全く同じだと言っているようなものだ。<span
id="natural_isomorphism" class="keyword"><em>自然同型</em></span>
(natural isomorphism)
は、成分がすべて同型（可逆な射）である自然変換として定義される。</p>
<h2 data-number="10.1" id="多相関数"><span
class="header-section-number">10.1</span> 多相関数</h2>
<p>プログラミングにおける関手（より正確には自己関手）の役割についてはすでに述べた。それらは型を型に写すような型構成子に対応する。また、そういった関手は関数を関数に写すが、この写像は高階関数<code>fmap</code>（あるいはC++における<code>transform</code>や<code>then</code>に類するもの）によって実装される。</p>
<p>つまり、自然変換を構成するのに、まずは1つの対象、ここでは型<code>a</code>から始めることにする。関手<code>F</code>はそれを型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>に写すとし、別の関手<code>G</code>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">G a</annotation></semantics></math>に写すとする。<code>a</code>における自然変換<code>alpha</code>の成分は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">G a</annotation></semantics></math>への関数だ。疑似Haskellではこうなる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub><mo>∷</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>G</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\alpha_a \Colon F a \to G a</annotation></semantics></math>
自然変換は、すべての型<code>a</code>に対して定義される多相関数だ。</p>
<div class="sourceCode" id="cb265"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">F</span> a <span class="ot">-&gt;</span> <span class="dt">G</span> a</span></code></pre></div>
<p>
この<code>forall a</code>はHaskellでは必須ではない（そして実際にそれを明記するには言語拡張<code>ExplicitForAll</code>を有効にする必要がある）。通常は次のように記述する。</p>
<div class="sourceCode" id="cb266"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="dt">F</span> a <span class="ot">-&gt;</span> <span class="dt">G</span> a</span></code></pre></div>
<p>
これは実際には<code>a</code>によってパラメーター化された関数の族であることに注意してほしい。これもまた、Haskellの構文の簡潔さを示す一例だ。C++では同様の構文はもう少し冗長になる。</p>
<div class="sourceCode" id="cb267"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">&gt;</span> G<span class="op">&lt;</span>A<span class="op">&gt;</span> alpha<span class="op">(</span>F<span class="op">&lt;</span>A<span class="op">&gt;);</span></span></code></pre></div>
<p> Haskellの多相 (polymorphic) 関数とC++の総称 (generic)
関数との間にはさらに大きな違いがあり、そういった関数を実装したり型検査したりする方法はそれを反映している。Haskellでは、多相関数はすべての型に対して一様に定義されなければならない。1つの解決法があらゆる型にわたって機能する必要がある。これは<em>パラメトリック多相</em>
(parametric polymorphism) と呼ばれる。</p>
<p>一方、C++はデフォルトで<span id="ad_hoc_polymorphism"
class="keyword"><em>アドホック多相</em></span><a href="#fn69"
class="footnote-ref" id="fnref69" role="doc-noteref"><sup>69</sup></a>
(ad hoc polymorphism)
をサポートしており、テンプレートはすべての型に対して明確に定義されている必要はない。ある型に対してテンプレートが機能するかどうかは、型パラメーターが具体的な型で置換されるインスタンス化時に決定される。型検査が遅延されるため、残念ながら、理解し難いエラーメッセージにつながることがよくある。</p>
<p>C++には関数のオーバーロードとテンプレートの特殊化のための機構もあり、同じ関数で異なる型に対して異なる定義を行える。Haskellでは、この機能は型クラスと型族
(type family) によって提供されている。</p>
<p>Haskellのパラメトリック多相は予想外の結果をもたらす。次のような型の多相関数</p>
<div class="sourceCode" id="cb268"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="dt">F</span> a <span class="ot">-&gt;</span> <span class="dt">G</span> a</span></code></pre></div>
<p>
を関手<code>F</code>と<code>G</code>について考えると、それらはすべて自動的に自然性条件を満たす。圏論の表記法で表すとこうなる（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>は関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to b</annotation></semantics></math>だ）。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>f</mi><mo>∘</mo><msub><mi>α</mi><mi>a</mi></msub><mo>=</mo><msub><mi>α</mi><mi>b</mi></msub><mo>∘</mo><mi>F</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">G f \circ \alpha_a = \alpha_b \circ F f</annotation></semantics></math>
Haskellでは、関手<code>f</code>の射<code>G</code>に対する作用は<code>fmap</code>を使って実装される。最初に疑似Haskellで、明示的な型注釈を付けて書こう。</p>
<p><div class="sourceCode" id="cb270"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f<sub>G</sub> <span class="op">.</span> alpha<sub>a</sub> <span class="ot">=</span> alpha<sub>b</sub> <span class="op">.</span> <span class="fu">fmap<sub>F</sub></span> f</span></code></pre></div></p>
<p> 型推論によって、これらの型注釈は不要になり、次の等式が成り立つ。</p>
<div class="sourceCode" id="cb269"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f <span class="op">.</span> alpha <span class="ot">=</span> alpha <span class="op">.</span> <span class="fu">fmap</span> f</span></code></pre></div>
<p>
これはまだ本物のHaskellではない――実際のHaskellでは関数の等しさをコードで表現できない――が、この恒等式はプログラマーによる等式による推論やコンパイラーによる最適化の実装に使える。</p>
<p>Haskellで自然性条件が自動で成り立つ理由は “theorems for free”
に関係している。Haskellで自然変換を定義するのに使われるパラメトリック多相は、実装に非常に強い制限を課す――すべての型に対して1つの解決法という制限だ。それらの制限は、そのような関数に関する等式定理に変換される。関手を変換する関数の場合、free
theoremは自然性条件だ<a href="#fn70" class="footnote-ref" id="fnref70"
role="doc-noteref"><sup>70</sup></a>。</p>
<p>関手のHaskellにおける捉え方の1つとして以前述べたのは、一般化されたコンテナーと見なすことだった。その類推を続けると、自然変換は、あるコンテナーの中身を別のコンテナーに再パッケージするレシピと見なせる。要素自体に触れることはなく、要素を変更したり新しい要素を作成したりはしない。それら（の一部）を、ときには複数回、新しいコンテナーにコピーするだけだ。</p>
<p>自然性条件は、最初に<code>fmap</code>を適用して要素を変更してから後で再パッケージするのか、それとも最初に再パッケージしてから<code>fmap</code>を独自に実装して新しいコンテナー内の要素を変更するのか、は問題ではないという宣言になる。再パッケージ化と<code>fmap</code>の2つの作用は直交している。「一方は卵を動かし、もう一方は茹でる。」<a
href="#fn71" class="footnote-ref" id="fnref71"
role="doc-noteref"><sup>71</sup></a></p>
<p>Haskellでの自然変換の例をいくつか見てみよう。1つ目はリスト関手と<code>Maybe</code>関手の間の自然変換だ。これはリストが空でない場合に先頭要素を返す。</p>
<div class="sourceCode" id="cb270"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a><span class="ot">safeHead ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb270-2"><a href="#cb270-2" aria-hidden="true" tabindex="-1"></a>safeHead [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb270-3"><a href="#cb270-3" aria-hidden="true" tabindex="-1"></a>safeHead (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Just</span> x</span></code></pre></div>
<p>
これは<code>a</code>について多相な関数だ。<code>a</code>がどんな型であっても制限なく機能するので、パラメトリック多相の一例だと言える。したがって、これは2つの関手の間の自然変換だ。だが、我々自身が納得するために、自然性条件を証明してみよう。</p>
<div class="sourceCode" id="cb271"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f <span class="op">.</span> safeHead <span class="ot">=</span> safeHead <span class="op">.</span> <span class="fu">fmap</span> f</span></code></pre></div>
<p> 考慮すべきケースは2つある。1つは空リストだ。</p>
<div class="sourceCode" id="cb272"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (safeHead []) <span class="ot">=</span> <span class="fu">fmap</span> f <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<div class="sourceCode" id="cb273"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a>safeHead (<span class="fu">fmap</span> f []) <span class="ot">=</span> safeHead [] <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p> もう1つは空でないリストだ。</p>
<div class="sourceCode" id="cb274"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (safeHead (x<span class="op">:</span>xs)) <span class="ot">=</span> <span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div>
<div class="sourceCode" id="cb275"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a>safeHead (<span class="fu">fmap</span> f (x<span class="op">:</span>xs)) <span class="ot">=</span></span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true" tabindex="-1"></a>    safeHead (f x <span class="op">:</span> <span class="fu">fmap</span> f xs) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div>
<p>
ここで、<code>fmap</code>の実装として以下の2つを利用した。リスト用</p>
<div class="sourceCode" id="cb276"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f [] <span class="ot">=</span> []</span>
<span id="cb276-2"><a href="#cb276-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">:</span> <span class="fu">fmap</span> f xs</span></code></pre></div>
<p> <code>Maybe</code>用</p>
<div class="sourceCode" id="cb277"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div>
<p>
興味深いのは、関手の1つが自明な<code>Const</code>関手であるケースだ。<code>Const</code>関手からの自然変換は戻り値の型について多相な関数のように見え、<code>Const</code>関手への自然変換は引数の型について多相な関数のように見える。</p>
<p>たとえば、<code>length</code>はリスト関手から<code>Const Int</code>関手への自然変換と見なせる。</p>
<div class="sourceCode" id="cb278"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Const</span> <span class="dt">Int</span> a</span>
<span id="cb278-2"><a href="#cb278-2" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> [] <span class="ot">=</span> <span class="dt">Const</span> <span class="dv">0</span></span>
<span id="cb278-3"><a href="#cb278-3" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Const</span> (<span class="dv">1</span> <span class="op">+</span> unConst (<span class="fu">length</span> xs))</span></code></pre></div>
<p>
ここで、<code>unConst</code>は<code>Const</code>コンストラクターを引き剥がすのに使われる。</p>
<div class="sourceCode" id="cb279"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unConst ::</span> <span class="dt">Const</span> c a <span class="ot">-&gt;</span> c</span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true" tabindex="-1"></a>unConst (<span class="dt">Const</span> x) <span class="ot">=</span> x</span></code></pre></div>
<p> 当然、実用上は<code>length</code>は次のように定義される。</p>
<div class="sourceCode" id="cb280"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p> これは実質的に、自然変換であるという事実を隠してしまう。</p>
<p><code>Const</code>関手<em>から</em>のパラメトリック多相関数を見つけるのは少し難しい。無から値を生成する必要があるからだ。最善を尽くすと、次のようになる。</p>
<div class="sourceCode" id="cb281"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a><span class="ot">scam ::</span> <span class="dt">Const</span> <span class="dt">Int</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb281-2"><a href="#cb281-2" aria-hidden="true" tabindex="-1"></a>scam (<span class="dt">Const</span> x) <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>
すでに見たもう1つの一般的な関手で、後ほど米田の補題で重要な役を果たすのは、<code>Reader</code>関手だ。定義を<code>newtype</code>に書き直そう。</p>
<div class="sourceCode" id="cb282"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Reader</span> e a <span class="ot">=</span> <span class="dt">Reader</span> (e <span class="ot">-&gt;</span> a)</span></code></pre></div>
<p>
これは2つの型によってパラメーター化されているが、（共変）関手的なのは2番目の型だけだ。</p>
<div class="sourceCode" id="cb283"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Reader</span> e) <span class="kw">where</span></span>
<span id="cb283-2"><a href="#cb283-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Reader</span> g) <span class="ot">=</span> <span class="dt">Reader</span> (\x <span class="ot">-&gt;</span> f (g x))</span></code></pre></div>
<p>
すべての型<code>e</code>について、<code>Reader e</code>から他の任意の関手<code>f</code>への自然変換の族を定義できる。この族の元が常に<code>f e</code>の要素と1対1に対応している（<a
href="#the-yoneda-lemma">米田の補題</a>）ことを後で説明する。</p>
<p>たとえば、1つの要素<code>()</code>を持つ、いくぶんつまらないunit型<code>()</code>について考えてみよう。関手<code>Reader ()</code>は、任意の型<code>a</code>を取り、それを関数型<code>() -&gt; a</code>に写す。これらは単に、集合<code>a</code>から1つの要素を選択するすべての関数だ。それらは<code>a</code>にある要素と同じ数だけある。ここで、この関手から<code>Maybe</code>関手への自然変換を考えてみよう。</p>
<div class="sourceCode" id="cb284"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="dt">Reader</span> () a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span></code></pre></div>
<p> あるのは<code>dumb</code>と<code>obvious</code>の2つだけだ。</p>
<div class="sourceCode" id="cb285"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a>dumb (<span class="dt">Reader</span> _) <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p> および</p>
<div class="sourceCode" id="cb286"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a>obvious (<span class="dt">Reader</span> g) <span class="ot">=</span> <span class="dt">Just</span> (g ())</span></code></pre></div>
<p>
(<code>g</code>についてできるのはunit値<code>()</code>に適用することだけだ。)</p>
<p>そして実際、米田の補題によって予言されるように、これらは<code>Maybe ()</code>型の2つの要素、<code>Nothing</code>と<code>Just ()</code>に対応している。米田の補題には後で戻ってこよう――ここではほんの少し垣間見ただけだ。</p>
<aside id="footnotes-41" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="68">
<li
id="fn68"><p>訳注：上で言うところの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>b</mi></msub><annotation encoding="application/x-tex">\alpha_b</annotation></semantics></math>に一致する。<a
href="#fnref68" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn69"><p>訳注：大雑把に言えば、型ごとに実装が変わるような多相性。<a
href="#fnref69" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn70"><p>free theoremの詳細については、著者のブログ<a
href="https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/">Parametricity:
Money for Nothing and Theormes for Free</a> (<a
href="https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/"
class="uri">https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/</a>)
を参照してほしい。<a href="#fnref70" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn71"><p>訳注：この語句は何かの引用ではなく著者自身によるものとのこと。<a
href="#fnref71" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="10.2" id="自然性を越えて"><span
class="header-section-number">10.2</span> 自然性を越えて</h2>
<p>2つの関手の間のパラメトリック多相関数（<code>Const</code>関手という特殊な例を含む）は常に自然変換だ。標準的な代数的データ型はすべて関手なので、これらの型の間の多相関数はすべて自然変換だ。</p>
<p>また、関数型も自由に使えて、それらは戻り値の型について関手的だ。それらを使って（<code>Reader</code>関手のような）関手を構成し、高階関数である自然変換を定義できる。</p>
<p>しかし、関数型は引数について共変ではない。それらは<span
id="contravariant"
class="keyword"><em>反変</em></span>だ。当然、反変関手は反対圏からの共変関手と等価だ。2つの反変関手の間の多相関数は、反対圏からHaskellの型への関手を処理する点を除けば、圏論的には自然変換だ。</p>
<p>反変関手の例を前に見たのを覚えているだろう。</p>
<div class="sourceCode" id="cb287"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Op</span> r a <span class="ot">=</span> <span class="dt">Op</span> (a <span class="ot">-&gt;</span> r)</span></code></pre></div>
<p> この関手は<code>a</code>について反変だ。</p>
<div class="sourceCode" id="cb288"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> (<span class="dt">Op</span> r) <span class="kw">where</span></span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true" tabindex="-1"></a>    contramap f (<span class="dt">Op</span> g) <span class="ot">=</span> <span class="dt">Op</span> (g <span class="op">.</span> f)</span></code></pre></div>
<p>
たとえば、<code>Op Bool</code>から<code>Op String</code>への多相関数を書ける。</p>
<div class="sourceCode" id="cb289"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true" tabindex="-1"></a>predToStr (<span class="dt">Op</span> f) <span class="ot">=</span> <span class="dt">Op</span> (\x <span class="ot">-&gt;</span> <span class="kw">if</span> f x <span class="kw">then</span> <span class="st">&quot;T&quot;</span> <span class="kw">else</span> <span class="st">&quot;F&quot;</span>)</span></code></pre></div>
<p>
ただし、2つの関手は共変ではないので、これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐇</mi><mi>𝐚</mi><mi>𝐬</mi><mi>𝐤</mi></mrow><annotation encoding="application/x-tex">\mathbf{Hask}</annotation></semantics></math>での自然変換ではない。しかし、どちらも反変なので、「反対」の自然性条件は満たしている。</p>
<div class="sourceCode" id="cb290"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb290-1"><a href="#cb290-1" aria-hidden="true" tabindex="-1"></a>contramap f <span class="op">.</span> predToStr <span class="ot">=</span> predToStr <span class="op">.</span> contramap f</span></code></pre></div>
<p>
<code>contramap</code>のシグネチャーは次のとおりなので、関数<code>f</code>は<code>fmap</code>で使うのとは逆方向でなければならないことに注意してほしい。</p>
<div class="sourceCode" id="cb291"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true" tabindex="-1"></a><span class="ot">contramap ::</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Op</span> <span class="dt">Bool</span> a <span class="ot">-&gt;</span> <span class="dt">Op</span> <span class="dt">Bool</span> b)</span></code></pre></div>
<p>
共変にしろ反変にしろ、関手ではない型構成子は存在するのだろうか？　次のような例が挙げられる。</p>
<div class="sourceCode" id="cb292"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>
同じ型<code>a</code>が負（反変）と正（共変）の両方の位置で使われているので、これは関手ではない。この型には<code>fmap</code>や<code>contramap</code>を実装できない。したがって、次のシグネチャーを持つ関数</p>
<div class="sourceCode" id="cb293"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true" tabindex="-1"></a>(a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> f a</span></code></pre></div>
<p>
は自然変換にはなれない。ここで、<code>f</code>は任意の関手だ。興味深いことに、このような場合を扱う一般化された自然変換として、対角自然変換と呼ばれるものがある。これについてはエンドについて議論するときに説明しよう。</p>
<h2 data-number="10.3" id="関手圏"><span
class="header-section-number">10.3</span> 関手圏</h2>
<p>関手間の写像――自然変換――ができたいま、関手が圏をなすのかを問うのは自然だ。そして、実際になす、というのが答だ！　<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の圏のペアごとに、関手の圏が1つある。この圏の対象は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>への関手であり、射はこれらの関手間の自然変換だ。</p>
<p>2つの自然変換の合成を定義する必要があるが、それは非常に簡単だ。自然変換の成分は射であり、射を合成する方法は分かっている。</p>
<p>実際に、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>への自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>を取ろう。対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>におけるその成分はこのような射だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub><mo>∷</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>G</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\alpha_a \Colon F a \to G a</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>を、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>への自然変換である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>と合成したい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>での<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>の成分は次の射だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mi>a</mi></msub><mo>∷</mo><mi>G</mi><mi>a</mi><mo>→</mo><mi>H</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\beta_a \Colon G a \to H a</annotation></semantics></math>
これらの射は合成可能であり、その合成は次のような別の射だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mi>a</mi></msub><mo>∘</mo><msub><mi>α</mi><mi>a</mi></msub><mo>∷</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>H</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\beta_a \circ \alpha_a \Colon F a \to H a</annotation></semantics></math>
この射を自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>⋅</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\beta \cdot \alpha</annotation></semantics></math>――自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>を自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>の後に合成したもの――の成分として使う。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>β</mi><mo>⋅</mo><mi>α</mi><msub><mo stretchy="false" form="postfix">)</mo><mi>a</mi></msub><mo>=</mo><msub><mi>β</mi><mi>a</mi></msub><mo>⋅</mo><msub><mi>α</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">(\beta \cdot \alpha)_a = \beta_a \cdot \alpha_a</annotation></semantics></math></p>
<p> <img src="images/5_vertical.jpg" style="width:40.0%" /> </p>
<p>
図式を（長く）見ていると、この合成の結果は本当に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>H</mi><annotation encoding="application/x-tex">H</annotation></semantics></math>への自然変換だと確信できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>f</mi><mo>∘</mo><mo stretchy="false" form="prefix">(</mo><mi>β</mi><mo>⋅</mo><mi>α</mi><msub><mo stretchy="false" form="postfix">)</mo><mi>a</mi></msub><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>β</mi><mo>⋅</mo><mi>α</mi><msub><mo stretchy="false" form="postfix">)</mo><mi>b</mi></msub><mo>∘</mo><mi>F</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">H f \circ (\beta \cdot \alpha)_a = (\beta \cdot \alpha)_b \circ F f</annotation></semantics></math></p>
<p> <img src="images/6_verticalnaturality.jpg" style="width:35.0%" />
</p>
<p>
自然変形の合成は結合的だ。それらの構成要素は通常の射であり、合成に関して結合的だからだ。</p>
<p>最後に、各関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>について恒等自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mn>1</mn><mi>F</mi></msub><annotation encoding="application/x-tex">1_F</annotation></semantics></math>があり、その成分は恒等射だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mrow><mi>F</mi><mi>a</mi></mrow></msub><mo>∷</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\mathbf{id}_{F a} \Colon F a \to F a</annotation></semantics></math>
以上より、確かに関手は圏をなしている。</p>
<p>記法について述べておこう。ソーンダーズ・マックレーンにしたがって、私は先ほど述べたような自然変換の合成にドットを使う。問題は、自然変換を合成する方法が2つあることだ。ここで使ったものは垂直合成
(vertical composition)
と呼ばれている。通常は関手を上下に積んだ図式で説明されるからだ。垂直合成は関手圏を定義するうえで重要だ。水平合成についてもすぐに説明する。</p>
<p> <img src="images/6a_vertical.jpg" style="width:30.0%" /> </p>
<p>
圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の間の関手圏は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐅</mi><mi>𝐮</mi><mi>𝐧</mi><mo stretchy="false" form="prefix" mathvariant="bold">(</mo><mi>𝐂</mi><mo mathvariant="bold">,</mo><mi>𝐃</mi><mo stretchy="false" form="postfix" mathvariant="bold">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Fun(C, D)}</annotation></semantics></math>または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix" mathvariant="bold">[</mo><mi>𝐂</mi><mo mathvariant="bold">,</mo><mi>𝐃</mi><mo stretchy="false" form="postfix" mathvariant="bold">]</mo></mrow><annotation encoding="application/x-tex">\mathbf{[C, D]}</annotation></semantics></math>、場合によっては<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐃</mi><mi>𝐂</mi></msup><annotation encoding="application/x-tex">\mathbf{D^C}</annotation></semantics></math>と書かれる。この最後の表記法は、関手圏自体が他の圏では関数対象（冪）と見なせることを示唆している。だが、本当にそうだろうか？</p>
<p>これまでに構成してきた抽象化の階層を見てみよう。最初は対象と射の集まりとしての圏から始めた。圏自体（厳密に言えば、対象たちが集合をなす<em>小さい</em>圏）は、それ自体がより高いレベルの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>における対象だ。その圏における射は関手だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>におけるhom集合は関手の集合だ。たとえば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi><mo stretchy="false" form="prefix" mathvariant="bold">(</mo><mi>𝐂</mi><mo mathvariant="bold">,</mo><mi>𝐃</mi><mo stretchy="false" form="postfix" mathvariant="bold">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Cat(C, D)}</annotation></semantics></math>は、2つの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の間の関手の集合だ。</p>
<p> <img src="images/7_cathomset.jpg" style="width:30.0%" /> </p>
<p>
関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix" mathvariant="bold">[</mo><mi>𝐂</mi><mo mathvariant="bold">,</mo><mi>𝐃</mi><mo stretchy="false" form="postfix" mathvariant="bold">]</mo></mrow><annotation encoding="application/x-tex">\mathbf{[C, D]}</annotation></semantics></math>も、2つの圏の間の関手の集合に、射としての自然変換を加えたものだ。その対象は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi><mo stretchy="false" form="prefix" mathvariant="bold">(</mo><mi>𝐂</mi><mo mathvariant="bold">,</mo><mi>𝐃</mi><mo stretchy="false" form="postfix" mathvariant="bold">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Cat(C, D)}</annotation></semantics></math>の元と同じだ。さらに、関手圏は圏なので、それ自体が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>の対象でなければならない（2つの小さい圏の間の関手圏も、それ自体が小さい圏だ）。ある圏のhom集合と、同じ圏の対象の間の関係は知っている。この状況は、前の章で見た冪対象と全く同じだ。後者を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>において構成する方法を見てみよう。</p>
<p>覚えていると思うが、冪を構成するには、まず積を定義する必要がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>では、これは実は比較的簡単だ。なぜなら、小さい圏は対象の<em>集合</em>であり、集合のデカルト積を定義する方法は知っているからだ。したがって、積圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo mathvariant="bold">×</mo><mi>𝐃</mi></mrow><annotation encoding="application/x-tex">\mathbf{C \times D}</annotation></semantics></math>内の対象は単なる対象のペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(c, d)</annotation></semantics></math>
であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>からそれぞれ1つ取ったものだ。同様に、そのような2つのペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(c, d)</annotation></semantics></math>
と
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>c</mi><mo>′</mo></msup><mo>,</mo><msup><mi>d</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(c&#39;, d&#39;)</annotation></semantics></math>
の間の射は、射のペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(f, g)</annotation></semantics></math>
であり、ここで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>c</mi><mo>→</mo><msup><mi>c</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">f \Colon c \to c&#39;</annotation></semantics></math>および<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∷</mo><mi>d</mi><mo>→</mo><msup><mi>d</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">g \Colon d \to d&#39;</annotation></semantics></math>だ。これらの射のペアは成分ごとに合成でき、恒等ペアとしての単なる恒等射のペアも常に存在する。手短に言うと、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>は完全なデカルト閉圏であり、そこにはあらゆる圏のペアに対する冪対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐃</mi><mi>𝐂</mi></msup><annotation encoding="application/x-tex">\mathbf{D^C}</annotation></semantics></math>が存在する。そして、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>の「対象」は圏を意味するので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐃</mi><mi>𝐂</mi></msup><annotation encoding="application/x-tex">\mathbf{D^C}</annotation></semantics></math>は圏であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の間の関手圏と同一視できる。</p>
<h2 data-number="10.4" id="圏"><span
class="header-section-number">10.4</span> 2-圏</h2>
<p>閑話休題、ここで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>を詳しく見てみよう。定義より、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>内のどのHom集合も関手の集合だ。しかし、これまで見てきたように、2対象間の関手は単なる集合よりも豊かな構造を持っている。それらは圏をなし、自然変換は射として作用する。関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>では射と見なされるので、自然変換は射の間の射だ。</p>
<p>より豊かなこの構造は、圏の一般化である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏の例であり、対象と（この文脈では<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-射とも呼べる）射の他に、射の間の射である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-射も存在する。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏と見なす場合、次のようになる。</p>
<ul>
<li>対象：（小さい）圏</li>
<li>1-射：圏の間の関手</li>
<li>2-射：関手の間の自然変換</li>
</ul>
<p> <img src="images/8_cat-2-cat.jpg" style="width:30.0%" /> </p>
<p>
2つの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の間のHom集合の代わりにHom圏――関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐃</mi><mi>𝐂</mi></msup><annotation encoding="application/x-tex">\mathbf{D^C}</annotation></semantics></math>がある。通常の関手合成があり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐃</mi><mi>𝐂</mi></msup><annotation encoding="application/x-tex">\mathbf{D^C}</annotation></semantics></math>からの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐄</mi><mi>𝐃</mi></msup><annotation encoding="application/x-tex">\mathbf{E^D}</annotation></semantics></math>からの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>と合成して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐄</mi><mi>𝐂</mi></msup><annotation encoding="application/x-tex">\mathbf{E^C}</annotation></semantics></math>からの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>∘</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">G \circ F</annotation></semantics></math>を与える。さらに、それぞれのHom圏内での合成もある――関手間での自然変換（すなわち2つの射）の垂直合成だ。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏に2種類の合成があるので、それらはどのように相互作用するのか、という疑問が生じる。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>内の関手すなわち1-射を2つ選択しよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>F</mi><mo>∷</mo><mi>𝐂</mi><mo>→</mo><mi>𝐃</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>G</mi><mo>∷</mo><mi>𝐃</mi><mo>→</mo><mi>𝐄</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
F \Colon \mathbf{C} \to \mathbf{D} \\
G \Colon \mathbf{D} \to \mathbf{E}
\end{gathered}
</annotation></semantics></math> これらの合成は次のとおりだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>∘</mo><mi>F</mi><mo>∷</mo><mi>𝐂</mi><mo>→</mo><mi>𝐄</mi></mrow><annotation encoding="application/x-tex">G \circ F \Colon \mathbf{C} \to \mathbf{E}</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>という2つの自然変換があって、それぞれ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>に作用するとする。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>α</mi><mo>∷</mo><mi>F</mi><mo>→</mo><msup><mi>F</mi><mo>′</mo></msup></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>β</mi><mo>∷</mo><mi>G</mi><mo>→</mo><msup><mi>G</mi><mo>′</mo></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
\alpha \Colon F \to F&#39; \\
\beta \Colon G \to G&#39;
\end{gathered}
</annotation></semantics></math></p>
<p> <img src="images/10_horizontal.jpg" style="width:40.0%" /> </p>
<p>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>の余域と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>の域が異なるため、このペアには垂直合成を適用できないことに注意してほしい。実際、これらは別々の関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐃</mi><mi>𝐂</mi></msup><annotation encoding="application/x-tex">\mathbf{D^C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐄</mi><mi>𝐃</mi></msup><annotation encoding="application/x-tex">\mathbf{E^D}</annotation></semantics></math>のメンバーだ。しかし、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mo>′</mo></msup><annotation encoding="application/x-tex">F&#39;</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>G</mi><mo>′</mo></msup><annotation encoding="application/x-tex">G&#39;</annotation></semantics></math>に合成を適用することはできる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mo>′</mo></msup><annotation encoding="application/x-tex">F&#39;</annotation></semantics></math>の余域も<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>G</mi><mo>′</mo></msup><annotation encoding="application/x-tex">G&#39;</annotation></semantics></math>の域も圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>だからだ。関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo>′</mo></msup><mo>∘</mo><msup><mi>F</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">G&#39; \circ F&#39;</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>∘</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">G \circ F</annotation></semantics></math>はどのような関係だろうか？</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>を自由に使えるので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>∘</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">G \circ F</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo>′</mo></msup><mo>∘</mo><msup><mi>F</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">G&#39; \circ F&#39;</annotation></semantics></math>への自然変換を定義できるだろうか？　構成をスケッチしよう。</p>
<p> <img src="images/9_horizontal.jpg" style="width:50.0%" /> </p>
<p>
いつものように、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から始める。その像は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi></mrow><annotation encoding="application/x-tex">F&#39;a</annotation></semantics></math>に分割される。また、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>の成分である射が2つの対象を接続している。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub><mo>∷</mo><mi>F</mi><mi>a</mi><mo>→</mo><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi></mrow><annotation encoding="application/x-tex">\alpha_a \Colon F a \to F&#39;a</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐄</mi><annotation encoding="application/x-tex">\mathbf{E}</annotation></semantics></math>に移行するとき、これら2つの対象はさらに4つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">G(F a)</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">G&#39;(F a)</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">G&#39;(F&#39;a)</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">G&#39;(F&#39;a)</annotation></semantics></math>
に分割される。正方図式を形成する4つの射もある。これらの射のうちの2つは、自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>の成分だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>β</mi><mrow><mi>F</mi><mi>a</mi></mrow></msub><mo>∷</mo><mi>G</mi><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><msup><mi>G</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>β</mi><mrow><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi></mrow></msub><mo>∷</mo><mi>G</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><msup><mi>G</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
\beta_{F a} \Colon G (F a) \to G&#39;(F a) \\
\beta_{F&#39;a} \Colon G (F&#39;a) \to G&#39;(F&#39;a)
\end{gathered}
</annotation></semantics></math>
他の2つは、2つの関手による<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\alpha_a</annotation></semantics></math>の像だ（関手は射を写す）。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>G</mi><msub><mi>α</mi><mi>a</mi></msub><mo>∷</mo><mi>G</mi><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>G</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msup><mi>G</mi><mo>′</mo></msup><msub><mi>α</mi><mi>a</mi></msub><mo>∷</mo><msup><mi>G</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><msup><mi>G</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
G \alpha_a \Colon G (F a) \to G (F&#39;a) \\
G&#39;\alpha_a \Colon G&#39;(F a) \to G&#39;(F&#39;a)
\end{gathered}
</annotation></semantics></math>
射がとてもたくさんある。目標は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">G(F a)</annotation></semantics></math>
から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">G&#39;(F&#39;a)</annotation></semantics></math>
への射を見つけることだ。これは2つの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>∘</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">G \circ F</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>∘</mo><msup><mi>F</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">G \circ F&#39;</annotation></semantics></math>を接続する自然変換の成分の候補だ。実際、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">G(F a)</annotation></semantics></math>
から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">G&#39;(F&#39;a)</annotation></semantics></math>
への道は1つではなく2つある。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><msup><mi>G</mi><mo>′</mo></msup><msub><mi>α</mi><mi>a</mi></msub><mo>∘</mo><msub><mi>β</mi><mrow><mi>F</mi><mi>a</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>β</mi><mrow><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi></mrow></msub><mo>∘</mo><mi>G</mi><msub><mi>α</mi><mi>a</mi></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
G&#39;\alpha_a \circ \beta_{F a} \\
\beta_{F&#39;a} \circ G \alpha_a
\end{gathered}
</annotation></semantics></math>
ありがたいことに、これらは等しい。我々が形成した正方図式は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>の四角い自然性の図式だからだ。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>∘</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">G \circ F</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>∘</mo><msup><mi>F</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">G \circ F&#39;</annotation></semantics></math>への自然変換の成分が定義できた。この変換に対する自然性の証明は、十分に忍耐強い人にとっては、ごく簡単だ。</p>
<p>この自然変換を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>の<span
id="horizontal_composition" class="keyword"><em>水平合成</em></span>
(horizontal composition) と呼ぶ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>∘</mo><mi>α</mi><mo>∷</mo><mi>G</mi><mo>∘</mo><mi>F</mi><mo>→</mo><msup><mi>G</mi><mo>′</mo></msup><mo>∘</mo><msup><mi>F</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">\beta \circ \alpha \Colon G \circ F \to G&#39; \circ F&#39;</annotation></semantics></math>
ここでも私はマックレーンに従って水平合成を表すのに小さな円を使うが、代わりにアスタリスクが使われることもある。</p>
<p>圏論的経験から言えば、合成に出会うたびに圏を探すべきだ。自然変換には垂直合成があり、それは関手圏の一部だ。しかし、水平合成についてはどうだろうか？　それはどの圏にあるのだろう？</p>
<p>これを解明する方法は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>を横から見ることだ。自然変換を、関手の間の矢としてではなく、圏の間の矢として見てほしい。自然変換は、それが変換する関手で接続された2つの圏の間に位置する。つまり、それら2つの圏を結びつけるものと見なせる。</p>
<p> <img src="images/sideways.jpg" style="width:50.0%" /> </p>
<p>
ここでは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>の2つの対象――圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>に焦点を当てる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>に接続する関手間をつなぐ自然変換の集合がある。それらの自然変換が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>への新しい矢だ。同様に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐄</mi><annotation encoding="application/x-tex">\mathbf{E}</annotation></semantics></math>に接続する関手間をつなぐ自然変換が存在する。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐄</mi><annotation encoding="application/x-tex">\mathbf{E}</annotation></semantics></math>へ向かう新しい矢として扱える。水平合成はこれらの矢の合成だ。</p>
<p>また、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>への恒等射も存在する。これは恒等自然変換であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>上の恒等関手をそれ自体に写す。水平合成の恒等射は垂直合成の恒等射でもあるが、逆は成り立たないことに注意してほしい。</p>
<p>最後に、2つの合成は相互交換法則 (interchange law) を満たす。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>β</mi><mo>′</mo></msup><mo>⋅</mo><msup><mi>α</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>∘</mo><mo stretchy="false" form="prefix">(</mo><mi>β</mi><mo>⋅</mo><mi>α</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><msup><mi>β</mi><mo>′</mo></msup><mo>∘</mo><mi>β</mi><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><mo stretchy="false" form="prefix">(</mo><msup><mi>α</mi><mo>′</mo></msup><mo>∘</mo><mi>α</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\beta&#39; \cdot \alpha&#39;) \circ (\beta \cdot \alpha) = (\beta&#39; \circ \beta) \cdot (\alpha&#39; \circ \alpha)</annotation></semantics></math>
ここでソーンダーズ・マックレーンの言葉を引用しよう。「読者はこの事実を証明するのに必要となる証明の図式を書き下すと楽しいだろう。」<a
href="#fn72" class="footnote-ref" id="fnref72"
role="doc-noteref"><sup>72</sup></a></p>
<p>あともう1つ、将来役に立つだろう表記法がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>のこの水平方向の新解釈では、対象から対象へ行く方法が2つある。関手を使う方法と自然変換を使う方法だ。しかし、関手の矢は特別な種類の自然変換として再解釈できる。すなわち、その関手に作用する恒等自然変換として解釈すればよい。したがって、このような記法をよく目にすることになるだろう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∘</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">F \circ \alpha</annotation></semantics></math>
ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐄</mi><annotation encoding="application/x-tex">\mathbf{E}</annotation></semantics></math>への関手で、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>への2つの関手間の自然変換だ。関手と自然変換は合成できないので、これは恒等自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mn>1</mn><mi>F</mi></msub><annotation encoding="application/x-tex">1_F</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>の後に水平合成したものと解釈される[^訳注：この記法はwhiskeringと呼ばれる。詳しくは、同じ著者による
“The Dao of Functional Programming” の第9章3節を参照。]。</p>
<p>同様に
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∘</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">\alpha \circ F</annotation></semantics></math>
は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mn>1</mn><mi>F</mi></msub><annotation encoding="application/x-tex">1_F</annotation></semantics></math>の後に水平合成したものだ。</p>
<aside id="footnotes-42" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="72">
<li id="fn72"><p>訳注：丸善出版、S. マックレーン著、三好 博之/高木 理
訳『圏論の基礎』（原著名：<em>Categories for the Working
Mathematician</em>）第II章5節より。<a href="#fnref72"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="10.5" id="おわりに"><span
class="header-section-number">10.5</span> おわりに</h2>
<p>この本の第I部はここで締めくくろう。我々は圏論の基本的な語彙を学んだ。対象・圏は名詞、射・関手・自然変換は動詞と見なせる。射は対象たちを結びつけ、関手は圏たちを結びつけ、自然変換は関手たちを結びつける。</p>
<p>しかし、ある抽象化レベルで作用として現れるものが、次のレベルでは対象になることもまた見た。射の集合は関数対象になる。それは対象なので、別の射の始点や終点になり得る。これが高階関数の背景にある概念だ。</p>
<p>関手は対象を対象に写すので、型構成子、すなわちパラメーター化された型として使える。関手は射も写すので、高階関数<code>fmap</code>でもある。<code>Const</code>・積・余積などの単純な関手がいくつかあって、さまざまな代数的データ型の生成に使える。関数型も［訳注：戻り値の型において］共変関手的かつ［訳注：引数の型において］反変関手的で、代数的データ型を拡張するのに使える。</p>
<p>関手は関手圏での対象とも見なせる。そうすることで、それらは自然変換、すなわち射の始点および終点になる。自然変換は特別な多相関数だ。</p>
<h2 data-number="10.6" id="課題-8"><span
class="header-section-number">10.6</span> 課題</h2>
<ol type="1">
<li><p><code>Maybe</code>関手からリスト関手への自然変換を定義せよ。その自然性条件を証明せよ。</p></li>
<li><p><code>Reader ()</code>とリスト関手の間に、少なくとも2つの異なる自然変換を定義せよ。要素がunit型<code>()</code>のリストは何種類あるか？</p></li>
<li><p><code>Reader Bool</code>と<code>Maybe</code>を使って前の課題を続けよ。</p></li>
<li><p>自然変換の水平合成が自然性条件を満たしていることを示せ（ヒント：成分を使う）。これは図式を追う良い練習になる。</p></li>
<li><p>相互交換法則を証明するために必要な明確な図を描くのを楽しむ方法について、短いレポートを書け。</p></li>
<li><p>異なる<code>Op</code>関手間の変換についての反対の自然性条件について、テストケースをいくつか作成せよ。以下は選択肢の1つだ。</p>
<div class="sourceCode" id="cb294"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb294-1"><a href="#cb294-1" aria-hidden="true" tabindex="-1"></a><span class="ot">op ::</span> <span class="dt">Op</span> <span class="dt">Bool</span> <span class="dt">Int</span></span>
<span id="cb294-2"><a href="#cb294-2" aria-hidden="true" tabindex="-1"></a>op <span class="ot">=</span> <span class="dt">Op</span> (\x <span class="ot">-&gt;</span> x <span class="op">&gt;</span> <span class="dv">0</span>)</span></code></pre></div>
<p> および</p>
<div class="sourceCode" id="cb295"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb295-2"><a href="#cb295-2" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> <span class="fu">read</span> x</span></code></pre></div></li>
</ol>
<h1 data-number="11" id="宣言的プログラミング"><span
class="header-section-number">11</span> 宣言的プログラミング</h1>
<p>第I部では、圏論とプログラミングはどちらも合成可能性に関するものだと論じた。プログラミングでは、扱える程度の詳細さに達するまで問題を分解し続け、それぞれの部分問題を順番に解決し、それらの解決策をボトムアップで再合成する。これには大きく2つの方法がある。コンピューターに何をすべきか指示する方法と、どのようにすべきか指示する方法だ。前者は宣言的と呼ばれ、後者は命令的と呼ばれる。</p>
<p>このことは最も基本的なレベルでさえ見られる。合成自体は宣言的にも定義できる。たとえば、<code>h</code>は<code>g</code>を<code>f</code>の後に合成したものだ。</p>
<div class="sourceCode" id="cb296"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true" tabindex="-1"></a>h <span class="ot">=</span> g <span class="op">.</span> f</span></code></pre></div>
<p>
あるいは、命令的にも定義できる。まず<code>f</code>を呼び出し、その呼び出しの結果を記憶し、それからその結果を使って<code>g</code>を呼び出す。</p>
<div class="sourceCode" id="cb297"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a>h x <span class="ot">=</span> <span class="kw">let</span> y <span class="ot">=</span> f x</span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span> g y</span></code></pre></div>
<p>
命令的な方のプログラムは通常、動作を時系列で並べたものとして記述される。特に、<code>f</code>の実行が完了する前に<code>g</code>の呼び出しは起こりえない。少なくとも、概念としてはそうだ。ただし、<em>call-by-need</em>で引数が渡される遅延評価言語では、実際の実行順序は異なる可能性がある。</p>
<p>実際、コンパイラーの賢さによっては、宣言的コードと命令的コードの実行方法にほとんど違いがない場合もある。しかし、この2つの方法論は、問題解決へのアプローチ方法や実装コードの保守性とテスト可能性において、ときには劇的に異なる。</p>
<p>最大の疑問はこうだ。問題に直面したとき、解決のための選択肢として、宣言的アプローチと命令的アプローチの両方が常にあるのだろうか？　そして、宣言的な解決策があるなら、それは常にコンピューターコードに翻訳できるのだろうか？　この疑問への答えは自明とは全く言えず、もしその答えを見つけられたなら、宇宙の理解に革命が起こるだろう。</p>
<p>詳しく説明させてほしい。物理学にも似たような双対性がある。それは、何か深い基本原理を指し示したり、我々の心の働きについて何かを教えてくれたりする。リチャード・ファインマンはこの双対性について、自身の量子電磁力学の研究におけるインスピレーションとして言及している。</p>
<p>ほとんどの物理法則には2つの表現形式がある。1つは局所的すなわち無限小的な考察を用いる。我々はごく近傍の系の状態を見て、それが次の瞬間にどう変化するかを予測する。これは通常、ある期間にわたって積分すなわち合計する必要があるような微分方程式で表される。</p>
<p>このアプローチが命令的思考に似ていることに注目してほしい。つまり、前のステップの結果に応じた一連の小さなステップに従って最終的な解に到達する。実際、物理系のコンピューターシミュレーションの実装では、微分方程式を差分方程式に変換して反復実行するのが常道だ。小惑星ゲームの宇宙船はそのようにしてアニメーション化される。各時間ステップにおける宇宙船の位置は、速度に時間間隔を掛け算した小さな増分を加えることで変化する。同様に、速度は加速度（力を質量で割った値となる）に比例した小さな増分によって変化する。</p>
<p> <img src="images/asteroids.png" style="width:50.0%" /> </p>
<p>
ニュートンの運動法則に対応する微分方程式を直接的に記述すると次のようになる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>F</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mi>m</mi><mfrac><mrow><mi>d</mi><mi>v</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>v</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mfrac><mrow><mi>d</mi><mi>x</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
F &amp;= m \frac{dv}{dt} \\
v &amp;= \frac{dx}{dt}
\end{aligned}
</annotation></semantics></math>
同様の方法は、より複雑な問題にも適用できる。たとえば、電磁場の伝播はマクスウェル方程式で記述でき、陽子内部のクォークやグルーオンの挙動さえも格子量子色力学で記述できる。</p>
<p>この局所的な考え方と、デジタルコンピューターの使用によって促進された空間と時間の離散化とが組み合わさった最たるものは、宇宙全体の複雑さをセルオートマトンの系に縮約しようとするスティーブン・ウルフラム<a
href="#fn73" class="footnote-ref" id="fnref73"
role="doc-noteref"><sup>73</sup></a>の英雄的な試みの中に表れている。</p>
<p>もう1つのアプローチは大域的なものだ。我々はシステムの初期状態と最終状態を見て、それらを結ぶ軌道を、特定の汎関数を最小化することで計算する。最も簡単な例はフェルマーの最小時間の原理だ。それは、光線は伝搬時間が最小となる経路に沿って伝搬すると述べている。特に、反射や屈折をする物体がない場合、点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>から点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>への光線は最短経路である直線を通る。しかし、水やガラスのような（透明な）高密度の媒質中では光の伝播速度は遅くなる。したがって、始点を空気中とし、終点を水中とすると、光にとって空中をより長く進んでから水中を近道する方が有利になる。最小時間の経路では光線が空気と水の境界で屈折し、スネルの屈折の法則が導かれる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>θ</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow></mfrac><mo>=</mo><mfrac><msub><mi>v</mi><mn>1</mn></msub><msub><mi>v</mi><mn>2</mn></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{sin(\theta_1)}{sin(\theta_2)} = \frac{v_1}{v_2}</annotation></semantics></math>
ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mn>1</mn></msub><annotation encoding="application/x-tex">v_1</annotation></semantics></math>は空気中の光速、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>v</mi><mn>2</mn></msub><annotation encoding="application/x-tex">v_2</annotation></semantics></math>は水中の光速だ。</p>
<p> <img src="images/snell.jpg" style="width:30.0%" /> </p>
<p>
古典力学のすべては最小作用の原理から導出できる。作用は任意の経路について、運動エネルギーからポテンシャルエネルギーを引いた差であるラグランジアンを積分することで計算できる（注：和ではなく差だ――和は全エネルギーとなる）。大砲を撃って標的に命中させようとするとき、弾はまず重力によるポテンシャルエネルギーがより高い場所へと上昇し、しばらくの間そこで作用への負の寄与を蓄積する。しかも、放物線の頂点に向けて減速することで運動エネルギーを最小限に抑える。それから加速することでポテンシャルエネルギーの低い領域を素早く通過する。</p>
<p> <img src="images/mortar.jpg" style="width:35.0%" /> </p>
<p>
ファインマンの最大の功績は、最小作用の原理が量子力学に一般化できると示したことだ。ここでも、問題は初期状態と最終状態について定式化されている。ファインマン経路積分をそれらの状態間に用いると、遷移確率を計算できる。</p>
<p> <img src="images/feynman.jpg" style="width:35.0%" /> </p>
<p>
重要なのは、我々が物理法則を記述できる方法には奇妙で説明のつかない双対性があるということだ。局所的な描像を採用し、物事が連続して小さな増分で起こると捉えてもよい。あるいは、大域的な描像を採用し、初期条件と最終条件を宣言し、途中のすべてはそれらにただ従うと捉えてもよい。</p>
<p>大域的アプローチはプログラミングでも使える。たとえば、レイトレーシングを実装する場合などだ。眼の位置と光源の位置を宣言し、それらを光線が接続できる経路を見つければよい。各光線について飛行時間を明示的には最小化しないが、実際にスネルの法則と反射の幾何学を用いて同じ効果を得ている。</p>
<p>局所的アプローチと大域的アプローチの大きな違いは、空間の扱いと、さらに重要なことに、時間の扱いだ。局所的なアプローチでは、いま・ここの即時的な満足を受け入れるのに対し、大域的なアプローチでは、あたかも未来があらかじめ決まっていて、我々は不変なる宇宙の性質をただ分析しているかのように、長期的で静的な見方をする。</p>
<p>ユーザーインタラクションに対する関数型リアクティブプログラミング
(FRP)
アプローチほど、これが分かりやすく説明されているものはない。想定されるすべてのユーザーアクションに対して個別のハンドラーを記述して、そのすべてが共有の可変状態にアクセスできるようにする代わりに、FRPでは外部イベントを無限リストとして扱って一連の変換を適用する。概念的には、将来のすべてのアクションのリストがそこにあり、プログラムへの入力データとして利用できる。プログラムの観点からは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math>の数字のリスト、擬似乱数のリスト、コンピューターのハードウェアから得られるマウス座標のリストの間に違いはない。いずれの場合も、第<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>項を得るには最初の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math>個の項を先に調べる必要がある。時間的イベントについて述べる場合、この性質は<em>因果律</em>
(causality) と呼ばれる。</p>
<p>それで、圏論と何の関係があるのだろうか？　私の主張としては、圏論は大域的アプローチを奨励しており、それゆえ宣言的プログラミングを支持している。第一に、微積分とは違って、距離・近傍・時間などの概念が組み込まれていない。あるのは抽象的な対象たちとそれらの間の抽象的な接続だけだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>へ一連のステップで到達できるなら、一足飛びにも到達できる。さらに、圏論の主要なツールはまさに普遍的構成であり、それは大域的アプローチの典型だ。実際の使用例は、たとえば、圏論的な積の定義ですでに見た。それは積の性質を指定することによってなされた、まさしく宣言的なアプローチだ。積とは2つの射影を伴う対象であり、そういった対象のうち最も優れたものだ。つまり、ある特性を最適化している。それは、他の同様の対象の射影を分解する特性だ。</p>
<p> <img src="images/productranking.jpg" style="width:35.0%" /> </p>
<p>
これをフェルマーの最短時間の原理、あるいは最小作用の原理と比較してほしい。</p>
<p>逆に、デカルト積の従来の定義と対比させるとどうだろう。後者の方がはるかに命令的だ。積の要素を作るには、ある集合から1つの要素を選択し、別の集合から別の要素を選択する、という説明になる。これはペアを作るためのレシピだ。また、ペアを分解するためのレシピもある。</p>
<p>Haskellなどの関数型言語を含め、ほとんどすべてのプログラム言語では、直積型・余積型・関数型は組み込まれており、普遍的構成で定義されるのではない。ただし、圏論的プログラム言語の作成も試みられている
(たとえば、<a
href="http://web.sfc.keio.ac.jp/~hagino/thesis.pdf">萩野達也の博士論文</a><a
href="#fn74" class="footnote-ref" id="fnref74"
role="doc-noteref"><sup>74</sup></a>を参照)。</p>
<p>直接使われるかどうかにかかわらず、圏論的な定義は既存のプログラミング構成を正当なものにするとともに、新しい構成を生み出す。最も重要なのは、宣言的レベルでコンピュータープログラムについて推論するためのメタ言語を圏論が提供することだ。また、コードとして表す前に問題の仕様について推論することも奨励する。</p>
<aside id="footnotes-43" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="73">
<li
id="fn73"><p>訳注：複雑系を専門とする数理物理学者で、数式処理ソフトMathematicaの作者としても知られる。<a
href="#fnref73" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn74"><p><a href="http://web.sfc.keio.ac.jp/~hagino/thesis.pdf"
class="uri">http://web.sfc.keio.ac.jp/~hagino/thesis.pdf</a><a
href="#fnref74" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 data-number="12" id="limits-and-colimits"><span
class="header-section-number">12</span> 極限と余極限</h1>
<p>圏論では、すべてがすべてに関係していて、すべてのものを様々な角度から見られるようだ。たとえば、<a
href="#products-and-coproducts">積</a>（第5章）の普遍的構成を考えてみよう。いまは<a
href="#functors">関手</a>と<a
href="#natural-transformations">自然変換</a>（第10章）についても学んだので、それらを単純化し、可能なら一般化できないだろうか？　やってみよう。</p>
<p> <img src="images/productpattern.jpg" style="width:30.0%" /> </p>
<p>
積の構成は、積を構築したい2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>を選択することから始まる。しかし、<em>対象を選択する</em>とは何を意味するのだろう？　もっと圏論らしい言葉で言い換えられないだろうか？　2つの対象はあるパターンをなす――ごく単純なパターンだ。このパターンは圏に抽象化できる――ごく単純な圏だが、それでも紛れもなく圏だ。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>と呼ばれる圏だ。それは2つの対象（それぞれ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>と呼ぶことにする）と、2つの必須の恒等射だけを含む。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の2つの対象を選択するということを、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>を定義することだと言い換えられる。関手は対象を対象に写すため、その像はちょうど2つの対象になる（関手が対象を潰す場合は1つの対象になるが、その場合も問題ない）。この関手は射も写すが、ここでは単に恒等射を恒等射に写す。</p>
<p>このアプローチの素晴らしいところは、圏論の概念に基づいて構築されていることであり、「対象を選択する」といった不正確な、我々の祖先たる狩猟採集民の語彙からそのまま採ったような記述を避けていることだ。おまけに、一般化するのも簡単だ。パターンを定義するために<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>より複雑な圏を使ってはいけない理由はないからだ。</p>
<p> <img src="images/two.jpg" style="width:35.0%" /> </p>
<p>
だが、ここではこのまま進もう。積を定義する次のステップは候補となる対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>の選択だ。ここでも、単元圏からの関手によって対象の選択を言い換えてしまってもよいかもしれない。そして確かに、もし我々がすでにカン拡張を使っていたとしたら、そうするのが正しかっただろう。しかし、まだカン拡張を使う準備ができていないので、別のトリックを使おう。同じ圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>への定関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Δ</mi><annotation encoding="application/x-tex">\Delta</annotation></semantics></math>である。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>を選択できる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>はすべての対象を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>に写し、すべての射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>c</mi></msub><annotation encoding="application/x-tex">%
\mathbf{id}_{c}%
</annotation></semantics></math>に写すことを思い出してほしい。</p>
<p> <img src="images/twodelta.jpg" style="width:35.0%" /> </p>
<p>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>という、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の間の2つの関手が手に入ったからには、これらの関手の間の自然変換について問うのは自然なことだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>の対象は2つだけなので、自然変換は2つの成分を持つことになる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>に写される。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>の間の自然変換の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>における成分は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>への射だ。それを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>と呼ぼう。同様に、2番目の成分は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>である。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>による像である。しかし、これらはもともとの積の定義で用いた2つの射影とそっくりだ。つまり、対象の選択と射影について議論する代わりに、単に関手の選択と自然変換について議論するのでよいということだ。たまたま、ここでの単純なケースでは変換の自然性条件が自明に満たされている。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>には射が（恒等射以外には）存在しないからだ。</p>
<p> <img src="images/productcone.jpg" style="width:35.0%" /> </p>
<p>
この構成を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>以外の圏（たとえば、自明でない射を含む圏）に一般化すると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>の間の変換に自然性条件が課される。このような変換は<em>錐</em>
(cone)
と呼ばれる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Δ</mi><annotation encoding="application/x-tex">\Delta</annotation></semantics></math>の像が、自然変換の成分たちが側面を構成するような錐体（円錐・角錐など）<a
href="#fn75" class="footnote-ref" id="fnref75"
role="doc-noteref"><sup>75</sup></a>の頂点になっているからだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>の像は錐の底面をなす。</p>
<p>一般に、錐を構築するには、そのパターンを定義する圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>から始める。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>は小さい圏で、しばしば有限である。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>を選択し、それ（またはその像）を<em>図式</em>
(diagram)
と呼ぶ。また、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>を錐の頂点として選択する。それを使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>への定関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>を定義する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>への自然変換こそが、ここで言うところの錐となる。有限の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>に対しては、錐は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>と図式、つまり<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>による<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>の像とを接続するただの射の集まりだ。</p>
<p> <img src="images/cone.jpg" style="width:35.0%" /> </p>
<p>
自然性は、この図式のすべての三角形（角錐の側面）が可換であることを必要とする。実際に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>内の任意の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を取ったとしよう。関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>は、それを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">D f</annotation></semantics></math>に写し、その射はある三角形の底辺となる。定関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>における恒等射に写す。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Δ</mi><annotation encoding="application/x-tex">\Delta</annotation></semantics></math>はその射の両端を1つの対象にまとめ、自然性の正方図式は可換な三角形になる。この三角形の2辺は自然変換の成分になっている。</p>
<p> <img src="images/conenaturality.jpg" style="width:35.0%" /> </p>
<p> これは錐のひとつではある。だが、関心があるのは<em>普遍錐</em>
(universal cone) だ――普遍的な対象を積の定義としたのと同様だ。</p>
<p>その普遍錐の構成を目指す方法はいろいろある。たとえば、与えられた関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>に基づいて<em>錐の圏</em>を定義できる。その圏における対象は錐だ。ただし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>のすべての対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>が錐の頂点になれるわけではない。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>の間に自然変換が存在しないことがあるからだ。</p>
<p>圏にするには、錐の間の射も定義しなければならない。それらは頂点間の射によって完全に決定されることになる。しかし、どんな射でも良いわけではない。我々の積の構成では、候補となる対象（頂点）の間の射は射影の共通因子でなければならない、という条件を課したのを思い出してほしい。具体的には</p>
<div class="sourceCode" id="cb298"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb298-1"><a href="#cb298-1" aria-hidden="true" tabindex="-1"></a>p&#39; <span class="ot">=</span> p <span class="op">.</span> m</span>
<span id="cb298-2"><a href="#cb298-2" aria-hidden="true" tabindex="-1"></a>q&#39; <span class="ot">=</span> q <span class="op">.</span> m</span></code></pre></div>
<p> <img src="images/productranking.jpg" style="width:35.0%" /> </p>
<p> 一般の場合<a href="#fn76" class="footnote-ref" id="fnref76"
role="doc-noteref"><sup>76</sup></a>には、この条件は、1辺が分解射である三角形はすべて可換である、という条件に翻訳される。</p>
<figure>
<img src="images/conecommutativity.jpg"
title="分解射$h$によって2つの錐を接続する可換な三角形（ここで、下側の錐は$\Lim[D]$を頂点とする普遍錐）"
style="width:35.0%"
alt="分解射hによって2つの錐を接続する可換な三角形（ここで、下側の錐は%
\mathbf{Lim}{D}%
を頂点とする普遍錐）" />
<figcaption
aria-hidden="true">分解射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>によって2つの錐を接続する可換な三角形（ここで、下側の錐は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">%
\mathbf{Lim}{D}%
</annotation></semantics></math>を頂点とする普遍錐）</figcaption>
</figure>
<p>
これらの分解射を錐の圏における射とする。これらの射が実際に合成できることと、恒等射が分解射であることを確認するのは簡単だ。したがって、錐たち<a
href="#fn77" class="footnote-ref" id="fnref77"
role="doc-noteref"><sup>77</sup></a>は圏をなす。</p>
<p>ここで、普遍錐を錐の圏の<em>終対象</em>として定義できる。終対象の定義から、どの対象からも終対象への一意な射がある。ここでは、それは他のどの錐の頂点からも普遍錐の頂点への一意な分解射があることを意味する。この普遍錐は図式<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>の<em>極限</em>
(limit)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">%
\mathbf{Lim}{D}%
</annotation></semantics></math>と呼ばれる（この分野では<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mrow></mrow></mrow><annotation encoding="application/x-tex">%
\mathbf{Lim}{}%
</annotation></semantics></math>記号の下に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>に向かう左矢印が記されていることも多い）。しばしば、この錐の頂点を指して極限（あるいは極限対象）と略称する。</p>
<p>直観的には、極限は図式全体の特性を単一の対象で具現化している。たとえば、2対象の図式の極限は2つの対象の積だ。積（および2つの射影を合わせたもの）には両方の対象についての情報が含まれている。そして、普遍であるということは要らないものを含まないことを意味する。</p>
<h2 data-number="12.1" id="自然同型としての極限"><span
class="header-section-number">12.1</span> 自然同型としての極限</h2>
<p>この極限の定義にはまだ不満が残る。どういうことかと言うと、使えはするものの、任意の2つの錐を結ぶ三角形には依然として前述のような可換性条件が課されている。それを何らかの自然性条件に置き換えられれば、はるかにエレガントになるだろう。だが、どうやって？</p>
<p>もはや我々は、1つの錐ではなく、錐の集まり（実際には圏）全体を扱っている。極限が存在するなら（そして――明言しておくと――存在する保証はない）、それらの錐の1つは普遍錐だ。他のすべての錐のそれぞれに対して、その頂点（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>と呼ぼう）を普遍錐の頂点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">%
\mathbf{Lim}{D}%
</annotation></semantics></math>に写す一意な分解射が存在する。（実際には「他の」という言葉は省ける。普遍錐が恒等射によって普遍錐自身に写され、それ自身を分解するのは自明だからだ。）
要点を繰り返そう。任意の錐について、特別な種類の一意な射が存在する。つまり、それは錐からそういった特別な射への写像があって、それは1対1の写像であるということだ。</p>
<p>この特別な射はhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>,</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c, %
\mathbf{Lim}{D}%
)</annotation></semantics></math>
の元だ。このhom集合のそれ以外の元は、残念ながら2つの錐の写像を分解しない。ここで必要なのは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>ごとに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>,</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c, %
\mathbf{Lim}{D}%
)</annotation></semantics></math>
から1つの射――特定の可換性条件を満たす射――を選択できるようにすることだ。まるで自然変換を定義しているかのように聞こえるだろうか？　まさしくそのとおり！</p>
<p>だが、この変換によって関連付けられるのはどのような関手だろう？</p>
<p>関手の1つは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>から集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>,</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c, %
\mathbf{Lim}{D}%
)</annotation></semantics></math>
への写像だ。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への関手で、対象たちを集合たちに写す。正確には反変関手だ。射に関する作用は次のように定める。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を取ってきたとしよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><msup><mi>c</mi><mo>′</mo></msup><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f \Colon c&#39; \to c</annotation></semantics></math>
我々の関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>を集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>c</mi><mo>′</mo></msup><mo>,</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c&#39;, %
\mathbf{Lim}{D}%
)</annotation></semantics></math>
に写す。この関手の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>に対する作用を定義する（言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を持ち上げる）には、それに対応する、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>,</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c, %
\mathbf{Lim}{D}%
)</annotation></semantics></math>
と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>c</mi><mo>′</mo></msup><mo>,</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c&#39;, %
\mathbf{Lim}{D}%
)</annotation></semantics></math>
の間の写像を定義しなければならない。そこで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>,</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c, %
\mathbf{Lim}{D}%
)</annotation></semantics></math>
の要素<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math>を1つ選択し、それを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>c</mi><mo>′</mo></msup><mo>,</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c&#39;, %
\mathbf{Lim}{D}%
)</annotation></semantics></math>
の要素に写せるか見てみよう。hom集合の要素は射なので、次のことが言える。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>∷</mo><mi>c</mi><mo>→</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">u \Colon c \to %
\mathbf{Lim}{D}%
</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>に前合成<a
href="#fn78" class="footnote-ref" id="fnref78"
role="doc-noteref"><sup>78</sup></a>することで次が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>∘</mo><mi>f</mi><mo>∷</mo><msup><mi>c</mi><mo>′</mo></msup><mo>→</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">u \circ f \Colon c&#39; \to %
\mathbf{Lim}{D}%
</annotation></semantics></math>
そして、これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>c</mi><mo>′</mo></msup><mo>,</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c&#39;, %
\mathbf{Lim}{D}%
)</annotation></semantics></math>
の要素だ――つまり、実際に射の写像が見つかった。</p>
<div class="sourceCode" id="cb299"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true" tabindex="-1"></a><span class="ot">contramap ::</span> (c&#39; <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> <span class="dt">Lim</span> <span class="dt">D</span>) <span class="ot">-&gt;</span> (c&#39; <span class="ot">-&gt;</span> <span class="dt">Lim</span> <span class="dt">D</span>)</span>
<span id="cb299-2"><a href="#cb299-2" aria-hidden="true" tabindex="-1"></a>contramap f u <span class="ot">=</span> u <span class="op">.</span> f</span></code></pre></div>
<p>
<em>反変</em>関手の特徴である、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>の順序の反転に注目してほしい。</p>
<p> <img src="images/homsetmapping.jpg" style="width:35.0%" /> </p>
<p>
自然変換を定義するには、同じく<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への写像である別の関手が必要だ。今回については錐の集合を考えてみる。錐は単なる自然変換なので、自然変換の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑁</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{Nat}(\Delta_c, D)</annotation></semantics></math>
を見ていることになる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>をこの特定の自然変換の集合へ対応させる写像は（反変）関手となる。どうやってそれを示そう？　ここでも、次の射に対するその関手の作用を定義してみよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><msup><mi>c</mi><mo>′</mo></msup><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">f \Colon c&#39; \to c</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を持ち上げると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>へ向かう2つの関手間の自然変換たちの写像になる必要がある。つまり、
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑁</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mrow><mi>𝑁</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi mathvariant="normal">Δ</mi><msup><mi>c</mi><mo>′</mo></msup></msub><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{Nat}(\Delta_c, D) \to \mathit{Nat}(\Delta_{c&#39;}, D)</annotation></semantics></math>
自然変換はどう写せば良いだろう？　自然変換は射――その成分――の選択であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>の要素ごとに射を1つ選択する。ある（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑁</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{Nat}(\Delta_c, D)</annotation></semantics></math>
の元である）<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>の、（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>内の対象である）<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>における成分は、次の射となる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub><mo>∷</mo><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><mi>a</mi><mo>→</mo><mi>D</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\alpha_a \Colon \Delta_c a \to D a</annotation></semantics></math>
つまり、定関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Δ</mi><annotation encoding="application/x-tex">\Delta</annotation></semantics></math>の定義から
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub><mo>∷</mo><mi>c</mi><mo>→</mo><mi>D</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\alpha_a \Colon c \to D a</annotation></semantics></math>
となる。任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑁</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi mathvariant="normal">Δ</mi><msup><mi>c</mi><mo>′</mo></msup></msub><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{Nat}(\Delta_{c&#39;}, D)</annotation></semantics></math>
の元である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>を構築する必要がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>における成分は次の射となる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mi>a</mi></msub><mo>∷</mo><msup><mi>c</mi><mo>′</mo></msup><mo>→</mo><mi>D</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\beta_a \Colon c&#39; \to D a</annotation></semantics></math>
後者（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>β</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\beta_a</annotation></semantics></math>）は前者（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\alpha_a</annotation></semantics></math>）を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>に前合成すれば簡単に得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>β</mi><mi>a</mi></msub><mo>=</mo><msub><mi>α</mi><mi>a</mi></msub><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">\beta_a = \alpha_a \circ f</annotation></semantics></math>
これらの成分たちが実際に自然変換をなすことは比較的簡単に示せる。</p>
<p> <img src="images/natmapping.jpg" style="width:40.0%" /> </p>
<p>
以上より、与えられた射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>について、2つの自然変換の間の写像を成分ごとに構築できた。この写像は次の関手について<code>contramap</code>を定義する<a
href="#fn79" class="footnote-ref" id="fnref79"
role="doc-noteref"><sup>79</sup></a>。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>→</mo><mrow><mi>𝑁</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">c \to \mathit{Nat}(\Delta_c, D)</annotation></semantics></math>
ここまでで示したのは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への2つの（反変）関手があるということだ。示すにあたっては何の仮定も置かなかった。よって、これらの関手は常に存在すると言える。</p>
<p>ちなみに、これらの関手のうち1つ目は圏論で重要な役割を果たしている。米田の補題について話すときに再び見ることになるだろう。任意の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への反変関手は「前層」(presheaf)
と呼ばれる。ここでのものは<span id="representable_presheaf"
class="keyword"><em>表現可能前層</em></span> (representable presheaf)
と呼ばれている。2つ目の関手も前層だ。</p>
<p>2つの関手が出てきたので、その間の自然変換について述べられるようになった。では、これ以上何も言わず、結論を述べよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>が極限<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">%
\mathbf{Lim}{D}%
</annotation></semantics></math>を持つのは、先ほど定義した2つの関手間に自然同型がある場合、かつその場合に限る。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>,</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi><mo stretchy="false" form="postfix">)</mo><mo>≃</mo><mrow><mi>𝑁</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c, %
\mathbf{Lim}{D}%
) \simeq \mathit{Nat}(\Delta_c, D)</annotation></semantics></math>
自然同型とは何かを思い出してほしい。すべての成分が同型、すなわち可逆な射である自然変換だった。</p>
<p>この命題の証明をなぞるつもりはない。退屈とまでは言わないにしても、ごく単純な手順で済むからだ。自然変換を扱うときには通常、その成分、つまり射に注目する。ここでは両方の関手の余域が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>なので、前述の自然同型の成分は関数になる。そして、それらの関数はhom集合から自然変換の集合へと向かうので、高階関数となる。再び、関数が引数に対して何を行うかを調べることで関数を分析できる。ここで、引数は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>,</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c, %
\mathbf{Lim}{D}%
)</annotation></semantics></math>
の元である射になり、結果は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑁</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{Nat}(\Delta_c, D)</annotation></semantics></math>
の元である自然変換、すなわち錐と呼んだものになる。この自然変換自身にもそれぞれの成分があり、それらは射である。このようにどこまでも射が続くので、それらを追跡できれば先ほどの命題を証明できる。</p>
<p>最も重要な結果は、この同型に対する自然性条件がまさしく錐の写像についての可換性条件になっているということだ。</p>
<p>今後のアトラクションの予告として、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑁</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{Nat}(\Delta_c, D)</annotation></semantics></math>
を関手圏のhom集合と見なせることに触れておきたい。つまり、ここでの自然同型は2つのhom集合を関連づけ、随伴と呼ばれるさらに一般的な関係を指し示している。</p>
<aside id="footnotes-44" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="75">
<li id="fn75"><p>訳注：原文ではcone/pyramid。<a href="#fnref75"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn76"><p>訳注：つまり、錐の間の射の場合。<a href="#fnref76"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn77"><p>訳注：「底面」（関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>）が同じであるような錐たち。<a
href="#fnref77" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn78"><p>訳注：本書で前合成 (precomposition) や後合成
(postcomposition)
と言うときは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>∘</mi><annotation encoding="application/x-tex">\circ</annotation></semantics></math>の左側を前としている。<a
href="#fnref78" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn79"><p>訳注：ここでは写像による元の対応について述べているので、より適切な書き方としては<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>↦</mo><mrow><mi>𝑁</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">c \mapsto \mathit{Nat}(\Delta_c, D)</annotation></semantics></math>となる。<a
href="#fnref79" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="12.2" id="極限の例"><span
class="header-section-number">12.2</span> 極限の例</h2>
<p>すでに見たように、圏論的な積は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>と呼ばれる単純な圏が生成する図式の極限だ。</p>
<p>極限のさらに単純な例としては終対象がある。単元圏が終対象につながる、と初期衝動で考えるかもしれないが、真実はさらに殺風景だ。終対象は空圏が生成する極限なのだ。空圏からの関手は対象を選択しないので、錐は頂点だけに収縮する。普遍錐はその唯一の頂点で、他の頂点からの一意な射を持つ。これが終対象の定義だと気付くだろう。</p>
<p>次に興味深い極限は<em>等化子</em> (equalizer)
と呼ばれる。これは2つの要素からなる圏によって生成された極限であり、要素間の2つの並行した射を伴う（そして当然、恒等射も持つ）。この圏は、2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>と、2つの射とで構成される<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の図式を選択する。</p>
<div class="sourceCode" id="cb300"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb300-2"><a href="#cb300-2" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> a <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>
この図式の上に錐を構築するには、頂点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>と2つの射影を追加する必要がある。</p>
<div class="sourceCode" id="cb301"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> c <span class="ot">-&gt;</span> a</span>
<span id="cb301-2"><a href="#cb301-2" aria-hidden="true" tabindex="-1"></a><span class="ot">q ::</span> c <span class="ot">-&gt;</span> b</span></code></pre></div>
<p> <img src="images/equalizercone.jpg" style="width:35.0%" /> </p>
<p> 可換でなければならない三角形が2つある。</p>
<div class="sourceCode" id="cb302"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true" tabindex="-1"></a>q <span class="ot">=</span> f <span class="op">.</span> p</span>
<span id="cb302-2"><a href="#cb302-2" aria-hidden="true" tabindex="-1"></a>q <span class="ot">=</span> g <span class="op">.</span> p</span></code></pre></div>
<p>
これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>が、これらの等式の1つ、たとえば<code>q = f . p</code>によって一意に決定され、図から省けることを示している。残りの条件は1つだけになる。</p>
<div class="sourceCode" id="cb303"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">.</span> p <span class="ot">=</span> g <span class="op">.</span> p</span></code></pre></div>
<p>
これは、注目する範囲を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>だけに限れば、関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>の像は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の部分集合を選択している、と解釈できる。この部分集合に限れば、関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>は等しくなる。</p>
<p>たとえば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を座標<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>でパラメーター化された2次元平面とする。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>を実数の直線とし、次のようにする。</p>
<div class="sourceCode" id="cb304"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a>f (x, y) <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> y <span class="op">+</span> x</span>
<span id="cb304-2"><a href="#cb304-2" aria-hidden="true" tabindex="-1"></a>g (x, y) <span class="ot">=</span> y <span class="op">-</span> x</span></code></pre></div>
<p>
これら2つの関数の等化子は、実数の集合（頂点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>）と次の関数だ。</p>
<div class="sourceCode" id="cb305"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true" tabindex="-1"></a>p t <span class="ot">=</span> (t, (<span class="op">-</span><span class="dv">2</span>) <span class="op">*</span> t)</span></code></pre></div>
<p>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mspace width="0.222em"></mspace><mi>t</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(p~t)</annotation></semantics></math>
は2次元平面内の直線を定義することに注意してほしい。この線上では2つの関数は等しい。</p>
<p>当然、この等しさは他の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>と関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>′</mo></msup><annotation encoding="application/x-tex">p&#39;</annotation></semantics></math>でも満たしうる。</p>
<div class="sourceCode" id="cb306"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">.</span> p&#39; <span class="ot">=</span> g <span class="op">.</span> p&#39;</span></code></pre></div>
<p>
ただし、それらはすべて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>を通じて一意に分解する。たとえば、単元集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix" mathvariant="bold">(</mo><mo stretchy="false" form="postfix" mathvariant="bold">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{()}</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>として受け取れば次の関数を使える。</p>
<div class="sourceCode" id="cb307"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a>p&#39;() <span class="ot">=</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span></code></pre></div>
<p>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(0, 0) = g(0, 0)</annotation></semantics></math>
だから、これは良い錐だ。しかし、普遍錐ではなく、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>によって一意に分解できる。</p>
<div class="sourceCode" id="cb308"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true" tabindex="-1"></a>p&#39; <span class="ot">=</span> p <span class="op">.</span> h</span></code></pre></div>
<p> ここで、</p>
<div class="sourceCode" id="cb309"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb309-1"><a href="#cb309-1" aria-hidden="true" tabindex="-1"></a>h () <span class="ot">=</span> <span class="dv">0</span></span></code></pre></div>
<p> <img src="images/equilizerlimit.jpg" style="width:35.0%" /> </p>
<p>
したがって、等化子は型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mspace width="0.222em"></mspace><mi>x</mi><mo>=</mo><mi>g</mi><mspace width="0.222em"></mspace><mi>x</mi></mrow><annotation encoding="application/x-tex">f~x = g~x</annotation></semantics></math>の方程式を解くのに使える。しかも、もっと一般化されている。代数的な定義ではなく、対象や射によって定義されているからだ。</p>
<p>方程式を解くという考え方をさらに一般化したものが、別の極限で具体化されている――引き戻し
(pullback)
だ。ここに、等価にしたい2つの射がまたあるが、今回はそれらの始点が異なる。まず<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mn>2</mn><mo>←</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1\rightarrow2\leftarrow3</annotation></semantics></math>という形の3対象の圏から始める。この圏に対応する図式は、3つの対象（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>）と2つの射で構成されている。</p>
<div class="sourceCode" id="cb310"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> c <span class="ot">-&gt;</span> b</span></code></pre></div>
<p> この図式は<em>余スパン</em> (cospan) と呼ばれることが多い。</p>
<p>この図式の上に構築された錐は、頂点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>と3つの射から構成されている。</p>
<div class="sourceCode" id="cb311"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> d <span class="ot">-&gt;</span> a</span>
<span id="cb311-2"><a href="#cb311-2" aria-hidden="true" tabindex="-1"></a><span class="ot">q ::</span> d <span class="ot">-&gt;</span> c</span>
<span id="cb311-3"><a href="#cb311-3" aria-hidden="true" tabindex="-1"></a><span class="ot">r ::</span> d <span class="ot">-&gt;</span> b</span></code></pre></div>
<p> <img src="images/pullbackcone.jpg" style="width:35.0%" /> </p>
<p>
可換性条件から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>r</mi><annotation encoding="application/x-tex">r</annotation></semantics></math>は他の射によって完全に決定されることが分かり、図から省略できる。したがって、次の条件のみが残る。</p>
<div class="sourceCode" id="cb312"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">.</span> q <span class="ot">=</span> f <span class="op">.</span> p</span></code></pre></div>
<p> 引き戻しは、この形の普遍錐だ。</p>
<p> <img src="images/pullbacklimit.jpg" style="width:35.0%" /> </p>
<p>
再び、注目する範囲を集合だけに絞ると、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>からの要素のペアのうち、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>が1番目の成分に作用したものと<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>が2番目の成分に作用したものとが等しいという条件を満たすものからなると見なせる。これがまだ一般的すぎるなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>が定数関数である特別な場合を考えてみてほしい。たとえば、（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>が実数の集合だと仮定して）<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mspace width="0.222em"></mspace><mi>_</mi><mo>=</mo><mn>1.23</mn></mrow><annotation encoding="application/x-tex">g~\_ = 1.23</annotation></semantics></math>とする。そうすれば、実際に方程式を解いていることになる。</p>
<div class="sourceCode" id="cb313"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> <span class="fl">1.23</span></span></code></pre></div>
<p>
この場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>として何を選択しても（空集合でない限り）関係ないので、単元集合として構わない。たとえば、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>が3次元ベクトルの集合で、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>がベクトル長だとする。そうすれば、引き戻しはペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>v</mi><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(v, ())</annotation></semantics></math>
の集合で、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>は長さ1.23のベクトル（方程式<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow></msqrt><mo>=</mo><mn>1.23</mn></mrow><annotation encoding="application/x-tex">\sqrt{(x^{2}+y^{2}+z^{2})} = 1.23</annotation></semantics></math>の解）となる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">()</annotation></semantics></math>
は単元集合のダミー要素だ。</p>
<p>もっとも、引き戻しにはより一般的な用途があり、プログラミングでも使える。たとえば、C++のクラスを圏と見なし、派生クラスを基底クラスに結ぶ矢印を射と見なそう。継承関係は推移的であると見なせる。つまり、<code>C</code>が<code>B</code>を継承し、<code>B</code>が<code>A</code>を継承しているなら、<code>C</code>は<code>A</code>を継承していると言える（要するに、<code>A</code>へのポインターを想定する箇所に<code>C</code>へのポインターを渡せるということだ）。また、<code>C</code>は<code>C</code>を継承すると見なそう。つまり、すべてのクラスに恒等射がある。このようにすれば、派生クラス関係は部分型関係と一致することになる。C++は多重継承もサポートしているので、<code>A</code>を継承する2つのクラス<code>B</code>と<code>C</code>、および<code>B</code>と<code>C</code>とを多重継承する4番目のクラス<code>D</code>を含むダイヤモンド継承の図式を構築できる。通常、<code>D</code>は<code>A</code>を2つ持つことになる。ほとんどの場合、これは望ましくない。だが、仮想継承を使えば<code>D</code>内の<code>A</code>を1つだけにできる。</p>
<p><code>D</code>がこの図式の引き戻しになるとは何を意味するのだろう？　それは、<code>B</code>と<code>C</code>を多重継承するすべてのクラス<code>E</code>が、<code>D</code>の派生クラスでもあることを意味する。これはC++では直接表現できない。C++の部分型付け<a
href="#fn80" class="footnote-ref" id="fnref80"
role="doc-noteref"><sup>80</sup></a>は名前に基づくもの (nominal)
だからだ（C++コンパイラーはこの種のクラス関係を推測しない――それには「ダックタイピング」が必要となる<a
href="#fn81" class="footnote-ref" id="fnref81"
role="doc-noteref"><sup>81</sup></a>）。しかし、部分型付け関係の外に出て、代わりに<code>E</code>から<code>D</code>へのキャストが安全かどうか確かめることはできる。このキャストが安全なのは、<code>D</code>が<code>B</code>と<code>C</code>の必要最小限の組み合わせで、追加データやメソッドのオーバーライドがない場合だ。そしてもちろん、<code>B</code>と<code>C</code>のメソッドに名前の衝突がある場合、引き戻しはない。</p>
<p> <img src="images/classes.jpg" style="width:25.0%" /> </p>
<p>
さらに、型推論では引き戻しがより高度な使い方をされる。2つの表現の型を<em>単一化</em>
(unify)
したいことはよくある。たとえば、コンパイラーが関数の型を推測しようとしているとする。</p>
<div class="sourceCode" id="cb314"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a>twice f x <span class="ot">=</span> f (f x)</span></code></pre></div>
<p>
これはすべての変数と部分式に予備的な型を割り当てる。具体的には、以下を割り当てる。</p>
<div class="sourceCode" id="cb315"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f       ::</span> t0</span>
<span id="cb315-2"><a href="#cb315-2" aria-hidden="true" tabindex="-1"></a><span class="ot">x       ::</span> t1</span>
<span id="cb315-3"><a href="#cb315-3" aria-hidden="true" tabindex="-1"></a>f<span class="ot"> x     ::</span> t2</span>
<span id="cb315-4"><a href="#cb315-4" aria-hidden="true" tabindex="-1"></a>f (f x)<span class="ot"> ::</span> t3</span></code></pre></div>
<p> そこから次のことが演繹される。</p>
<div class="sourceCode" id="cb316"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true" tabindex="-1"></a><span class="ot">twice ::</span> t0 <span class="ot">-&gt;</span> t1 <span class="ot">-&gt;</span> t3</span></code></pre></div>
<p> また、関数適用の規則から生じる一連の制約も課される。</p>
<div class="sourceCode" id="cb317"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true" tabindex="-1"></a>t0 <span class="ot">=</span> t1 <span class="ot">-&gt;</span> t2 <span class="co">-- fがxに適用されるため</span></span>
<span id="cb317-2"><a href="#cb317-2" aria-hidden="true" tabindex="-1"></a>t0 <span class="ot">=</span> t2 <span class="ot">-&gt;</span> t3 <span class="co">-- fが (f x) に適用されるため</span></span></code></pre></div>
<p>
これらの制約は、両方の式の未知の型に代入したときに両辺が同じになるような型（あるいは型変数）の集合を見つけることによって単一化される。そのような代入の1つは次のとおりだ。</p>
<div class="sourceCode" id="cb318"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb318-1"><a href="#cb318-1" aria-hidden="true" tabindex="-1"></a>t1 <span class="ot">=</span> t2 <span class="ot">=</span> t3 <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb318-2"><a href="#cb318-2" aria-hidden="true" tabindex="-1"></a><span class="ot">twice ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p> しかし、明らかに、これは最も一般的なものではない。最も一般的な代入<a
href="#fn82" class="footnote-ref" id="fnref82"
role="doc-noteref"><sup>82</sup></a>を得るには引き戻しを用いる。詳細は本書の範囲外であるため説明しないが、次のような結果になるはずであることは確信できるだろう。</p>
<div class="sourceCode" id="cb319"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true" tabindex="-1"></a><span class="ot">twice ::</span> (t <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> t</span></code></pre></div>
<p> ここで<code>t</code>は自由 (free) 型変数だ。</p>
<aside id="footnotes-45" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="80">
<li id="fn80"><p>訳注：つまり、派生クラス関係。<a href="#fnref80"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn81"><p>訳注：ダックタイピングは主に動的言語で用いられるが、動的な枠組みを使わずともここでの目的は達成できる。C++ではテンプレートによる手法が知られており、また、構造的部分型付けを行う言語でも実現できる。<a
href="#fnref81" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn82"><p>訳注：最汎単一化子 (most general unifier)
と呼ばれる。<a href="#fnref82" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="12.3" id="余極限"><span
class="header-section-number">12.3</span> 余極限</h2>
<p>圏論のすべての構造と同じく、極限には双対となる像が反対圏にある。錐内のすべての射の方向を反転させると余錐
(co-cone) ができ、余錐たちのうち普遍なものが余極限 (colimit)
と呼ばれる。反転が分解射にも影響することに注意してほしい。分解射は普遍な余錐から他の余錐へと向かうことになる。</p>
<figure>
<img src="images/colimit.jpg"
title="2つの頂点を結ぶ分解射`h`を持つ余錐。" style="width:35.0%"
alt="2つの頂点を結ぶ分解射hを持つ余錐。" />
<figcaption
aria-hidden="true">2つの頂点を結ぶ分解射<code>h</code>を持つ余錐。</figcaption>
</figure>
<p>
余極限の典型的な例は余積だ。これは、積の定義で使った<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏によって生成される図式に対応する。</p>
<p> <img src="images/coproductranking.jpg" style="width:35.0%" /> </p>
<p> 積も余積も、別々の方法で対象のペアの本質を具現化している。</p>
<p>終対象が極限であったように、始対象は空圏に基づく図式に対応する余極限である。</p>
<p>引き戻しの双対は<em>押し出し</em> (pushout)
と呼ばれる。それは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>←</mo><mn>2</mn><mo>→</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1\leftarrow2\rightarrow3</annotation></semantics></math>によって生成されるスパン
(span) と呼ばれる図式に基づく。</p>
<h2 data-number="12.4" id="連続性"><span
class="header-section-number">12.4</span> 連続性</h2>
<p>すでに述べたように、関手は圏の連続写像の概念に近い。既存の接続（射）を決して壊さないからだ。圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐂</mi><mo mathvariant="bold">′</mo></msup><annotation encoding="application/x-tex">\mathbf{C&#39;}</annotation></semantics></math>への<em>連続関手</em>
(continuous functor)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>の実際の定義には、関手が極限を保存するという要件が含まれている。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内のすべての図式<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>は、単に2つの関手を合成すれば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐂</mi><mo mathvariant="bold">′</mo></msup><annotation encoding="application/x-tex">\mathbf{C&#39;}</annotation></semantics></math>内の図式<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∘</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F \circ D</annotation></semantics></math>に写せる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>の連続性条件は、図式<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>が極限<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi></mrow><annotation encoding="application/x-tex">%
\mathbf{Lim}{D}%
</annotation></semantics></math>を有するなら、図式<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∘</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">F \circ D</annotation></semantics></math>も極限を有し、それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F (%
\mathbf{Lim}{D}%
)</annotation></semantics></math> に等しいことを示している。</p>
<p> <img src="images/continuity.jpg" style="width:60.0%" /> </p>
<p>
関手は射を射に、合成を合成に写すので、錐の像は常に錐であることに注意してほしい。可換な三角形は常に可換な三角形に写される（関手は合成を保存する）。分解射についても同じことが言えて、分解射の像も分解射となる。したがって、どの関手も<em>ほぼ</em>連続している。問題になりうるのは一意性条件だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐂</mi><mo mathvariant="bold">′</mo></msup><annotation encoding="application/x-tex">\mathbf{C&#39;}</annotation></semantics></math>の分解射は一意でないことがある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐂</mi><mo mathvariant="bold">′</mo></msup><annotation encoding="application/x-tex">\mathbf{C&#39;}</annotation></semantics></math>には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>にはなかった「より優れた錐」が他にあるかもしれない。</p>
<p>Hom関手は連続関手の一例だ。Hom関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
が、1番目の変数について反変であり、2番目の変数について共変であることを思い出してほしい。言い換えれば、次の関手だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>×</mo><mrow></mrow><mi>𝐂</mi><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{C}^\mathit{op} \times{} \mathbf{C} \to \mathbf{Set}</annotation></semantics></math>
第2引数が固定されると、hom集合関手（表現可能前層になる）は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の余極限を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>の極限に写す。第1引数が固定されると、極限を極限に写す。</p>
<p>Haskellでのhom関手は、任意の2つの型を関数型に対応させる写像であるため、単なるパラメーター化された関数型だ。2番目のパラメーターを、たとえば<code>String</code>に固定すると、次の反変関手が得られる。</p>
<div class="sourceCode" id="cb320"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb320-1"><a href="#cb320-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ToString</span> a <span class="ot">=</span> <span class="dt">ToString</span> (a <span class="ot">-&gt;</span> <span class="dt">String</span>)</span>
<span id="cb320-2"><a href="#cb320-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">ToString</span> <span class="kw">where</span></span>
<span id="cb320-3"><a href="#cb320-3" aria-hidden="true" tabindex="-1"></a>    contramap f (<span class="dt">ToString</span> g) <span class="ot">=</span> <span class="dt">ToString</span> (g <span class="op">.</span> f)</span></code></pre></div>
<p>
連続性は、<code>ToString</code>が余極限、たとえば余積<code>Either b c</code>に適用された場合に極限を生成することを意味する。この場合、極限は2つの関数型の積である。つまり、</p>
<div class="sourceCode" id="cb321"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb321-1"><a href="#cb321-1" aria-hidden="true" tabindex="-1"></a><span class="dt">ToString</span> (<span class="dt">Either</span> b c) <span class="op">~</span> (b <span class="ot">-&gt;</span> <span class="dt">String</span>, c <span class="ot">-&gt;</span> <span class="dt">String</span>)</span></code></pre></div>
<p>
実際に、<code>Either b c</code>のどんな関数も、関数のペアに対応する2つの場合分けを持つ<code>case</code>式として実装される。</p>
<p>同様に、hom集合の第1引数を固定すると、おなじみのreader関手が得られる。その連続性は、たとえば、積を返す関数どの関数も積と等価であることを意味する。具体的にはこうなる。</p>
<div class="sourceCode" id="cb322"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb322-1"><a href="#cb322-1" aria-hidden="true" tabindex="-1"></a>r <span class="ot">-&gt;</span> (a, b) <span class="op">~</span> (r <span class="ot">-&gt;</span> a, r <span class="ot">-&gt;</span> b)</span></code></pre></div>
<p>
読者がどう思っているかは分かっている。これらを理解するのに圏論は必要ない。そのとおりだ！　それでも、このような結果がビットやバイト、プロセッサーアーキテクチャ、コンパイラー技術、さらにはラムダ計算に頼ることなく第一原理から得られるのは驚くべきことだと思う。</p>
<p>「極限」と「連続性」という名前の由来が何なのか気になるなら、それらは微積分学において対応する概念を一般化したものだ。微積分学では、極限と連続性は開近傍によって定義される。開集合たちは、位相
(topology) を定義し、圏（半順序集合）もなす。</p>
<h2 data-number="12.5" id="課題-9"><span
class="header-section-number">12.5</span> 課題</h2>
<ol type="1">
<li><p>C++のクラスの圏における押し出しはどのようなものだろうか？</p></li>
<li><p>恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐈</mi><mi>𝐝</mi></mrow><mo>∷</mo><mi>𝐂</mi><mo>→</mo><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">\mathbf{Id} \Colon \mathbf{C} \to \mathbf{C}</annotation></semantics></math>の極限が始対象であることを示せ。</p></li>
<li><p>与えられた集合の部分集合たちは圏をなす。その圏の射は、1番目の集合が2番目の集合の部分集合である場合、それら2つの集合を接続する矢として定義される。そのような圏内の集合2つの引き戻しは何か？
押し出しは何か？ 始対象と終対象は何か？</p></li>
<li><p>余等化子 (coequalizer) とは何か予想できるか？</p></li>
<li><p>終対象が存在する圏では、終対象に向かう引き戻しが積であることを示せ。</p></li>
<li><p>同様に、始対象が存在するなら、始対象からの押し出しが余積であることを示せ。</p></li>
</ol>
<h1 data-number="13" id="free-monoids"><span
class="header-section-number">13</span> 自由モノイド</h1>
<p>モノイドは圏論とプログラミングの両方において重要な概念となる。圏は強く型付けされた言語に対応し、モノイドは型なし言語に対応する。型なしの言語で任意の2つの関数を合成できる（当然、プログラムを実行したときにランタイムエラーが発生する可能性はある）ように、モノイドでは任意の2つの射を合成できるからだ。</p>
<p>これまでに見てきたように、モノイドは単一の対象を持つ圏として記述され、その圏ではすべての論理が射の合成の規則として表現されている。この圏論的モデルは、より伝統的で集合論的なモノイドの定義と完全に等価だ。そこでは集合の2つの要素を「乗算」することで第3の要素が得られる。この「乗算」の過程はさらに細かく分割できる。すなわち、まず要素のペア1つを形成するという過程と、次にこのペアを既存の要素――それらの「積」と同一視するという過程だ。</p>
<p>乗算の2番目の部分、つまりペアと既存の要素との同一視を省くとどうなるだろうか？　たとえば、任意の集合から始めて、ペアにできる要素をすべてペアにし、それらを新しい要素と呼ぶことができる。次に、それらの新しい要素とペアにできる要素をすべてペアにしていく。以下同様だ。これは連鎖反応だ――新しい要素を永久に追加し続けられる。その結果は、無限集合であり、<em>ほぼ</em>モノイドとなる。ただし、モノイドには単位元と結合律も必要となる。しかし、問題ない。特別な単位元を追加し、生成されたペアの一部を同一視すれば、単位律
(unit law) と結合律をきちんと満たせる。</p>
<p>実際にどうなるかを簡単な例で見てみよう。2要素の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{a, b\}</annotation></semantics></math>から始めることにしよう。それらの要素を自由モノイドの生成元
(generator)
と呼ぶことにする。まず、単位元となる特別な要素<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math>を追加する。次に、要素のすべてのペアを追加し、それらを「積」と呼ぶ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の積はペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math>
となる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の積はペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(b, a)</annotation></semantics></math>
となり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の積は
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, a)</annotation></semantics></math>
となり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の積は
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(b, b)</annotation></semantics></math>
となる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math>とのペアも作れて、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>e</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, e)</annotation></semantics></math>
や
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>e</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(e, b)</annotation></semantics></math>
などになるが、それらは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>や<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>などと同一視することにする。結局このラウンドでは
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, a)</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(b, a)</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(b, a)</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(b, a)</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(b, b)</annotation></semantics></math>
だけを追加して、結果として<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>e</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{e, a, b, (a, a), (a, b), (b, a), (b, b)\}</annotation></semantics></math>という集合が得られる。</p>
<p> <img src="images/bunnies.jpg" style="width:80.0%" /> </p>
<p> 次のラウンドでは
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, (a, b))</annotation></semantics></math>
や
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">((a, b), a)</annotation></semantics></math>
といった要素を追加していく。この時点で、結合律が確実に満たされるようにする必要がある。そのため、たとえば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, (b, a))</annotation></semantics></math>
と
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">((a, b), a)</annotation></semantics></math>
を同一視する。要するに、内側の括弧は必要ないということだ。</p>
<p>このプロセスの最終的な結果が予想できるだろう。要素が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>か<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>であるようなすべてのリストが作られる。実際、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math>を空リストで表せば、「乗算」はリストの連接に他ならないことが分かる。</p>
<p>この種の構成では、要素の組み合わせとして可能なものすべてを生成し続け、同一視は最小限に――その構造の規則を維持するのにちょうど十分なだけに留める。こういった構成は自由構成と呼ばれる。上記では、生成元の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{a, b\}</annotation></semantics></math>から<span
id="free_monoid"
class="keyword"><em>自由モノイド</em></span>を構築した。</p>
<h2 data-number="13.1" id="haskellにおける自由モノイド"><span
class="header-section-number">13.1</span>
Haskellにおける自由モノイド</h2>
<p>Haskellにおける二元集合は型<code>Bool</code>と等価であり、この集合から生成される自由モノイドは型<code>[Bool]</code>（<code>Bool</code>のリスト）と等価だ。（無限リストの問題は意図的に無視している。）</p>
<p>Haskellのモノイドは型クラスによって定義されている。</p>
<div class="sourceCode" id="cb323"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb323-1"><a href="#cb323-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="kw">where</span></span>
<span id="cb323-2"><a href="#cb323-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    mempty  ::</span> m</span>
<span id="cb323-3"><a href="#cb323-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    mappend ::</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m</span></code></pre></div>
<p>
このクラスが意味しているのは、すべての<code>Monoid</code>が<code>mempty</code>と呼ばれる中立元と、<code>mappend</code>と呼ばれる二項関数（乗算）を持たなければならないということだ。Haskellでは単位律と結合律は表現できず、具体的なモノイドを与えるたびにプログラマーによって検証されなければならない。</p>
<p>任意の型のリストがモノイドをなすという事実は、次のインスタンス定義によって説明される。</p>
<div class="sourceCode" id="cb324"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb324-1"><a href="#cb324-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> [a] <span class="kw">where</span></span>
<span id="cb324-2"><a href="#cb324-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span>  <span class="ot">=</span> []</span>
<span id="cb324-3"><a href="#cb324-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mappend</span> <span class="ot">=</span> (<span class="op">++</span>)</span></code></pre></div>
<p>
これはリストモノイドについて、空リスト<code>[]</code>が単位元であり、リスト連接<code>(++)</code>が二項演算であることを述べている。</p>
<p>これまで見てきたように、型<code>a</code>のリストは集合<code>a</code>を生成元たちとする自由モノイドに対応する。その一方で、乗算を伴う自然数の集合は、多くの積が同一視されるので自由モノイドではない。次の2つを比べてみよう。</p>
<div class="sourceCode" id="cb325"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb325-1"><a href="#cb325-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">*</span> <span class="dv">3</span> <span class="ot">=</span> <span class="dv">6</span></span>
<span id="cb325-2"><a href="#cb325-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>] <span class="op">++</span> [<span class="dv">3</span>] <span class="ot">=</span> [<span class="dv">2</span>, <span class="dv">3</span>] <span class="co">-- [6]と同じではない</span></span></code></pre></div>
<p>
これは簡単な例だったが、圏論では対象の中を見るのが許されないのにどうやってこの自由構成を実現できるのか、という疑問がある。そこで我々の働き者にもうひと仕事してもらうとしよう。普遍的構成だ。</p>
<p>2番目の興味深い疑問は、単位律と結合律が最小限必要とするよりも多くの要素を同一視すれば、ある自由モノイドから任意のモノイドを得られるのか、ということだ。これが普遍的構成から直接導かれることをお見せしよう。</p>
<h2 data-number="13.2" id="自由モノイドの普遍的構成"><span
class="header-section-number">13.2</span> 自由モノイドの普遍的構成</h2>
<p>普遍的構成についての経験を振り返れば、それは何かを構築するというより、特定のパターンに最もよく適合する対象を選択するものだと気付くだろう。なので、普遍的構成を使って自由モノイドを「構築」したいなら、選択肢となる多数のモノイドの全体を考慮する必要がある。つまり、選択のもととなるモノイドの圏がまるごと必要だ。だが、モノイドたちは圏をなすのだろうか<a
href="#fn83" class="footnote-ref" id="fnref83"
role="doc-noteref"><sup>83</sup></a>？</p>
<p>まずは、単位元と二項演算による構造が加わった集合としてモノイドを見てみよう。そして、モノイドの構造を保存するような関数を射として採用する。構造を保存するそういった関数は<span
id="homomorphisms" class="keyword"><em>準同型</em></span> (homomorphism)
と呼ばれる。モノイド準同型は2つの要素の積を2つの要素の写し先の積へと写さなければならない。</p>
<div class="sourceCode" id="cb326"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb326-1"><a href="#cb326-1" aria-hidden="true" tabindex="-1"></a>h (a <span class="op">*</span> b) <span class="ot">=</span> h a <span class="op">*</span> h b</span></code></pre></div>
<p> そして、単位元を単位元に写さなければならない。</p>
<p>例として、整数のリストから整数への準同型を考えよう<a href="#fn84"
class="footnote-ref" id="fnref84"
role="doc-noteref"><sup>84</sup></a>。<code>[2]</code>を2に写し、<code>[3]</code>を3に写すなら、<code>[2, 3]</code>を6に写す必要がある。なぜなら、連接</p>
<div class="sourceCode" id="cb327"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>] <span class="op">++</span> [<span class="dv">3</span>] <span class="ot">=</span> [<span class="dv">2</span>, <span class="dv">3</span>]</span></code></pre></div>
<p> が次のような乗算に写されるからだ。</p>
<div class="sourceCode" id="cb328"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">*</span> <span class="dv">3</span> <span class="ot">=</span> <span class="dv">6</span></span></code></pre></div>
<p>
ここで、個々のモノイドの内部構造については忘れて、対応する射を持つ対象としてのみ見よう。すると、モノイドの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>が得られる。</p>
<p>さて、内部構造を忘れる前に、重要な性質に注目しておいた方がよいだろう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>のどの対象も自明に集合へと写せる。写し先の集合は単にもとのモノイドの要素の集合である。この集合は<span
id="underlying" class="keyword"><em>台</em></span>集合 (underlying set)
と呼ばれる。実際には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>の各対象を集合に写せるだけでなく、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>の各射（準同型）も関数に写せる。これも自明なだけに見えるが、すぐに役に立つ。この<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への対象と射の写像は、実は関手になっている。この関手はモノイドの構造を「忘れている」。いったん通常の集合の中に入ると、もはや単位元を区別したり乗算を気にしたりすることはない。こういった関手は<span
id="forgetful_functor" class="keyword"><em>忘却関手</em></span>
(forgetful functor) と呼ばれる。忘却関手は圏論ではよく出てくる。</p>
<p>これで、2つの異なる観点から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>を見たことになる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>は対象と射を伴う他のすべての圏と同じように扱える。この観点では、モノイドの内部構造は見えない。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>の中の特定の対象について言えるのは、それ自身や他の対象と射を通じて接続しているということだけだ。射の「乗算」表――つまり、合成の規則――は、もう一方の観点から導かれる。すなわち、集合としてのモノイドからである。圏論に進んだことでこの観点が完全に失われたわけではない――忘却関手を通じてならアクセスできる。</p>
<p>普遍的構成を適用するには、モノイドの圏を探索して自由モノイドの最も優れた候補を選べるようにするための特別な性質を定義する必要がある。しかし、自由モノイドはその生成元たちによって定義される。別の生成元たちを選べば、生成される自由モノイドは変わる（<code>Bool</code>のリストと<code>Int</code>のリストは違う）。我々の構成は、生成元の集合から始めなければならない。つまり、集合に戻ってきたということだ！</p>
<p>ここで忘却関手が役立つことになる。忘却関手によってモノイドをレントゲン撮影できる。そして、それらのかたまりたちのレントゲン写真から生成元たちを特定できる。その仕組みは以下のとおりだ。</p>
<p>生成元の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>から始める。この集合は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>の対象だ。</p>
<p>マッチさせようとしているパターンは、モノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>の対象――と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内の関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>で構成されている。</p>
<div class="sourceCode" id="cb329"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb329-1"><a href="#cb329-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> x <span class="ot">-&gt;</span> <span class="dt">U</span> m</span></code></pre></div>
<p>
ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への忘却関手だ。これは奇妙な混成パターンだ――半分は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>で半分は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>になっている。</p>
<p>意図としては、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>のレントゲン写真に写った生成元の集合が関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>によって特定されるようにするということだ。関数たちが集合内の点たち<a
href="#fn85" class="footnote-ref" id="fnref85"
role="doc-noteref"><sup>85</sup></a>をきちんと特定できない（それらを潰す）かもしれないことは問題ない。普遍的構成によってこのパターンの最も優れた代表が選ばれ、すべてが整理されるだろう<a
href="#fn86" class="footnote-ref" id="fnref86"
role="doc-noteref"><sup>86</sup></a>。</p>
<p> <img src="images/monoid-pattern.jpg" style="width:40.0%" /> </p>
<p>
候補間の順位付けも定義しなければならない。もう1つの候補があるとしよう。モノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>と、そのレントゲン写真に写った生成元たちを特定しようとする関数だ。</p>
<div class="sourceCode" id="cb330"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb330-1"><a href="#cb330-1" aria-hidden="true" tabindex="-1"></a><span class="ot">q ::</span> x <span class="ot">-&gt;</span> <span class="dt">U</span> n</span></code></pre></div>
<p>
以下のような条件を満たす場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>よりも優れていると言うことにしよう。その条件とは、モノイドの射（準同型なので構造を保存する）</p>
<div class="sourceCode" id="cb331"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb331-1"><a href="#cb331-1" aria-hidden="true" tabindex="-1"></a><span class="ot">h ::</span> m <span class="ot">-&gt;</span> n</span></code></pre></div>
<p>
があり、その<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>の下の像（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>は関手なので射を関数に写す）が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>を通じて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>を分解することだ。</p>
<div class="sourceCode" id="cb332"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb332-1"><a href="#cb332-1" aria-hidden="true" tabindex="-1"></a>q <span class="ot">=</span> <span class="dt">U</span> h <span class="op">.</span> p</span></code></pre></div>
<p>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>内で生成元たちを選択し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>内で「同じ」生成元たちを選択していると見なすなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>はこれらの生成元たちを2つのモノイドの間で写していると見なせる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>は、定義より、モノイドの構造を保存することを思い出してほしい。これは、一方のモノイドにおける2つの生成元の積が、もう一方のモノイドにおける対応する2つの生成元の積に写されることなどを意味する。</p>
<p> <img src="images/monoid-ranking.jpg" style="width:40.0%"
alt="モノイドの順位付け" /> </p>
<p>
この順位付けは、最も優れた候補、すなわち自由モノイドを見つけるために使われる。定義は次のとおりだ。</p>
<blockquote>
<p>（関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>を伴う）<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>を生成元<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>を伴う<strong>自由モノイド</strong>と呼ぶのは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>から（関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>を伴う）他の任意のモノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>への、前述の分解特性を満たす<em>一意な</em>射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>が存在する場合、かつその場合に限る。</p>
</blockquote>
<p>ところで、これは2番目の疑問に対する答えになっている。関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">U h</annotation></semantics></math>には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>m</mi></mrow><annotation encoding="application/x-tex">U m</annotation></semantics></math>の複数の要素を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">U n</annotation></semantics></math>の1つの要素へ潰す力がある。ここで、潰すことは自由モノイドのいくつかの要素を同一視することに対応する。したがって、生成元たちとして<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>を持つモノイドはどれも、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>に基づく自由モノイドから、いくつかの要素を同一視することによって得られる。自由モノイドとは、最小限のものだけしか同一視されていないモノイドのことだ。</p>
<p>自由モノイドについては、随伴について話すときにまた戻ってくることにしよう。</p>
<aside id="footnotes-46" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="83">
<li
id="fn83"><p>訳注：この章の冒頭ではモノイドと単一対象の圏との対応について述べていたが、ここではモノイドが対象であるような圏について述べていることに注意。<a
href="#fnref83" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn84"><p>訳注：ここでは二項演算が乗算であるようなモノイド構造を考えている。<a
href="#fnref84" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn85"><p>訳注：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>の生成元たちのこと。<a
href="#fnref85" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn86"><p>訳注：一般の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>について、ある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>による<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>の像は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>の全体を生成するとは限らず、ある部分モノイドを生成する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>が自由モノイド（後述の順位付けにおける最も優れた候補）ならば全体が生成される。<a
href="#fnref86" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="13.3" id="課題-10"><span
class="header-section-number">13.3</span> 課題</h2>
<ol type="1">
<li><p>モノイドの準同型が単位元を保存する、という条件は（当初は私もそう思ったように）冗長だと思うかもしれない。何しろ、すべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>について次が言えるのだから。</p>
<div class="sourceCode" id="cb333"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb333-1"><a href="#cb333-1" aria-hidden="true" tabindex="-1"></a>h a <span class="op">*</span> h e <span class="ot">=</span> h (a <span class="op">*</span> e) <span class="ot">=</span> h a</span></code></pre></div>
<p>
つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">h e</annotation></semantics></math>は右単位元のように働く（同様に、左単位元のようにも働く）。問題は、すべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>に対して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">h a</annotation></semantics></math>を集めてきたものを考えると、余域モノイドの部分モノイドしかカバーできないということだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>の像の外部に「真の」単位元が存在するかもしれない。モノイド間で乗算を保存する同型は自動的に単位元を保存することになることを示せ。</p></li>
<li><p>連接を二項演算とする整数リストから乗算を二項演算とする整数へのモノイド準同型について考える。空リスト<code>[]</code>の像は何か？　すべての単要素リストは、それが含む整数に写されるとする。たとえば、<code>[3]</code>は3に写される。<code>[1, 2, 3, 4]</code>の像は何か？　整数12に写されるリストはいくつあるか？　2つのモノイド間に他の準同型はあるか？</p></li>
<li><p>単元集合によって生成される自由モノイドとは何か？　それが何と同型なのか分かるか？</p></li>
</ol>
<h1 data-number="14" id="representable-functors"><span
class="header-section-number">14</span> 表現可能関手</h1>
<p>そろそろ集合について少し話すべき時が来た。数学者たちは集合論に対して愛憎する関係にある。集合論は数学にとってのアセンブリー言語だ――少なくともかつてはそうだった。圏論はある程度、集合論から距離を置こうとする。たとえば、すべての集合の集合は存在しないが、すべての集合の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>なら存在する、というのはよく知られた事実だ。これは良い。一方で我々は、圏内の任意の2対象間の射たちは集合をなす、と仮定した。そしてそれをhom集合と名付けさえした。公平のために言うと、圏論には射たちが集合をなさないことがあるような分野もある<a
href="#fn87" class="footnote-ref" id="fnref87"
role="doc-noteref"><sup>87</sup></a>。その代わりにそれらは別の圏の対象となる。hom集合の代わりにhom対象を使う圏は<span
id="enriched" class="keyword"><em>豊穣</em></span>圏 (enriched category)
と呼ばれる。だが、以下では古き良きhom集合を持つ圏に留まることにする。</p>
<p>集合は、圏論における対象たちから取り出せる特徴のない塊、というのが最も近い。集合は要素を含むが、それらについて多くは語れない。有限集合なら要素数を数えられる。基数
(cardinal number)
を使えば、無限集合の要素数をある意味で数えられる。たとえば、自然数の集合も実数の集合も無限集合だが、前者は後者よりも小さい。しかし、驚くかもしれないが、有理数の集合は自然数の集合と同じ大きさだ。</p>
<p>それ以外には、集合に関するすべての情報は、集合間の関数――特に、同型と呼ばれる可逆関数――として表せる。どこからどう見ても同型集合は同一だ。数学基礎論の研究者の逆鱗に触れる前に、等しさと同型には根本的に重要な区別があることを説明しておこう。これは数学の最新分野であるホモトピー型理論
(Homotopy Type Theory, HoTT)
の主要な関心事の1つだ。ここでHoTTについて触れる理由は、それが計算からインスピレーションを得た純粋な数学理論で、主唱者の1人であるVladimir
Voevodskyによる大きな発見が定理証明器Coqを研究しているときに得られたものだからだ。数学とプログラミングの相互作用は双方向なのだ。</p>
<p>集合に関する重要な教訓は、別種の要素からなる集合同士を比較しても問題ないということだ。たとえば、任意の自然変換の集合は何らかの射の集合と同型である、などと主張できる。集合は集合にすぎないからだ。この場合の同型は単に、一方の集合に属するどの自然変換に対しても他方の集合に属する一意な射が存在し、その逆もまた成り立つことを意味する。それらは互いにペアにできる。リンゴとオレンジが異なる圏の対象なら比較できないが、リンゴの集合とオレンジの集合は比較できる。多くの場合、圏論の問題を集合論の問題に変換すれば、必要な洞察が得られ、有用な定理を証明することさえ可能になる。</p>
<h2 data-number="14.1" id="hom関手-1"><span
class="header-section-number">14.1</span> Hom関手</h2>
<p>すべての圏には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への写像のカノニカルな族が用意されている。それらの写像は実際には関手であるため、圏の構造を保存している。そのような写像を1つ構築しよう。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内のある対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を固定し、同じく<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の別の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>を選択しよう。Hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation></semantics></math>
は集合であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>の対象だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を固定したまま<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>を変化させると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation></semantics></math>
も<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内で変化する。それゆえ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への写像が得られる。</p>
<p> <img src="images/hom-set.jpg" style="width:45.0%" /> </p>
<p>
hom集合を2番目の引数に関する写像と見なしていることを強調したい場合は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
と表記する。ここで、ダッシュは引数のプレースホルダーを表している。</p>
<p>この対象の写像は射の写像へと容易に拡張できる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の任意の2対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>の間の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を考えてみよう。先ほど定義した写像によって、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>は集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation></semantics></math>
に写され、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, y)</annotation></semantics></math>
に写される。この写像が関手となるなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>は2つの集合間の関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, x) \to \mathbf{C}(a, y)</annotation></semantics></math>
に写されなければならない。</p>
<p>この関数を点ごとに、つまり、引数ごとに個別に定義しよう。引数として<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation></semantics></math>
の任意の要素を1つ選択する必要がある。それを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>と呼ぶことにする。射たちは端と端が一致すれば合成できる。たまたま<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>の終点が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>の始点と一致しているので、それらの合成
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∘</mo><mi>h</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f \circ h \Colon a \to y</annotation></semantics></math>
は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>への射となる。したがって、これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, y)</annotation></semantics></math>
の元だ。</p>
<p> <img src="images/hom-functor.jpg" style="width:45.0%"
alt="Hom関手" /> </p>
<p>
先ほど、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation></semantics></math>
から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, y)</annotation></semantics></math>
への関数を見つけた。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>の像として使える。混乱のおそれがない場合は、この持ち上げられた関数を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, f)</annotation></semantics></math>と記し、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>に対する作用を次のように記すことにしよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mi>h</mi><mo>=</mo><mi>f</mi><mo>∘</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, f) h = f \circ h</annotation></semantics></math>
この構成はどの圏でも機能するので、Haskellの型の圏でも機能するはずだ。Haskellでは、hom関手は<code>Reader</code>関手としてよく知られている。</p>
<div class="sourceCode" id="cb334"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb334-1"><a href="#cb334-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Reader</span> a x <span class="ot">=</span> a <span class="ot">-&gt;</span> x</span></code></pre></div>
<div class="sourceCode" id="cb335"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb335-1"><a href="#cb335-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Reader</span> a) <span class="kw">where</span></span>
<span id="cb335-2"><a href="#cb335-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f h <span class="ot">=</span> f <span class="op">.</span> h</span></code></pre></div>
<p>
さて、Hom集合の始点を固定する代わりに終点を固定すると何が起こるかを考えてみよう。言い換えれば、写像<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(-, a)</annotation></semantics></math>
も関手なのかを問うている。答えはそのとおり、関手なのだが、共変関手ではなく反変関手になる。射の端と端を同様にマッチングすると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>との後合成となり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
の場合のような前合成ではないからだ。</p>
<p>この反変関手はHaskellですでに見た。それは<code>Op</code>と呼ばれていた。</p>
<div class="sourceCode" id="cb336"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb336-1"><a href="#cb336-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Op</span> a x <span class="ot">=</span> x <span class="ot">-&gt;</span> a</span></code></pre></div>
<div class="sourceCode" id="cb337"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb337-1"><a href="#cb337-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> (<span class="dt">Op</span> a) <span class="kw">where</span></span>
<span id="cb337-2"><a href="#cb337-2" aria-hidden="true" tabindex="-1"></a>    contramap f h <span class="ot">=</span> h <span class="op">.</span> f</span></code></pre></div>
<p>
最後に、両方の対象を変化させると、プロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mo>=</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(-, =)</annotation></semantics></math>
が得られる。これは1つ目の引数について反変で、2つ目の引数について共変だ（2つの引数が独立して変化することを強調するため、2つ目のプレースホルダーとしてダブルダッシュを使った）。このプロ関手については、関手性について述べたときにすでに見た。</p>
<div class="sourceCode" id="cb338"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb338-1"><a href="#cb338-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb338-2"><a href="#cb338-2" aria-hidden="true" tabindex="-1"></a>  dimap ab cd bc <span class="ot">=</span> cd <span class="op">.</span> bc <span class="op">.</span> ab</span>
<span id="cb338-3"><a href="#cb338-3" aria-hidden="true" tabindex="-1"></a>  lmap <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">.</span>)</span>
<span id="cb338-4"><a href="#cb338-4" aria-hidden="true" tabindex="-1"></a>  rmap <span class="ot">=</span> (<span class="op">.</span>)</span></code></pre></div>
<p>
重要な教訓として、対象たちをhom集合へ写すことは関手的である、という観察はすべての圏に当てはまる。反変性は反対圏から写すことと等価なので、この事実は簡潔にこう記せる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mo>=</mo><mo stretchy="false" form="postfix">)</mo><mo>∷</mo><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>×</mo><mi>𝐂</mi><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">C(-, =) \Colon \mathbf{C}^\mathit{op} \times \mathbf{C} \to \mathbf{Set}</annotation></semantics></math></p>
<aside id="footnotes-47" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="87">
<li
id="fn87"><p>訳注：ここでは2対象間の射たちについて述べている。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>でも、すべての射の集まり自体は集合にならない。<a
href="#fnref87" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="14.2" id="表現可能関手"><span
class="header-section-number">14.2</span> 表現可能関手</h2>
<p>これまでに見たように、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の選択ごとに<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への関手が得られる。構造を保存する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>へのこの種の写像は<span
id="representation" class="keyword"><em>表現</em></span>
(representation)
とよく呼ばれる。つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>における対象や射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内の集合や関数として表現しているということだ。</p>
<p>関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
自体を指して表現可能関手と呼ぶこともある。より一般には、ある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の選択に対してhom関手と自然同型である関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>はすべて<span
id="representable" class="keyword"><em>表現可能</em></span>
(representable) 関手と呼ばれる。このような関手は必然的に集合値
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>-valued)
関手となる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
がそうだからだ。</p>
<p>以前述べたように、同型集合は同一と見なされることが多い。より一般には、圏の同型<em>対象</em>は同一と見なされる。対象たちは他の対象たち（およびそれら自身）との射による関係だけしか構造を持たないからだ。</p>
<p>たとえば、モノイドの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>について前に説明した。それは最初は集合たちでモデル化されていた。ただし、それらの集合によるモノイドの構造を保存する関数のみを射として選ぶように気を付けた。そのため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>内の2つの対象は、同型なら、つまり可逆な射が間にあるなら、全く同じ構造を持つ。それらが基づく集合と関数を覗き見ると、一方のモノイドの単位元がもう一方のモノイドの単位元へと写され、2つの要素の積がそれらの要素を写したものの積へと写されているのが分かるだろう。</p>
<p>同じ推論が関手にも適用できる。2つの圏の間の関手は圏をなし、そこでは自然変換が射の役割を果たしている。したがって、2つの関手の間に可逆な自然変換があれば、それらは同型であり、同一と見なせる。</p>
<p>この観点から表現可能関手の定義を分析してみよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>が表現可能となるには次が必要だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内に対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>があり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>への自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>があり、逆方向に別の自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">\beta</annotation></semantics></math>があり、それらの合成が恒等自然変換である。</p>
<p>ある対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>における<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>の成分を見てみよう。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内の関数だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>x</mi></msub><mo>∷</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>F</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">\alpha_x \Colon \mathbf{C}(a, x) \to F x</annotation></semantics></math>
この変換の自然性条件は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>への任意の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>について、次の関係を表す図式が可換となることを示している。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>f</mi><mo>∘</mo><msub><mi>α</mi><mi>x</mi></msub><mo>=</mo><msub><mi>α</mi><mi>y</mi></msub><mo>∘</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F f \circ \alpha_x = \alpha_y \circ \mathbf{C}(a, f)</annotation></semantics></math>
Haskellでは、自然変換を多相関数で置き換えることになる。</p>
<div class="sourceCode" id="cb339"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb339-1"><a href="#cb339-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="kw">forall</span> x<span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> <span class="dt">F</span> x</span></code></pre></div>
<p> ここで使った量化子<code>forall</code>は必須ではない。自然性条件</p>
<div class="sourceCode" id="cb340"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb340-1"><a href="#cb340-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f <span class="op">.</span> alpha <span class="ot">=</span> alpha <span class="op">.</span> <span class="fu">fmap</span> f</span></code></pre></div>
<p> はパラメトリシティ (parametricity)
によって自動的に満たされる（この自然性条件は前述のtheorems for
freeのひとつだ）。これは、左辺の<code>fmap</code>が関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>によって定義され、右辺の<code>fmap</code>がreader関手によって定義されるという理解に基づく。readerの<code>fmap</code>は単なる関数の前合成<a
href="#fn88" class="footnote-ref" id="fnref88"
role="doc-noteref"><sup>88</sup></a>なので、さらにはっきりと書ける。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation></semantics></math>
の要素である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>に作用したときの自然性条件は次のように簡潔に書ける。</p>
<div class="sourceCode" id="cb341"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb341-1"><a href="#cb341-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (alpha h) <span class="ot">=</span> alpha (f <span class="op">.</span> h)</span></code></pre></div>
<p> もう1つの変換<code>beta</code>は方向が逆だ。</p>
<div class="sourceCode" id="cb342"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb342-1"><a href="#cb342-1" aria-hidden="true" tabindex="-1"></a><span class="ot">beta ::</span> <span class="kw">forall</span> x<span class="op">.</span> <span class="dt">F</span> x <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> x)</span></code></pre></div>
<p>
この関数も自然性条件を満たす必要があり、そして<code>alpha</code>の逆関数でなければならない。</p>
<div class="sourceCode" id="cb343"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb343-1"><a href="#cb343-1" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">.</span> beta <span class="ot">=</span> <span class="fu">id</span> <span class="ot">=</span> beta <span class="op">.</span> alpha</span></code></pre></div>
<p>
後で説明するとおり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>が空でないならば常に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
から任意の集合値関手への自然変換が存在する（米田の補題）が、この変換は可逆であるとは限らない。</p>
<p>Haskellでリスト関手を用い、<code>Int</code>を<code>a</code>とした例を挙げよう。以下が具体的な自然変換の一例だ。</p>
<div class="sourceCode" id="cb344"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb344-1"><a href="#cb344-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="kw">forall</span> x<span class="op">.</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> [x]</span>
<span id="cb344-2"><a href="#cb344-2" aria-hidden="true" tabindex="-1"></a>alpha h <span class="ot">=</span> <span class="fu">map</span> h [<span class="dv">12</span>]</span></code></pre></div>
<p>
勝手な数として12を選び、それを使って単要素リストを作成した。次に、このリストに関数<code>h</code>を<code>fmap</code>し、<code>h</code>の戻り値の型のリストを取得する。（実際には、そのような変換は整数のリストと同じくらいたくさんある。）</p>
<p>自然性条件は<code>map</code>（<code>fmap</code>のリスト版）の合成可能性と等価だ。</p>
<div class="sourceCode" id="cb345"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb345-1"><a href="#cb345-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f (<span class="fu">map</span> h [<span class="dv">12</span>]) <span class="ot">=</span> <span class="fu">map</span> (f <span class="op">.</span> h) [<span class="dv">12</span>]</span></code></pre></div>
<p>
しかし、逆変換を見つけるには、任意の型<code>x</code>のリストをもとに<code>x</code>を返す関数を探さなくてはならない。</p>
<div class="sourceCode" id="cb346"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb346-1"><a href="#cb346-1" aria-hidden="true" tabindex="-1"></a><span class="ot">beta ::</span> <span class="kw">forall</span> x<span class="op">.</span> [x] <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> x)</span></code></pre></div>
<p>
<code>head</code>か何かを使ってリストから<code>x</code>を取得しようと考えたかもしれないが、空のリストには使えない。（<code>Int</code>の箇所の）型<code>a</code>の選択肢としてここで使えるものがないことに注目してほしい。すなわち、リスト関手は表現可能ではない。</p>
<p>Haskellの（自己）関手がコンテナーに少し似ていると言ったのを覚えているだろうか？　同じように、表現可能関手は関数呼び出しの結果をメモ化して保存するためのコンテナーと見なせる（Haskellでのhom集合の要素は単なる関数だ）。表現対象
(representing
object)、すなわち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
における型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>はキー型と見なせて、それを用いれば表化
(tabulate)
された関数値にアクセスできる。ここでの変換<code>alpha</code>は<code>tabulate</code>と呼ばれ、その逆の<code>beta</code>は<code>index</code>と呼ばれる。以下に（少し単純化した）<code>Representable</code>のクラス定義を示す。</p>
<div class="sourceCode" id="cb347"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb347-1"><a href="#cb347-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Representable</span> f <span class="kw">where</span></span>
<span id="cb347-2"><a href="#cb347-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">type</span> <span class="dt">Rep</span><span class="ot"> f ::</span> <span class="op">*</span></span>
<span id="cb347-3"><a href="#cb347-3" aria-hidden="true" tabindex="-1"></a><span class="ot">   tabulate ::</span> (<span class="dt">Rep</span> f <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> f x</span>
<span id="cb347-4"><a href="#cb347-4" aria-hidden="true" tabindex="-1"></a><span class="ot">   index    ::</span> f x <span class="ot">-&gt;</span> <span class="dt">Rep</span> f <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>
表現型、すなわち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>が、ここでは<code>Rep f</code>と呼ばれ、<code>Representable</code>の定義の一部であることに注目してほしい。スターは<code>Rep f</code>が型である（型構成子や他のエキゾチックな種ではない）ことを意味する<a
href="#fn89" class="footnote-ref" id="fnref89"
role="doc-noteref"><sup>89</sup></a>。</p>
<p>無限リストや無限ストリームは、空ではあり得ず、表現可能だ。</p>
<div class="sourceCode" id="cb348"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb348-1"><a href="#cb348-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stream</span> x <span class="ot">=</span> <span class="dt">Cons</span> x (<span class="dt">Stream</span> x)</span></code></pre></div>
<p>
それらは<code>Integer</code>を引数に取る関数の値をメモ化したものと見なせる。（厳密に言えば、非負整数を使うべきだが、コードを複雑にしたくなかった<a
href="#fn90" class="footnote-ref" id="fnref90"
role="doc-noteref"><sup>90</sup></a>。）</p>
<p>このような関数を<code>tabulate</code>にするには、値の無限ストリームを作成する。もちろん、これが可能なのはHaskellが遅延評価だからだ。つまり、値は必要になったとき評価される。メモ化された値にアクセスするには<code>index</code>を使う。</p>
<div class="sourceCode" id="cb349"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb349-1"><a href="#cb349-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Representable</span> <span class="dt">Stream</span> <span class="kw">where</span></span>
<span id="cb349-2"><a href="#cb349-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Rep</span> <span class="dt">Stream</span> <span class="ot">=</span> <span class="dt">Integer</span></span>
<span id="cb349-3"><a href="#cb349-3" aria-hidden="true" tabindex="-1"></a>    tabulate f <span class="ot">=</span> <span class="dt">Cons</span> (f <span class="dv">0</span>) (tabulate (f <span class="op">.</span> (<span class="op">+</span><span class="dv">1</span>)))</span>
<span id="cb349-4"><a href="#cb349-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">index</span> (<span class="dt">Cons</span> b bs) n <span class="ot">=</span></span>
<span id="cb349-5"><a href="#cb349-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> b <span class="kw">else</span> <span class="fu">index</span> bs (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>
任意の戻り値型を持つ関数の族をすべてカバーするような単一のメモ化スキームを実装できるのは興味深い。</p>
<p>反変関手の表現可能性も同様に定義される。ただし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(-, a)</annotation></semantics></math>
の2番目の引数を固定する。あるいは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への関手を考えるのでも等価だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}(a, -)</annotation></semantics></math>
は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(-, a)</annotation></semantics></math>
と同じだからだ。</p>
<p>表現可能性には興味深いひねりがある。デカルト閉圏では、hom集合を内部的には冪対象として扱えることを思い出してほしい。hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation></semantics></math>
は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>x</mi><mi>a</mi></msup><annotation encoding="application/x-tex">x^a</annotation></semantics></math>と等価で、表現可能関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>に対しては<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>−</mo><mi>a</mi></msup><mo>=</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">-^a = F</annotation></semantics></math>と書ける。</p>
<p>試しに、両辺の対数を取ってみると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mrow><mi>𝐥</mi><mi>𝐨</mi><mi>𝐠</mi></mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">a = \mathbf{log}F</annotation></semantics></math>となる。</p>
<p>もちろん、これは純粋に形式的な変換だが、対数の性質を多少知っているなら非常に便利だ。特に、直積型に基づく関手は直和型を用いて表現でき<a
href="#fn91" class="footnote-ref" id="fnref91"
role="doc-noteref"><sup>91</sup></a>、直和型の関手は一般に表現可能ではないことが知られている（例：リスト関手）。</p>
<p>最後に、表現可能関手が同じものに対する2種類の実装――ひとつは関数、もうひとつはデータ構造――を与えることに注目してほしい。それらの内容は全く同じだ――同じキーを使えば同じ値が取得される。それが、語ろうとしていた「同一性」の感覚だ。2つの自然同型な関手は内容に関する限り同一だ。その一方で、2つの表現は異なる方法で実装されることが多く、パフォーマンス特性が異なる可能性がある。メモ化はパフォーマンス改善策として使われ、実行時間の大幅な短縮につながる可能性がある。同じ計算を背景とする異なる表現を生成できることは、実用上の価値が非常に高い。そのため、驚くべきことに、圏論はパフォーマンスを全く考慮しないにもかかわらず、実用上の価値を持つ別の実装を探求する十分な機会を与えてくれる。</p>
<aside id="footnotes-48" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="88">
<li
id="fn88"><p>訳注：引数の関数<code>f</code>にreaderの関数を前合成する。<a
href="#fnref88" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn89"><p>訳注：事実標準のHaskell処理系のGHCでは、現在はこの用法でのスター<code>*</code>は非推奨となっている。代わりに<code>Data.Kind</code>モジュールが提供する<code>Type</code>を用いる。<a
href="#fnref89" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn90"><p>訳注：<code>Integer</code>の代わりに<code>Numeric.Natural</code>モジュールが提供する<code>Natural</code>を用いればよい。<a
href="#fnref90" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn91"><p>訳注：すなわち、上で言うところの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>が直和型になるということ。<a
href="#fnref91" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="14.3" id="課題-11"><span
class="header-section-number">14.3</span> 課題</h2>
<ol type="1">
<li><p>Hom関手が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の恒等射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内の対応する恒等関数に写すことを示せ。</p></li>
<li><p><code>Maybe</code>が表現可能でないことを示せ。</p></li>
<li><p><code>Reader</code>関手は表現可能か？</p></li>
<li><p><code>Stream</code>表現を使って、引数を2乗する関数をメモ化せよ。</p></li>
<li><p><code>Stream</code>に対する<code>tabulate</code>と<code>index</code>が実際に互いに逆であることを示せ。（ヒント：数学的帰納法を使う。）</p></li>
<li><p>次の関手</p>
<div class="sourceCode" id="cb350"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb350-1"><a href="#cb350-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Pair</span> a <span class="ot">=</span> <span class="dt">Pair</span> a a</span></code></pre></div>
<p> は表現可能だ。それを表現する型が分かるだろうか？
<code>tabulate</code>と<code>index</code>を実装せよ。</p></li>
</ol>
<h2 data-number="14.4" id="参考文献-2"><span
class="header-section-number">14.4</span> 参考文献</h2>
<ol type="1">
<li><a
href="https://www.youtube.com/watch?v=4QgjKUzyrhM">表現可能関手についてのCatstersの動画</a><a
href="#fn92" class="footnote-ref" id="fnref92"
role="doc-noteref"><sup>92</sup></a></li>
</ol>
<aside id="footnotes-49" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="92">
<li id="fn92"><p><a href="https://www.youtube.com/watch?v=4QgjKUzyrhM"
class="uri">https://www.youtube.com/watch?v=4QgjKUzyrhM</a><a
href="#fnref92" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 data-number="15" id="the-yoneda-lemma"><span
class="header-section-number">15</span> 米田の補題</h1>
<p>圏論における構成物のほとんどは、より具体的な他の数学の分野での結果を一般化したものだ。積・余積・モノイド・冪などは、圏論よりずっと前から知られていた。それらは別の数学の分野では別の名前で知られていたかもしれない。集合論におけるデカルト積、順序理論における交わり
(meet)、論理学における論理積――これらはすべて圏論的な積という抽象概念に対応する具体例だ。</p>
<p>米田の補題は、この観点から、数学の他の分野では全くと言ってよいほど前例がないような圏一般に関する包括的な主張として際立っている。一番似ているのは群論におけるケイリーの定理（すべての群はある集合の置換群と同型）<a
href="#fn93" class="footnote-ref" id="fnref93"
role="doc-noteref"><sup>93</sup></a>だという説もある。</p>
<p>米田の補題の問題設定は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>を持つような任意の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>についてのものだ。すでに前章で述べたように、集合値関手のいくつかは表現可能、つまりhom関手と同型である。米田の補題は、すべての集合値関手がhom関手たちから自然変換によって得られることを示し、そのようなすべての変換を明示的に列挙する。</p>
<p>自然変換について話したとき、自然性条件は制限が非常に強いものになる場合があると述べた。1つの対象における自然変換の成分を定義するとき、射を介して接続されている別の対象へとその成分を「トランスポート」できるほどに自然性が強いことがある。もとの圏と行き先の圏で対象間の射が多いほど、自然変換の成分をトランスポートするための制約が厳しくなる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>はたまたま射が豊富な圏だ。</p>
<p>米田の補題から言えるのは、あるhom関手と他の任意の関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>との間の自然変換が、その単一成分の値をある1点について指定するだけで完全に決定されるということだ！　残りの成分は単に自然性条件に従って決まる。</p>
<p>では、米田の補題に関わる2つの関手について、その間の自然性条件をおさらいしよう。1番目の関手はhom関手だ。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>を射の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation></semantics></math>
に写す。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の固定された対象だ。また、すでに見たとおり、そのhom関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>をすべて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, f)</annotation></semantics></math>
に写す。</p>
<p>2番目の関手は任意の集合値関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>だ。</p>
<p>この2つの関手の間の自然変換を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>と呼ぶことにしよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内を扱っているので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\alpha_x</annotation></semantics></math>や<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>y</mi></msub><annotation encoding="application/x-tex">\alpha_y</annotation></semantics></math>などの自然変換の成分は集合間の通常の関数にすぎない。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>α</mi><mi>x</mi></msub><mo>∷</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>F</mi><mi>x</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>α</mi><mi>y</mi></msub><mo>∷</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>F</mi><mi>y</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
\alpha_x \Colon \mathbf{C}(a, x) \to F x \\
\alpha_y \Colon \mathbf{C}(a, y) \to F y
\end{gathered}
</annotation></semantics></math></p>
<p> <img src="images/yoneda1.png" style="width:40.0%" /> </p>
<p>
そして、これらは単なる関数なので、特定の点での値を見られる。だが、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation></semantics></math>
内の点とは何だろうか？　鍵となる観察はこうだ。集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation></semantics></math>
内のすべての点は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>でもある。</p>
<p>したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>についての自然性の正方図式
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>y</mi></msub><mo>∘</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>F</mi><mi>f</mi><mo>∘</mo><msub><mi>α</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_y \circ \mathbf{C}(a, f) = F f \circ \alpha_x</annotation></semantics></math>
の両辺を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>に作用させると、点ごとの等式になる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>y</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mi>h</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>α</mi><mi>x</mi></msub><mi>h</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\alpha_y (\mathbf{C}(a, f) h) = (F f) (\alpha_x h)</annotation></semantics></math>
前の節でhom関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>への作用を、次のような前合成として定義したことを思い出しただろう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mi>h</mi><mo>=</mo><mi>f</mi><mo>∘</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, f) h = f \circ h</annotation></semantics></math>
これにより次が導かれる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>y</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>∘</mo><mi>h</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>α</mi><mi>x</mi></msub><mi>h</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\alpha_y (f \circ h) = (F f) (\alpha_x h)</annotation></semantics></math>
この条件がどれほど強いかは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x = a</annotation></semantics></math>の場合に特化させれば分かる。</p>
<p> <img src="images/yoneda2.png" style="width:40.0%" /> </p>
<p>
この場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>への射となる。そのような射が少なくとも1つ存在するのは分かっている。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">h = \mathbf{id}_a</annotation></semantics></math>だ。これを代入してみよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>y</mi></msub><mi>f</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>α</mi><mi>a</mi></msub><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\alpha_y f = (F f) (\alpha_a \mathbf{id}_a)</annotation></semantics></math>
何が起きたか注目してほしい。左辺は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>y</mi></msub><annotation encoding="application/x-tex">\alpha_y</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, y)</annotation></semantics></math>
の任意の要素<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>に作用させている。そして、その結果は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub><annotation encoding="application/x-tex">\mathbf{id}_a</annotation></semantics></math>における<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\alpha_a</annotation></semantics></math>という単一の値によって完全に決まる。そのような値は任意に選べて、それによって自然変換が生成される。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\alpha_a</annotation></semantics></math>たちの値は集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>に含まれるので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>のどの点からも何らかの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>が定義される。</p>
<p>逆に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>への自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>が与えられた場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub><annotation encoding="application/x-tex">\mathbf{id}_a</annotation></semantics></math>において評価すれば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>の点を得られる。</p>
<p>以上より、米田の補題が証明された。</p>
<blockquote>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>への自然変換と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>の要素との間には1対1の対応がある。</p>
</blockquote>
<p>言い換えれば
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑁</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>F</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\mathit{Nat}(\mathbf{C}(a, -), F) \cong F a</annotation></semantics></math>
となる。あるいは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation></semantics></math>という表記で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>の間の関手圏を表すと、自然変換の集合は単にその圏のhom集合であり、次のように書ける。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>F</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(a, -), F) \cong F a</annotation></semantics></math>
この対応が実際には自然同型である仕組みについては後で説明する。</p>
<p>さて、この結果について直観的に理解してみよう。最も驚くべきことは、自然変換全体の結晶化が、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub><annotation encoding="application/x-tex">\mathbf{id}_a</annotation></semantics></math>において割り当てた値というたった1粒の種から始まることだ。結晶化はその1点から自然性条件に従って広がっていく。そして<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の像を溢れさせる。そこで、まずは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
の下で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の像について考えてみたい。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>自体の像から始めよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>は、hom関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
の下では集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
に写される。一方、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>の下では集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>に写される。自然変換の成分<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\alpha_a</annotation></semantics></math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>への何らかの関数となる。集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
の中の1点だけに注目することにしよう。具体的には射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub><annotation encoding="application/x-tex">\mathbf{id}_a</annotation></semantics></math>に対応する点だ。集合内の1点にすぎないという事実を強調するために、それを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>と呼ぼう。成分<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\alpha_a</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>内のある点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>に写すはずだ。どんな<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>を選択しても一意な自然変換が得られることを説明しよう。</p>
<p> <img src="images/yoneda3.png" style="width:30.0%" /> </p>
<p>
1つ目の主張は、1点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>を選択すれば関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\alpha_a</annotation></semantics></math>の残りが一意に決まる、というものだ。実際に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>へのある射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>に対応する他の任意の点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>′</mo></msup><annotation encoding="application/x-tex">p&#39;</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
内で選んでみよう。ここで米田の補題の魔法が起こり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>は集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
内の点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>′</mo></msup><annotation encoding="application/x-tex">p&#39;</annotation></semantics></math>と見なせる。同時に、それは集合間の2つの<em>関数</em>を選択する。確かに射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>は、hom関手では関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, g)</annotation></semantics></math>
に写され、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>では<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">F g</annotation></semantics></math>に写される。</p>
<p> <img src="images/yoneda4.png" style="width:40.0%" /> </p>
<p>
ここで、もとの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>に対する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, g)</annotation></semantics></math>
の作用を考えてみよう。覚えているとおり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub><annotation encoding="application/x-tex">\mathbf{id}_a</annotation></semantics></math>に対応する。それは前合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">g \circ \mathbf{id}_a</annotation></semantics></math>として定義され、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>と同じであり、点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>′</mo></msup><annotation encoding="application/x-tex">p&#39;</annotation></semantics></math>に対応する。したがって、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>に作用すると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>′</mo></msup><annotation encoding="application/x-tex">p&#39;</annotation></semantics></math>、すなわち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>を生成するような関数に写される。ぐるりと一周した！</p>
<p>さて、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>に対する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">F g</annotation></semantics></math>の作用を考えてみよう。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>内のある点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>q</mi><mo>′</mo></msup><annotation encoding="application/x-tex">q&#39;</annotation></semantics></math>となる。自然性の正方図式<a
href="#fn94" class="footnote-ref" id="fnref94"
role="doc-noteref"><sup>94</sup></a>を完成させるには、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>′</mo></msup><annotation encoding="application/x-tex">p&#39;</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\alpha_a</annotation></semantics></math>によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>q</mi><mo>′</mo></msup><annotation encoding="application/x-tex">q&#39;</annotation></semantics></math>に写される必要がある。
任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>′</mo></msup><annotation encoding="application/x-tex">p&#39;</annotation></semantics></math>（任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>）を選択し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\alpha_a</annotation></semantics></math>の下でのその写し先<a
href="#fn95" class="footnote-ref" id="fnref95"
role="doc-noteref"><sup>95</sup></a>を導出した。したがって、関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\alpha_a</annotation></semantics></math>は完全に決定される。</p>
<p>2つ目の主張は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>に接続された対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>に対して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\alpha_x</annotation></semantics></math>が一意に決定される、というものだ。これも同様の論法による。ただし、ここではさらに2つの集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation></semantics></math>
と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">F x</annotation></semantics></math>があり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>への［訳注：任意に選んだ］射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>は、hom関手の下では
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>∷</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, g) \Colon \mathbf{C}(a, a) \to \mathbf{C}(a, x)</annotation></semantics></math>
に写され、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>の下では
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>g</mi><mo>∷</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>F</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">F g \Colon F a \to F x</annotation></semantics></math>
に写される。ここでも、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>に作用した場合の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, g)</annotation></semantics></math>
は前合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">g \circ \mathbf{id}_a</annotation></semantics></math>によって与えられ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation></semantics></math>
内の点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>′</mo></msup><annotation encoding="application/x-tex">p&#39;</annotation></semantics></math>となる。自然性により、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>′</mo></msup><annotation encoding="application/x-tex">p&#39;</annotation></semantics></math>に作用する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\alpha_x</annotation></semantics></math>の値はこう決まる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>q</mi><mo>′</mo></msup><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">q&#39; = (F g) q</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mo>′</mo></msup><annotation encoding="application/x-tex">p&#39;</annotation></semantics></math>は任意に決めていたので、関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mi>x</mi></msub><annotation encoding="application/x-tex">\alpha_x</annotation></semantics></math>全体が決定される。</p>
<p> <img src="images/yoneda5.png" style="width:40.0%" /> </p>
<p>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と接続されていない対象がある場合はどうなるだろう？　それらすべてが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
の下で空集合に写される。空集合は集合の圏における始対象であることを思い出してほしい。これは、この集合から他のどの集合へも一意な関数があることを意味する。その関数を<code>absurd</code>と呼んだ。したがって、ここでも自然変換の成分には選択の余地がなく、<code>absurd</code>しかあり得ない。</p>
<p>米田の補題を理解する方法の1つは、集合値関手の間の自然変換は関数の族にすぎず、関数は一般には非可逆だと気付くことだ。関数は情報を潰すこともあり、余域の一部しかカバーしないこともある。非可逆でない関数は、可逆なもの、つまり同型たちだけだ。したがって、構造を保存する最も優れた集合値関手たちは表現可能関手だということになる。それらはhom関手か、あるいはhom関手と自然同型な関手のどちらかだ。その他の関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>はすべてhom関手を非可逆変換することで得られる。そのような変換は、情報を失わせるだけでなく、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>による<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内の像のごく一部しかカバーしない可能性がある。</p>
<h2 data-number="15.1" id="haskellにおける米田の補題"><span
class="header-section-number">15.1</span> Haskellにおける米田の補題</h2>
<p>Haskellのhom関手には、すでにreader関手という名前で出会っている。</p>
<div class="sourceCode" id="cb351"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb351-1"><a href="#cb351-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Reader</span> a x <span class="ot">=</span> a <span class="ot">-&gt;</span> x</span></code></pre></div>
<p> Readerは射たち（ここでは関数たち）を前合成で写す。</p>
<div class="sourceCode" id="cb352"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb352-1"><a href="#cb352-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Reader</span> a) <span class="kw">where</span></span>
<span id="cb352-2"><a href="#cb352-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f h <span class="ot">=</span> f <span class="op">.</span> h</span></code></pre></div>
<p> 米田の補題によれば、reader関手は他の任意の関手へ自然に写せる。</p>
<p>自然変換は多相関数だ。さて、任意の関手<code>F</code>について、reader関手からの写像を考えられる。</p>
<div class="sourceCode" id="cb353"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb353-1"><a href="#cb353-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="kw">forall</span> x <span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> <span class="dt">F</span> x</span></code></pre></div>
<p>
いつものように、<code>forall</code>は必須ではないが、自然変換のパラメトリック多相性を強調するために明示的に書くことにしている。</p>
<p>米田の補題によれば、これらの自然変換は<code>F a</code>の要素たちと1対1に対応している。</p>
<div class="sourceCode" id="cb354"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb354-1"><a href="#cb354-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> x <span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> <span class="dt">F</span> x ≅ <span class="dt">F</span> a</span></code></pre></div>
<p>
この等式の右辺は、通常はデータ構造と見なしているものだった。一般化されたコンテナーとして関手を解釈したのを覚えているだろうか？　<code>F a</code>は<code>a</code>のコンテナーだ。一方で、左辺は関数を引数に取る多相関数だ。米田の補題によれば、この2つの表現は等価だ――それらは同じ情報を含んでいる。</p>
<p>別の言い方をすると以下のようになる。次のような型の多相関数</p>
<div class="sourceCode" id="cb355"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb355-1"><a href="#cb355-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="kw">forall</span> x <span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> <span class="dt">F</span> x</span></code></pre></div>
<p>
を与えてくれれば<code>a</code>のコンテナーを作成してみせよう。ここで使うトリックは米田の補題の証明で使ったものだ。つまり、この関数を<code>id</code>で呼び出すことで型<code>F a</code>の要素を得る。</p>
<div class="sourceCode" id="cb356"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb356-1"><a href="#cb356-1" aria-hidden="true" tabindex="-1"></a>alpha<span class="ot"> id ::</span> <span class="dt">F</span> a</span></code></pre></div>
<p> 逆もまた真だ。型<code>F a</code>の任意の値</p>
<div class="sourceCode" id="cb357"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb357-1"><a href="#cb357-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fa ::</span> <span class="dt">F</span> a</span></code></pre></div>
<p> について、適切な型の多相関数</p>
<div class="sourceCode" id="cb358"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb358-1"><a href="#cb358-1" aria-hidden="true" tabindex="-1"></a>alpha h <span class="ot">=</span> <span class="fu">fmap</span> h fa</span></code></pre></div>
<p> を定義できる。2つの表現の間は簡単に行き来できるということだ。</p>
<p>表現が複数ある利点は、一方が他方よりも合成しやすかったり、用途によってはより効率的だったりすることだ。</p>
<p>この原則の最も単純な例は、コンパイラーの構成でよく使われるコード変換である、継続渡し形式
(continuation passing style, CPS)
だ。これは米田の補題を恒等関手へ最も単純に適用したものだ。<code>F</code>を恒等関手に置き換えると、次のようになる。</p>
<div class="sourceCode" id="cb359"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb359-1"><a href="#cb359-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> r <span class="op">.</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r ≅ a</span></code></pre></div>
<p>
この等式は、任意の型<code>a</code>は<code>a</code>に対する「ハンドラー」を取る関数によって置き換えられる、と解釈できる。ハンドラーは、<code>a</code>を受け入れ、残りの計算――継続――を実行する関数だ。（型<code>r</code>は通常、ある種のステータスコードをカプセル化している。）</p>
<p>このスタイルのプログラミングは、UI、非同期システム、並行プログラミングではごく一般的だ。CPSの欠点は、制御の反転を伴うことだ。コードが生産者と消費者（ハンドラー）に分割され、簡単には合成できない。ウェブプログラミングの経験がある人なら誰でも、ステートフルなハンドラーとやり取りするスパゲッティコードの悪夢をよく知っている<a
href="#fn96" class="footnote-ref" id="fnref96"
role="doc-noteref"><sup>96</sup></a>。後で見るように、関手とモナドを慎重に使えばCPSの合成的な特性をいくらか取り戻せる。</p>
<aside id="footnotes-50" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="93">
<li
id="fn93"><p>監訳注：詳細は省くが、群の要素<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>↦</mo><mi>x</mi><mo>⊗</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">y \mapsto x \otimes y</annotation></semantics></math>という関数に写すような写像を考えると、これが実は単射な準同型写像になっていて像も部分群になっている。同様の写像は、モノイドについて、関数プログラミングにおける差分リストの表現（Hughesのリスト表現）でも用いられる。また、（こちらもモノイドについての）16章の章末課題3も参照。<a
href="#fnref93" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn94"><p>訳注：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub><mo>∘</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>F</mi><mi>g</mi><mo>∘</mo><msub><mi>α</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_a \circ \mathbf{C}(a, g) = F g \circ \alpha_a</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">p = \mathbf{id}_a</annotation></semantics></math>に作用させたもの。いま、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mi>p</mi><mo>=</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, g) p = g</annotation></semantics></math>であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mo>′</mo></msup><mo>=</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">p&#39; = g</annotation></semantics></math>とおいていたので、左辺が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub><msup><mi>p</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">\alpha_a p&#39;</annotation></semantics></math>となり、また<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><msub><mi>α</mi><mi>a</mi></msub><mi>p</mi></mrow><annotation encoding="application/x-tex">q = \alpha_a p</annotation></semantics></math>であったので、右辺が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>g</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>α</mi><mi>a</mi></msub><mi>p</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>F</mi><mi>g</mi><mi>q</mi><mo>=</mo><msup><mi>q</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">F g (\alpha_a p) = F g q = q&#39;</annotation></semantics></math>となる。<a
href="#fnref94" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn95"><p>訳注：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>q</mi><mo>′</mo></msup><annotation encoding="application/x-tex">q&#39;</annotation></semantics></math>、すなわち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>g</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">F g q</annotation></semantics></math>のこと。<a
href="#fnref95" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn96"><p>訳注：2026年現在では、そういった処理を直接書くことは<code>async</code>/<code>await</code>などによって少なくなったかもしれない。<a
href="#fnref96" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="15.2" id="余米田の補題"><span
class="header-section-number">15.2</span> 余米田の補題</h2>
<p>いつものように、射の方向を逆にすればおまけの構成が得られる。米田の補題を反対圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}</annotation></semantics></math>に適用すれば反変関手の間の写像が得られる。</p>
<p>同様に、hom関手の始点となる対象の代わりに終点となる対象を固定することで、余米田の補題を導出できる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への反変hom関手を取れる。すなわち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(-, a)</annotation></semantics></math>
である。反変版の米田の補題は、この関手から他の任意の反変関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>への自然変換と、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>の要素との間に1対1の対応を確立する。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐍</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>F</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\mathbf{Nat}(\mathbf{C}(-, a), F) \cong F a</annotation></semantics></math>
Haskell版の余米田の補題は次のようになる。</p>
<div class="sourceCode" id="cb360"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb360-1"><a href="#cb360-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> x <span class="op">.</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">F</span> x ≅ <span class="dt">F</span> a</span></code></pre></div>
<p>
一部の文献では反変版の方を米田の補題と呼んでいるので注意してほしい。</p>
<h2 data-number="15.3" id="課題-12"><span
class="header-section-number">15.3</span> 課題</h2>
<ol type="1">
<li><p>米田の同型をなす2つのHaskellの関数<code>phi</code>と<code>psi</code>が互いに逆であることを示せ。</p>
<div class="sourceCode" id="cb361"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb361-1"><a href="#cb361-1" aria-hidden="true" tabindex="-1"></a><span class="ot">phi ::</span> (<span class="kw">forall</span> x <span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> <span class="dt">F</span> x) <span class="ot">-&gt;</span> <span class="dt">F</span> a</span>
<span id="cb361-2"><a href="#cb361-2" aria-hidden="true" tabindex="-1"></a>phi alpha <span class="ot">=</span> alpha <span class="fu">id</span></span>
<span id="cb361-3"><a href="#cb361-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb361-4"><a href="#cb361-4" aria-hidden="true" tabindex="-1"></a><span class="ot">psi ::</span> <span class="dt">F</span> a <span class="ot">-&gt;</span> (<span class="kw">forall</span> x <span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> <span class="dt">F</span> x)</span>
<span id="cb361-5"><a href="#cb361-5" aria-hidden="true" tabindex="-1"></a>psi fa h <span class="ot">=</span> <span class="fu">fmap</span> h fa</span></code></pre></div></li>
<li><p>離散圏 (discrete category)
は、対象はあるが恒等射以外の射はない圏だ。米田の補題はそのような圏の関手でどのように役立つだろうか？</p></li>
<li><p>unit型のリスト<code>[()]</code>は長さ以外の情報を含まない。したがって、データ型としては、非負整数を表したものと見なせる。空リストは0を表し、単リスト<code>[()]</code>（型ではなく値）は1を表し、以下同様だ。このデータ型の別の表現を、リスト関手に対する米田の補題を使って構成せよ。</p></li>
</ol>
<h2 data-number="15.4" id="参考文献-3"><span
class="header-section-number">15.4</span> 参考文献</h2>
<ol type="1">
<li><a
href="https://www.youtube.com/watch?v=TLMxHB19khE">Catstersの動画</a><a
href="#fn97" class="footnote-ref" id="fnref97"
role="doc-noteref"><sup>97</sup></a></li>
</ol>
<aside id="footnotes-51" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="97">
<li id="fn97"><p><a href="https://www.youtube.com/watch?v=TLMxHB19khE"
class="uri">https://www.youtube.com/watch?v=TLMxHB19khE</a><a
href="#fnref97" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 data-number="16" id="yoneda-embedding"><span
class="header-section-number">16</span> 米田埋め込み</h1>
<p>以前見たとおり、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>について対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を固定すると、写像<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への（共変）関手となる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>→</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x \to \mathbf{C}(a, x)</annotation></semantics></math>
（Hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation></semantics></math>
は<em>集合</em>なのでこの関手の余域は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>だ。）
この写像はhom関手と呼ばれる。射に対するこの関手の作用についてもすでに定義したことを思い出してほしい。</p>
<p>さて、この写像において<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を変化させてみよう。すると、Hom<em>関手</em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
を任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>に対して割り当てる新しい写像が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a \to \mathbf{C}(a, -)</annotation></semantics></math>
これは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の対象たちから関手たち、すなわち関手圏の<em>対象</em>たちへの写像である（関手圏については<a
href="#natural-transformations">自然変換</a>（第10章3節）
を参照）。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への関手圏を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation></semantics></math>と表記しよう。また、覚えているかもしれないが、Hom関手は<a
href="#representable-functors">表現可能関手</a>（第14章）の原型だった。</p>
<p>2つの圏の間に対象の写像があるのを見るたび、そのような写像が関手でもあるかを問うのは自然なことだ。言い換えると、一方の圏の射をもう一方の圏の射へと持ち上げられるか、ということだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
の要素にすぎないが、関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation></semantics></math>の射は自然変換だ。つまり、ここでは射から自然変換への写像を探していることになる。</p>
<p>射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to b</annotation></semantics></math>に対応する自然変換が見つかるか見てみよう。そのため、まず<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>が何に写されるか見てみよう。それらは2つの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation></semantics></math>
と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(b, -)</annotation></semantics></math>
に写される。求めるものは、これら2つの関手の間の自然変換だ。</p>
<p>そして、ここで秘訣がある。米田の補題
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>F</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(a, -), F) \cong F a</annotation></semantics></math>
を使い、さらに総称的な<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>をhom関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(b, -)</annotation></semantics></math>
で置き換える。すると、次が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(a, -), \mathbf{C}(b, -)) \cong \mathbf{C}(b, a)</annotation></semantics></math></p>
<p> <img src="images/yoneda-embedding.jpg" style="width:60.0%" /> </p>
<p>
これはまさに探していた2つのhom関手の間の自然変換だが、少しねじれがある。つまり、自然変換と射との対応は見つけたのだが、射――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(b, a)</annotation></semantics></math>
の要素――の向きが「間違って」いる。でも大丈夫だ。それは単に注目している関手が反変であることを意味する。</p>
<p> <img src="images/yoneda-embedding-2.jpg" style="width:65.0%" /> </p>
<p>
実際には、期待以上のものが得られた。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation></semantics></math>への写像は反変関手というだけではない――それは<em>充満忠実</em>
(fully faithful)
関手なのだ。充満性と忠実性という特性は、関手がhom集合をどう写すかを述べている。</p>
<p><em>忠実</em> (faithful)
関手はhom集合上の<em>単射</em>だ。つまり、別々の射は別々の射へと写す。言い換えれば、射を潰さない。</p>
<p><em>充満</em> (full)
関手はhom集合上の<em>全射</em>だ。つまり、一方のhom集合をもう一方のhom集合の<em>上へ</em>写し、後者を完全にカバーする。</p>
<p>充満忠実関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>はhom集合上の<span
id="bijection" class="keyword"><em>全単射</em></span> (bijection)
であり、つまり両方の集合のすべての要素が1対1で対応する。もとの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>のすべてのペアに対して、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>a</mi><mo>,</mo><mi>F</mi><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{D}(F a, F b)</annotation></semantics></math>
の間に全単射がある。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>の行き先の圏（この場合は関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation></semantics></math>）だ。ただし、これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>が<em>対象</em>について全単射であることを意味しないので注意してほしい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>内の対象のうち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>の像内にないものが存在する可能性があり、それらの対象についてのhom集合たちに関しては何も言えない。</p>
<h2 data-number="16.1" id="埋め込み"><span
class="header-section-number">16.1</span> 埋め込み</h2>
<p>先ほど説明した（反変）関手、すなわち、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation></semantics></math>内の関手に写す関手
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a \to \mathbf{C}(a, -)</annotation></semantics></math>
は<span id="Yoneda_embedding"
class="keyword"><em>米田埋め込み</em></span> (Yoneda embedding)
を定義する。それは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>（厳密に言うと反変なので圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}</annotation></semantics></math>）を関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation></semantics></math>の内部に<em>埋め込む</em>。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象を関手に写すだけでなく、それらの間のすべての接続を忠実に保持する。</p>
<p>これは非常に有用な結果だ。なぜなら、数学者は関手圏について、特に余域が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>である関手について多くのことを知っているからだ。任意の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>について、関手圏へ埋め込むことで多くの知見が得られる。</p>
<p>もちろん米田埋め込みにも双対があり、それは余米田埋め込み (co-Yoneda
embedding)
と呼ばれることもある。議論の始めの時点で（始点となる対象ではなく）終点となる対象を固定したhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(-, a)</annotation></semantics></math>
を考えても良かったことに着目しよう。そうすれば反変hom関手が得られていたことになる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への反変関手は、おなじみの前層だ
(たとえば、第12章の<a
href="#limits-and-colimits">極限と余極限</a>を参照)。余米田埋め込みは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の前層圏への埋め込みを定義する。射に対する作用は次によって与えられる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}^\mathit{op}, \mathbf{Set}](\mathbf{C}(-, a), \mathbf{C}(-, b)) \cong \mathbf{C}(a, b)</annotation></semantics></math>
ここでも、数学者は前層圏について多くのことを知っているので、任意の圏をそれに埋め込めるのは大きな戦果だ。</p>
<h2 data-number="16.2" id="haskellへの応用"><span
class="header-section-number">16.2</span> Haskellへの応用</h2>
<p>Haskellでの米田埋め込みは、式の一辺がreader関手同士の自然変換、他辺が（逆方向へ向かう）関数であるような同型として表せる。</p>
<div class="sourceCode" id="cb362"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb362-1"><a href="#cb362-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> x<span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> x) ≅ b <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>
(Reader関手が<code>((-&gt;) a)</code>と等価であることを思い出してほしい。)</p>
<p>この等式の左辺は、<code>a</code>から<code>x</code>への関数と型<code>b</code>の値が与えられたときに、型<code>x</code>の値を生成できるような多相関数である（ここでは非カリー化した視点で、つまり関数<code>b -&gt; x</code>の周りの括弧を除いて考えている）。これをすべての<code>x</code>に対して行えるのは、関数が<code>b</code>を<code>a</code>に変換する方法を知っている場合だけだ。関数<code>b -&gt; a</code>に密かにアクセスできる必要がある。</p>
<p>そのようなコンバーター<code>btoa</code>があれば、この左辺を、<code>fromY</code>と呼ぶとして、以下のように定義できる。</p>
<div class="sourceCode" id="cb363"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb363-1"><a href="#cb363-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fromY ::</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> x</span>
<span id="cb363-2"><a href="#cb363-2" aria-hidden="true" tabindex="-1"></a>fromY f b <span class="ot">=</span> f (btoa b)</span></code></pre></div>
<p>
逆に、関数<code>fromY</code>があれば、恒等射について<code>fromY</code>を呼び出すことでそのコンバーターを復元できる。</p>
<div class="sourceCode" id="cb364"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb364-1"><a href="#cb364-1" aria-hidden="true" tabindex="-1"></a>fromY<span class="ot"> id ::</span> b <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>
これによって関数<code>fromY</code>と<code>btoa</code>の間に全単射が確立される。</p>
<p>この同型を別の観点で見ると、<code>b</code>から<code>a</code>への関数を継続渡し形式で表しているとも見なせる。引数<code>a -&gt; x</code>は継続（ハンドラー）であると見なせる<a
href="#fn98" class="footnote-ref" id="fnref98"
role="doc-noteref"><sup>98</sup></a>。結果は<code>b</code>から<code>x</code>への関数であり、型<code>b</code>の値を引数として呼ばれたとき、エンコードされようとしている関数に前合成された継続を実行する。</p>
<p>米田埋め込みでHaskellのデータ構造のうちいくつかの別の表現についても説明できる。特に、レンズ<a
href="#fn99" class="footnote-ref" id="fnref99"
role="doc-noteref"><sup>99</sup></a>の<a
href="https://bartoszmilewski.com/2015/07/13/from-lenses-to-yoneda-embedding/">非常に便利な表現</a><a
href="#fn100" class="footnote-ref" id="fnref100"
role="doc-noteref"><sup>100</sup></a>を<code>Control.Lens</code>ライブラリーで提供する。</p>
<aside id="footnotes-52" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="98">
<li
id="fn98"><p>訳注：この見方をするときは左辺の引数の順を入れ替えて<code>b -&gt; (a -&gt; x) -&gt; x</code>とすることが多い。<a
href="#fnref98" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn99"><p>訳注：ゲッターとセッターをペアにし合成可能にしたもの。第3部でも少し触れる。レンズについて初めて述べた下記の論文は後に2015年のMost
Influential POPL Paper Awardを受賞している。</p>
<ul>
<li>Nate Foster, Michael B. Greenwald, Jonathan T. Moore, Benjamin C.
Pierce, Alan Schmitt. <em>Combinators for bi-directional tree
transformations: a linguistic approach to the view update problem</em>.
POPL 2005. pp. 233–246. <a
href="https://doi.org/10.1145/1040305.1040325"
class="uri">https://doi.org/10.1145/1040305.1040325</a></li>
</ul>
<p>また、以下の文献も参考になる。</p>
<ul>
<li>加藤 弘之, 胡 振江, 日高 宗一郎, 松田
一孝「『ソフトウェアサイエンスの基本』シリーズ第4回
高談闊論：双方向変換の原理と実践」『コンピュータ ソフトウェア』2014年,
31巻2号, pp. 44-56, <a href="https://doi.org/10.11309/jssst.31.2_44"
class="uri">https://doi.org/10.11309/jssst.31.2_44</a></li>
<li>日高 宗一郎「双方向変換 :
古典的なビュー更新問題から,プログラミング言語によるアプローチとソフトウェア開発への応用まで」『情報処理』2017年,
58巻12号, pp. 1114-1122, <a
href="https://ipsj.ixsq.nii.ac.jp/records/184314"
class="uri">https://ipsj.ixsq.nii.ac.jp/records/184314</a></li>
</ul>
<a href="#fnref99" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn100"><p><a
href="https://bartoszmilewski.com/2015/07/13/from-lenses-to-yoneda-embedding/"
class="uri">https://bartoszmilewski.com/2015/07/13/from-lenses-to-yoneda-embedding/</a></p>
<p>訳注：van Laarhoven表現として知られる（<a
href="https://twanvl.nl/blog/haskell/cps-functional-references"
class="uri">https://twanvl.nl/blog/haskell/cps-functional-references</a>）。<a
href="#fnref100" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="16.3" id="前順序での例"><span
class="header-section-number">16.3</span> 前順序での例</h2>
<p>この節の例はRobert
Harperによって提案された。前順序によって定義された圏に米田埋め込みを適用するものだ。前順序は要素間に順序関係がある集合であり、この順序関係は伝統的に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≤</mo><annotation encoding="application/x-tex">\leqslant</annotation></semantics></math>（小なりイコール）で記述される。前順序に「前」が付いているのは、関係が推移律
(transitive law) と反射律 (reflexive law)
を満たす必要があるだけで、必ずしも反対称律 (antisymmetric law)
を満たす必要はないからだ（すなわち、循環してもよい）<a href="#fn101"
class="footnote-ref" id="fnref101"
role="doc-noteref"><sup>101</sup></a>。</p>
<p>前順序関係を持つ集合は圏をなす。対象となるのはその集合の各要素だ。対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への射は、対象が比較できない場合や<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant  b</annotation></semantics></math>が真でない場合には存在せず、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant b</annotation></semantics></math>の場合には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への向きに存在する。ある対象から別の対象への射が2つ以上存在することはない。したがって、このような圏のhom集合はすべて、空集合または単元集合だ。このような圏は<em>細い圏</em>と呼ばれる。</p>
<p>この構成が実際に圏であることは簡単に納得できる。まず、射は合成可能だ。なぜなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant b</annotation></semantics></math>かつ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">b \leqslant c</annotation></semantics></math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \leqslant c</annotation></semantics></math>だからだ。そして、合成は結合性を持つ。恒等射も存在する。なぜなら、すべての要素がそれ自身（以下）となる（もとになっている順序の反射律）からだ。</p>
<p>これで前順序圏に余米田埋め込みを適用できるようになった。特に興味があるのは射に対する作用だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(-, a), \mathbf{C}(-, b)) \cong \mathbf{C}(a, b)</annotation></semantics></math>
右辺のhom集合が空集合でないのは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant b</annotation></semantics></math>のときだけだ。その場合は単元集合となる。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant b</annotation></semantics></math>の場合、左辺には自然変換が1つだけ存在する。それ以外の場合は自然変換はない。</p>
<p>では、前順序のhom関手間の自然変換とは何だろうか？　それは2つの集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(-, a)</annotation></semantics></math>
と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(-, b)</annotation></semantics></math>
の間の関数の族でなければならない。前順序集合では、2つの集合はそれぞれ空集合か単元集合だ。どんな関数があり得るか見てみよう。</p>
<p>空集合からそれ自身への関数（空集合に作用する恒等射)、空集合から単元集合への<code>absurd</code>関数（関数の値を定義すべき要素が空集合には1つもないので、何もしない）、そして単元集合からそれ自身への関数
(要素が1つの集合に作用する恒等射）がある。単元集合から空集合への組み合わせだけは禁じられている（そのような関数が単元集合の要素に作用したとして、どんな値を返せばよいだろう？）。</p>
<p>つまり、この自然変換は決してhom単元集合をhom空集合に接続しない。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x \leqslant a</annotation></semantics></math>
(hom単元集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(x, a)</annotation></semantics></math>)
ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(x, b)</annotation></semantics></math>
は空集合ではない。空でない<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(x, b)</annotation></semantics></math>
は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>以下であることを意味する。したがって、ここでの自然変換が存在するためには、すべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">x \leqslant a</annotation></semantics></math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">x \leqslant b</annotation></semantics></math>が成り立つ必要がある。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mtext mathvariant="normal">任意の </mtext><mspace width="0.333em"></mspace></mrow><mi>x</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> について </mtext><mspace width="0.333em"></mspace></mrow><mi>x</mi><mo>≤</mo><mi>a</mi><mo>⇒</mo><mi>x</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\text{任意の } x \text{ について } x \leqslant a \Rightarrow x \leqslant b</annotation></semantics></math>
一方、余米田の補題によると、この自然変換の存在は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
が空でないこと、つまり<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant b</annotation></semantics></math>であることと等価だ。まとめると、次の結果が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> ならばそのときに限り任意の </mtext><mspace width="0.333em"></mspace></mrow><mi>x</mi><mrow><mspace width="0.333em"></mspace><mtext mathvariant="normal"> について </mtext><mspace width="0.333em"></mspace></mrow><mi>x</mi><mo>≤</mo><mi>a</mi><mo>⇒</mo><mi>x</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant b \text{ ならばそのときに限り任意の } x \text{ について } x \leqslant a \Rightarrow x \leqslant b</annotation></semantics></math>
この結果に直接到達することもできただろう。直観的には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant b</annotation></semantics></math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>以下のすべての要素も<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>以下である必要がある。逆に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を右辺の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>に代入すると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant b</annotation></semantics></math>となる。しかし、米田埋め込みを通じてこの結果に到達する方がはるかに刺激的なのは認めなければならない。</p>
<aside id="footnotes-53" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="101">
<li
id="fn101"><p>訳注：集合の任意の元<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a, b, c</annotation></semantics></math>について</p>
<ul>
<li>推移律：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant b</annotation></semantics></math>かつ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">b \leqslant c</annotation></semantics></math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \leqslant c</annotation></semantics></math></li>
<li>反射律：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a \leqslant a</annotation></semantics></math></li>
<li>反対称律：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant b</annotation></semantics></math>かつ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≤</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">b \leqslant a</annotation></semantics></math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a = b</annotation></semantics></math></li>
</ul>
<a href="#fnref101" class="footnote-back" role="doc-backlink">↩︎</a></li>
</ol>
</aside>
<h2 data-number="16.4" id="自然性"><span
class="header-section-number">16.4</span> 自然性</h2>
<p>米田の補題は自然変換の集合と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>の対象との間に同型射を設ける。いま扱っている自然変換たちは関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation></semantics></math>内の射だ。任意の2つの関手間の自然変換の集合は、関手圏におけるhom集合となる。米田の補題とは次の同型だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>F</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(a, -), F) \cong F a</annotation></semantics></math>
この同型は実は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>についても<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>についても自然である。言い換えれば、積圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo>×</mo><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}] \times \mathbf{C}</annotation></semantics></math>から取られたペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(F, a)</annotation></semantics></math>
について自然だ。ここでは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>を関手圏の<em>対象</em>として扱っていることに注意してほしい。</p>
<p>これが何を意味するのか少し考えてみよう。自然同型は2つの関手の間の可逆な<em>自然変換</em>だ。そして実際、前述の同型の右辺は関手だ。具体的には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo>×</mo><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]\times \mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への関手だ。ペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(F, a)</annotation></semantics></math>
に対するその作用は集合――関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>を対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>において評価した結果――となる。この関手は評価関手
(evaluation functor) と呼ばれる。</p>
<p>左辺も関手であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(F, a)</annotation></semantics></math>
を自然変換の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>F</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(a, -), F)</annotation></semantics></math>
に変換する。</p>
<p>これらが本当に関手だと示すには、射に対する作用も定義しなければならない。しかし、ペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(F, a)</annotation></semantics></math>
と
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>G</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(G, b)</annotation></semantics></math>
の間の射とは何だろうか？　それは射のペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi mathvariant="normal">Φ</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\Phi, f)</annotation></semantics></math>
だ。1番目は関手間の射――自然変換――であり、2番目は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の通常の射だ。</p>
<p>評価関手はこのペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi mathvariant="normal">Φ</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\Phi, f)</annotation></semantics></math>
を取り、2つの集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">G b</annotation></semantics></math>の間の関数に写す。このような関数は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>における<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math>の成分（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">G a</annotation></semantics></math>に写す）と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>によって持ち上げられた射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>から、簡単に構築できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>G</mi><mi>f</mi><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><msub><mi mathvariant="normal">Φ</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">(G f) \cdot \Phi_a</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Φ</mi><annotation encoding="application/x-tex">\Phi</annotation></semantics></math>の自然性により、これは次と同じであることに注意してほしい。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant="normal">Φ</mi><mi>b</mi></msub><mo>⋅</mo><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\Phi_b \cdot (F f)</annotation></semantics></math>
この同型全体の自然性を証明するつもりはない――関手とは何かが掴めれば、ごく機械的に証明できる。それはこの同型が関手と自然変換から成り立っているという事実から導かれる。うまくいかないはずがない。</p>
<h2 data-number="16.5" id="課題-13"><span
class="header-section-number">16.5</span> 課題</h2>
<ol type="1">
<li>余米田埋め込みをHaskellで表現せよ。</li>
<li><code>fromY</code>と<code>btoa</code>の間に確立された全単射が同型である（2つの写像が互いに逆である）ことを示せ。</li>
<li>与えられたモノイドに対し、米田埋め込みを行え。そのモノイドの単一の対象に対応する関手は何か<a
href="#fn102" class="footnote-ref" id="fnref102"
role="doc-noteref"><sup>102</sup></a>？　そのモノイドの射たちに対応する自然変換たちはどのようなものか？</li>
<li><em>共変</em>米田埋め込みを前順序に適用したものは何か？（この問いはGershom
Bazermanによって提案された。）</li>
<li>米田埋め込みを使えば、任意の関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mi>𝐃</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{D}]</annotation></semantics></math>を関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mi>𝐃</mi><mo stretchy="false" form="postfix">]</mo><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[[\mathbf{C}, \mathbf{D}], \mathbf{Set}]</annotation></semantics></math>に埋め込める。それが射（この場合は自然変換）にどう作用するか説明せよ。</li>
</ol>
<aside id="footnotes-54" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="102">
<li
id="fn102"><p>訳注：この問いは15章で出てきたケイリーの定理（のモノイド版）に関連する。また、モノイドが単一対象の圏として表せることについては<a
href="#monoid-as-set">圏としてのモノイド</a>（第3章4節）を参照。]<a
href="#fnref102" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 data-number="17" id="射こそすべて"><span
class="header-section-number">17</span> 射こそすべて</h1>
<p>まだ圏論の勘所は射だと確信してもらえていないなら、私が務めをきちんと果たせなかったということになる。次章の話題である随伴
(adjunction)
は、hom集合間の同型によって定義されるため、hom集合の構成要素についての直観を見直すのが理にかなっている。また、随伴はこれまで見てきた多くの構成を記述するさらに汎用的な語彙を提供するため、それらの構成を復習しておくのも有意義だろう。</p>
<h2 data-number="17.1" id="関手"><span
class="header-section-number">17.1</span> 関手</h2>
<p>まず始めに、関手を射の写像だと真剣に考えるべきだ。これはHaskellの<code>Functor</code>型クラスの定義において強調される考え方だ。そこでは<code>fmap</code>が中心だった。もちろん、関手は対象――射の両端――も写す。そうでなければ、合成の保存について語れない。対象は射のどのペアが合成可能か教えてくれる。一方の射の終点がもう一方の始点と等しくなければ合成できない。したがって、射の合成を<span
id="lifted"
class="keyword"><em>持ち上げられた</em></span>射の合成に写すなら、それらの両端の写像もほぼ決まる。</p>
<h2 data-number="17.2" id="可換図式"><span
class="header-section-number">17.2</span> 可換図式</h2>
<p>射についての性質の多くは可換図式によって表される。ある特定の射が他の射の合成として複数の方法で記述できるなら、可換図式があることになる。</p>
<p>特に、可換図式はほぼすべての普遍的構成の基礎となっている（始対象と終対象という重要な例外はある）。このことはすでに、積、余積、その他さまざまな（余）極限、冪対象、自由モノイドなどの定義で見てきた。</p>
<p>積は普遍的構成の簡単な例だ。2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>を選び、それらの積となる普遍性を持つような、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>のペアを伴う対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>が存在するかを見る。</p>
<p> <img src="images/productranking.jpg" style="width:30.0%" /> </p>
<p>
積は極限の特別な場合でもある。極限は錐によって定義される。一般的な錐は可換図式から作成される。それらの図式の可換性は、関手間の写像についての適切な自然性条件で置き換えられる<a
href="#fn103" class="footnote-ref" id="fnref103"
role="doc-noteref"><sup>103</sup></a>。このようにして、可換性は自然変換という高水準言語に対するアセンブリー言語の役割に降格される。</p>
<aside id="footnotes-55" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="103">
<li
id="fn103"><p>訳注：錐とは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑁</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><mo>,</mo><mi>F</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{Nat}(\Delta_c, F)</annotation></semantics></math>
のことだったのを思い出してほしい。<a href="#fnref103"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="17.3" id="自然変換"><span
class="header-section-number">17.3</span> 自然変換</h2>
<p>一般に、自然変換は射から可換正方図式への写像が必要なときに非常に便利だ。自然性の正方図式で向かい合う辺のうち2つは、ある射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を2つの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>でそれぞれ写したものだ。残りの2辺は自然変換の成分（これらも射）である。</p>
<p> <img src="images/3_naturality.jpg" style="width:35.0%" /> </p>
<p>
自然性は「隣接する」（つまり射でつながった）成分に移っても圏や関手の構造に反しないことを意味している。自然変換の成分を使って対象間のギャップをまず埋めてから関手を使って隣の対象にジャンプするのでも、その逆でも関係ない。すなわち、2つの方向は直交している。いうなれば、自然変換は左右に移動させ、関手は上下や前後に移動させる。関手の<em>像</em>は、その行き先となる圏でのシートとして視覚化できる。この見方では、自然変換は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>に対応するシートを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>に対応する別のシートに写す。</p>
<p> <img src="images/sheets.png" style="width:35.0%" /> </p>
<p>
この直交性のHaskellにおける例はすでに見ている。そこでは、関手の作用はコンテナーの形状を変更せずに内容を変更し、一方で自然変換は内容を変更せずに別のコンテナーに詰め直すものだった<a
href="#fn104" class="footnote-ref" id="fnref104"
role="doc-noteref"><sup>104</sup></a>。これらの操作の順序は関係なかった。</p>
<p>極限の定義の中で錐が自然変換に置き換えられるのを見た。自然性はすべての錐の側面が可換だと保証する。しかし、極限は錐の<em>間の</em>写像によって定義されていた。これらの写像は可換性条件も満たす必要があった。（たとえば、積の定義における三角形は可換である必要がある。）</p>
<p>これらの条件も自然性によって置き換えられる。<em>普遍な</em>錐、すなわち極限が、（反変）hom関手
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∷</mo><mi>c</mi><mo>→</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>,</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mrow></mrow><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F \Colon c \to \mathbf{C}(c, %
\mathbf{Lim}{}%
{D})</annotation></semantics></math>
と、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象を、それ自体が自然変換である錐に写すような（反変）関手
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>∷</mo><mi>c</mi><mo>→</mo><mrow><mi>𝑁</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">G \Colon c \to \mathit{Nat}(\Delta_c, D)</annotation></semantics></math>
の自然変換として定義されていたのを思い出してほしい。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>は定関手、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>での図式を定義する関手である。関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>は両方とも、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の射に対する作用が明確に定義されている。奇遇にも<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>の間の特定の自然変換は<em>同型</em>である。</p>
<aside id="footnotes-56" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="104">
<li
id="fn104"><p>訳注：詰め直す際に各要素の位置が変わりうることを考えると、位置に依存しないような変更である必要がある。<a
href="#fnref104" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="17.4" id="自然同型"><span
class="header-section-number">17.4</span> 自然同型</h2>
<p>自然同型――すべての成分が可逆な自然変換――は、圏論で「2つのものは同じである」と言うときの言い方だ。そのような変換の成分は対象間の同型射――逆が存在する射――でなければならない。関手の像をシートとして表すなら、自然同型はシート間の1対1の可逆な写像だと言える。</p>
<h2 data-number="17.5" id="hom集合"><span
class="header-section-number">17.5</span> Hom集合</h2>
<p>それにしても、射とは何だろう？　射は対象よりも構造が豊かだ。対象とは違って、射には2つの端がある。しかし、始点となる対象と終点となる対象を固定すると、それら2つの間の射たちは（少なくとも局所的に小さい圏では）単に集合をなしてしまう。この集合の要素を区別するために<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>や<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>のような名前を付けることはできるが、一体何がこれらの射を区別しているのだろう？</p>
<p>与えられたhom集合内の射同士の本質的な差異は、（隣接するhom集合からの）他の射とどのように合成されるかにある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>との合成（前合成でも後合成でもよい）が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>との合成と異なるような射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>が存在する場合、つまり、たとえば
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>∘</mo><mi>f</mi><mo>≠</mo><mi>h</mi><mo>∘</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">h \circ f \neq h \circ g</annotation></semantics></math>
なら<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>の違いを直接「観察」できる。しかし、違いが直接観察できない場合でも、関手を使えばそのhom集合にズームインできる。関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>は2つの射を、より豊かな圏における別々の射
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>f</mi><mo>≠</mo><mi>F</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">F f \neq F g</annotation></semantics></math>
に写せる。そこでは、隣接するhom集合による分解能がより高い場合がある。たとえば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>の像に含まれない<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>h</mi><mo>′</mo></msup><annotation encoding="application/x-tex">h&#39;</annotation></semantics></math>によって
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>h</mi><mo>′</mo></msup><mo>∘</mo><mi>F</mi><mi>f</mi><mo>≠</mo><msup><mi>h</mi><mo>′</mo></msup><mo>∘</mo><mi>F</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">h&#39; \circ F f \neq h&#39; \circ F g</annotation></semantics></math>
のように区別できる場合がある[^訳注：合成後の両辺の射を結局どう区別するのかが述べられていないが、根底には「2つの射のうち一方が恒等射で他方がその他の自己射となるような合成が見つかるならば、それらは区別できる」というアイデアがある。著者のブログでのコメント&lt;https://bartoszmilewski.com/2015/11/17/its-all-about-morphisms/#comment-220465&gt;を参照。]。</p>
<h2 data-number="17.6" id="hom集合同型"><span
class="header-section-number">17.6</span> Hom集合同型</h2>
<p>圏論では多くの構成がhom集合間の同型に依存している。もっとも、hom集合はただの集合なので、それらの間の同型から分かることはあまりない。有限集合の場合は、同型は要素数が同じだと示すだけだ。無限集合の場合は、同型が存在するならばそれらの濃度が同じでなければならない。しかし、hom集合の意味のある同型はすべて、合成も考慮しなければならない。合成に関わるhom集合はひとつだけではない。あらゆるhom集合にまたがる同型を定義する必要があり、合成と相互運用できるような何らかの互換性の条件を課す必要がある。そして、<span
id="natural"
class="keyword"><em>自然</em></span>同型はその条件にぴったり合う。</p>
<p>だが、hom集合同士の自然同型とは何だろう？　自然性は、関手間の写像の性質であり、集合間の写像についてのものではない。つまり、いま話しているのは実際にはhom集合値関手の間の自然同型についてである。それらの関手は単なる集合値関手ではない。射に対するその作用は、適切なhom関手によって導かれる。射はhom関手によって、（合成の変性に依存して）前合成か後合成のどちらかで正準的に写される。</p>
<p>米田埋め込みはそのような同型の一例だ。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内のhom集合を関手圏内のhom集合に写す。そしてそれは自然だ。米田埋め込みにおける関手のひとつは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>のhom関手で、もうひとつは対象をhom集合間の自然変換の集合に写すような関手だ。</p>
<p>極限の定義もhom集合間の自然同型だ（ここでも2番目は関手圏内のhom集合だ）。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>,</mo><mrow><mi>𝐋</mi><mi>𝐢</mi><mi>𝐦</mi></mrow><mrow></mrow><mi>D</mi><mo stretchy="false" form="postfix">)</mo><mo>≃</mo><mrow><mi>𝑁</mi><mi>𝑎</mi><mi>𝑡</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c, %
\mathbf{Lim}{}%
{D}) \simeq \mathit{Nat}(\Delta_c, D)</annotation></semantics></math>
実は、冪対象や自由モノイドの構成もhom集合間の自然同型として書き直せる。</p>
<p>これは偶然の一致ではない――次章で見るように、これらはhom集合の自然同型として定義される随伴の様々な例にすぎない。</p>
<h2 data-number="17.7" id="hom集合の非対称性"><span
class="header-section-number">17.7</span> Hom集合の非対称性</h2>
<p>随伴を理解するのに役立つ観察結果はもう1つある。Hom集合は一般に対称ではない。Hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
は、hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(b, a)</annotation></semantics></math>
と大きく異なることがよくある。この非対称性の究極の例は、半順序を圏と見なすことだ。半順序では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>以下の場合、かつその場合に限って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への射が存在する。さらに<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>が異なる場合は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>へと逆方向に進む射は存在しない。Hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
が空集合でない（ここでは単元集合であることを意味する）なら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a = b</annotation></semantics></math>でない限り、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(b, a)</annotation></semantics></math>
は空でなければならない。この圏の射には明確な一方向の流れが存在する。</p>
<p>関係が反対称でなくてもよい前順序も、たまにある循環を除けば「ほとんど」方向付けられている。任意の圏を前順序の一般化と見なすと便利だ。</p>
<p>前順序は細い圏だ――すべてのhom集合が単元集合か空集合のどちらかだ。一般の圏は「太い」(thick)
前順序として描写できる。</p>
<h2 data-number="17.8" id="課題-14"><span
class="header-section-number">17.8</span> 課題</h2>
<ol type="1">
<li>退化 (degenerate)
した自然性条件の例を考え、適切な図を描け。たとえば、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>のどちらかが対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to b</annotation></semantics></math>の両端）の両方を同じ対象に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi><mo>=</mo><mi>F</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">F a = F b</annotation></semantics></math>または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>a</mi><mo>=</mo><mi>G</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">G a = G b</annotation></semantics></math>のように写したらどうなるか？
（この方法で錐や余錐が得られることに注目してほしい。）次に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi><mo>=</mo><mi>G</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a = G a</annotation></semantics></math>または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>b</mi><mo>=</mo><mi>G</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">F b = G b</annotation></semantics></math>のどちらかの場合について考えよ。最後に、自分自身へループする射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to a</annotation></semantics></math>から始めた場合はどうか？</li>
</ol>
<h1 data-number="18" id="adjunctions"><span
class="header-section-number">18</span> 随伴</h1>
<p>数学では、あるものが別のものに似ているという言い方はいろいろある。最も厳密なのは等しさだ。互いを区別する方法がなければ、2つのものは等しい。想像できるあらゆる状況において、一方を他方の代わりにできる。たとえば、可換図式について話すときはいつも射の<span
id="equality" class="keyword"><em>等しさ</em></span> (equality)
を使っていることに気付いただろうか？　それは、射が集合（hom集合）をなし、集合の要素は等しさを確認できるからだ。</p>
<p>しかし、等しさは強すぎることが多い。2つのものが実際には等しくないのに、あらゆる意図と目的に照らして同じであるという例はたくさんある。たとえば、ペアの型<code>(Bool, Char)</code>は<code>(Char, Bool)</code>と厳密に等しいわけではないが、含んでいる情報が同じなのは分かっている。この概念を最もうまく捉えたものは、2つの型の間の<em>同型射</em>――可逆な射だ。これは射なので、構造を保存する。そして同型射
(isomorphism) の “iso”
は、どちら側から出発してももとの場所に帰り着く往復旅行の一部であることを意味する。ペアにおいては、この同型射は<code>swap</code>と呼ばれる。</p>
<div class="sourceCode" id="cb365"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb365-1"><a href="#cb365-1" aria-hidden="true" tabindex="-1"></a><span class="ot">swap ::</span> (a,b) <span class="ot">-&gt;</span> (b,a)</span>
<span id="cb365-2"><a href="#cb365-2" aria-hidden="true" tabindex="-1"></a>swap (a,b) <span class="ot">=</span> (b,a)</span></code></pre></div>
<p> <code>swap</code>は奇しくもそれ自身の逆になっている。</p>
<h2 data-number="18.1" id="随伴と単位余単位ペア"><span
class="header-section-number">18.1</span> 随伴と単位/余単位ペア</h2>
<p>圏が同型だと述べるときは、これを圏間の写像、すなわち関手によって表す。圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>への可逆な関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>（“right”）が存在する場合に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>は同型だと言えるようにしたい。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>に戻る別の関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>（“left”）が存在し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>と合成することで恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>に等しくなるということだ。合成は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R \circ L</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \circ R</annotation></semantics></math>の2通りあるので、恒等関手も<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>内の2つが考えられる。</p>
<p> <img src="images/adj-1.jpg" style="width:50.0%" /> </p>
<p>
しかし、ここがややこしいところだ。2つの関手が<em>等しい</em>とは何を意味するのだろうか？　次の等しさ
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi><mo>=</mo><msub><mi>I</mi><mi>𝐃</mi></msub></mrow><annotation encoding="application/x-tex">R \circ L = I_{\mathbf{D}}</annotation></semantics></math>
や次のものは何を意味するだろう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi><mo>=</mo><msub><mi>I</mi><mi>𝐂</mi></msub></mrow><annotation encoding="application/x-tex">L \circ R = I_{\mathbf{C}}</annotation></semantics></math>
関手の等しさを対象の等しさによって定義するのは合理的に思える。2つの関手が同じ対象に作用するなら、同じ対象が得られるはずだ。しかし、一般に、対象の等しさの概念は任意の圏において存在するわけではない。それは単に定義の一部ではない。（この「等しさとは本当は何なのか」というウサギの穴に深く潜る<a
href="#fn105" class="footnote-ref" id="fnref105"
role="doc-noteref"><sup>105</sup></a>と、ホモトピー型理論に辿り着く。）</p>
<p>関手は圏の圏における射<em>なのだ</em>から、それらは等しさで比較可能なはずだ、と主張したくなるかもしれない。実際、対象の集まりが集合をなすような小さい圏を扱う限り、集合の要素の等しさを使って対象の等しさを比較できる。</p>
<p>だが、ここで思い出してほしい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>は実際には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏だった。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏のhom集合には追加の構造――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟏</mn><annotation encoding="application/x-tex">\mathbf{1}</annotation></semantics></math>-射の間に作用する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-射――がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟏</mn><annotation encoding="application/x-tex">\mathbf{1}</annotation></semantics></math>-射は関手であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-射は自然変換だった。だから、関手について述べるときに自然同型を等しさの代わりと考えるのは、より自然なのだ（この駄洒落は避けようがない！）。</p>
<p>したがって、圏の同型の代わりに<span id="equivalence"
class="keyword"><em>同値性</em></span> (equivalence)
という、より一般的な概念を考えるのが理にかなっている<a href="#fn106"
class="footnote-ref" id="fnref106"
role="doc-noteref"><sup>106</sup></a>。2つの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>が<em>同値</em>
(equivalent)
であるとは、それらの間を行き来する2つの関手が存在して、合成が（いずれの向きでも）恒等関手と<span
id="naturally_isomorphic" class="keyword"><em>自然同型</em></span>
(naturally isomorphic)
であることだ。言い換えると、合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R \circ L</annotation></semantics></math>と恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mi>𝐃</mi></msub><annotation encoding="application/x-tex">I_{\mathbf{D}}</annotation></semantics></math>の間には双方向の自然変換があり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \circ R</annotation></semantics></math>と恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mi>𝐂</mi></msub><annotation encoding="application/x-tex">I_{\mathbf{C}}</annotation></semantics></math>の間にも別の双方向の自然変換がある。</p>
<p>随伴は同値性よりもさらに弱い。2つの関手の合成が恒等関手と<span
id="isomorphic"
class="keyword"><em>同型</em></span>であることは要求しない。その代わり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mi>𝐃</mi></msub><annotation encoding="application/x-tex">I_{\mathbf{D}}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R \circ L</annotation></semantics></math>への<span
id="one_way2"
class="keyword"><em>一方向の</em></span>自然変換と、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \circ R</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mi>𝐂</mi></msub><annotation encoding="application/x-tex">I_{\mathbf{C}}</annotation></semantics></math>への別の一方向の自然変換が存在することを要求する。これら2つの自然変換のシグネチャーを以下に示す。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>η</mi><mo>∷</mo><msub><mi>I</mi><mi>𝐃</mi></msub><mo>→</mo><mi>R</mi><mo>∘</mo><mi>L</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>ε</mi><mo>∷</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo>→</mo><msub><mi>I</mi><mi>𝐂</mi></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
\eta \Colon I_{\mathbf{D}} \to R \circ L \\
\varepsilon \Colon L \circ R \to I_{\mathbf{C}}
\end{gathered}
</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>は随伴の単位
(unit)
と呼ばれ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>は余単位
(counit) と呼ばれる。</p>
<p>これら2つの定義の非対称性に注目してほしい。一般には、残りの2つの写像
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>R</mi><mo>∘</mo><mi>L</mi><mo>→</mo><msub><mi>I</mi><mi>𝐃</mi></msub><mspace width="1.0em"></mspace><mspace width="1.0em"></mspace><mtext mathvariant="normal">必須ではない</mtext></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>I</mi><mi>𝐂</mi></msub><mo>→</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mspace width="1.0em"></mspace><mspace width="1.0em"></mspace><mtext mathvariant="normal">必須ではない</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
R \circ L \to I_{\mathbf{D}} \quad\quad\text{必須ではない} \\
I_{\mathbf{C}} \to L \circ R \quad\quad\text{必須ではない}
\end{gathered}
</annotation></semantics></math>
は存在するとは限らない。この非対称性のため、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>は関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>に対する<span
id="left_adjoint" class="keyword"><em>左随伴</em></span> (left adjoint)
と呼ばれ、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>に対する右随伴
(right adjoint)
と呼ばれる。（当然、左と右に意味があるのは図を特定の向きに描いた場合だけだ）。</p>
<p>随伴は次のように略記される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊣</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \dashv R</annotation></semantics></math>
随伴をよりよく理解するために、単位と余単位をさらに詳しく分析してみよう。</p>
<p> <img src="images/adj-unit.jpg" style="width:50.0%" /> </p>
<p>
まずは単位から始めよう。これは自然変換なので、射の族だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>の成分は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">I d</annotation></semantics></math>（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>に等しい）と
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">(R \circ L) d</annotation></semantics></math>（図中の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>d</mi><mo>′</mo></msup><annotation encoding="application/x-tex">d&#39;</annotation></semantics></math>）の間の射となる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mi>d</mi></msub><mo>∷</mo><mi>d</mi><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">\eta_d \Colon d \to (R \circ L) d</annotation></semantics></math>
合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R \circ L</annotation></semantics></math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>上の自己関手であることに注意してほしい。</p>
<p>このシグネチャーは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>内の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>を始点として選択でき、往復する関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R \circ L</annotation></semantics></math>を使って終点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>d</mi><mo>′</mo></msup><annotation encoding="application/x-tex">d&#39;</annotation></semantics></math>を選択できることを示している。そして、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>d</mi></msub><annotation encoding="application/x-tex">\eta_d</annotation></semantics></math>という矢が終点に向けて放たれる。</p>
<p> <img src="images/adj-counit.jpg" style="width:50.0%" /> </p>
<p>
同様に、余単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>の成分は次のように記述できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mi>c</mi></msub><mo>∷</mo><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo><mi>c</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">\varepsilon_{c} \Colon (L \circ R) c \to c</annotation></semantics></math>
これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>を終点として選択でき、往復する関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \circ R</annotation></semantics></math>を使って始点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>c</mi><mo>′</mo></msup><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">c&#39; = (L \circ R) c</annotation></semantics></math>を選択できることを示している。そして、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ε</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\varepsilon_{c}</annotation></semantics></math>という矢が始点から終点に向けて放たれる。</p>
<p>単位と余単位について別の見方をすると、単位は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>上の恒等関手を挿入できる場所ならどこでも合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R \circ L</annotation></semantics></math>を<em>導入</em>
(introduce)
でき、余単位は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の恒等射で置き換えることによって合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \circ R</annotation></semantics></math>を<em>除去</em>
(eliminate)
できることを表している。これにより、導入した後で除去すれば何も変更されないことを保証するいくつかの「自明な」整合性条件が導かれる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>L</mi><mo>=</mo><mi>L</mi><mo>∘</mo><msub><mi>I</mi><mi>𝐃</mi></msub><mo>→</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo>→</mo><msub><mi>I</mi><mi>𝐂</mi></msub><mo>∘</mo><mi>L</mi><mo>=</mo><mi>L</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>R</mi><mo>=</mo><msub><mi>I</mi><mi>𝐃</mi></msub><mo>∘</mo><mi>R</mi><mo>→</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo>→</mo><mi>R</mi><mo>∘</mo><msub><mi>I</mi><mi>𝐂</mi></msub><mo>=</mo><mi>R</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
L = L \circ I_{\mathbf{D}} \to L \circ R \circ L \to I_{\mathbf{C}} \circ L = L \\
R = I_{\mathbf{D}} \circ R \to R \circ L \circ R \to R \circ I_{\mathbf{C}} = R
\end{gathered}
</annotation></semantics></math>
これらは、次の図式を可換にするので、三角恒等式 (triangular identity)
と呼ばれる。</p>
<div style="display:flex">
<script type="text/tikz">
\begin{tikzcd}[column sep=large, row sep=large]
  L \arrow[rd, equal] \arrow[r, "L \circ \eta"]
  & L \circ R \circ L \arrow[d, "\varepsilon \circ L"] \\
  & L
\end{tikzcd}
</script>
<script type="text/tikz">
\begin{tikzcd}[column sep=large, row sep=large]
  R \arrow[rd, equal] \arrow[r, "\eta \circ R"]
  & R \circ L \circ R \arrow[d, "R \circ \varepsilon"] \\
  & R
\end{tikzcd}
</script>
</div>
<p>
これらは関手圏の図式だ[^訳注：この図式では第10章4節の末尾で説明された記法が使われている。]。つまり、矢は自然変換であり、それらの合成は自然変換の水平合成だ。成分で表すと、これらの等式は次のように書ける。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>ε</mi><mrow><mi>L</mi><mi>d</mi></mrow></msub><mo>∘</mo><mi>L</mi><msub><mi>η</mi><mi>d</mi></msub><mo>=</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mrow><mi>L</mi><mi>d</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>R</mi><msub><mi>ε</mi><mi>c</mi></msub><mo>∘</mo><msub><mi>η</mi><mrow><mi>R</mi><mi>c</mi></mrow></msub><mo>=</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mrow><mi>R</mi><mi>c</mi></mrow></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
\varepsilon_{L d} \circ L \eta_d = \mathbf{id}_{L d} \\
R \varepsilon_{c} \circ \eta_{R c} = \mathbf{id}_{R c}
\end{gathered}
</annotation></semantics></math>
Haskellでは単位と余単位を別の名前でよく見かける。単位は<code>return</code>（あるいは<code>Applicative</code>の定義においては<code>pure</code>）として知られている。</p>
<div class="sourceCode" id="cb366"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb366-1"><a href="#cb366-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span><span class="ot"> ::</span> d <span class="ot">-&gt;</span> m d</span></code></pre></div>
<p> また、余単位は<code>extract</code>として知られている。</p>
<div class="sourceCode" id="cb367"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb367-1"><a href="#cb367-1" aria-hidden="true" tabindex="-1"></a><span class="ot">extract ::</span> w c <span class="ot">-&gt;</span> c</span></code></pre></div>
<p>
ここで、<code>m</code>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R \circ L</annotation></semantics></math>に対応する（自己）関手であり、<code>w</code>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \circ R</annotation></semantics></math>に対応する（自己）関手だ。後で述べるように、これらはそれぞれモナドとコモナドの定義の一部となる。</p>
<p>自己関手をコンテナーと見なすなら、単位（つまり<code>return</code>）は任意の型の値を囲む既定の箱を生成する多相関数だ。余単位（つまり<code>extract</code>）はその逆を行い、コンテナーから単一の値を取得または生成する。</p>
<p>後で述べるように、随伴関手のどの組もモナドとコモナドを定義する。逆に、すべてのモナドやコモナドは随伴関手のペアに分解できる――ただし、その分解は一意ではない。</p>
<p>Haskellにおいて我々はよくモナドを使うが、それらを随伴関手のペアに分解することはめったにない。その主な理由は、それらの関手は通常、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐇</mi><mi>𝐚</mi><mi>𝐬</mi><mi>𝐤</mi></mrow><annotation encoding="application/x-tex">\mathbf{Hask}</annotation></semantics></math>の外へ追い出すからだ。</p>
<p>しかし、Haskellでも<span id="endofunctors"
class="keyword"><em>自己関手</em></span>の随伴は定義できる。以下は<code>Data.Functor.Adjunction</code>から抜粋した定義の一部だ<a
href="#fn107" class="footnote-ref" id="fnref107"
role="doc-noteref"><sup>107</sup></a>。</p>
<div class="sourceCode" id="cb368"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb368-1"><a href="#cb368-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Functor</span> f, <span class="dt">Representable</span> u) <span class="ot">=&gt;</span></span>
<span id="cb368-2"><a href="#cb368-2" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Adjunction</span> f u <span class="op">|</span> f <span class="ot">-&gt;</span> u, u <span class="ot">-&gt;</span> f <span class="kw">where</span></span>
<span id="cb368-3"><a href="#cb368-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    unit ::</span> a <span class="ot">-&gt;</span> u (f a)</span>
<span id="cb368-4"><a href="#cb368-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    counit ::</span> f (u a) <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>
この定義には説明が必要だ。まず、これは多パラメーター型クラスを記述している――2つのパラメーターは<code>f</code>と<code>u</code>だ。その2つの型構成子<a
href="#fn108" class="footnote-ref" id="fnref108"
role="doc-noteref"><sup>108</sup></a>の間に<code>Adjunction</code>という関係を確立している。</p>
<p>バーティカルバーの後の追加条件は、関数従属性を指定している。たとえば、<code>f -&gt; u</code>は<code>f</code>によって<code>u</code>が決定されることを意味する（<code>f</code>と<code>u</code>の関係は関数で、ここでは型構成子についての関数だ）。逆に、<code>u -&gt; f</code>は、<code>u</code>が分かれば<code>f</code>が一意に決まることを意味する。</p>
<p>なぜHaskellでは右随伴<code>u</code>が<span id="representable2"
class="keyword"><em>表現可能</em></span>関手であるという条件を課せるのかについては、すぐ後で説明する。</p>
<aside id="footnotes-57" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="105">
<li
id="fn105"><p>訳注：『不思議の国のアリス』に由来する表現で、探究心から深みに嵌まって抜け出せなくなることを表す。<a
href="#fnref105" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn106"><p>訳注：もともと考えていた関手の等しさ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∘</mo><mi>G</mi><mo>=</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">F \circ G = I</annotation></semantics></math>を自然同型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∘</mo><mi>G</mi><mo>≃</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">F \circ G \simeq I</annotation></semantics></math>に緩めているので、より弱い（つまり、より多くものが等価になるような）等価性となる。<a
href="#fnref106" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn107"><p>訳注：これは標準ライブラリー (base)
の一部ではなく、外部ライブラリーの一部である。<a href="#fnref107"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn108"><p>訳注：<code>f</code>や<code>u</code>は、たとえば
<code>(,) a</code>も動くので、通常は型構成子とは呼ばれない。<a
href="#fnref108" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="18.2" id="随伴とhom集合"><span
class="header-section-number">18.2</span> 随伴とhom集合</h2>
<p>随伴の等価な定義として、hom集合の自然同型によるものがある。その定義はこれまで学んだ普遍的構成とうまく結びついている。ある一意な射がある構成を分解しているという話を聞いたら毎回、それはある集合からhom集合への写像だと見なすべきだ。それが「一意な射を選択する」ということの意味だ。</p>
<p>さらに言うと、分解は自然変換によって記述されることが多い。分解には可換図式が関わる――ある射は2つの射（因子）の合成に等しい。自然変換は射を可換図式に写す。したがって、普遍的構成では、射から可換図式へ、そして一意な射へ向かう。最終的には、射から射への写像、あるいはあるhom集合から別の（通常は異なる圏の）hom集合への写像が得られる。もしこの写像が可逆で、すべてのhom集合に自然に拡張できるならば、随伴が存在する。</p>
<p>普遍的構成と随伴の主な違いは、後者がすべてのhom集合に対して大域的に定義されていることだ。たとえば、普遍的構成を使えば選択した2つの対象の積を定義できる。これはその圏内の他の対象のペアに対して積が存在しない場合でも同様だ。すぐ後で説明するように、対象の<em>任意のペア</em>の積が圏に存在する場合は、随伴によっても定義できる。</p>
<p> <img src="images/adj-homsets.jpg" style="width:50.0%" /> </p>
<p>
ここでhom集合を使った随伴の別の定義が出てくる。前と同じように、2つの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∷</mo><mi>𝐃</mi><mo>→</mo><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">L \Colon \mathbf{D} \to \mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∷</mo><mi>𝐂</mi><mo>→</mo><mi>𝐃</mi></mrow><annotation encoding="application/x-tex">R \Colon \mathbf{C} \to \mathbf{D}</annotation></semantics></math>がある。ここで任意の2つの対象を選択しよう。始点となる<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>と、終点となる<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>を使うことで始点となる対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>に写せる。これで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">L d</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>が得られた。これらはhom集合を定義する。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mi>d</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(L d, c)</annotation></semantics></math>
同様に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>を使えば終点となる対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>を写せる。これで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>内の2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">R c</annotation></semantics></math>が得られた。これらもhom集合を定義する。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>d</mi><mo>,</mo><mi>R</mi><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{D}(d, R c)</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>に対する左随伴となるのは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>の両方について自然なhom集合の同型
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mi>d</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>d</mi><mo>,</mo><mi>R</mi><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(L d, c) \cong \mathbf{D}(d, R c)</annotation></semantics></math>
が存在する場合、かつその場合に限る。自然性は、始点となる対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>上でスムーズに変化させられ、終点となる対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>上でスムーズに変化させられることを意味する。より正確には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への次の2つの（共変）関手間に自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi><annotation encoding="application/x-tex">\varphi</annotation></semantics></math>が存在する。それらの関手は対象に対して次のように作用する。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>c</mi><mo>→</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mi>d</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>c</mi><mo>→</mo><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>d</mi><mo>,</mo><mi>R</mi><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
c \to \mathbf{C}(L d, c) \\
c \to \mathbf{D}(d, R c)
\end{gathered}
</annotation></semantics></math>
もう一方の自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>は次の（反変）関手間に作用する。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>d</mi><mo>→</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mi>d</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>d</mi><mo>→</mo><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>d</mi><mo>,</mo><mi>R</mi><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
d \to \mathbf{C}(L d, c) \\
d \to \mathbf{D}(d, R c)
\end{gathered}
</annotation></semantics></math>
これらの自然変換は両方とも可逆でなければならない。</p>
<p>随伴の2つの定義が等しいことは簡単に示せる。たとえば、単位変換を、hom集合の同型
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mi>d</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>d</mi><mo>,</mo><mi>R</mi><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(L d, c) \cong \mathbf{D}(d, R c)</annotation></semantics></math>
から導出してみよう。この同型は任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>で成り立つので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mi>L</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">c = L d</annotation></semantics></math>でも成り立つ必要がある。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mi>d</mi><mo>,</mo><mi>L</mi><mi>d</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>d</mi><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo><mi>d</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(L d, L d) \cong \mathbf{D}(d, (R \circ L) d)</annotation></semantics></math>
左辺は少なくとも1つの射、つまり恒等射を必ず含むのが分かっている。自然変換はこの射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>d</mi><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo><mi>d</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{D}(d, (R \circ L) d)</annotation></semantics></math>
の要素に写す。恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>を挿入すれば、次の圏内の射に写すとも言える。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>I</mi><mi>d</mi><mo>,</mo><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo><mi>d</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{D}(I d, (R \circ L) d)</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>でパラメーター化された射の族が得られた。それらは関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>と関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R \circ L</annotation></semantics></math>の間に自然変換を形成する（自然性条件は容易に確認できる）。これはまさに単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>だ。</p>
<p>逆に、単位と余単位の存在から始めれば、hom集合間の変換を定義できる。たとえば、hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mi>d</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(L d, c)</annotation></semantics></math>
内の任意の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を選択してみよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>に作用して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>d</mi><mo>,</mo><mi>R</mi><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{D}(d, R c)</annotation></semantics></math>
内に射を生成する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi><annotation encoding="application/x-tex">\varphi</annotation></semantics></math>を定義したい。</p>
<p>選択肢はあまりない。試せる方法の1つは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>を使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を持ち上げることだ。これにより、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mi>d</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">R (L d)</annotation></semantics></math>
から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">R c</annotation></semantics></math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">R f</annotation></semantics></math>――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo><mi>d</mi><mo>,</mo><mi>R</mi><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{D}((R \circ L) d, R c)</annotation></semantics></math>
の要素である射が生成される。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi><annotation encoding="application/x-tex">\varphi</annotation></semantics></math>の成分に必要なのは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">R c</annotation></semantics></math>への射だ。これは問題ない。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>d</mi></msub><annotation encoding="application/x-tex">\eta_d</annotation></semantics></math>の成分を使えば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>から
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo stretchy="false" form="postfix">)</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">(R \circ L) d</annotation></semantics></math>を得られるからだ。すると、次の結果が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mi>f</mi></msub><mo>=</mo><mi>R</mi><mi>f</mi><mo>∘</mo><msub><mi>η</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">\varphi_f = R f \circ \eta_d</annotation></semantics></math>
他の方向についても同様で、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>を導出できる。</p>
<p>Haskellでの<code>Adjunction</code>の定義に戻ると、自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>φ</mi><annotation encoding="application/x-tex">\varphi</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>はそれぞれ（<code>a</code>と<code>b</code>についての）多相関数<code>leftAdjunct</code>と<code>rightAdjunct</code>に置き換えられる。関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>は<code>f</code>と<code>u</code>と呼ばれる。</p>
<div class="sourceCode" id="cb369"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb369-1"><a href="#cb369-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Functor</span> f, <span class="dt">Representable</span> u) <span class="ot">=&gt;</span></span>
<span id="cb369-2"><a href="#cb369-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Adjunction</span> f u <span class="op">|</span> f <span class="ot">-&gt;</span> u, u <span class="ot">-&gt;</span> f <span class="kw">where</span></span>
<span id="cb369-3"><a href="#cb369-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    leftAdjunct  ::</span> (f a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> u b)</span>
<span id="cb369-4"><a href="#cb369-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    rightAdjunct ::</span> (a <span class="ot">-&gt;</span> u b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> b)</span></code></pre></div>
<p>
<code>unit</code>/<code>counit</code>の構成と<code>leftAdjunct</code>/<code>rightAdjunct</code>の構成の等価性は、次の対応によって示される。</p>
<div class="sourceCode" id="cb370"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb370-1"><a href="#cb370-1" aria-hidden="true" tabindex="-1"></a>  unit           <span class="ot">=</span> leftAdjunct <span class="fu">id</span></span>
<span id="cb370-2"><a href="#cb370-2" aria-hidden="true" tabindex="-1"></a>  counit         <span class="ot">=</span> rightAdjunct <span class="fu">id</span></span>
<span id="cb370-3"><a href="#cb370-3" aria-hidden="true" tabindex="-1"></a>  leftAdjunct f  <span class="ot">=</span> <span class="fu">fmap</span> f <span class="op">.</span> unit</span>
<span id="cb370-4"><a href="#cb370-4" aria-hidden="true" tabindex="-1"></a>  rightAdjunct f <span class="ot">=</span> counit <span class="op">.</span> <span class="fu">fmap</span> f</span></code></pre></div>
<p>
随伴について圏論での記述からHaskellのコードへの翻案をなぞるのは非常に有益だ。演習として大いに推奨したい。</p>
<p>以上で、Haskellで右随伴が自動的に<a
href="#representable-functors">表現可能関手</a>（第14章）になる理由を説明する準備ができた。その理由とは、第1近似としては、Haskellの型の圏を集合の圏として扱えることだ。</p>
<p>右圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>であるとき、右随伴<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への関手となる。そのような関手が表現可能なのは、hom関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝑟</mi><mi>𝑒</mi><mi>𝑝</mi></mrow><mo>,</mo><mi>_</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(\mathit{rep}, \_)</annotation></semantics></math>
が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>に対して自然同型であるような<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑟</mi><mi>𝑒</mi><mi>𝑝</mi></mrow><annotation encoding="application/x-tex">\mathit{rep}</annotation></semantics></math>がある場合だ。実は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>へのある関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>に対して右随伴である場合、そのような対象は常に存在する――それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>の下の単元集合
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">()</annotation></semantics></math>
の像である。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑟</mi><mi>𝑒</mi><mi>𝑝</mi></mrow><mo>=</mo><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{rep} = L ()</annotation></semantics></math>
実際、随伴は次の2つのhom集合が自然同型だと教えてくれる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>R</mi><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(L (), c) \cong \mathbf{Set}((), R c)</annotation></semantics></math>
与えられたどの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>についても、右辺は単元集合
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">()</annotation></semantics></math>
から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">R c</annotation></semantics></math>への関数の集合となる。そのような関数が集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">R c</annotation></semantics></math>からそれぞれ1つの要素を選択することはすでに述べた。そのような関数の集合は、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">R c</annotation></semantics></math>と同型となる。したがって、次が成り立つ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}(L (), -) \cong R</annotation></semantics></math>
これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>が確かに表現可能であることを示している。</p>
<h2 data-number="18.3" id="随伴に基づく積"><span
class="header-section-number">18.3</span> 随伴に基づく積</h2>
<p>これまでに、普遍的構成を用いていろいろな概念を導入してきた。これらの概念の多くは、大域的に定義される場合、随伴を使ってより簡単に表現できる。非自明な例のうち最も単純なものは積である。<a
href="#products-and-coproducts">積の普遍的構成</a>（第5章）の要点は、普遍的な積を通じて積に似た候補を分解できることだ。</p>
<p>より正確には、2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の積は2つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑓</mi><mi>𝑠</mi><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">\mathit{fst}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑠</mi><mi>𝑛</mi><mi>𝑑</mi></mrow><annotation encoding="application/x-tex">\mathit{snd}</annotation></semantics></math>を伴う対象
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>×</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a \times b)</annotation></semantics></math>（すなわちHaskell表記の<code>(a, b)</code>）で、かつ2つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∷</mo><mi>c</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">p \Colon c \to a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>∷</mo><mi>c</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">q \Colon c \to b</annotation></semantics></math>を伴う他の候補<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>に対して、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑓</mi><mi>𝑠</mi><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">\mathit{fst}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑠</mi><mi>𝑛</mi><mi>𝑑</mi></mrow><annotation encoding="application/x-tex">\mathit{snd}</annotation></semantics></math>を通じて分解する一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∷</mo><mi>c</mi><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">m \Colon c \to (a, b)</annotation></semantics></math>
が存在するようなものである。</p>
<p><a
href="#products-and-coproducts">すでに</a>見たように、Haskellで2つの射影からこの射を生成する関数<code>factorizer</code>を実装できる。</p>
<div class="sourceCode" id="cb371"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb371-1"><a href="#cb371-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorizer ::</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> (a, b))</span>
<span id="cb371-2"><a href="#cb371-2" aria-hidden="true" tabindex="-1"></a>factorizer p q <span class="ot">=</span> \x <span class="ot">-&gt;</span> (p x, q x)</span></code></pre></div>
<p> 分解条件が成立することは簡単に確認できる。</p>
<div class="sourceCode" id="cb372"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb372-1"><a href="#cb372-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fst</span> <span class="op">.</span> factorizer p q <span class="ot">=</span> p</span>
<span id="cb372-2"><a href="#cb372-2" aria-hidden="true" tabindex="-1"></a><span class="fu">snd</span> <span class="op">.</span> factorizer p q <span class="ot">=</span> q</span></code></pre></div>
<p>
つまり、射のペア<code>p</code>と<code>q</code>を取り、もう1つの射<code>m = factorizer p q</code>を生成する写像が存在するということだ。</p>
<p>これをどう変換すれば、随伴を定義するために必要な2つのhom集合間の写像にできるだろう？　秘訣は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐇</mi><mi>𝐚</mi><mi>𝐬</mi><mi>𝐤</mi></mrow><annotation encoding="application/x-tex">\mathbf{Hask}</annotation></semantics></math>の外に出て、射のペアを積圏内の単一の射として扱うことだ。</p>
<p>積圏とは何か思い出してほしい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>を任意の2つの圏としよう。積圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐃</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{D}</annotation></semantics></math>内の対象は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>からの1つの対象と、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>からのもう1つの対象のペアだ。射は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>からの1つの射と、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>からのもう1つの射のペアだ。</p>
<p>ある圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>に積を定義するには、積圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation></semantics></math>から始める必要がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の射のペアは、積圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation></semantics></math>内の単一の射となる。</p>
<p> <img src="images/adj-productcat.jpg" style="width:50.0%" /> </p>
<p>
積を定義するために積圏を使うのは、最初は少し混乱するかもしれない。しかし、それらの積は全く異なる。普遍的構成は積圏を定義するのに必要ない。必要なのは対象のペアと射のペアという概念だけだ。</p>
<p>ただし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の対象のペアは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の対象では<em>ない</em>。それは別の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation></semantics></math>の対象である。このペアは形式的に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle a, b \rangle</annotation></semantics></math>と書ける。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の対象だ。一方、普遍的構成は、<em>同じ</em>圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mrow></mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">a\times{}b</annotation></semantics></math>（すなわちHaskellでの<code>(a, b)</code>）を定義するために必要となるものだ。この対象は、普遍的構成によって指定された方法でペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle a, b \rangle</annotation></semantics></math>を表すはずのものだ。これは常に存在するわけではなく、また、たとえ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の一部の対象のペアに対して存在しても、他の対象のペアに対しては存在しない場合もある。</p>
<p>さて、<code>factorizer</code>をhom集合間の写像として見てみよう。1つ目のhom集合は積圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation></semantics></math>内にあり、2つ目は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内にある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation></semantics></math>内の一般の射は、射のペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle f, g \rangle</annotation></semantics></math>
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>f</mi><mo>∷</mo><msup><mi>c</mi><mo>′</mo></msup><mo>→</mo><mi>a</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>g</mi><mo>∷</mo><msup><mi>c</mi><mo>″</mo></msup><mo>→</mo><mi>b</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
f \Colon c&#39; \to a \\
g \Colon  c&#39;&#39; \to b
\end{gathered}
</annotation></semantics></math>
となり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>″</mo></msup><annotation encoding="application/x-tex">c&#39;&#39;</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>と異なる可能性がある。しかし、積を定義するために関心があるのは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation></semantics></math>内で同じ始点となる対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>を共有する特別な射のペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>だ。それは問題とならない。随伴の定義では、左hom集合の始点は任意の対象ではない――左関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>が右圏内の対象に作用した結果だ。要求に合う関手を推測するのは簡単だ――それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation></semantics></math>への対角関手
(diagonal functor)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Δ</mi><annotation encoding="application/x-tex">\Delta</annotation></semantics></math>で、対象への作用は次のようになる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>c</mi><mo>=</mo><mo stretchy="false" form="prefix">⟨</mo><mi>c</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\Delta c = \langle c, c \rangle</annotation></semantics></math>
したがって、ここでの随伴の左側のhom集合はこうなる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐂</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi mathvariant="normal">Δ</mi><mi>c</mi><mo>,</mo><mo stretchy="false" form="prefix">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{C}\times{}\mathbf{C})(\Delta c, \langle a, b \rangle)</annotation></semantics></math>
これは積圏のhom集合だ。その要素は、<code>factorizer</code>の引数として我々が認識している射のペアだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>→</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>→</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mi>…</mi><mrow></mrow></mrow><annotation encoding="application/x-tex">(c \to a) \to (c \to b) \ldots{}</annotation></semantics></math>
右側のhom集合は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内にあり、始点となる対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>から、ある関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation></semantics></math>内の終点となる対象に作用した結果へと向かう。これこそがペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle a, b \rangle</annotation></semantics></math>を積対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mrow></mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">a\times{}b</annotation></semantics></math>に写す関手だ。hom集合のこの要素は<code>factorizer</code>の<em>結果</em>として認識される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>…</mi><mrow></mrow><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\ldots{} \to (c \to (a, b))</annotation></semantics></math></p>
<p> <img src="images/adj-product.jpg" style="width:50.0%" /> </p>
<p>
まだ完全な随伴は得られていない。そのためには、まず<code>factorizer</code>が可逆である必要がある――いま構築しようとしているのはhom集合間の<em>同型射</em>である。<code>factorizer</code>の逆は、ある対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>から積対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mrow></mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">a\times{}b</annotation></semantics></math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>で始まる必要がある。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>は次のものの要素でなければならない。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>,</mo><mi>a</mi><mo>×</mo><mrow></mrow><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c, a\times{}b)</annotation></semantics></math>
逆factorizerは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>c</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle c, c \rangle</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle a, b \rangle</annotation></semantics></math>へ向かう<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation></semantics></math>内の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle p, q \rangle</annotation></semantics></math>に写す。言い換えると、次のものの要素である射に写す。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐂</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi mathvariant="normal">Δ</mi><mi>c</mi><mo>,</mo><mo stretchy="false" form="prefix">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{C}\times{}\mathbf{C})(\Delta c, \langle a, b \rangle)</annotation></semantics></math>
この写像が存在するならば、対角関手に対して右随伴が存在すると結論できる。この関手は積を定義する。</p>
<p>Haskellでは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑓</mi><mi>𝑠</mi><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">\mathit{fst}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑠</mi><mi>𝑛</mi><mi>𝑑</mi></mrow><annotation encoding="application/x-tex">\mathit{snd}</annotation></semantics></math>にそれぞれ合成することで、常に<code>factorizer</code>の逆を構成できる。</p>
<div class="sourceCode" id="cb373"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb373-1"><a href="#cb373-1" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> <span class="fu">fst</span> <span class="op">.</span> m</span>
<span id="cb373-2"><a href="#cb373-2" aria-hidden="true" tabindex="-1"></a>q <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> m</span></code></pre></div>
<p>
積を定義する2つの方法の等価性の証明を完成するには、このhom集合間の写像が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>について自然であることも示す必要がある。これは熱心な読者のための練習として残しておこう。</p>
<p>ここまでで行ったことを要約しよう。圏論的な積は対角関手の<span
id="right_adjoint"
class="keyword"><em>右随伴</em></span>として大域的に定義できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐂</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi mathvariant="normal">Δ</mi><mi>c</mi><mo>,</mo><mo stretchy="false" form="prefix">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">⟩</mo><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>,</mo><mi>a</mi><mo>×</mo><mrow></mrow><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{C} \times{} \mathbf{C})(\Delta c, \langle a, b \rangle) \cong \mathbf{C}(c, a\times{}b)</annotation></semantics></math>
ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mrow></mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">a\times{}b</annotation></semantics></math>は、ペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle a, b \rangle</annotation></semantics></math>に対する右随伴関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑃</mi><mi>𝑟</mi><mi>𝑜</mi><mi>𝑑</mi><mi>𝑢</mi><mi>𝑐</mi><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">\mathit{Product}</annotation></semantics></math>の作用の結果だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation></semantics></math>からの関手はすべて双関手であるため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑃</mi><mi>𝑟</mi><mi>𝑜</mi><mi>𝑑</mi><mi>𝑢</mi><mi>𝑐</mi><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">\mathit{Product}</annotation></semantics></math>も双関手であることに注意してほしい。Haskellでは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑃</mi><mi>𝑟</mi><mi>𝑜</mi><mi>𝑑</mi><mi>𝑢</mi><mi>𝑐</mi><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">\mathit{Product}</annotation></semantics></math>双関手は単に<code>(,)</code>と書かれる。次の例のように、2つの型にこれを適用すれば直積型を得られる<a
href="#fn109" class="footnote-ref" id="fnref109"
role="doc-noteref"><sup>109</sup></a>。</p>
<div class="sourceCode" id="cb374"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb374-1"><a href="#cb374-1" aria-hidden="true" tabindex="-1"></a>(,) <span class="dt">Int</span> <span class="dt">Bool</span> <span class="op">~</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>)</span></code></pre></div>
<aside id="footnotes-58" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="109">
<li id="fn109"><p>訳注：実際には、Haskellでは <code>(Int, Bool)</code>
は <code>(,) Int Bool</code>の糖衣構文である。<a href="#fnref109"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="18.4" id="随伴に基づく冪"><span
class="header-section-number">18.4</span> 随伴に基づく冪</h2>
<p>冪<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>b</mi><mi>a</mi></msup><annotation encoding="application/x-tex">b^a</annotation></semantics></math>、すなわち関数対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⇒</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \Rightarrow b</annotation></semantics></math>も、<a
href="#function-types">普遍的構成</a>を使って定義できる。この構成は、対象のすべてのペアに対して存在するなら、随伴と見なせる。ここでも秘訣は次の言明に集中することだ。</p>
<blockquote>
<p>他の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>のうち、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∷</mo><mi>z</mi><mo>×</mo><mrow></mrow><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">g \Colon z\times{}a \to b</annotation></semantics></math>を伴うものについて、一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>∷</mo><mi>z</mi><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">h \Colon z \to (a \Rightarrow b)</annotation></semantics></math>
が存在する。</p>
</blockquote>
<p> この言明によりhom集合間の写像が確立される。</p>
<p>この例では、同じ圏内の対象を扱っているので、随伴関手は2つとも自己関手だ。左（自己）関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>は、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>に作用すると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>×</mo><mrow></mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">z\times{}a</annotation></semantics></math>を生成するものである。つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>はある固定された<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>について積を求めることに相当する関手だ。</p>
<p>右（自己）関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>に作用すると、関数対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>⇒</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \Rightarrow b</annotation></semantics></math>（すなわち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>b</mi><mi>a</mi></msup><annotation encoding="application/x-tex">b^a</annotation></semantics></math>）を生成するものである。ここでも、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>は固定されている。この2つの関手間の随伴は次のように記述されることがよくある。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>−</mi><mo>×</mo><mrow></mrow><mi>a</mi><mo>⊣</mo><mo stretchy="false" form="prefix">(</mo><mi>−</mi><msup><mo stretchy="false" form="postfix">)</mo><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">-\times{}a \dashv (-)^a</annotation></semantics></math>
この随伴のもとになっているhom集合の写像を極力理解しやすくするには、普遍的構成で用いた図式を描き直せばよい。</p>
<p> <img src="images/adj-expo.jpg" style="width:40.0%" /> </p>
<p>
射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑒</mi><mi>𝑣</mi><mi>𝑎</mi><mi>𝑙</mi></mrow><annotation encoding="application/x-tex">\mathit{eval}</annotation></semantics></math><a
href="#fn110" class="footnote-ref" id="fnref110"
role="doc-noteref"><sup>110</sup></a>はこの随伴の余単位に他ならないことに注目してほしい。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">(a \Rightarrow b)\times{}a \to b</annotation></semantics></math>
ここで、
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>⇒</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>a</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo stretchy="false" form="postfix">)</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">(a \Rightarrow b)\times{}a = (L \circ R) b</annotation></semantics></math>
前に述べたとおり、普遍的構成は同型を除いて一意な対象を定義する。それが積を
“the” product、冪を “the”
exponentialと書く理由だ。この性質は随伴にも及ぶ。つまり、ある関手に随伴関手があるなら、その随伴関手は同型を除いて一意だ。</p>
<aside id="footnotes-59" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="110">
<li id="fn110"><p>第9章の<a
href="#function-types">普遍的構成</a>を参照。<a href="#fnref110"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="18.5" id="課題-15"><span
class="header-section-number">18.5</span> 課題</h2>
<ol type="1">
<li>次の2つの（反変）関手間の変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ψ</mi><annotation encoding="application/x-tex">\psi</annotation></semantics></math>について、自然性の正方図式を導出せよ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>a</mi><mo>→</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>a</mi><mo>→</mo><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>R</mi><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
a \to \mathbf{C}(L a, b) \\
a \to \mathbf{D}(a, R b)
\end{gathered}
</annotation></semantics></math></li>
<li>随伴の2つ目の定義におけるhom集合同型から始めて、余単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>を導出せよ。</li>
<li>随伴の2つの定義の等価性の証明を完成せよ。</li>
<li>余積が随伴によって定義できることを示せ。余積のfactorizerの定義から出発せよ。</li>
<li>余積が対角関手の左随伴であることを示せ。</li>
<li>積と関数対象の間の随伴をHaskellで定義せよ。</li>
</ol>
<h1 data-number="19" id="freeforgetful-adjunctions"><span
class="header-section-number">19</span> 自由/忘却随伴</h1>
<!-- ## 随伴に基づく自由モノイド -->
<p>自由構成は随伴の強力な応用例だ。<span id="free_functor"
class="keyword"><em>自由関手</em></span>は<span id="forgetful_functor2"
class="keyword"><em>忘却関手</em></span>への左随伴として定義される。忘却関手は構造を忘れる関手で、通常は非常に単純だ。たとえば、多くの興味深い圏は集合の上に構築されている。しかし、それらの集合を抽象化した圏論的な対象は、内部構造
すなわち要素を持たない。それでも、これらの対象が、その圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への写像――つまり、関手――が存在するという意味で集合の記憶を保っていることはよくある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内のある対象に対応する集合は、その対象の<span
id="underlying_set"
class="keyword"><em>台集合</em></span>と呼ばれる。</p>
<p>モノイドはそのような台集合――要素の集合――を持つような対象である。モノイドの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>から集合の圏への忘却関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>が存在し、モノイドをその台集合に写す。また、モノイド射（準同型）を集合間の関数に写す。</p>
<p>私は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>を二重人格だと見なすのが好きだ。一方では、それは乗算と単位元を持つたくさんの集合からなる。他方では、それは特徴のない対象たちからなる圏であり、その唯一の構造は対象間の射として表されている。乗算と単位元を保存するすべての集合関数は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>の射となる。<br />
<br />
注意事項：</p>
<ul>
<li>同じ集合に写されるモノイドは多数存在しうる。</li>
<li>モノイド射は、それらの台集合の間に存在する関数より少ない（あるいは、高々同数）。</li>
</ul>
<p>この忘却関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>の左随伴である関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>は、生成元の集合から自由モノイドを構築するような自由関手となる。この随伴は、前に議論した<a
href="#free-monoids">自由モノイドの普遍的構成</a>（第13章2節）から導かれる。</p>
<figure>
<img src="images/forgetful.jpg"
title="モノイド$m_1$と$m_2$は同じ台集合を持つ。$m_2$と$m_3$の台集合の間の関数は、それらの間の射よりも多い。"
style="width:60.0%"
alt="モノイドm_1とm_2は同じ台集合を持つ。m_2とm_3の台集合の間の関数は、それらの間の射よりも多い。" />
<figcaption
aria-hidden="true">モノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>m</mi><mn>1</mn></msub><annotation encoding="application/x-tex">m_1</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>m</mi><mn>2</mn></msub><annotation encoding="application/x-tex">m_2</annotation></semantics></math>は同じ台集合を持つ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>m</mi><mn>2</mn></msub><annotation encoding="application/x-tex">m_2</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>m</mi><mn>3</mn></msub><annotation encoding="application/x-tex">m_3</annotation></semantics></math>の台集合の間の関数は、それらの間の射よりも多い。</figcaption>
</figure>
<p> Hom集合による定義では、この随伴は次のように書ける。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>x</mi><mo>,</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>U</mi><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Mon}(F x, m) \cong \mathbf{Set}(x, U m)</annotation></semantics></math>
この（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>について自然な）同型によって以下のことが分かる。</p>
<ul>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>によって生成された自由モノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">F x</annotation></semantics></math>と任意のモノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>との間のどのモノイド準同型についても、生成元の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>の台集合に埋め込む関数が一意に存在する。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>U</mi><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Set}(x, U m)</annotation></semantics></math>
内の関数である。</li>
<li>ある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>の台集合に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>を埋め込むどの関数についても、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>によって生成された自由モノイドとそのモノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>の間に一意なモノイド射が存在する。（これは普遍的構成で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>と呼んでいた射だ。）</li>
</ul>
<p> <img src="images/freemonadjunction.jpg" style="width:80.0%" /> </p>
<p>
直観的には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">F x</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>に基づいて構築できる「最大の」モノイドとなる。もしモノイドの内部を見られたなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>x</mi><mo>,</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Mon}(F x, m)</annotation></semantics></math>
に属するどの射もこの自由モノイドを別のモノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>に<em>埋め込む</em>ことが分かるだろう。その際、いくつかの要素は同一視されうる。特に、その射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">F x</annotation></semantics></math>の生成元（すなわち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>の要素）を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>に埋め込む。この随伴は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>の埋め込み（図の右側の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>U</mi><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Set}(x, U m)</annotation></semantics></math>
から取ってきた関数によって与えられる）が、左側のモノイドの埋め込みを一意に決定し、またその逆も成り立つことを表している。</p>
<p>Haskellにおいては、リストデータ構造は自由モノイドである（ただし、注意点がいくつかある。<a
href="http://comonad.com/reader/2015/free-monoids-in-haskell/">Dan
Doelのブログ記事</a><a href="#fn111" class="footnote-ref" id="fnref111"
role="doc-noteref"><sup>111</sup></a>を参照）。リスト型<code>[a]</code>は型<code>a</code>が生成元の集合を表しているような自由モノイドである。たとえば、型<code>[Char]</code>は、単位元――空リスト<code>[]</code>――と、<code>['a']</code>、<code>['b']</code>などのような単要素リスト――自由モノイドの生成元を含む。残りの要素は「積」を適用することにより生成される。ここでは、2つのリストの積は単に片方をもう片方に連接するだけだ。連接は結合的で単位元的
(unital)
だ（つまり、中立元が存在する――ここでは空リストだ）。<code>Char</code>によって生成される自由モノイドは、<code>Char</code>の文字からなるすべての文字列の集合に他ならない。これはHaskellでは<code>String</code>と呼ばれる。</p>
<div class="sourceCode" id="cb375"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb375-1"><a href="#cb375-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">String</span> <span class="ot">=</span> [<span class="dt">Char</span>]</span></code></pre></div>
<p>
（<code>type</code>は型シノニム――既存の型に対する別名――を定義する。）</p>
<p>もう1つの興味深い例として、単一の生成元から作られた自由モノイドが挙げられる。これはunitのリストの型<code>[()]</code>だ。その要素は<code>[]</code>、<code>[()]</code>、<code>[(), ()]</code>などだ。そのようなリストはすべて、1つの自然数――長さによって表せる。それ以外にunitのリストが含む情報はない。このようなリストを2つ連接すると、もとのリストの長さを合計した長さの新しいリストが生成される。型<code>[()]</code>が（0を含む）自然数の加算モノイドと同型であることは容易に理解できる。以下の2つの関数は互いに逆であり、この同型の証拠となっている。</p>
<div class="sourceCode" id="cb376"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb376-1"><a href="#cb376-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toNat ::</span> [()] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb376-2"><a href="#cb376-2" aria-hidden="true" tabindex="-1"></a>toNat <span class="ot">=</span> <span class="fu">length</span></span>
<span id="cb376-3"><a href="#cb376-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb376-4"><a href="#cb376-4" aria-hidden="true" tabindex="-1"></a><span class="ot">toLst ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [()]</span>
<span id="cb376-5"><a href="#cb376-5" aria-hidden="true" tabindex="-1"></a>toLst n <span class="ot">=</span> <span class="fu">replicate</span> n ()</span></code></pre></div>
<p>
簡単のため<code>Natural</code>型ではなく<code>Int</code>型を使ったが、考え方は同じだ<a
href="#fn112" class="footnote-ref" id="fnref112"
role="doc-noteref"><sup>112</sup></a>。関数<code>replicate</code>は、任意の値――ここではunit――で埋められた長さ<code>n</code>のリストを作成する。</p>
<h2 data-number="19.1" id="いくつかの直観"><span
class="header-section-number">19.1</span> いくつかの直観</h2>
<p>以下では、大雑把な議論をいくつか挙げる。この種の議論はまったく厳密ではないが、直観を形成するのには役立つ。</p>
<p>自由／忘却随伴について何らかの直観を得るには、関手や関数は本質的に情報を損失するものだということを心に留めておくのがよい。関手は複数の対象や射を潰すことがあり、関数は集合の複数の要素をまとめることがある。また、関手や関数の像は余域の一部しかカバーしていないこともある。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内の「平均的な」hom集合は、最も損失の少ない関数（たとえば単射、または場合によっては同型）から、域全体を単一要素（もしあれば）に潰す定数関数まで、一連の関数すべてを含む。</p>
<p>私はよく、任意の圏における射も損失があると見なす。これはメンタルモデルにすぎないが、有用な考え方であり、随伴――特に、圏の1つが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>である場合――について考えるとき役に立つ。</p>
<p>形式的には、我々が語れるのは可逆な射（同型射）または非可逆な射についてだけだ。損失があると見なせるのは後者だ。また、単射関数（潰さない関数）と全射関数（余域全体をカバーする関数）という概念を一般化した、モノ
(mono-) 射とエピ (epi-)
射という概念もある。ただし、モノかつエピでありながら非可逆な射も存在する場合がある。</p>
<p>自由<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊣</mo><annotation encoding="application/x-tex">\dashv</annotation></semantics></math>忘却随伴では、左側に制約の多い圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>があり、右側に制約の少ない圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の射が「より少ない」のは、何らかの追加構造を保存しなければならないからだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>の場合は乗算と単位元を保存しなければならない。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の射はそれほど多くの構造を保存しなくてよいので、「より多くの」射がある。</p>
<p>忘却関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>に適用するとき、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>の「内部構造」を暴いていると見なせる。実際、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>なら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>の内部構造――台集合――を<em>定義</em>していると見なせる。（任意の圏においては、対象の内部については他の対象との接続を通じてしか述べられないが、ここでは単に大雑把に議論しているだけだ。）</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>を使って2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>を写す場合、一般に、hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>c</mi><mo>′</mo></msup><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c&#39;, c)</annotation></semantics></math>
の写像は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>U</mi><msup><mi>c</mi><mo>′</mo></msup><mo>,</mo><mi>U</mi><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{D}(U c&#39;, U c)</annotation></semantics></math>
の部分集合のみをカバーすると予想される。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>c</mi><mo>′</mo></msup><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(c&#39;, c)</annotation></semantics></math>
内の射が追加構造を保存しなければならないのに対して、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>U</mi><msup><mi>c</mi><mo>′</mo></msup><mo>,</mo><mi>U</mi><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{D}(U c&#39;, U c)</annotation></semantics></math>
の射はそうではないからだ。</p>
<p> <img src="images/forgettingmorphisms.jpg" style="width:45.0%" />
</p>
<p> しかし、随伴は特定のhom集合間の<span id="isomorphism"
class="keyword"><em>同型</em></span>として定義されるので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>は非常に慎重に選択しなければならない。随伴では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mo>′</mo></msup><annotation encoding="application/x-tex">c&#39;</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内のどこから選択してもよいわけではなく、自由関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>の（より小さいと推察される）像から選択される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>d</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>d</mi><mo>,</mo><mi>U</mi><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(F d, c) \cong \mathbf{D}(d, U c)</annotation></semantics></math>
したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>の像は任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>に向かう多くの射を持つ対象たちのみからなっていなければならない。実際、構造を保存する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">F d</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>への射は、構造を保存しない<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>d</mi><annotation encoding="application/x-tex">d</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">U c</annotation></semantics></math>への射と同数存在する必要がある。これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>の像が（射が保存すべき構造がなくなる程度に）本質的に構造のない対象たちからなっている必要があることを意味する。そのような「構造のない」対象は自由対象
(free object) と呼ばれる。</p>
<p> <img src="images/freeimage.jpg" style="width:45.0%" /> </p>
<p>
モノイドの例では、自由モノイドは単位律と結合律によって生成される構造以外には何の構造も持たない。それ以外では、すべての乗算は全く新しい要素を生成する。</p>
<p>自由モノイドでは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>*</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">2 * 3</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>6</mn><annotation encoding="application/x-tex">6</annotation></semantics></math>ではない――新しい要素<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}2, 3{]}</annotation></semantics></math>だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}2, 3{]}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>6</mn><annotation encoding="application/x-tex">6</annotation></semantics></math>は同一視されないので、この自由モノイドから他の任意のモノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>への射は、それらを別々に写すことが許される。もちろん、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}2, 3{]}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>6</mn><annotation encoding="application/x-tex">6</annotation></semantics></math>（それらの積）の両方を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>の同じ要素に写しても構わない。また、加算モノイドで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}2, 3{]}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>5</mn><annotation encoding="application/x-tex">5</annotation></semantics></math>（それらの和）を同一視することなども同様だ。同一視が異なれば、得られるモノイドも異なる。</p>
<p>これは別の興味深い直観を導く。すなわち、自由モノイドは、モノイドの演算を実行する代わりに、渡された引数を累積
(accumulate)
する。たとえば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>を掛ける代わりに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>をリストに記憶する。この手法の利点は、どんなモノイドの演算を使うか指定する必要がないことだ。引数を累積し続けて、最後にだけ演算子を累積結果に適用すればよい。しかも、どんな演算子を適用するかはその最後の時点で選択できる。数値を加算したり、乗算したり、モジュロ2加算したりできる。つまり、自由モノイドは式の作成と評価を分離する。この考え方は代数について述べるときにもう一度見ることになるだろう。</p>
<p>この直観は他のもっと複雑な自由構成にも一般化できる。たとえば、式木
(expression tree)
を評価する前にその全体を累積できる。このアプローチの利点は、そのような木を変換して、評価を高速にしたり、メモリー消費を減らしたりできることだ。これは、たとえば行列計算の実装に使われる。愚直に前から計算すると、中間結果を保存するための一時的な配列が大量に割り当てられる場合があるからだ<a
href="#fn113" class="footnote-ref" id="fnref113"
role="doc-noteref"><sup>113</sup></a>。</p>
<aside id="footnotes-60" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="111">
<li id="fn111"><p><a
href="http://comonad.com/reader/2015/free-monoids-in-haskell/"
class="uri">http://comonad.com/reader/2015/free-monoids-in-haskell/</a></p>
<p>訳注：要は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">\bot</annotation></semantics></math>や無限リストを無視すればということ。<a
href="#fnref111" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn112"><p>訳注：<code>Int</code>型は固定幅かつ負数も表現可能。<code>Natural</code>を使う場合は<code>length</code>と<code>replicate</code>の代わりに<code>genericLength</code>と<code>genericReplicate</code>を使う。<a
href="#fnref112" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn113"><p>監訳注：Bird &amp; Gibbons: Algorithm Design with
Haskell, Cambridge University Press, 2020. <a
href="https://www.cambridge.org/core/books/algorithm-design-with-haskell/824BE0319E3762CE8BA5B1D91EEA3F52"
class="uri">https://www.cambridge.org/core/books/algorithm-design-with-haskell/824BE0319E3762CE8BA5B1D91EEA3F52</a>
の14章 “Optimum Bracketing” を参照。<a href="#fnref113"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="19.2" id="課題-16"><span
class="header-section-number">19.2</span> 課題</h2>
<ol type="1">
<li>ある単元集合から生成された自由モノイドを考える。その自由モノイドから任意のモノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>への射と、その単元集合から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>の台集合への関数との間に1対1の対応があることを示せ。</li>
</ol>
<h1 data-number="20" id="モナドプログラマーの定義"><span
class="header-section-number">20</span> モナド：プログラマーの定義</h1>
<p>プログラマーたちは、モナドにまつわる神話を発展させてきた。それはプログラミングにおける最も抽象的で難しい概念の1つだと考えられている。「理解した」人とそうでない人がいる。多くの人にとって、モナドの概念を理解した瞬間はあたかも神秘的な体験のようだ。モナドは非常に多様な構成の本質を抽象化しているので、日常生活でうまく比喩できるものがない。そして我々は暗闇の中で手探りするようになった。まるで盲人たちが象の様々な部分に触れて「ロープだ」「木の幹だ」「ブリトーだ！」と勝ち誇って叫ぶように<a
href="#fn114" class="footnote-ref" id="fnref114"
role="doc-noteref"><sup>114</sup></a>。</p>
<p>誤解を正させてもらおう。モナドを取り巻く神秘主義はすべて誤解に基づいている。モナドはとてもシンプルな概念だ。混乱を引き起こしているのは、モナドの応用先の多様さなのだ。</p>
<p>この記事のための調査の一環として、私はダクトテープ（別名ダックテープ）とその応用先について調べた。それを使ってできることのほんの一例を紹介しよう。</p>
<ul>
<li>ダクトをシーリングする</li>
<li>アポロ13号に搭載された二酸化炭素除去装置を修理する</li>
<li>いぼを治療する</li>
<li>アップルのiPhone 4の通話切断問題を修正する</li>
<li>プロムで着るドレスを作る</li>
<li>吊り橋を建設する</li>
</ul>
<p>仮にあなたがダクトテープが何か知らず、このリストに基づいて理解しようとしているところを想像してほしい。幸運を祈る！</p>
<p>そういうわけで、「モナドは……のようなものだ」という常套句のコレクションにもう1つ追加しようと思う。モナドはダクトテープのようなものだ。応用は幅広く多様だが、原理はごく単純だ。モナドは物同士をくっつける。より正確には、物同士を合成する。</p>
<p>このことは、多くのプログラマー、特に命令型言語をバックグラウンドに持つプログラマーがモナドを理解するのに困難が伴う理由の一部を説明している。問題は、我々がプログラミングを関数合成の観点から考えるのに慣れていないことにある。これはもっともなことだ。関数から関数へ値を直接渡さずに、中間値に名前を付けるのは我々にとってよくあることだ。また、しばしばグルーコードの短い断片を、ヘルパー関数に抽象化せずにインライン化する。以下は、ベクトルの長さを求める関数をC言語で命令型スタイルで実装したものだ。</p>
<div class="sourceCode" id="cb377"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb377-1"><a href="#cb377-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> vlen<span class="op">(</span><span class="dt">double</span> <span class="op">*</span>v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb377-2"><a href="#cb377-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> d <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb377-3"><a href="#cb377-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb377-4"><a href="#cb377-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> n <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> <span class="op">++</span>n<span class="op">)</span></span>
<span id="cb377-5"><a href="#cb377-5" aria-hidden="true" tabindex="-1"></a>        d <span class="op">+=</span> v<span class="op">[</span>n<span class="op">]*</span> v<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb377-6"><a href="#cb377-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sqrt<span class="op">(</span>d<span class="op">);</span></span>
<span id="cb377-7"><a href="#cb377-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>
これを、明示的な関数合成を用いた（様式化された）Haskell版と比較してほしい。</p>
<div class="sourceCode" id="cb378"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb378-1"><a href="#cb378-1" aria-hidden="true" tabindex="-1"></a>vlen <span class="ot">=</span> <span class="fu">sqrt</span> <span class="op">.</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">fmap</span>  (<span class="fu">flip</span> (<span class="op">^</span>) <span class="dv">2</span>)</span></code></pre></div>
<p>
(ここでは、より謎めかせるために、指数演算子<code>(^)</code>の2番目の引数を<code>2</code>に設定して部分適用した<a
href="#fn115" class="footnote-ref" id="fnref115"
role="doc-noteref"><sup>115</sup></a>。)</p>
<p>Haskellのポイントフリースタイルが常に優れていると主張しているのではなく、プログラミングで行うことのすべての基礎に関数合成があると主張しているだけだ。そして実質的には関数を合成しているにもかかわらず、Haskellではわざわざ<code>do</code>記法と呼ばれる命令型構文をモナド的な合成のために提供している。その使い方については後で説明する。まずは、そもそもなぜモナド的な合成が必要なのか説明しよう。</p>
<h2 data-number="20.1" id="クライスリ圏-1"><span
class="header-section-number">20.1</span> クライスリ圏</h2>
<p>以前、通常の関数を装飾することで<a
href="#writer_monad">Writerモナド</a>（第4章）に到達したのだった。この特定の装飾は、戻り値を文字列と、あるいはもっと一般にはモノイドの要素とペアにすることによってなされた。いまではそのような装飾が関手だと気付ける。</p>
<div class="sourceCode" id="cb379"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb379-1"><a href="#cb379-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Writer</span> w a <span class="ot">=</span> <span class="dt">Writer</span> (a, w)</span>
<span id="cb379-2"><a href="#cb379-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb379-3"><a href="#cb379-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Writer</span> w) <span class="kw">where</span></span>
<span id="cb379-4"><a href="#cb379-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Writer</span> (a, w)) <span class="ot">=</span> <span class="dt">Writer</span> (f a, w)</span></code></pre></div>
<p> 続いて、以下の形式の装飾された関数すなわちクライスリ射 (Kleisli
arrow) を合成する方法を発見したのだった。</p>
<div class="sourceCode" id="cb380"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb380-1"><a href="#cb380-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> <span class="dt">Writer</span> w b</span></code></pre></div>
<p> ログの累積は、まさにこの合成の内部で実装されているのだった。</p>
<p>いまではクライスリ圏をより一般的に定義する準備が完了している。まずは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>から始める。対応するクライスリ圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐊</mi><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と同じ対象を持つが、射は異なる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐊</mi><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math>内の2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の間の射は、もとの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の射
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>m</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">a \to m\ b</annotation></semantics></math>
として実装される。注意すべきは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐊</mi><annotation encoding="application/x-tex">\mathbf{K}</annotation></semantics></math>内のクライスリ射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の間の射として扱い、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">m\ b</annotation></semantics></math>の間の射としては扱わないことだ。</p>
<p>我々の例においては、ある決まったモノイド<code>w</code>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>は<code>Writer w</code>に特化されていた。</p>
<p>クライスリ射は、それらに対し適切な合成を定義できるときだけ圏をなす。合成があって、その合成が結合的かつどの対象についても恒等射を持つ場合、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>は<span
id="monad" class="keyword"><em>モナド</em></span> (monad)
と呼ばれ、その結果形成される圏はクライスリ圏と呼ばれる。</p>
<p>Haskellでは、クライスリ合成はfish演算子<code>&gt;=&gt;</code>を用いて定義され、その恒等射は<code>return</code>と呼ばれる多相関数だ。クライスリ合成を使ったモナドの定義は次のとおりだ<a
href="#fn116" class="footnote-ref" id="fnref116"
role="doc-noteref"><sup>116</sup></a>。</p>
<div class="sourceCode" id="cb381"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb381-1"><a href="#cb381-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb381-2"><a href="#cb381-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;=&gt;) ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m c)</span>
<span id="cb381-3"><a href="#cb381-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>
モナドを定義する方法には同等のものがいくつもあり、前述のものがHaskellエコシステムでの主要な方法ではないことを覚えておいてほしい。この方法の概念の簡潔さと得られる直観は気に入っているが、プログラミングの際に便利な定義は他にもある。それらについてはすぐに話すつもりだ。</p>
<p>この定式化ではモナド則を非常に簡単に表現できる。Haskellではモナド則を強制できないが、等式による推論には使える。それらは単にクライスリ圏の標準的な合成律だ。</p>
<div class="sourceCode" id="cb382"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb382-1"><a href="#cb382-1" aria-hidden="true" tabindex="-1"></a>(f <span class="op">&gt;=&gt;</span> g) <span class="op">&gt;=&gt;</span> h <span class="ot">=</span> f <span class="op">&gt;=&gt;</span> (g <span class="op">&gt;=&gt;</span> h) <span class="co">-- 結合性</span></span>
<span id="cb382-2"><a href="#cb382-2" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> <span class="op">&gt;=&gt;</span> f <span class="ot">=</span> f                  <span class="co">-- 左単位元</span></span>
<span id="cb382-3"><a href="#cb382-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;=&gt;</span> <span class="fu">return</span> <span class="ot">=</span> f                  <span class="co">-- 右単位元</span></span></code></pre></div>
<p>
この種の定義はモナドが本当は何なのかも表している。つまり、モナドは装飾された関数を合成する方法なのだ。副作用や状態は関係ない。関係あるのは合成だ。後で見るように、装飾された関数はさまざまな作用や状態を表現するために使えるが、モナドはそのためのものではない。モナドとは、装飾された関数の一端を別の装飾された関数の一端につなぐような粘着力のあるダクトテープなのだ。</p>
<p><code>Writer</code>の例に戻ろう。ログ生成関数（<code>Writer</code>関手に対するクライスリ射）たちは圏をなす。なぜなら、<code>Writer</code>はモナドだからだ<a
href="#fn117" class="footnote-ref" id="fnref117"
role="doc-noteref"><sup>117</sup></a>。</p>
<div class="sourceCode" id="cb383"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb383-1"><a href="#cb383-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Writer</span> w) <span class="kw">where</span></span>
<span id="cb383-2"><a href="#cb383-2" aria-hidden="true" tabindex="-1"></a>    f <span class="op">&gt;=&gt;</span> g <span class="ot">=</span> \a <span class="ot">-&gt;</span></span>
<span id="cb383-3"><a href="#cb383-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="dt">Writer</span> (b, s)  <span class="ot">=</span> f a</span>
<span id="cb383-4"><a href="#cb383-4" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Writer</span> (c, s&#39;) <span class="ot">=</span> g b</span>
<span id="cb383-5"><a href="#cb383-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span> <span class="dt">Writer</span> (c, s <span class="ot">`mappend`</span> s&#39;)</span>
<span id="cb383-6"><a href="#cb383-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Writer</span> (a, <span class="fu">mempty</span>)</span></code></pre></div>
<p>
<code>Writer w</code>のモナド則は、<code>w</code>のモノイド則が満たされている限り満たされる（これもHaskellでは強制できない）。</p>
<p><code>Writer</code>モナドについて、<code>tell</code>と呼ばれる便利なクライスリ射が定義されている。その唯一の目的は引数をログに追加することだ。</p>
<div class="sourceCode" id="cb384"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb384-1"><a href="#cb384-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tell ::</span> w <span class="ot">-&gt;</span> <span class="dt">Writer</span> w ()</span>
<span id="cb384-2"><a href="#cb384-2" aria-hidden="true" tabindex="-1"></a>tell s <span class="ot">=</span> <span class="dt">Writer</span> ((), s)</span></code></pre></div>
<p> これは後で他のモナド的な関数の構成要素として使うことになる。</p>
<aside id="footnotes-61" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="114">
<li
id="fn114"><p>訳注：もともとの「群盲像を評す」というインドの寓話にはブリトー（小麦粉の薄焼き生地で具材を包んだ料理）は出てこない。モナドがしばしばブリトーに例えられるのには、Brent
Yorgeyがブログで「モナドの変な理解の仕方」の例として挙げたのに対し、きちんと理解している人たちが「ブリトーとしてもちゃんと説明できる」とふざけて乗ってきた、という経緯がある。参考：</p>
<ul>
<li><a
href="https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/"
class="uri">https://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/</a></li>
<li><a href="https://blog.plover.com/prog/burritos.html"
class="uri">https://blog.plover.com/prog/burritos.html</a></li>
</ul>
<a href="#fnref114" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn115"><p>訳注：普通は、ポイントフリー記法を使う場合でも
<code>sqrt . sum . fmap (^ 2)</code>
または<code>sqrt . sum . map (^ 2)</code> とする。<a href="#fnref115"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn116"><p>訳注：現在のHaskellでは<code>Monad</code>は<code>Applicative</code>の派生クラス。<code>Applicative</code>では<code>pure :: a -&gt; f a</code>が定義されており、<code>Monad</code>で<code>return = pure</code>以外の定義をすると警告が表示される。<a
href="#fnref116" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn117"><p>監訳注：本書では簡潔性からか <code>&lt;&gt;</code>
演算子には言及がないが、現在のHaskellでは<code>Data.Semigroup.&lt;&gt;</code>
を用いて<code>mappend = (&lt;&gt;)</code>
と定義されているので、ここでのコードについては<code>s &lt;&gt; s'</code>のように書いたほうがよりストレートだろう。<a
href="#fnref117" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="20.2" id="fishの解剖"><span
class="header-section-number">20.2</span> Fishの解剖</h2>
<p>さまざまなモナドに対してfish演算子を実装するとすぐ、コードに重複がたくさんあり、簡単に括り出せることに気付くだろう。まず、2つの関数のクライスリ合成は1つの関数を返す必要があるので、その実装も型<code>a</code>の引数を1つ取るラムダから始められる。</p>
<div class="sourceCode" id="cb385"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb385-1"><a href="#cb385-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;=&gt;) ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m c)</span>
<span id="cb385-2"><a href="#cb385-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;=&gt;</span> g <span class="ot">=</span> \a <span class="ot">-&gt;</span> <span class="op">...</span></span></code></pre></div>
<p> この引数は<code>f</code>に渡す以外のことはできない。</p>
<div class="sourceCode" id="cb386"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb386-1"><a href="#cb386-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;=&gt;</span> g <span class="ot">=</span> \a <span class="ot">-&gt;</span> <span class="kw">let</span> mb <span class="ot">=</span> f a</span>
<span id="cb386-2"><a href="#cb386-2" aria-hidden="true" tabindex="-1"></a>                <span class="kw">in</span> <span class="op">...</span></span></code></pre></div>
<p>
ここで、型<code>m c</code>の結果を生成する必要がある。そのために自由に使えるのは型<code>m b</code>の対象と関数<code>g :: b -&gt; m c</code>だ。この関数は<em>bind</em>と呼ばれ、通常は中置演算子として書かれる。</p>
<div class="sourceCode" id="cb387"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb387-1"><a href="#cb387-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>
どんなモナドについても、fish演算子を定義する代わりにbindを定義できる。実際、標準的なHaskellのモナドの定義ではbindが使われている。</p>
<div class="sourceCode" id="cb388"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb388-1"><a href="#cb388-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb388-2"><a href="#cb388-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb388-3"><a href="#cb388-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p> 以下に<code>Writer</code>モナドのbindの定義を示す。</p>
<div class="sourceCode" id="cb389"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb389-1"><a href="#cb389-1" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Writer</span> (a, w)) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="kw">let</span> <span class="dt">Writer</span> (b, w&#39;) <span class="ot">=</span> f a</span>
<span id="cb389-2"><a href="#cb389-2" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">in</span>  <span class="dt">Writer</span> (b, w <span class="ot">`mappend`</span> w&#39;)</span></code></pre></div>
<p> これは確かにfish演算子の定義より短い。</p>
<p><code>m</code>が関手であるという事実を利用すればbindをさらに詳しく分析できる。<code>fmap</code>を使えば<code>m a</code>の内容に関数<code>a -&gt; m b</code>を適用できる。それによって<code>a</code>は<code>m b</code>に変換される。したがって、適用結果の型は<code>m (m b)</code>となる。これは欲しかったものそのものではない――必要なのは型<code>m b</code>の結果だ――が、惜しいところまでは行っている。<code>m</code>の2重適用を潰す、つまりフラット化する関数さえあればよい。そのような関数は<code>join</code>と呼ばれる。</p>
<div class="sourceCode" id="cb390"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb390-1"><a href="#cb390-1" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> m (m a) <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p> <code>join</code>を使ってbindを次のように書き直せる。</p>
<div class="sourceCode" id="cb391"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb391-1"><a href="#cb391-1" aria-hidden="true" tabindex="-1"></a>ma <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> join (<span class="fu">fmap</span> f ma)</span></code></pre></div>
<p> これはモナドの定義の3番目の選択肢につながる。</p>
<div class="sourceCode" id="cb392"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb392-1"><a href="#cb392-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb392-2"><a href="#cb392-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    join ::</span> m (m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb392-3"><a href="#cb392-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>
ここでは<code>m</code>が<code>Functor</code>であることを明示的に要求した。これまでの2つのモナドの定義ではその必要はなかった<a
href="#fn118" class="footnote-ref" id="fnref118"
role="doc-noteref"><sup>118</sup></a>。型構成子<code>m</code>は、fish演算子とbind演算子のどちらかをサポートするなら自動的に関手になるからだ。たとえば、<code>fmap</code>はbindと<code>return</code>で定義できる。</p>
<div class="sourceCode" id="cb393"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb393-1"><a href="#cb393-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f ma <span class="ot">=</span> ma <span class="op">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> <span class="fu">return</span> (f a)</span></code></pre></div>
<p>
完全を期すため、<code>Writer</code>モナドの<code>join</code>を以下に示す<a
href="#fn119" class="footnote-ref" id="fnref119"
role="doc-noteref"><sup>119</sup></a>。</p>
<div class="sourceCode" id="cb394"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb394-1"><a href="#cb394-1" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> <span class="dt">Writer</span> w (<span class="dt">Writer</span> w a) <span class="ot">-&gt;</span> <span class="dt">Writer</span> w a</span>
<span id="cb394-2"><a href="#cb394-2" aria-hidden="true" tabindex="-1"></a>join (<span class="dt">Writer</span> ((<span class="dt">Writer</span> (a, w&#39;)), w)) <span class="ot">=</span> <span class="dt">Writer</span> (a, w <span class="ot">`mappend`</span> w&#39;)</span></code></pre></div>
<aside id="footnotes-62" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="118">
<li
id="fn118"><p>監訳注：実際のHaskellでは「その必要はない」ことをコンパイラーに教える手段が（少なくともまだ）ないので、標準的なHaskellのモナドの定義でも<code>m</code>が<code>Functor</code>であることは（より正確には<code>Applicative</code>経由で）明示的に要求される。もっとも、定義は効率を考えなければこの章にあるとおりであるが。<a
href="#fnref118" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn119"><p>訳注：<code>join</code>も<code>bind</code>を用いて<code>join m = m &gt;&gt;= id</code>と定義できる。これが上記の定義と一致していることを確認してみよう。<a
href="#fnref119" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="20.3" id="do記法"><span
class="header-section-number">20.3</span> <code>do</code>記法</h2>
<p>モナドを使ってコードを書く方法の1つは、クライスリ射の使用――fish演算子によるそれらの合成だ。このプログラミング手法はポイントフリースタイルを一般化したものだ。ポイントフリーのコードはコンパクトで、実にエレガントなことが多い。しかし、一般には、理解するのが難しくほとんど意味不明だ。だから、ほとんどのプログラマーは関数の引数や中間結果の値に名前を付ける方を好む。</p>
<p>それはつまり、モナドを扱う場合にはfish演算子よりもbind演算子が好ましいことを意味する。Bindはモナド的な値を取ってモナド的な値を返す。プログラマーはそれらの値に名前を付けることもできる。しかし、これは改善とは言えない。本当にやりたいことは、あたかも通常の値を扱っているかのようなふりであって、それらの値をカプセル化しているモナド的コンテナーを扱いたいのではない。そのことこそ命令型コードの仕組みだ――グローバルなログの更新などの副作用は、ほとんど目に付かないところに隠されている。そしてHaskellが<code>do</code>記法でエミュレートするものでもある。</p>
<p>ここで疑問に思うだろう。一体なぜモナドを使うのか？　副作用を見えなくしたいなら、命令型言語を使い続ければよいのではないか？　その答えは、モナドなら副作用をはるかにうまくコントロールできるからだ。たとえば、<code>Writer</code>モナドのログは関数から関数へ渡され、グローバルに公開されることはない。ログを改竄したりデータ競合を引き起したりする可能性はない。また、モナド的なコードはプログラムの他の部分から明確に区分され隔離される。</p>
<p><code>do</code>記法はモナド的な合成のための単なる糖衣構文だ。表面上は命令型コードによく似ているが、bindとラムダ式のシーケンスに直接変換できる。</p>
<p>一例として、前に<code>Writer</code>モナドでのクライスリ射の合成を説明するために使った例を取り上げる。現在の定義を使うと、それは次のように書き直せる。</p>
<div class="sourceCode" id="cb395"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb395-1"><a href="#cb395-1" aria-hidden="true" tabindex="-1"></a><span class="ot">process ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> <span class="dt">String</span> [<span class="dt">String</span>]</span>
<span id="cb395-2"><a href="#cb395-2" aria-hidden="true" tabindex="-1"></a>process <span class="ot">=</span> upCase <span class="op">&gt;=&gt;</span> toWords</span></code></pre></div>
<p>
この関数は、動作ログを生成しつつ、入力文字列内のすべての文字を大文字に変換して単語に分割する。</p>
<p><code>do</code>記法なら以下のようになるだろう。</p>
<div class="sourceCode" id="cb396"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb396-1"><a href="#cb396-1" aria-hidden="true" tabindex="-1"></a>process s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb396-2"><a href="#cb396-2" aria-hidden="true" tabindex="-1"></a>    upStr <span class="ot">&lt;-</span> upCase s</span>
<span id="cb396-3"><a href="#cb396-3" aria-hidden="true" tabindex="-1"></a>    toWords upStr</span></code></pre></div>
<p>
ここで、<code>upCase</code>は<code>Writer</code>を生成するにもかかわらず</p>
<div class="sourceCode" id="cb397"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb397-1"><a href="#cb397-1" aria-hidden="true" tabindex="-1"></a><span class="ot">upCase ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb397-2"><a href="#cb397-2" aria-hidden="true" tabindex="-1"></a>upCase s <span class="ot">=</span> <span class="dt">Writer</span> (<span class="fu">map</span> <span class="fu">toUpper</span> s, <span class="st">&quot;upCase &quot;</span>)</span></code></pre></div>
<p>
のように<code>upStr</code>は単なる<code>String</code>になっている。これは<code>do</code>ブロックがコンパイラーによって次のように脱糖されるためだ。</p>
<div class="sourceCode" id="cb398"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb398-1"><a href="#cb398-1" aria-hidden="true" tabindex="-1"></a>process s <span class="ot">=</span></span>
<span id="cb398-2"><a href="#cb398-2" aria-hidden="true" tabindex="-1"></a>    upCase s <span class="op">&gt;&gt;=</span> \upStr <span class="ot">-&gt;</span></span>
<span id="cb398-3"><a href="#cb398-3" aria-hidden="true" tabindex="-1"></a>        toWords upStr</span></code></pre></div>
<p>
<code>upCase</code>のモナド的な結果と、<code>String</code>を引数とするラムダとがbindされている。まさにこの引数の名前が<code>do</code>ブロックに書かれていた。次の行</p>
<div class="sourceCode" id="cb399"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb399-1"><a href="#cb399-1" aria-hidden="true" tabindex="-1"></a>upStr <span class="ot">&lt;-</span> upCase s</span></code></pre></div>
<p>
は、<code>upStr</code>が<em>得る</em>のは<code>upCase s</code>の結果だ、と読める。</p>
<p>擬似的な命令型スタイルは<code>toWords</code>をインライン化するとさらに顕著になる。2つの関数呼び出しに置き換えてインライン化しよう。まず<code>tell</code>を呼び出して、文字列<code>"toWords"</code>をログに記録する。続いて<code>return</code>を呼び出して、文字列<code>upStr</code>を<code>words</code>によって分割した結果を返す。<code>words</code>は文字列を扱う通常の関数であることに注意してほしい。</p>
<div class="sourceCode" id="cb400"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb400-1"><a href="#cb400-1" aria-hidden="true" tabindex="-1"></a>process s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb400-2"><a href="#cb400-2" aria-hidden="true" tabindex="-1"></a>    upStr <span class="ot">&lt;-</span> upCase s</span>
<span id="cb400-3"><a href="#cb400-3" aria-hidden="true" tabindex="-1"></a>    tell <span class="st">&quot;toWords &quot;</span></span>
<span id="cb400-4"><a href="#cb400-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="fu">words</span> upStr)</span></code></pre></div>
<p>
ここで、doブロックの各行を脱糖すると、ネストされた新たなbindが導入される。</p>
<div class="sourceCode" id="cb401"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb401-1"><a href="#cb401-1" aria-hidden="true" tabindex="-1"></a>process s <span class="ot">=</span></span>
<span id="cb401-2"><a href="#cb401-2" aria-hidden="true" tabindex="-1"></a>    upCase s <span class="op">&gt;&gt;=</span> \upStr <span class="ot">-&gt;</span></span>
<span id="cb401-3"><a href="#cb401-3" aria-hidden="true" tabindex="-1"></a>      tell <span class="st">&quot;toWords &quot;</span> <span class="op">&gt;&gt;=</span> \() <span class="ot">-&gt;</span></span>
<span id="cb401-4"><a href="#cb401-4" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> (<span class="fu">words</span> upStr)</span></code></pre></div>
<p>
<code>tell</code>はunit値を生成するので、後続のラムダに渡す必要はないことに注意してほしい。モナド的な結果の内容を無視する（ただし、その作用――ここではログへの寄与――は無視しない）のはよくあることだ。そのため、そのような場合にbindを置き換える特別な演算子がある。</p>
<div class="sourceCode" id="cb402"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb402-1"><a href="#cb402-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;) ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b</span>
<span id="cb402-2"><a href="#cb402-2" aria-hidden="true" tabindex="-1"></a>m <span class="op">&gt;&gt;</span> k <span class="ot">=</span> m <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> k)</span></code></pre></div>
<p> 実際に脱糖されたコードは次のようになる。</p>
<div class="sourceCode" id="cb403"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb403-1"><a href="#cb403-1" aria-hidden="true" tabindex="-1"></a>process s <span class="ot">=</span></span>
<span id="cb403-2"><a href="#cb403-2" aria-hidden="true" tabindex="-1"></a>    upCase s <span class="op">&gt;&gt;=</span> \upStr <span class="ot">-&gt;</span></span>
<span id="cb403-3"><a href="#cb403-3" aria-hidden="true" tabindex="-1"></a>      tell <span class="st">&quot;toWords &quot;</span> <span class="op">&gt;&gt;</span></span>
<span id="cb403-4"><a href="#cb403-4" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> (<span class="fu">words</span> upStr)</span></code></pre></div>
<p>
一般に<code>do</code>ブロックは、左矢印によってそれ以降のコードで使える名前を導入するような行や、純粋に副作用を目的として実行される行（またはサブブロック）から構成される。Bind演算子は行間で暗黙的に使われる。ちなみに、Haskellでは<code>do</code>ブロックの書式［訳注：改行やインデント］を波括弧とセミコロンで置き換えられる。これが、モナドはセミコロンをオーバーロードする方法だ、と表現される理由になっている。</p>
<p><code>do</code>記法を脱糖する際にラムダとbind演算子がネストされることで、<code>do</code>ブロックの残りを各行の結果に基づいて実行するのに影響を与えることに注目してほしい。この性質は、例外をシミュレートするなど、複雑な制御構造を導入するために使える。</p>
<p>興味深いことに、<code>do</code>記法と同等のものが命令型言語に、特にC++に応用されている。再開可能な関数
(resumable function) やコルーチン (coroutine) のことだ。C++の<a
href="https://bartoszmilewski.com/2014/02/26/c17-i-see-a-monad-in-your-future/">futureがモナドをなす</a><a
href="#fn120" class="footnote-ref" id="fnref120"
role="doc-noteref"><sup>120</sup></a>
ことは秘密ではない。それは継続モナドの一例だ。継続モナドについてはすぐ後で議論する。継続の問題点は、合成するのが非常に難しいことだ。Haskellでは<code>do</code>という表記法を使うことで、「こっちのハンドラーがそっちのハンドラーを呼ぶ」というスパゲッティを、逐次コードに非常によく似たものに変換している。再開可能な関数によって、同じ変換がC++でも可能になる。
また、同じメカニズムを適用すれば、<a
href="https://bartoszmilewski.com/2014/04/21/getting-lazy-with-c/">ネストされたループのスパゲッティ</a><a
href="#fn121" class="footnote-ref" id="fnref121"
role="doc-noteref"><sup>121</sup></a>
をリスト内包表記または「ジェネレーター」に変えられる。これは本質的にリストモナドの<code>do</code>記法だ。モナドによる統一的な抽象化がなければ、これらの個々の問題は通常、その問題に特化した拡張を言語に提供することで対処されることになる。Haskellでは、すべてライブラリーを通じて対処される。</p>
<aside id="footnotes-63" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="120">
<li id="fn120"><p><a
href="https://bartoszmilewski.com/2014/02/26/c17-i-see-a-monad-in-your-future/"
class="uri">https://bartoszmilewski.com/2014/02/26/c17-i-see-a-monad-in-your-future/</a><a
href="#fnref120" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn121"><p><a
href="https://bartoszmilewski.com/2014/04/21/getting-lazy-with-c/"
class="uri">https://bartoszmilewski.com/2014/04/21/getting-lazy-with-c/</a><a
href="#fnref121" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 data-number="21" id="モナドと計算効果"><span
class="header-section-number">21</span> モナドと計算効果</h1>
<p>モナドが何のためにあるのかは理解できた。モナドによって、装飾された関数を合成できるようになる。本当に興味深い疑問は、なぜ装飾された関数が関数プログラミングにおいてそんなに重要なのかということだ。すでに1つの例については見た。<code>Writer</code>モナドだ。そこでは、装飾によって複数の関数呼び出しにわたってログを作成し累積できた。そうでもなければ非純粋関数
(impure function)
を使って（たとえば、何らかのグローバルな状態にアクセスし変更することで）解決するような問題を、純粋関数を使って解決できたことになる。</p>
<h2 data-number="21.1" id="問題"><span
class="header-section-number">21.1</span> 問題</h2>
<p>よく似た問題を集めた短いリストを、<a
href="https://doi.org/10.1016/0890-5401(91)90052-4">エウジニオ・モッジの先駆的な論文</a><a
href="#fn122" class="footnote-ref" id="fnref122"
role="doc-noteref"><sup>122</sup></a>から転載して以下に示した。どれも伝統的には関数の純粋さを放棄することで解決される。</p>
<ul>
<li>部分性：停止しない可能性のある計算</li>
<li>非決定性：複数の結果を返す可能性のある計算</li>
<li>副作用：状態にアクセス・変更する計算
<ul>
<li>読み取り専用の状態、すなわち環境</li>
<li>書き込み専用の状態、すなわちログ</li>
<li>読み取り・書き込みの両方が可能な状態</li>
</ul></li>
<li>例外：失敗する可能性があるような部分関数</li>
<li>継続：プログラムの状態を保存でき、要求に応じて復元できること</li>
<li>インタラクティブな入力</li>
<li>インタラクティブな出力</li>
</ul>
<p>本当に驚くべきことに、これらすべての問題は1つの巧妙なトリックで解決できる。装飾された関数にするというトリックだ。もちろん、装飾は各ケースで全く違うものになる。</p>
<p>装飾がモナド的だという条件は、この段階では必要ないことを認識しておかなくてはならない。合成――1つの装飾された関数をより小さな装飾された関数に分解できること――を主張するとき、初めてモナドが必要になる。また、それぞれの装飾が違うため、モナド的な合成の実装方法もやはり違うものになるが、全体的なパターンは同じだ。非常に単純な、恒等射を伴った結合的な合成というパターンである。</p>
<p>次節はHaskellでの例でいっぱいだ。圏論に戻りたい人や、Haskellによるモナドの実装にすでに慣れている人は、遠慮なく斜め読みしたり飛ばしたりして構わない。</p>
<aside id="footnotes-64" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="122">
<li id="fn122"><p><em>Notions of Computation and Monads</em>. Inf.
Comput. 93(1): 55-92 (1991). <a
href="https://doi.org/10.1016/0890-5401(91)90052-4"
class="uri">https://doi.org/10.1016/0890-5401(91)90052-4</a><a
href="#fnref122" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="21.2" id="解決策"><span
class="header-section-number">21.2</span> 解決策</h2>
<p>まず、<code>Writer</code>モナドをどう使ったか分析してみよう。我々はまず、何らかのタスクを実行するような純粋関数――つまり、引数が与えられると何らかの結果を返す関数――から始めた。そして、この関数を、もとの出力を文字列とペアにすることで装飾する別の関数に置き換えた。これがログ生成の問題に対する我々の解決策だった。</p>
<p>それで終わりにできなかったのは、一般に、モノリシックな解決策は扱いたくないからだ。1つのログ生成関数をより小さなログ生成関数に分解できる必要があった。そして、こうした小さな関数の合成こそがモナドという概念への道標となった。</p>
<p>本当に驚くべきことは、関数の戻り値の型を装飾するという同一のパターンが、通常は純粋性を放棄する必要がある多種多様な問題に対して機能することだ。前述のリストのそれぞれの問題について、どのような装飾が適用されるかを順に確認していこう。</p>
<h3 data-number="21.2.1" id="部分性"><span
class="header-section-number">21.2.1</span> 部分性</h3>
<p>停止しない可能性のあるすべての関数について、戻り値の型を「持ち上げられた」型に変更する。その型はもとの型のすべての値および特別な「ボトム」値<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">\bot</annotation></semantics></math>を含む<a
href="#fn123" class="footnote-ref" id="fnref123"
role="doc-noteref"><sup>123</sup></a>。
たとえば、集合としての<code>Bool</code>型は<code>True</code>と<code>False</code>の2つの要素を含む。持ち上げられた<code>Bool</code>は3つの要素<a
href="#fn124" class="footnote-ref" id="fnref124"
role="doc-noteref"><sup>124</sup></a>を含む。それに対し、持ち上げられた<code>Bool</code>を返す関数は、<code>True</code>または<code>False</code>を生成するか、永久に実行され続ける。</p>
<p>奇妙なのは、Haskellのような遅延評価言語では、終わりのない関数が実際に値を返す<a
href="#fn125" class="footnote-ref" id="fnref125"
role="doc-noteref"><sup>125</sup></a>ことがあり、その値が次の関数に渡されうるということだ。
この特別な値をボトムと呼ぶ。この値が（たとえば、パターンマッチングに使うため、あるいは出力に使用されるため）明示的に必要とされているのでない限り、プログラムの実行を止めることなくこの値を渡せる。すべてのHaskellの関数は潜在的に停止しない関数であり得るため、Haskellのすべての型は持ち上げられているものであると仮定される。これが、単純な<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>ではなく、Haskellの（持ち上げられた）型と関数の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐇</mi><mi>𝐚</mi><mi>𝐬</mi><mi>𝐤</mi></mrow><annotation encoding="application/x-tex">\mathbf{Hask}</annotation></semantics></math>について頻繁に議論する理由だ。もっとも、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐇</mi><mi>𝐚</mi><mi>𝐬</mi><mi>𝐤</mi></mrow><annotation encoding="application/x-tex">\mathbf{Hask}</annotation></semantics></math>が本物の圏かどうかは明らかでない
(<a
href="http://math.andrej.com/2016/08/06/hask-is-not-a-category/">Andrej
Bauerによる記事</a><a href="#fn126" class="footnote-ref" id="fnref126"
role="doc-noteref"><sup>126</sup></a>を参照)。</p>
<aside id="footnotes-65" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="123">
<li id="fn123"><p>訳注：ボトムは停止しない計算結果を表す。<a
href="#fnref123" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn124"><p>訳注：<code>True</code>と<code>False</code>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">\bot</annotation></semantics></math>。<a
href="#fnref124" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn125"><p>訳注：正確には、ボトムは終わりのない関数の結果を表す
(denote) ものであり、少なくとも操作的な感覚では値 (value) ではない。<a
href="#fnref125" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn126"><p><a
href="http://math.andrej.com/2016/08/06/hask-is-not-a-category/"
class="uri">http://math.andrej.com/2016/08/06/hask-is-not-a-category/</a><a
href="#fnref126" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h3 data-number="21.2.2" id="非決定性"><span
class="header-section-number">21.2.2</span> 非決定性</h3>
<p>関数が複数の異なる結果を返すことがあるなら、一度にすべての結果を返す方がよいだろう。意味論的には、非決定的関数は結果のリストを返す関数と等価だ。これはガベージコレクションのある遅延評価言語では実に理に適っている。たとえば、必要な値が1つだけの場合はリストのheadだけを取得すればよく、このときtailが評価されることはない。ランダムな値が必要な場合は乱数ジェネレーターを使ってリストのn番目の要素を選択する。遅延評価では結果の無限リストを返すことさえ可能になる。</p>
<p>リストモナド――Haskellでの非決定的計算の実装<a href="#fn127"
class="footnote-ref" id="fnref127"
role="doc-noteref"><sup>127</sup></a>――では<code>join</code>は<code>concat</code>として実装されている。<code>join</code>の役割はコンテナーのコンテナーをフラット化することなのを思い出してほしい――<code>concat</code>はリストのリストを連接して1つのリストにする。また、<code>return</code>は単要素リストを作成する。</p>
<div class="sourceCode" id="cb404"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb404-1"><a href="#cb404-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span></span>
<span id="cb404-2"><a href="#cb404-2" aria-hidden="true" tabindex="-1"></a>    join <span class="ot">=</span> <span class="fu">concat</span></span>
<span id="cb404-3"><a href="#cb404-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> x <span class="ot">=</span> [x]</span></code></pre></div>
<p>
リストモナドのbind演算子は、<code>fmap</code>の後に<code>join</code>が続くという一般的な解法により与えられる。より具体的には、今回のケースでは次のようになる。</p>
<div class="sourceCode" id="cb405"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb405-1"><a href="#cb405-1" aria-hidden="true" tabindex="-1"></a>as <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="fu">concat</span> (<span class="fu">fmap</span> k as)</span></code></pre></div>
<p>
ここで、関数<code>k</code>はそれ自体がリストを生成する関数で、リスト<code>as</code>のすべての要素に適用される。結果はリストのリストとなり、<code>concat</code>を使ってフラット化される。</p>
<p>プログラマーの観点では、リストの操作は比較的簡単であり、たとえば、非決定的関数をループの中で呼び出す、つまりイテレーターを返す関数を実装することの方が難しい
(ただし、<a
href="http://ericniebler.com/2014/04/27/range-comprehensions/">近年のC++</a><a
href="#fn128" class="footnote-ref" id="fnref128"
role="doc-noteref"><sup>128</sup></a>では、遅延rangeを返すことがHaskellでリストを返すこととほぼ等価となる)。</p>
<p>非決定性が創造的に使われる好例はゲームプログラミングだ。たとえば、コンピューターが人間を相手にチェスをするとき、相手の次の手は予測できない。しかし、すべての可能な手のリストを生成して1つずつ分析はできる。同様に、非決定的な構文解析器は、与えられた式に対して可能なすべての構文解析結果のリストを生成できる。</p>
<p>リストを返す関数は非決定的だと解釈してもよいものの、リストモナドの応用範囲はもっと広い。リストを生成する計算をつなぎ合わせることは、命令型プログラミングで使われる反復構文――ループ――を関数プログラミングで完全に代替する手段だからだ。単一のループは、多くの場合<code>fmap</code>を使って書き直せる。fmapはループの本体をリストの各要素に適用する。リストモナドで<code>do</code>記法を使えば、複雑な多重ループを置き換えられる。</p>
<p>私のお気に入りの例は、ピタゴラス数 (Pythagorean triple)
――直角三角形の辺を形成できる3つの正の整数の組――を生成するプログラムだ。</p>
<div class="sourceCode" id="cb406"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb406-1"><a href="#cb406-1" aria-hidden="true" tabindex="-1"></a>triples <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb406-2"><a href="#cb406-2" aria-hidden="true" tabindex="-1"></a>    z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>]</span>
<span id="cb406-3"><a href="#cb406-3" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>z]</span>
<span id="cb406-4"><a href="#cb406-4" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">&lt;-</span> [x<span class="op">..</span>z]</span>
<span id="cb406-5"><a href="#cb406-5" aria-hidden="true" tabindex="-1"></a>    guard (x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">^</span><span class="dv">2</span> <span class="op">==</span> z<span class="op">^</span><span class="dv">2</span>)</span>
<span id="cb406-6"><a href="#cb406-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (x, y, z)</span></code></pre></div>
<p>
最初の行は、<code>z</code>が正の整数の無限リスト<code>[1..]</code>から要素を取得することを示している。次に<code>x</code>は、1から<code>z</code>までの整数の（有限）リスト<code>[1..z]</code>から要素を取得する。最後に<code>y</code>は、<code>x</code>から<code>z</code>までの整数のリストから要素を取得する。これで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>x</mi><mo>≤</mo><mi>y</mi><mo>≤</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">1 \leqslant x \leqslant y \leqslant z</annotation></semantics></math>の3つの整数を自由に使える。関数<code>guard</code>は、<code>Bool</code>式を取り、unitのリストを返す。</p>
<div class="sourceCode" id="cb407"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb407-1"><a href="#cb407-1" aria-hidden="true" tabindex="-1"></a><span class="ot">guard ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> [()]</span>
<span id="cb407-2"><a href="#cb407-2" aria-hidden="true" tabindex="-1"></a>guard <span class="dt">True</span>  <span class="ot">=</span> [()]</span>
<span id="cb407-3"><a href="#cb407-3" aria-hidden="true" tabindex="-1"></a>guard <span class="dt">False</span> <span class="ot">=</span> []</span></code></pre></div>
<p>
この関数（<code>MonadPlus</code>というより大きなクラスのメンバー）は、ここでは非ピタゴラス数を除外するために使われる。実際、bind（または関連する演算子<code>&gt;&gt;</code>）の実装を見ると、空リストが与えられると空リストが生成されることに気付くだろう。一方、空でないリスト（ここではunitを含む単リスト<code>[()]</code>）が与えられた場合、bindは継続を呼ぶ。ここでは<code>return(x, y, z)</code>だ。これは検証済みのピタゴラス数を持つ単リストを生成する。これらの単リストはすべて、内包するbindによって連接され、最終的な（無限の）結果を生成する。当然、<code>triple</code>の呼び出し側はリスト全体を消費できないが、Haskellは遅延評価言語なので問題ない。</p>
<p>通常は3重にネストされたループを必要とする問題が、リストモナドと<code>do</code>記法のおかげで劇的に単純化された。それだけでは不十分と言わんばかりに、Haskellではこのコードをリスト内包表記を使ってさらに単純化する。</p>
<div class="sourceCode" id="cb408"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb408-1"><a href="#cb408-1" aria-hidden="true" tabindex="-1"></a>triples <span class="ot">=</span> [(x, y, z) <span class="op">|</span> z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>]</span>
<span id="cb408-2"><a href="#cb408-2" aria-hidden="true" tabindex="-1"></a>                     , x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>z]</span>
<span id="cb408-3"><a href="#cb408-3" aria-hidden="true" tabindex="-1"></a>                     , y <span class="ot">&lt;-</span> [x<span class="op">..</span>z]</span>
<span id="cb408-4"><a href="#cb408-4" aria-hidden="true" tabindex="-1"></a>                     , x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">^</span><span class="dv">2</span> <span class="op">==</span> z<span class="op">^</span><span class="dv">2</span>]</span></code></pre></div>
<p> これはリストモナド（厳密に言えば、<code>MonadPlus</code><a
href="#fn129" class="footnote-ref" id="fnref129"
role="doc-noteref"><sup>129</sup></a>）のためのさらなる糖衣構文だ。</p>
<p>他の関数型言語や命令型言語でも、ジェネレーターやコルーチンという名のもとに同様の構造が見られることがある。</p>
<aside id="footnotes-66" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="127">
<li
id="fn127"><p>監訳注：実装のひとつ。非決定的計算をリストモナドで表現するのは結果が無限である場合（より正確には有限であると確定できない場合）にうまく扱えない。たとえば、<code>xs</code>が無限リストのときに<code>concat [xs, ...] = xs</code>であり、先頭要素以降の情報が失われる。より具体的な例としては、後述の<code>triples</code>において最初の2行を<code>x &lt;- [1..]</code>と<code>z &lt;- [x..]</code>のように入れかえると期待どおりに動作しない（<code>x = 1</code>のケースのみ試みられることになる）。</p>
<p>解決方法のひとつはSebastian FischerらのICFP 09論文 “Purely functional
lazy non-deterministic programming” (<a
href="https://doi.org/10.1145/1596550.1596556"
class="uri">https://doi.org/10.1145/1596550.1596556</a>)
で議論されている。<a href="#fnref127" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn128"><p><a
href="http://ericniebler.com/2014/04/27/range-comprehensions/"
class="uri">http://ericniebler.com/2014/04/27/range-comprehensions/</a><a
href="#fnref128" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn129"><p>訳注：MonadComprehensions拡張を有効にしている場合。<a
href="#fnref129" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h3 data-number="21.2.3" id="読み取り専用の状態"><span
class="header-section-number">21.2.3</span> 読み取り専用の状態</h3>
<p>外部の状態に対して読み取り専用でアクセス、すなわち環境にアクセスする関数は、その環境を追加の引数として取る関数に常に置き換え可能だ。純粋な関数<code>(a, e) -&gt; b</code>（ここで、<code>e</code>は環境の型）は、一見したところ、クライスリ射のようには見えない。しかし、それを<code>a -&gt; (e -&gt; b)</code>にカリー化すれば、その装飾がお馴染みのreader関手なのがすぐ分かる。</p>
<div class="sourceCode" id="cb409"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb409-1"><a href="#cb409-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Reader</span> e a <span class="ot">=</span> <span class="dt">Reader</span> (e <span class="ot">-&gt;</span> a)</span></code></pre></div>
<p>
<code>Reader</code>を返す関数は、小さな実行可能なものを生成する関数である、と解釈できる。ここで、その実行可能なものは、環境が与えられると望んだ結果を生成するようなアクションだ。ヘルパー関数<code>runReader</code>はそのようなアクションを実行する。</p>
<div class="sourceCode" id="cb410"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb410-1"><a href="#cb410-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runReader ::</span> <span class="dt">Reader</span> e a <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> a</span>
<span id="cb410-2"><a href="#cb410-2" aria-hidden="true" tabindex="-1"></a>runReader (<span class="dt">Reader</span> f) e <span class="ot">=</span> f e</span></code></pre></div>
<p> 環境の値が異なれば得られる結果も異なりうる。</p>
<p><code>Reader</code>を返す関数も<code>Reader</code>のアクションの実行自体も純粋であることに注意してほしい。</p>
<p><code>Reader</code>モナド用のbind<a href="#fn130"
class="footnote-ref" id="fnref130"
role="doc-noteref"><sup>130</sup></a>を実装するには、まず、環境<code>e</code>を取得して<code>b</code>を生成する関数を作る必要がある。</p>
<div class="sourceCode" id="cb411"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb411-1"><a href="#cb411-1" aria-hidden="true" tabindex="-1"></a>ra <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Reader</span> (\e <span class="ot">-&gt;</span> <span class="op">...</span>)</span></code></pre></div>
<p>
ラムダ内では、アクション<code>ra</code>を実行して<code>a</code>を生成できる。</p>
<div class="sourceCode" id="cb412"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb412-1"><a href="#cb412-1" aria-hidden="true" tabindex="-1"></a>ra <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Reader</span> (\e <span class="ot">-&gt;</span> <span class="kw">let</span> a <span class="ot">=</span> runReader ra e</span>
<span id="cb412-2"><a href="#cb412-2" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">in</span> <span class="op">...</span>)</span></code></pre></div>
<p>
次に、<code>a</code>を継続<code>k</code>に渡せば新しいアクション<code>rb</code>が得られる。</p>
<div class="sourceCode" id="cb413"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb413-1"><a href="#cb413-1" aria-hidden="true" tabindex="-1"></a>ra <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Reader</span> (\e <span class="ot">-&gt;</span> <span class="kw">let</span> a  <span class="ot">=</span> runReader ra e</span>
<span id="cb413-2"><a href="#cb413-2" aria-hidden="true" tabindex="-1"></a>                             rb <span class="ot">=</span> k a</span>
<span id="cb413-3"><a href="#cb413-3" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">in</span> <span class="op">...</span>)</span></code></pre></div>
<p>
最後に、環境<code>e</code>を用いてアクション<code>rb</code>を実行できる。</p>
<div class="sourceCode" id="cb414"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb414-1"><a href="#cb414-1" aria-hidden="true" tabindex="-1"></a>ra <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Reader</span> (\e <span class="ot">-&gt;</span> <span class="kw">let</span> a  <span class="ot">=</span> runReader ra e</span>
<span id="cb414-2"><a href="#cb414-2" aria-hidden="true" tabindex="-1"></a>                             rb <span class="ot">=</span> k a</span>
<span id="cb414-3"><a href="#cb414-3" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">in</span> runReader rb e)</span></code></pre></div>
<p>
<code>return</code>を実装するには、環境を無視して値をそのまま返すアクションを作成すればよい。</p>
<p>いくつかの簡略化を経てまとめると、次の定義が得られる。</p>
<div class="sourceCode" id="cb415"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb415-1"><a href="#cb415-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Reader</span> e) <span class="kw">where</span></span>
<span id="cb415-2"><a href="#cb415-2" aria-hidden="true" tabindex="-1"></a>    ra <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Reader</span> (\e <span class="ot">-&gt;</span> runReader (k (runReader ra e)) e)</span>
<span id="cb415-3"><a href="#cb415-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> x <span class="ot">=</span> <span class="dt">Reader</span> (\e <span class="ot">-&gt;</span> x)</span></code></pre></div>
<aside id="footnotes-67" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="130">
<li
id="fn130"><p>訳注：<code>bind :: (e -&gt; a) -&gt; (a -&gt; e -&gt; b) -&gt; e -&gt; b</code><a
href="#fnref130" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h3 data-number="21.2.4" id="書き込み専用の状態"><span
class="header-section-number">21.2.4</span> 書き込み専用の状態</h3>
<p>これは最初に例にしたログ生成と同じだ。装飾は<code>Writer</code>関手によって与えられる。</p>
<div class="sourceCode" id="cb416"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb416-1"><a href="#cb416-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Writer</span> w a <span class="ot">=</span> <span class="dt">Writer</span> (a, w)</span></code></pre></div>
<p>
完全を期すため、データ構成子をアンパックする小さなヘルパー関数<code>runWriter</code>も示そう。</p>
<div class="sourceCode" id="cb417"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb417-1"><a href="#cb417-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runWriter ::</span> <span class="dt">Writer</span> w a <span class="ot">-&gt;</span> (a, w)</span>
<span id="cb417-2"><a href="#cb417-2" aria-hidden="true" tabindex="-1"></a>runWriter (<span class="dt">Writer</span> (a, w)) <span class="ot">=</span> (a, w)</span></code></pre></div>
<p>
すでに見たとおり、<code>Writer</code>を合成可能にするには、<code>w</code>はモノイドでなければならない。bind演算子版の<code>Writer</code>の<code>Monad</code>インスタンスを以下に示す。</p>
<div class="sourceCode" id="cb418"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb418-1"><a href="#cb418-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Writer</span> w) <span class="kw">where</span></span>
<span id="cb418-2"><a href="#cb418-2" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Writer</span> (a, w)) <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="kw">let</span> (a&#39;, w&#39;) <span class="ot">=</span> runWriter (k a)</span>
<span id="cb418-3"><a href="#cb418-3" aria-hidden="true" tabindex="-1"></a>                            <span class="kw">in</span> <span class="dt">Writer</span> (a&#39;, w <span class="ot">`mappend`</span> w&#39;)</span>
<span id="cb418-4"><a href="#cb418-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Writer</span> (a, <span class="fu">mempty</span>)</span></code></pre></div>
<h3 data-number="21.2.5" id="状態"><span
class="header-section-number">21.2.5</span> 状態</h3>
<p>状態へ読み取り/書き込みアクセスする関数は、<code>Reader</code>と<code>Writer</code>の装飾を組み合わせる。それらは、追加の引数として状態を受け取り、結果として値/状態のペアを生成する純粋関数
<code>(a, s) -&gt; (b, s)</code>
と見なせる。カリー化すると、それらはクライスリ射<code>a -&gt; (s -&gt; (b, s))</code>の形になり、装飾は<code>State</code>関手へと抽象化される。</p>
<div class="sourceCode" id="cb419"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb419-1"><a href="#cb419-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> (s <span class="ot">-&gt;</span> (a, s))</span></code></pre></div>
<p>
ここでも、クライスリ射は作用を返すものと見なせて、次のヘルパー関数を使って実行できる。</p>
<div class="sourceCode" id="cb420"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb420-1"><a href="#cb420-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb420-2"><a href="#cb420-2" aria-hidden="true" tabindex="-1"></a>runState (<span class="dt">State</span> f) s <span class="ot">=</span> f s</span></code></pre></div>
<p>
初期状態が異なると、結果が異なりうるだけでなく、最終状態も異なりうる。</p>
<p><code>State</code>モナドに対するbindの実装は<code>Reader</code>モナドの実装と非常によく似ている。ただし、各ステップで正しい状態を渡すように注意する必要がある。</p>
<div class="sourceCode" id="cb421"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb421-1"><a href="#cb421-1" aria-hidden="true" tabindex="-1"></a>sa <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s&#39;) <span class="ot">=</span> runState sa s</span>
<span id="cb421-2"><a href="#cb421-2" aria-hidden="true" tabindex="-1"></a>                            sb <span class="ot">=</span> k a</span>
<span id="cb421-3"><a href="#cb421-3" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">in</span> runState sb s&#39;)</span></code></pre></div>
<p> インスタンス全体は次のとおりだ。</p>
<div class="sourceCode" id="cb422"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb422-1"><a href="#cb422-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">State</span> s) <span class="kw">where</span></span>
<span id="cb422-2"><a href="#cb422-2" aria-hidden="true" tabindex="-1"></a>    sa <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s&#39;) <span class="ot">=</span> runState sa s</span>
<span id="cb422-3"><a href="#cb422-3" aria-hidden="true" tabindex="-1"></a>                            <span class="kw">in</span> runState (k a) s&#39;)</span>
<span id="cb422-4"><a href="#cb422-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (a, s))</span></code></pre></div>
<p>
状態を操作するために使えるクライスリ射が2つある。そのうちの1つは状態を調べるために取得する。</p>
<div class="sourceCode" id="cb423"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb423-1"><a href="#cb423-1" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">State</span> s s</span>
<span id="cb423-2"><a href="#cb423-2" aria-hidden="true" tabindex="-1"></a>get <span class="ot">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (s, s))</span></code></pre></div>
<p> もう1つは状態を全く新しいものに置き換える。</p>
<div class="sourceCode" id="cb424"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb424-1"><a href="#cb424-1" aria-hidden="true" tabindex="-1"></a><span class="ot">put ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s ()</span>
<span id="cb424-2"><a href="#cb424-2" aria-hidden="true" tabindex="-1"></a>put s&#39; <span class="ot">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> ((), s&#39;))</span></code></pre></div>
<h3 data-number="21.2.6" id="例外"><span
class="header-section-number">21.2.6</span> 例外</h3>
<p>例外をスローする命令型関数は、実際には部分関数――引数の値のいくつかに対して定義されていない関数だ。例外を純粋全域関数として実装する最も単純なやり方は<code>Maybe</code>関手を使うものだ。これによって部分関数を、定義されているときは<code>Just a</code>、そうでないときは<code>Nothing</code>を返すような全域関数へと拡張できる。失敗の原因に関する何らかの情報も返したい場合は、<code>Maybe</code>の代わりに<code>Either</code>関手を使える（ただし、第1の型はたとえば<code>String</code>などに固定する）。</p>
<p>以下は<code>Maybe</code>の<code>Monad</code>インスタンスだ。</p>
<div class="sourceCode" id="cb425"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb425-1"><a href="#cb425-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb425-2"><a href="#cb425-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb425-3"><a href="#cb425-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> a  <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> k a</span>
<span id="cb425-4"><a href="#cb425-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Just</span> a</span></code></pre></div>
<p>
<code>Maybe</code>についてのモナド的な合成では、エラーが検出されたときは計算がきちんと短絡評価される（継続<code>k</code>が決して呼ばれない）ことに注意してほしい。これは例外に期待される振る舞いだ。</p>
<h3 data-number="21.2.7" id="継続"><span
class="header-section-number">21.2.7</span> 継続</h3>
<p>これは「電話はしないでください、こちらから電話しますので！」という、採用面接の後に経験しそうな状況を表す<a
href="#fn131" class="footnote-ref" id="fnref131"
role="doc-noteref"><sup>131</sup></a>。回答を直接得る代わりに、ユーザーはハンドラー（計算結果を引数として呼ばれる関数）を渡す。このスタイルのプログラミングが特に役立つのは、呼び出し時点ではすぐに結果が分からない場合だ。たとえば、別のスレッドで評価される場合や、リモートのウェブサイトから配信される場合などだ。この場合のクライスリ射はハンドラーを受け取るような関数を返し、そのハンドラーは「残りの計算」［訳注：つまり、継続］を表す。</p>
<div class="sourceCode" id="cb426"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb426-1"><a href="#cb426-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Cont</span> r a <span class="ot">=</span> <span class="dt">Cont</span> ((a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r)</span></code></pre></div>
<p>
このハンドラー<code>a -&gt; r</code>は、いずれ呼び出されると型<code>r</code>の結果を生成し、その結果が［訳注：クライスリ射が返す関数から］最終的に返されることになる。継続は結果の型によってパラメーター化される。（実用上は、この結果の型はある種のステータスインジケーターを表す場合が多い。）</p>
<p>クライスリ射から返されたアクションを実行するためのヘルパー関数もある。それはハンドラーを取得して継続に渡す。</p>
<div class="sourceCode" id="cb427"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb427-1"><a href="#cb427-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runCont ::</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb427-2"><a href="#cb427-2" aria-hidden="true" tabindex="-1"></a>runCont (<span class="dt">Cont</span> k) h <span class="ot">=</span> k h</span></code></pre></div>
<p>
継続の合成は非常に難しいことで知られており、それゆえモナドや、特に<code>do</code>記法による処理は非常に有利だ。</p>
<p>bindの実装について説明しよう。まず、余計なものを取り払ったシグネチャーに注目する。</p>
<div class="sourceCode" id="cb428"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb428-1"><a href="#cb428-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> ((a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span></span>
<span id="cb428-2"><a href="#cb428-2" aria-hidden="true" tabindex="-1"></a>         (a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span></span>
<span id="cb428-3"><a href="#cb428-3" aria-hidden="true" tabindex="-1"></a>         ((b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r)</span></code></pre></div>
<p>
目標は、ハンドラー<code>(b -&gt; r)</code>を受け取って結果<code>r</code>を生成する関数を作成することだ。そこで出発点はこうなる。</p>
<div class="sourceCode" id="cb429"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb429-1"><a href="#cb429-1" aria-hidden="true" tabindex="-1"></a>ka <span class="op">&gt;&gt;=</span> kab <span class="ot">=</span> <span class="dt">Cont</span> (\hb <span class="ot">-&gt;</span> <span class="op">...</span>)</span></code></pre></div>
<p>
このラムダの内部で、<code>ka</code>関数を、残りの計算を表す適切なハンドラーを添えて呼び出したい。そのハンドラーはラムダとして実装することにする。</p>
<div class="sourceCode" id="cb430"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb430-1"><a href="#cb430-1" aria-hidden="true" tabindex="-1"></a>runCont ka (\a <span class="ot">-&gt;</span> <span class="op">...</span>)</span></code></pre></div>
<p>
この場合において、残りの計算は、まず<code>kab</code>を<code>a</code>で呼び出し、次に<code>hb</code>を結果の作用<code>kb</code>に渡すことを伴う。</p>
<div class="sourceCode" id="cb431"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb431-1"><a href="#cb431-1" aria-hidden="true" tabindex="-1"></a>runCont ka (\a <span class="ot">-&gt;</span> <span class="kw">let</span> kb <span class="ot">=</span> kab a</span>
<span id="cb431-2"><a href="#cb431-2" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span> runCont kb hb)</span></code></pre></div>
<p>
ご覧のとおり、継続は裏返しに合成されている。最終的なハンドラー<code>hb</code>は、計算の最も内側の層から呼び出される。インスタンス全体は次のとおりだ。</p>
<div class="sourceCode" id="cb432"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb432-1"><a href="#cb432-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb432-2"><a href="#cb432-2" aria-hidden="true" tabindex="-1"></a>    ka <span class="op">&gt;&gt;=</span> kab <span class="ot">=</span> <span class="dt">Cont</span> (\hb <span class="ot">-&gt;</span> runCont ka (\a <span class="ot">-&gt;</span> runCont (kab a) hb))</span>
<span id="cb432-3"><a href="#cb432-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Cont</span> (\ha <span class="ot">-&gt;</span> ha a)</span></code></pre></div>
<aside id="footnotes-68" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="131">
<li
id="fn131"><p>訳注：プログラミングの文脈では、この台詞には「ハリウッドの原則」という名前が付いている。電話することと関数を呼び出すことが同じcallという動詞で表されることに基づく駄洒落。<a
href="#fnref131" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h3 data-number="21.2.8" id="インタラクティブな入力"><span
class="header-section-number">21.2.8</span> インタラクティブな入力</h3>
<p>これは最も厄介な問題であり、多くの混乱の源だ。明らかに、<code>getChar</code>のような関数は、キーボードから入力された文字を返すとしたら、純粋ではあり得ない。しかし、その関数が文字をコンテナーで包んで返すとしたらどうだろう？　そのコンテナーから文字を取り出す方法がない限り、この関数は純粋であると主張できる。<code>getChar</code>を呼び出すたびに、全く同じコンテナーが返される。概念としては、このコンテナーには可能な文字すべての重ね合わせが含まれる。</p>
<p>量子力学に馴染みがあれば、この比喩を問題なく理解できるだろう。これはシュレーディンガーの猫が入った箱のようなものだ――ただし、箱を開けたり中を覗いたりする方法はない。この箱は、組み込みの特別な<code>IO</code>関手を使って定義される。この例では<code>getChar</code>をクライスリ射として宣言できる。</p>
<div class="sourceCode" id="cb433"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb433-1"><a href="#cb433-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getChar</span><span class="ot"> ::</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Char</span></span></code></pre></div>
<p>
（実際には、unit型を取る関数は戻り値の型の値を選択するのと等価なので、<code>getChar</code>の宣言は単純に<code>getChar :: IO Char</code>となる。）</p>
<p><code>IO</code>は関手なので<code>fmap</code>を使って中身を操作できる。また、関手として、文字だけでなく任意の型の中身を保持できる。このアプローチの真の有用性が明らかになるのは、Haskellでの<code>IO</code>がモナドなのを考慮したときだ。これは<code>IO</code>オブジェクトを生成するクライスリ射を合成できることを意味する。</p>
<p>クライスリ合成を使えば、<code>IO</code>オブジェクトの内容を覗き見できると思うかもしれない（またも量子力学で比喩すると「波動関数を収縮させる」ことにあたる）。実際、<code>getChar</code>は、文字を受け取る別のクライスリ射と合成できる。たとえば、受け取った文字を整数に変換するようなものと合成できる。問題は、そのような2番目のクライスリ射は整数を<code>(IO Int)</code>としてしか返せないということだ。ここでも、最終的に得られるのはすべての可能な整数の重ね合わせとなる。以下同様だ。シュレーディンガーの猫は決して外に出ない。<code>IO</code>モナドに入ると、抜け出す方法はない。<code>IO</code>モナドについて<code>runState</code>や<code>runReader</code>と同等のものはない。<code>runIO</code>はないのだ！</p>
<p>では、クライスリ射の結果である<code>IO</code>オブジェクトを、他のクライスリ射と合成する以外に何ができるだろう？　ええと、<code>main</code>から返せる。Haskellでは<code>main</code>は次のシグネチャーを持つ。</p>
<div class="sourceCode" id="cb434"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb434-1"><a href="#cb434-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p> そしてこれはクライスリ射と見なして構わない。</p>
<div class="sourceCode" id="cb435"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb435-1"><a href="#cb435-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>
この観点からは、Haskellのプログラムは<code>IO</code>モナドにおける1つの大きなクライスリ射にすぎない。そうした射はモナド的な合成を使えば複数の小さなクライスリ射から合成できる。生成された<code>IO</code>オブジェクト（<code>IO</code>アクションとも呼ばれる）で何を行うかはランタイムシステム次第だ。</p>
<p>射自体が純粋関数であることに注目してほしい――それは一貫して純粋関数だ。純粋でない仕事は処理系へと追いやられている。<code>main</code>から返された<code>IO</code>アクションを最終的に実行するとき、あらゆる種類の汚れ仕事が行われる。たとえば、ユーザー入力の読み取り、ファイルの変更、不愉快なメッセージの表示、ディスクのフォーマット、などなどだ。Haskellのプログラムは決して手を汚すことはない（ただし、<code>unsafePerformIO</code>を呼び出す場合は除くが、それは別の話だ）。</p>
<p>当然、Haskellは遅延評価なので<code>main</code>はほとんど即座に戻り、純粋でない仕事は即座に始まる。純粋な計算の結果が要求され評価されるのは<code>IO</code>アクションの実行中なのだ。そのため、実際には、プログラムの実行では純粋な（Haskellの）コードと純粋でない（処理系の）コードが折り重なっている。</p>
<p><code>IO</code>モナドには別の解釈がある。さらに奇妙な解釈だが、数学モデルとしては完全な意味をなす。それは宇宙全体をプログラム中のオブジェクトとして扱う。概念として、命令型モデルは宇宙を外部のグローバルオブジェクトとして扱うため、I/Oを実行する手続きにはそのオブジェクトとの相互作用によるところの副作用が伴うことに着目してほしい。それらの手続きは宇宙の状態を読み取りも変更もしうる。</p>
<p>関数プログラミングで状態を扱う方法はすでに知っている――Stateモナドを使えばよい。だが、単純な状態とは違って、宇宙の状態は標準的なデータ構造では簡単に記述できない。しかし、直接扱わない限り、その必要はない。型<code>RealWorld</code>が存在し、宇宙工学の奇跡によってランタイムがこの型のオブジェクトを提供できる、と仮定すれば十分だ。<code>IO</code>作用はただの関数だ。</p>
<div class="sourceCode" id="cb436"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb436-1"><a href="#cb436-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">IO</span> a  <span class="ot">=</span>  <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (a, <span class="dt">RealWorld</span>)</span></code></pre></div>
<p> あるいは、<code>State</code>モナドとしてはこうなる。</p>
<div class="sourceCode" id="cb437"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb437-1"><a href="#cb437-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">IO</span> <span class="ot">=</span> <span class="dt">State</span> <span class="dt">RealWorld</span></span></code></pre></div>
<p>
ただし、<code>IO</code>モナドの<code>&gt;=&gt;</code>と<code>return</code>は言語に組み込まれている必要がある。</p>
<h3 data-number="21.2.9" id="インタラクティブな出力"><span
class="header-section-number">21.2.9</span> インタラクティブな出力</h3>
<p>同じ<code>IO</code>モナドが、インタラクティブな出力をカプセル化するのにも使われる。<code>RealWorld</code>はすべての出力デバイスを含むと見なされる。なぜ単にHaskellから出力関数を呼び出して、それが何もしないものであるかのようなふりをできないのか疑問に思うだろう。たとえば、なぜ次のように書くのだろう。</p>
<div class="sourceCode" id="cb438"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb438-1"><a href="#cb438-1" aria-hidden="true" tabindex="-1"></a><span class="fu">putStr</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p> 単純に次のように書くのではいけないのだろうか。</p>
<div class="sourceCode" id="cb439"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb439-1"><a href="#cb439-1" aria-hidden="true" tabindex="-1"></a><span class="fu">putStr</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> ()</span></code></pre></div>
<p>
理由は2つある。Haskellは遅延評価なので、出力――ここではunitオブジェクト――が全く使われない関数は呼び出されない。また、遅延評価でなかったとしても、そのような呼び出しの順序は自由に変更でき、出力を混乱させうる。Haskellで2つの関数を強制的に逐次実行する唯一の方法はデータ依存性を使うことだ。ある関数の入力を別の関数の出力に依存させる必要がある。<code>IO</code>アクション間で<code>RealWorld</code>を受け渡せば逐次処理を強制できる。</p>
<p>概念としては、以下のプログラム</p>
<div class="sourceCode" id="cb440"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb440-1"><a href="#cb440-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb440-2"><a href="#cb440-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb440-3"><a href="#cb440-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStr</span> <span class="st">&quot;Hello &quot;</span></span>
<span id="cb440-4"><a href="#cb440-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStr</span> <span class="st">&quot;World!&quot;</span></span></code></pre></div>
<p>
では、「World!」と表示するアクションは「Hello」がすでに画面に表示されている宇宙を入力として受け取る。そして画面に「Hello
World!」と表示された新しい宇宙を出力する。</p>
<h2 data-number="21.3" id="結論"><span
class="header-section-number">21.3</span> 結論</h2>
<p>当然ながらここではモナドを使うプログラミングのほんの表面を撫でたにすぎない。モナドは、命令型プログラミングで副作用を使って通常行われることを純粋関数で単に実現するのではなく、高度な制御と型安全性を備えて実現している。だが、欠点がないわけではない。モナドへのよくある不満は、モナド同士を簡単に合成できないことだ。だとしても、基本的なモナドのほとんどはモナド変換子ライブラリー
(Monad transformer library) <a href="#fn132" class="footnote-ref"
id="fnref132"
role="doc-noteref"><sup>132</sup></a>を使って結合できる。たとえば状態と例外を組み合わせたモナドスタックを作成するのは比較的簡単だ。ただし、任意のモナドをスタックするためのレシピはない。</p>
<aside id="footnotes-69" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="132">
<li id="fn132"><p>訳注：<a
href="https://hackage.haskell.org/package/mtl"
class="uri">https://hackage.haskell.org/package/mtl</a><a
href="#fnref132" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 data-number="22" id="monads-categorically"><span
class="header-section-number">22</span> 圏論から見たモナド</h1>
<p>モナドについてプログラマーに話すなら、おそらく計算効果について話すことになるだろう。だが、数学者にとってはモナドは代数に関するものだ。代数については後で話そう――代数はプログラミングにおいて重要な役割を果たす――まずは、代数とモナドとの関係について少し直観を得てもらおうと思う。さしあたっては、やや大雑把な議論になるが、ご容赦願いたい。</p>
<p>代数とは式を作成・操作・評価することだ。式は演算子を使って組み立てられる。次の単純な式を考えてみよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>2</mn><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x^2 + 2 x + 1</annotation></semantics></math>
この式は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>のような変数と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>や<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>のような定数とを加算や乗算のような演算子で組み合わせて構成されている。プログラマーはよく式を木と見なす。</p>
<p> <img src="images/exptree.png" style="width:30.0%" /> </p>
<p>
木はコンテナーなので、より一般化すると、式は変数を格納するコンテナーだと言える。圏論ではコンテナーを自己関手として表す。型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を変数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>に割り振ると、式は型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mspace width="0.222em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">m\ a</annotation></semantics></math>を持つことになる。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>は式木を構成する自己関手だ。（非自明な枝分かれした式は通常、再帰的に定義された自己関手を使って作成される。）</p>
<p>式に対して実行できる最も共通した操作は何だろう？　それは代入だ。つまり、変数を式に置き換えることだ。たとえば、この例では<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">y-1</annotation></semantics></math>に置き換えて次のようにできる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo>−</mo><mn>1</mn><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(y - 1)^2 + 2 (y - 1) + 1</annotation></semantics></math>
何が起きたかというと、型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mspace width="0.222em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">m\ a</annotation></semantics></math>の式を取って型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>m</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">a \to m\ b</annotation></semantics></math>への変換を適用した（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>の型を表す）。結果は型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">m\ b</annotation></semantics></math>の式になる。はっきり書いてみよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mspace width="0.222em"></mspace><mi>a</mi><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>→</mo><mi>m</mi><mspace width="0.222em"></mspace><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>m</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">m\ a \to (a \to m\ b) \to m\ b</annotation></semantics></math>
そう、これはモナドにおけるbindのシグネチャーだ。</p>
<p>ちょっとしたモチベーションが得られた。では、モナドについての数学に取り掛かろう。数学者はプログラマーとは異なる表記法を用いる。自己関手には文字<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>を、自然変換にはギリシャ文字を使うのが好みだ。ここでは、<code>join</code>には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>、<code>return</code>には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>を使う。
<code>join</code>も<code>return</code>も多相関数なので、自然変換に対応していると見当がつく。</p>
<p>それゆえ、圏論では、モナドは自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>のペアを伴った自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>として定義される。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>は関手の2乗<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>T</mi><mn>2</mn></msup><annotation encoding="application/x-tex">T^2</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>へ戻る自然変換だ。この2乗は単に関手をそれ自身と合成したもの、つまり<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>∘</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">T \circ T</annotation></semantics></math>である（このような2乗は自己関手でしか行えない）。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>∷</mo><msup><mi>T</mi><mn>2</mn></msup><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\mu \Colon T^2 \to T</annotation></semantics></math>
この自然変換の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>における成分は次の射だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>a</mi></msub><mo>∷</mo><mi>T</mi><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>T</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\mu_a \Colon T (T a) \to T a</annotation></semantics></math>
これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐇</mi><mi>𝐚</mi><mi>𝐬</mi><mi>𝐤</mi></mrow><annotation encoding="application/x-tex">\mathbf{Hask}</annotation></semantics></math>では、<code>join</code>の定義に直接対応する。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>は恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>と自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>の間の自然変換だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>∷</mo><mi>I</mi><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\eta \Colon I \to T</annotation></semantics></math>
対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>に対し<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>を作用させると単に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>になるのを考慮すると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>の成分は次の射によって与えられる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>η</mi><mi>a</mi></msub><mo>∷</mo><mi>a</mi><mo>→</mo><mi>T</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\eta_a \Colon a \to T a</annotation></semantics></math>
これは<code>return</code>の定義に直接対応する。</p>
<p>これらの自然変換にはいくつか追加で満たすべき規則がある。1つの観点としては、そうした追加の規則は自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>についてのクライスリ圏を定義するのに十分なものだ、ということだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の間のクライスリ射は射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>T</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a \to T b</annotation></semantics></math>として定義されたことを思い出そう。そのような2つの射の合成（ここでは下付き文字<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>を添えた円で記す）は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>を使って実装できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><msub><mo>∘</mo><mi>T</mi></msub><mi>f</mi><mo>=</mo><msub><mi>μ</mi><mi>c</mi></msub><mo>∘</mo><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">g \circ_T f = \mu_c \circ (T g) \circ f</annotation></semantics></math>
ただし、
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>T</mi><mi>b</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>g</mi><mo>∷</mo><mi>b</mi><mo>→</mo><mi>T</mi><mi>c</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
f \Colon a \to T b \\
g \Colon b \to T c
\end{gathered}
</annotation></semantics></math>
ここで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>は関手であるため、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>に適用できる。この式はHaskellの記法で理解した方が簡単かもしれない。</p>
<div class="sourceCode" id="cb441"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb441-1"><a href="#cb441-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;=&gt;</span> g <span class="ot">=</span> join <span class="op">.</span> <span class="fu">fmap</span> g <span class="op">.</span> f</span></code></pre></div>
<p> あるいは、成分で表すとこうなる。</p>
<div class="sourceCode" id="cb442"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb442-1"><a href="#cb442-1" aria-hidden="true" tabindex="-1"></a>(f <span class="op">&gt;=&gt;</span> g) a <span class="ot">=</span> join (<span class="fu">fmap</span> g (f a))</span></code></pre></div>
<p> 代数的に解釈すると、単に2つの連続した代入を合成しているだけだ。</p>
<p>クライスリ射が圏をなすために、それらの合成が結合性を持っていて、かつ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\eta_a</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>における恒等クライスリ射であってほしい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>に対するモナド則は、この要件を翻訳することで得られる。しかし、これらの規則は別の方法で導出することでもっとモノイド則に似て見えてくるのだ。実際、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>はしばしば<em>乗算</em>
(multiplication)
と呼ばれ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>は<em>単位</em>
(unit) と呼ばれる。</p>
<p>大まかに言うと、結合律は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>の三乗<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>T</mi><mn>3</mn></msup><annotation encoding="application/x-tex">T^3</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>に簡約するための2つの方法が同じ結果を与えなければならないことを述べている。また、左単位律と右単位律は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>に適用された後に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>で簡約すると再び<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>が得られることを述べている。</p>
<p>少しトリッキーなのは自然変換と関手を合成しているからだ。そこで水平合成について少し復習するのがよいだろう。たとえば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>T</mi><mn>3</mn></msup><annotation encoding="application/x-tex">T^3</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>T</mi><mn>2</mn></msup><annotation encoding="application/x-tex">T^2</annotation></semantics></math>の後に合成したものと見なせる。これに、次の2つの自然変換の水平合成を適用できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>T</mi></msub><mo>∘</mo><mi>μ</mi></mrow><annotation encoding="application/x-tex">I_T \circ \mu</annotation></semantics></math></p>
<p> <img src="images/assoc1.png" style="width:40.0%" /> </p>
<p>
すると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>∘</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">T \circ T</annotation></semantics></math>が得られ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>を適用するとさらに<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>に簡約できる。ここで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mi>T</mi></msub><annotation encoding="application/x-tex">I_T</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>への恒等自然変換だ。このような水平合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>T</mi></msub><mo>∘</mo><mi>μ</mi></mrow><annotation encoding="application/x-tex">I_T \circ \mu</annotation></semantics></math>はよく<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>∘</mo><mi>μ</mi></mrow><annotation encoding="application/x-tex">T \circ \mu</annotation></semantics></math>と短く表記される。この表記に曖昧さはない。なぜなら、関手を自然変換と合成するのは意味がなく、それゆえこの文脈では<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mi>T</mi></msub><annotation encoding="application/x-tex">I_T</annotation></semantics></math>を意味するに違いないからだ。</p>
<p>（自己）関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}\mathbf{C}, \mathbf{C}{]}</annotation></semantics></math>における図式を描くこともできる。</p>
<p> <img src="images/assoc2.png" style="width:30.0%" /> </p>
<p>
また別の簡約法として、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>T</mi><mn>3</mn></msup><annotation encoding="application/x-tex">T^3</annotation></semantics></math>を合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mn>2</mn></msup><mo>∘</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">T^2 \circ T</annotation></semantics></math>として扱い、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>∘</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\mu \circ T</annotation></semantics></math>を適用してもよい。その結果も<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>∘</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">T \circ T</annotation></semantics></math>となるので、今回も<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>を使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>に戻せる。これら2つの経路のどちらにおいても同じ結果が得られるようになっていてほしい。</p>
<p> <img src="images/assoc.png" style="width:30.0%" /> </p>
<p>
同様に、恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>の後に合成したものに対して水平合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>∘</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\eta \circ T</annotation></semantics></math>を適用して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>T</mi><mn>2</mn></msup><annotation encoding="application/x-tex">T^2</annotation></semantics></math>が得られ、その後で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>を使って簡約できる。その結果は恒等自然変換を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>に直接適用したのと同じになってほしい。そして、類推から、同様のことが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>∘</mo><mi>η</mi></mrow><annotation encoding="application/x-tex">T \circ \eta</annotation></semantics></math>にも当てはまってほしい。</p>
<p> <img src="images/unitlawcomp-1.png" style="width:40.0%" /> </p>
<p>
これらの規則から、クライスリ射の合成が実際に圏の規則を満たすことを確かめてみるとよい。</p>
<p>モナドとモノイドの類似点は驚異的だ。どちらにも乗算<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>・単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>・結合律・単位律が存在する。しかし、我々のモノイドの定義は狭すぎて、モナドをモノイドとしては記述できない。そこで、モノイドの概念を一般化しよう。</p>
<h2 data-number="22.1" id="モノイダル圏"><span
class="header-section-number">22.1</span> モノイダル圏</h2>
<p>モノイドの従来の定義に戻ろう。それは二項演算および、単位という特別な要素を持つ集合だった。Haskellでは、このことを型クラスとして表現できる。</p>
<div class="sourceCode" id="cb443"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb443-1"><a href="#cb443-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="kw">where</span></span>
<span id="cb443-2"><a href="#cb443-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    mappend ::</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m</span>
<span id="cb443-3"><a href="#cb443-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    mempty  ::</span> m</span></code></pre></div>
<p> 二項演算<code>mappend</code>は結合的かつ単位的 (unital)
でなければならない（すなわち、単位<code>mempty</code>を乗算することはno-opとなる）。</p>
<p>Haskellでの<code>mappend</code>の定義はカリー化されていることに注意してほしい。つまり、<code>mappend</code>は<code>m</code>のどの要素も関数に写せると解釈できる。すなわち、</p>
<div class="sourceCode" id="cb444"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb444-1"><a href="#cb444-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mappend</span><span class="ot"> ::</span> m <span class="ot">-&gt;</span> (m <span class="ot">-&gt;</span> m)</span></code></pre></div>
<p> この解釈こそが、モノイドを、自己射 (endomorphism)
<code>(m -&gt; m)</code>
がモノイドの要素を表すような単一対象圏として定義するもととなるものだった。ただし、Haskellにはカリー化が組み込まれているので、乗算の別の定義から始めてもよかったはずだ。</p>
<div class="sourceCode" id="cb445"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb445-1"><a href="#cb445-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mu ::</span> (m, m) <span class="ot">-&gt;</span> m</span></code></pre></div>
<p>
ここで、デカルト積<code>(m, m)</code>は乗算されるペアの域になる。</p>
<p>この定義は一般化への別の道を示唆する。デカルト積を圏論的な積に置き換えるというものだ。積が大域的に定義されている圏から始め、対象<code>m</code>を選択し、乗算を射として定義できるかもしれない。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>∷</mo><mi>m</mi><mo>×</mo><mrow></mrow><mi>m</mi><mo>→</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\mu \Colon m\times{}m \to m</annotation></semantics></math>
ただし、問題が1つある。任意の圏で対象の内部を覗き見られるわけではないのに、どうすれば単位元を選び取れるだろう？　そのためのトリックがある。要素の選択が単元集合からの関数と等価であったことを覚えているだろうか？　Haskellで言うと、<code>mempty</code>の定義を次の関数に置き換えられてもよかったはずだ。</p>
<div class="sourceCode" id="cb446"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb446-1"><a href="#cb446-1" aria-hidden="true" tabindex="-1"></a><span class="ot">eta ::</span> () <span class="ot">-&gt;</span> m</span></code></pre></div>
<p>
単元集合は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>の終対象なので、終対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>を持つすべての圏にこの定義を一般化するのは自然だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>∷</mo><mi>t</mi><mo>→</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\eta \Colon t \to m</annotation></semantics></math>
これにより、要素について述べることなく単位「要素」を選べる。</p>
<p>以前モノイドを単一対象圏として定義したときとは違って、ここではモノイド則が自動的に満たされるわけではなく、それらを課す必要がある。しかし、それらを定式化するには、基礎となる圏論的な積そのもののモノイドの構造を確立しなければならない。まずはHaskellでモノイドの構造がどのようになっていたか思い出していこう。</p>
<p>まずは結合性から見ていこう。Haskellでは、対応する等式規則 (equational
law) は次のように書ける。</p>
<div class="sourceCode" id="cb447"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb447-1"><a href="#cb447-1" aria-hidden="true" tabindex="-1"></a>mu x (mu y z) <span class="ot">=</span> mu (mu x y) z</span></code></pre></div>
<p>
この等式を他の圏に一般化する前に、関数（射）の等しさの形で書き直す必要がある。抽象化により個々の変数に対する作用から離れる必要がある――言い換えれば、ポイントフリー記法を使う必要がある。デカルト積は双関手だと分かっているので、左辺は次のように書き直せる。</p>
<div class="sourceCode" id="cb448"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb448-1"><a href="#cb448-1" aria-hidden="true" tabindex="-1"></a>(mu <span class="op">.</span> bimap <span class="fu">id</span> mu)(x, (y, z))</span></code></pre></div>
<p> そして右辺は次のように書ける。</p>
<div class="sourceCode" id="cb449"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb449-1"><a href="#cb449-1" aria-hidden="true" tabindex="-1"></a>(mu <span class="op">.</span> bimap mu <span class="fu">id</span>)((x, y), z)</span></code></pre></div>
<p> これはほぼ希望どおりだ。残念ながら、デカルト積には厳密 (strict)
な結合性がない――<code>(x, (y, z))</code>と<code>((x, y), z)</code>は異なる――ので、次のようにポイントフリーでは書けない。</p>
<div class="sourceCode" id="cb450"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb450-1"><a href="#cb450-1" aria-hidden="true" tabindex="-1"></a>mu <span class="op">.</span> bimap <span class="fu">id</span> mu <span class="ot">=</span> mu <span class="op">.</span> bimap mu <span class="fu">id</span></span></code></pre></div>
<p>
一方、この2つのペアのネストの仕方同士は同型だ。それらの間を変換する結合切替子
(associator) と呼ばれる可逆関数がある<a href="#fn133"
class="footnote-ref" id="fnref133"
role="doc-noteref"><sup>133</sup></a>。</p>
<div class="sourceCode" id="cb451"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb451-1"><a href="#cb451-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> ((a, b), c) <span class="ot">-&gt;</span> (a, (b, c))</span>
<span id="cb451-2"><a href="#cb451-2" aria-hidden="true" tabindex="-1"></a>alpha ((x, y), z) <span class="ot">=</span> (x, (y, z))</span></code></pre></div>
<p>
結合切替子の助けを借りれば<code>mu</code>についての結合律をポイントフリーで書ける。</p>
<div class="sourceCode" id="cb452"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb452-1"><a href="#cb452-1" aria-hidden="true" tabindex="-1"></a>mu <span class="op">.</span> bimap <span class="fu">id</span> mu <span class="op">.</span> alpha <span class="ot">=</span> mu <span class="op">.</span> bimap mu <span class="fu">id</span></span></code></pre></div>
<p>
単位律にも同様のトリックを適用できる。新しい記法では次のような形式になる。</p>
<div class="sourceCode" id="cb453"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb453-1"><a href="#cb453-1" aria-hidden="true" tabindex="-1"></a>mu (eta (), x) <span class="ot">=</span> x</span>
<span id="cb453-2"><a href="#cb453-2" aria-hidden="true" tabindex="-1"></a>mu (x, eta ()) <span class="ot">=</span> x</span></code></pre></div>
<p> これらは次のように書き直せる。</p>
<div class="sourceCode" id="cb454"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb454-1"><a href="#cb454-1" aria-hidden="true" tabindex="-1"></a>(mu <span class="op">.</span> bimap eta <span class="fu">id</span>) ((), x) <span class="ot">=</span> lambda ((), x)</span>
<span id="cb454-2"><a href="#cb454-2" aria-hidden="true" tabindex="-1"></a>(mu <span class="op">.</span> bimap <span class="fu">id</span> eta) (x, ()) <span class="ot">=</span> rho (x, ())</span></code></pre></div>
<p> 2つの同型射のうち<code>lambda</code>は左単位積子 (left unitor)
と呼ばれ、<code>rho</code>は右単位積子 (right unitor) と呼ばれる<a
href="#fn134" class="footnote-ref" id="fnref134"
role="doc-noteref"><sup>134</sup></a>。これらが示すのは、単位
<code>()</code> は同型を除いてデカルト積の単位元であるという事実だ。</p>
<div class="sourceCode" id="cb455"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb455-1"><a href="#cb455-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lambda ::</span> ((), a) <span class="ot">-&gt;</span> a</span>
<span id="cb455-2"><a href="#cb455-2" aria-hidden="true" tabindex="-1"></a>lambda ((), x) <span class="ot">=</span> x</span></code></pre></div>
<div class="sourceCode" id="cb456"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb456-1"><a href="#cb456-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rho ::</span> (a, ()) <span class="ot">-&gt;</span> a</span>
<span id="cb456-2"><a href="#cb456-2" aria-hidden="true" tabindex="-1"></a>rho (x, ()) <span class="ot">=</span> x</span></code></pre></div>
<p> したがって、ポイントフリー版の単位律は次のようになる。</p>
<div class="sourceCode" id="cb457"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb457-1"><a href="#cb457-1" aria-hidden="true" tabindex="-1"></a>mu <span class="op">.</span> bimap <span class="fu">id</span> eta <span class="ot">=</span> lambda</span>
<span id="cb457-2"><a href="#cb457-2" aria-hidden="true" tabindex="-1"></a>mu <span class="op">.</span> bimap eta <span class="fu">id</span> <span class="ot">=</span> rho</span></code></pre></div>
<p>
ここまでで、<code>mu</code>と<code>eta</code>についてのポイントフリーなモノイド則の定式化を、基礎となるデカルト積自体が型の圏におけるモノイド的な乗算のように作用するという事実を用いて行った。ただし、留意すべき点として、デカルト積の結合律と単位律は同型を除いてのみ成り立つ。</p>
<p>実は、これらの規則は積と終対象を持つすべての圏に一般化できる。圏論的な積は確かに同型を除いて結合的であり、同様に、同型を除いて終対象は単位だ。結合切替子と2つの単位積子は自然同型だ。それらについての規則は可換図式で表せる。</p>
<p> <img src="images/assocmon.png" style="width:50.0%" /> </p>
<p>
積は双関手なので射のペアを持ち上げられることに注意してほしい――Haskellではそのために<code>bimap</code>が使われる。</p>
<p>ここで議論を打ち切って、圏論的な積と終対象を持つあらゆる圏においてモノイドを定義できると述べることもできるかもしれない。つまり、モノイド則を満たすような対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>と2つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>を選択できるなら、モノイドが存在する、と。しかし、もっとうまくやれる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>について規則を定式化するために完全な圏論的な積は必要ない。積の定義は射影を使った普遍的構成によって行われていたのを思い出してほしい。その一方でモノイド則の定式化では射影を一切使わなかった。</p>
<p>積ではないものの積のように振る舞う双関手は<span id="tensor_product"
class="keyword"><em>テンソル積</em></span> (tensor product) と呼ばれ<a
href="#fn135" class="footnote-ref" id="fnref135"
role="doc-noteref"><sup>135</sup></a>、中置演算子<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊗</mi><annotation encoding="application/x-tex">\otimes</annotation></semantics></math>で表されることが多い。テンソル積の一般的な定義は少しトリッキーだが、気にしないでよい。ここでは単にその性質を列挙する――最も重要なのは同型を除いた結合性だ。</p>
<p>同様に、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>が終対象である必要はない。それが終対象であるという性質――つまり、どの対象からも一意な射が存在すること――を使いはしなかった。必要なのは、それがテンソル積とうまく協調して働くことだ。つまり、同型を除いてテンソル積の単位であってほしい。以上をまとめてみよう。</p>
<p>モノイダル圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>はテンソル積と呼ばれる双関手
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>⊗</mi><mo>∷</mo><mi>𝐂</mi><mo>×</mo><mrow></mrow><mi>𝐂</mi><mo>→</mo><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">\otimes \Colon \mathbf{C}\times{}\mathbf{C} \to \mathbf{C}</annotation></semantics></math>
および、単位対象と呼ばれる特定の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>と、それぞれ結合切替子・左単位積子・右単位積子と呼ばれる3つの自然同型写像
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>α</mi><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>⊗</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mi>c</mi><mo>→</mo><mi>a</mi><mo>⊗</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>⊗</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>λ</mi><mi>a</mi></msub></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>i</mi><mo>⊗</mo><mi>a</mi><mo>→</mo><mi>a</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>ρ</mi><mi>a</mi></msub></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>a</mi><mo>⊗</mo><mi>i</mi><mo>→</mo><mi>a</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\alpha_{a b c} &amp;\Colon (a \otimes b) \otimes c \to a \otimes (b \otimes c) \\
\lambda_a &amp;\Colon i \otimes a \to a \\
\rho_a &amp;\Colon a \otimes i \to a
\end{aligned}
</annotation></semantics></math>
を備えた圏である（上記に加えて四項のテンソル積を単純化するためのコヒーレンス条件
(coherence condition) も存在する<a href="#fn136" class="footnote-ref"
id="fnref136" role="doc-noteref"><sup>136</sup></a>。）</p>
<p>重要なのは、よく知られた多くの双関手がテンソル積として記述できることだ。特に、積、余積、そしてすぐ後でみるように自己関手の合成（そしてDay
convolutionのようなより深遠な積）がそのような例だ。そして、モノイダル圏は豊穣圏の定式化において不可欠な役割を果たすことになる。</p>
<aside id="footnotes-70" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="133">
<li
id="fn133"><p>訳注：associatorは結合子や結合律子とも訳されるが、本書では結合する順序を入れ替える働きに注目してこのように訳した。<a
href="#fnref133" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn134"><p>訳注：unitorは単位子や単位律子とも訳されるが、本書では単位との積を取っていることを示すためにこのように訳した。<a
href="#fnref134" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn135"><p>訳注：モノイダル圏に伴うテンソル積はモノイダル積
(monoidal product) とも呼ばれる。<a href="#fnref135"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn136"><p>訳注：第28章2節の五角図式を参照。<a href="#fnref136"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="22.2" id="モノイダル圏におけるモノイド"><span
class="header-section-number">22.2</span>
モノイダル圏におけるモノイド</h2>
<p>さて、モノイダル圏という、より一般的な設定においてモノイドを定義する準備が整った。対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>を選択することから始める。ここで、テンソル積を使えば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>の冪乗を形成できる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>の2乗は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>⊗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m \otimes m</annotation></semantics></math>だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>の3乗を形成する方法は2つあるが、それらは結合切替子を通じて同型だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>のより高次の冪乗についても同様だ（そこではコヒーレンス条件が必要になる）。モノイドをなすには2つの射を選ぶ必要がある。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>μ</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>m</mi><mo>⊗</mo><mi>m</mi><mo>→</mo><mi>m</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>η</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>i</mi><mo>→</mo><mi>m</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\mu &amp;\Colon m \otimes m \to m \\
\eta &amp;\Colon i \to m
\end{aligned}
</annotation></semantics></math>
ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>はテンソル積の単位対象だ。</p>
<p> <img src="images/monoid-1.jpg" style="width:40.0%" /> </p>
<p>
これらの射は結合律および単位律を満たさなければならない。それらは以下の可換図式で表せる。</p>
<p> <img src="images/assoctensor.jpg" style="width:50.0%" /> </p>
<p> <img src="images/unitmon.jpg" style="width:50.0%" /> </p>
<p>
ここではテンソル積が双関手であることが極めて重要だ。それは、積を作るには<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>⊗</mo><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow></mrow><annotation encoding="application/x-tex">\mu \otimes \mathbf{id}</annotation></semantics></math>や<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>⊗</mo><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow></mrow><annotation encoding="application/x-tex">\eta \otimes \mathbf{id}</annotation></semantics></math>のように射のペアを持ち上げる必要があるからだ。これらの図式は、圏論的な積に関するこれまでの結果の直截の一般化にすぎない。</p>
<h2 data-number="22.3" id="モノイドとしてのモナド"><span
class="header-section-number">22.3</span> モノイドとしてのモナド</h2>
<p>モノイドの構造は思いがけないところに現れる。その1つが関手圏だ。少し目を細めれば、関手の合成が積の一種に見えてくるだろう。問題は、2つの関手は合成できるとは限らないことだ――一方にとっての行き先となる圏が他方にとってのもととなる圏でなければならない。これは射の合成についてのいつもの規則に他ならない――そして、すでに知っているとおり、関手はまさに圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>内の射だった。ただし、自己射（同じ対象にループバックする射）と同様に自己関手も常に合成可能だ。任意の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>への自己関手は関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}\mathbf{C}, \mathbf{C}{]}</annotation></semantics></math>をなす。その対象は自己関手であり、射はそれらの間の自然変換だ。この圏から任意の2つの対象（自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>とする）を選び、もうひとつの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∘</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F \circ G</annotation></semantics></math>――それらを合成した自己関手――を得られる。</p>
<p>自己関手の合成はテンソル積の良い候補だろうか？　まず、それが双関手だと示さなければならない。それを使って射――ここでは自然変換――のペアを持ち上げられるだろうか？　テンソル積について<code>bimap</code>に相当するもののシグネチャーは次のようになるだろう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑏</mi><mi>𝑖</mi><mi>𝑚</mi><mi>𝑎</mi><mi>𝑝</mi></mrow><mo>∷</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>→</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>→</mo><mi>d</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>⊗</mo><mi>c</mi><mo>→</mo><mi>b</mi><mo>⊗</mo><mi>d</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{bimap} \Colon (a \to b) \to (c \to d) \to (a \otimes c \to b \otimes d)</annotation></semantics></math>
対象を自己関手で、矢印を自然変換で、テンソル積を合成で置き換えると次が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mo>→</mo><msup><mi>F</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>G</mi><mo>→</mo><msup><mi>G</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mo>∘</mo><mi>G</mi><mo>→</mo><msup><mi>F</mi><mo>′</mo></msup><mo>∘</mo><msup><mi>G</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(F \to F&#39;) \to (G \to G&#39;) \to (F \circ G \to F&#39; \circ G&#39;)</annotation></semantics></math>
これは、水平合成の特殊なケースだと見なせる。</p>
<p> <img src="images/horizcomp.png" style="width:40.0%" /> </p>
<p>
また、恒等自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>も自由に使える。これは自己関手の合成――新しいテンソル積――の単位として機能する。そのうえ、関手の合成は結合的だ。事実、結合律と単位律は厳密だ――結合切替子や2つの単位積子は必要ない。したがって、自己関手は関手合成をテンソル積として伴う厳密モノイダル圏をなす。</p>
<p>この圏でのモノイドとは何だろう？　それは対象――自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>と、次のような2つの射――自然変換だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>μ</mi><mo>∷</mo><mi>T</mi><mo>∘</mo><mi>T</mi><mo>→</mo><mi>T</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>η</mi><mo>∷</mo><mi>I</mi><mo>→</mo><mi>T</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
\mu \Colon T \circ T \to T \\
\eta \Colon I \to T
\end{gathered}
</annotation></semantics></math> それだけでなく、モノイド則もある。</p>
<p> <img src="images/assoc.png" style="width:40.0%" /> </p>
<p> <img src="images/unitlawcomp.png" style="width:50.0%" /> </p>
<p>
これらはいままで見てきたモナド則そのものだ。これでソーンダーズ・マックレーンの有名な言葉<a
href="#fn137" class="footnote-ref" id="fnref137"
role="doc-noteref"><sup>137</sup></a>が理解できるだろう。</p>
<blockquote>
<p>端的に言えば、モナドは自己関手からなる圏におけるモノイドに他ならない。</p>
</blockquote>
<p>これが関数プログラミングのカンファレンスでTシャツにプリントされているのを見たことがあるかもしれない
<a href="#fn138" class="footnote-ref" id="fnref138"
role="doc-noteref"><sup>138</sup></a> <a href="#fn139"
class="footnote-ref" id="fnref139"
role="doc-noteref"><sup>139</sup></a>。</p>
<aside id="footnotes-71" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="137">
<li id="fn137"><p>訳注：『圏論の基礎』第VI章1節から一部を略して引用。<a
href="#fnref137" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn138"><p>訳注：しばしば「モナドは単なる自己関手の圏におけるモノイドだよ。何か問題でも？」という形でPhilip
Wadlerが言ったとされるが、実際はJames Iryのブログにおけるジョーク記事 <a
href="https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html"
class="uri">https://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html</a>
が初出。Wadler本人がそのように発言した記録はなく、あくまでマックレーンの言葉をパロディ化したものである。<a
href="#fnref138" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn139"><p>監訳注：少なくとも監訳者の勝手な印象では、こうした内輪ノリは昨今ではだいぶ鳴りを潜めているように思われる。<a
href="#fnref139" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="22.4" id="随伴に基づくモナド"><span
class="header-section-number">22.4</span> 随伴に基づくモナド</h2>
<p><a
href="#adjunctions">随伴</a><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊣</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \dashv R</annotation></semantics></math>（第18章を参照）は2つの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の間を行き来する一対の関手だ。それらを合成する方法は2つあり、それぞれ2つの自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R \circ L</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \circ R</annotation></semantics></math>が得られる。随伴の定義によると、これらの自己関手は単位と余単位と呼ばれる2つの自然変換を通じて恒等関手と関係している。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>η</mi><mo>∷</mo><msub><mi>I</mi><mi>𝐃</mi></msub><mo>→</mo><mi>R</mi><mo>∘</mo><mi>L</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>ε</mi><mo>∷</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo>→</mo><msub><mi>I</mi><mi>𝐂</mi></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
\eta \Colon I_{\mathbf{D}} \to R \circ L \\
\varepsilon \Colon L \circ R \to I_{\mathbf{C}}
\end{gathered}
</annotation></semantics></math>
すぐに、随伴の単位はモナドの単位にそっくりだということが見て取れる。実は、自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R \circ L</annotation></semantics></math>は本当にモナドなのだ。必要なのは、あとは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>に対応する適切な<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>を定義することだけだ。これは自己関手の2乗と自己関手自体との間の自然変換であり、随伴関手の言葉で書くと次のように表される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo>→</mo><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R \circ L \circ R \circ L \to R \circ L</annotation></semantics></math>
そして、実際、余単位を使えば真ん中の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \circ R</annotation></semantics></math>を潰せる。正確には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>は水平合成で与えられる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mi>R</mi><mo>∘</mo><mi>ε</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\mu = R \circ \varepsilon \circ L</annotation></semantics></math>
モナド則は、随伴の単位と余単位が満たす恒等図式<a href="#fn140"
class="footnote-ref" id="fnref140"
role="doc-noteref"><sup>140</sup></a>と、 相互交換法則<a href="#fn141"
class="footnote-ref" id="fnref141"
role="doc-noteref"><sup>141</sup></a>から導かれる。</p>
<p>随伴から派生したモナドをHaskellであまり見かけないのは、随伴には通常2つの圏が関わるからだ。ただし、冪すなわち関数対象の定義は例外だ。この随伴は次の2つの自己関手から形成される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>L</mi><mi>z</mi><mo>=</mo><mi>z</mi><mo>×</mo><mrow></mrow><mi>s</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>R</mi><mi>b</mi><mo>=</mo><mi>s</mi><mo>⇒</mo><mi>b</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
L z = z\times{}s \\
R b = s \Rightarrow b
\end{gathered}
</annotation></semantics></math>
これらを合成するとお馴染みのstateモナドになるのが分かるだろう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo stretchy="false" form="prefix">(</mo><mi>L</mi><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>s</mi><mo>⇒</mo><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo>×</mo><mrow></mrow><mi>s</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">R (L z) = s \Rightarrow (z\times{}s)</annotation></semantics></math>
このモナドは以前Haskellで見たことがある。</p>
<div class="sourceCode" id="cb458"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb458-1"><a href="#cb458-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> (s <span class="ot">-&gt;</span> (a, s))</span></code></pre></div>
<p> もとの随伴もHaskellに翻訳してみよう。左関手は積関手だ。</p>
<div class="sourceCode" id="cb459"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb459-1"><a href="#cb459-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Prod</span> s a <span class="ot">=</span> <span class="dt">Prod</span> (a, s)</span></code></pre></div>
<p> そして右関手はreader関手だ。</p>
<div class="sourceCode" id="cb460"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb460-1"><a href="#cb460-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Reader</span> s a <span class="ot">=</span> <span class="dt">Reader</span> (s <span class="ot">-&gt;</span> a)</span></code></pre></div>
<p> これらは随伴をなす。</p>
<div class="sourceCode" id="cb461"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb461-1"><a href="#cb461-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Adjunction</span> (<span class="dt">Prod</span> s) (<span class="dt">Reader</span> s) <span class="kw">where</span></span>
<span id="cb461-2"><a href="#cb461-2" aria-hidden="true" tabindex="-1"></a>  counit (<span class="dt">Prod</span> (<span class="dt">Reader</span> f, s)) <span class="ot">=</span> f s</span>
<span id="cb461-3"><a href="#cb461-3" aria-hidden="true" tabindex="-1"></a>  unit a <span class="ot">=</span> <span class="dt">Reader</span> (\s <span class="ot">-&gt;</span> <span class="dt">Prod</span> (a, s))</span></code></pre></div>
<p>
ここで、reader関手を積関手の後に合成したものが実際にstate関手と等価なのは簡単に確認できる。</p>
<div class="sourceCode" id="cb462"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb462-1"><a href="#cb462-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> (s <span class="ot">-&gt;</span> (a, s))</span></code></pre></div>
<p>
予想どおり、随伴の<code>unit</code>はstateモナドの<code>return</code>関数と等価だ。また、<code>counit</code>は、その引数に作用する関数を評価することによって作用する<a
href="#fn142" class="footnote-ref" id="fnref142"
role="doc-noteref"><sup>142</sup></a>。これは、<code>runState</code>関数</p>
<div class="sourceCode" id="cb463"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb463-1"><a href="#cb463-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb463-2"><a href="#cb463-2" aria-hidden="true" tabindex="-1"></a>runState (<span class="dt">State</span> f) s <span class="ot">=</span> f s</span></code></pre></div>
<p> の非カリー化版として認識可能だ<a href="#fn143" class="footnote-ref"
id="fnref143"
role="doc-noteref"><sup>143</sup></a>（非カリー化する理由は、<code>counit</code>はペアに作用するからだ）。</p>
<p>ここでstateモナドの<code>join</code>を自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>の成分として定義できる。そのためには3つの自然変換を水平合成したものが必要だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mi>R</mi><mo>∘</mo><mi>ε</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\mu = R \circ \varepsilon \circ L</annotation></semantics></math>
言い換えると、余単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>をreader関手を1レベル超えて忍び込ませる必要がある。単に<code>fmap</code>を直接呼び出すことはできない。なぜなら、コンパイラーが<code>Reader</code>関手のものではなく<code>State</code>関手のものを選択するだろうからだ。だが、reader関手の<code>fmap</code>は左関数合成にすぎないことを思い出してほしい。そのため、関数合成を直接使うことにする。</p>
<p>まず、データ構成子<code>State</code>を一皮剥くことで<code>State</code>関手内の関数をあらわにする必要がある。これは<code>runState</code>を使えばできる。</p>
<div class="sourceCode" id="cb464"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb464-1"><a href="#cb464-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ssa ::</span> <span class="dt">State</span> s (<span class="dt">State</span> s a)</span>
<span id="cb464-2"><a href="#cb464-2" aria-hidden="true" tabindex="-1"></a>runState<span class="ot"> ssa ::</span> s <span class="ot">-&gt;</span> (<span class="dt">State</span> s a, s)</span></code></pre></div>
<p>
次に、<code>uncurry runState</code>によって定義される余単位に左合成する。最後に、<code>State</code>データ構成子で包み直す。</p>
<div class="sourceCode" id="cb465"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb465-1"><a href="#cb465-1" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> <span class="dt">State</span> s (<span class="dt">State</span> s a) <span class="ot">-&gt;</span> <span class="dt">State</span> s a</span>
<span id="cb465-2"><a href="#cb465-2" aria-hidden="true" tabindex="-1"></a>join ssa <span class="ot">=</span> <span class="dt">State</span> (<span class="fu">uncurry</span> runState <span class="op">.</span> runState ssa)</span></code></pre></div>
<p>
これはまさに<code>State</code>モナドのための<code>join</code>の実装だ<a
href="#fn144" class="footnote-ref" id="fnref144"
role="doc-noteref"><sup>144</sup></a>。</p>
<p>実は、あらゆる随伴からモナドが生じるだけでなく、逆もまた真である。あらゆるモナドは随伴関手2つの合成に分解できる。ただし、そのような分解は一意ではない。</p>
<p>もう一方の自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \circ R</annotation></semantics></math>については次章で述べる。</p>
<aside id="footnotes-72" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="140">
<li id="fn140"><p>訳注：第18章1節の三角恒等式を参照。<a href="#fnref140"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn141"><p>訳注：第10章4節の後半を参照。<a href="#fnref141"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn142"><p>訳注：<code>f</code>は<code>counit</code>の引数<code>s</code>に作用する関数であり、それを評価することで<code>a</code>の値を得る、というのが<code>counit</code>の作用。<a
href="#fnref142" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn143"><p>訳注：型構成子を取り払うと<code>counit :: (s -&gt; a, s) -&gt; a</code>と<code>uncurry runState :: (s -&gt; (a, s), s) -&gt; (a, s)</code>となり、<code>uncurry runstate</code>は<code>counit</code>のインスタンスだと見なせる。このインスタンスは後述の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\varepsilon \circ L</annotation></semantics></math>に対応しているので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>の構成についての議論にはこちらを用いるので十分である。<a
href="#fnref143" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn144"><p>訳注：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mi>R</mi><mo>∘</mo><mi>ε</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\mu = R \circ \varepsilon \circ L</annotation></semantics></math>とは以下のように対応している。</p>
<ul>
<li><code>runState ssa</code>は左関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>が<code>T(T x)</code>
の内側の<code>T</code>を適用する部分</li>
<li><code>uncurry runState</code>は随伴の余単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math></li>
<li><code>State (...)</code>
は右関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>が最終結果を<code>T x</code>の形に整える部分</li>
</ul>
<a href="#fnref144" class="footnote-back" role="doc-backlink">↩︎</a></li>
</ol>
</aside>
<h1 data-number="23" id="comonads"><span
class="header-section-number">23</span> コモナド</h1>
<p>これでモナドについてはカバーできたので、双対性の恩恵によって、射を逆にして反対圏で作業するだけでコモナドを無料で手に入れられる。</p>
<p>最も基本的なレベルでは、モナドはクライスリ射の合成についてのものであったのを思い出してほしい。</p>
<div class="sourceCode" id="cb466"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb466-1"><a href="#cb466-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>
ここで<code>m</code>はモナドである関手だ。コモナドを文字<code>w</code>（逆さの<code>m</code>）で表すと、余クライスリ射
(co-Kleisli arrow) を次の型の射として定義できる。</p>
<div class="sourceCode" id="cb467"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb467-1"><a href="#cb467-1" aria-hidden="true" tabindex="-1"></a>w a <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>
余クライスリ射についてfish演算子に相当するものは次のように定義される。</p>
<div class="sourceCode" id="cb468"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb468-1"><a href="#cb468-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(=&gt;=) ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (w b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (w a <span class="ot">-&gt;</span> c)</span></code></pre></div>
<p>
余クライスリ射が圏をなすには<code>extract</code>と呼ばれる恒等余クライスリ射も必要となる。</p>
<div class="sourceCode" id="cb469"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb469-1"><a href="#cb469-1" aria-hidden="true" tabindex="-1"></a><span class="ot">extract ::</span> w a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>
これは<code>return</code>の双対だ。さらに、<code>extract</code>が左恒等射かつ右恒等射であることだけでなく、結合律も必須だ。すべてをまとめると、Haskellではコモナドを次のように定義できるように思われる。</p>
<div class="sourceCode" id="cb470"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb470-1"><a href="#cb470-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> w <span class="ot">=&gt;</span> <span class="dt">Comonad</span> w <span class="kw">where</span></span>
<span id="cb470-2"><a href="#cb470-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (=&gt;=) ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (w b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (w a <span class="ot">-&gt;</span> c)</span>
<span id="cb470-3"><a href="#cb470-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    extract ::</span> w a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>
実用上は、後で説明するように、わずかに異なるプリミティブが使われる。</p>
<p>問題は、コモナドがプログラミングでどのように使われるかだ。</p>
<h2 data-number="23.1" id="コモナドによるプログラミング"><span
class="header-section-number">23.1</span>
コモナドによるプログラミング</h2>
<p>モナドとコモナドを比べてみよう。モナドはコンテナーに値を入れる手段を<code>return</code>によって提供している。しかし、内部に格納された値にアクセスする手段は提供しない。もちろんモナドを実装するデータ構造は内容へのアクセスを提供する場合もあるかもしれないが、それはおまけと見なされる。モナドから値を抽出するための共通したインターフェイスはない。そして、内容を決して公開しないことを誇りにしている<code>IO</code>モナドという例を我々はすでに見た。</p>
<p>一方、コモナドは値をひとつ取り出す手段を提供している。しかし、値を入れる手段は提供しない。コモナドをコンテナーと見なすとしたら、それは中身がいつも事前に満たされていて、覗き見られるようになっているようなコンテナーだ。</p>
<p>クライスリ射は値を受け取り、文脈で装飾した結果を生成する。同様に、余クライスリ射は文脈全体と共に値を受け取り、結果を生成する。これは<span
id="contextual_computation" class="keyword"><em>文脈付き計算</em></span>
(contextual computation) の実施例だ。</p>
<h2 data-number="23.2" id="積コモナド"><span
class="header-section-number">23.2</span> 積コモナド</h2>
<p>Readerモナドを覚えているだろうか？　それを導入した理由は、何らかの読み取り専用の環境<code>e</code>へのアクセスを必要とする計算を実装する問題に取り組むためだった。そのような計算は純粋関数として次の形で表せる。</p>
<div class="sourceCode" id="cb471"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb471-1"><a href="#cb471-1" aria-hidden="true" tabindex="-1"></a>(a, e) <span class="ot">-&gt;</span> b</span></code></pre></div>
<p> それらをクライスリ射に変えるのにはカリー化を使った。</p>
<div class="sourceCode" id="cb472"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb472-1"><a href="#cb472-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> b)</span></code></pre></div>
<p>
しかし、この関数がすでに余クライスリ射の形をしていることに注目してほしい。引数をもっと便利な関手の形式</p>
<div class="sourceCode" id="cb473"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb473-1"><a href="#cb473-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Product</span> e a <span class="ot">=</span> <span class="dt">Prod</span> e a <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>
に書き換えてみよう。合成演算子は簡単に定義できる。合成しようとしている射でも同じ環境を使えるようにすればよい。</p>
<div class="sourceCode" id="cb474"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb474-1"><a href="#cb474-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">=&gt;=</span>) <span class="ot">::</span></span>
<span id="cb474-2"><a href="#cb474-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Product</span> e a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span></span>
<span id="cb474-3"><a href="#cb474-3" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Product</span> e b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span></span>
<span id="cb474-4"><a href="#cb474-4" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Product</span> e a <span class="ot">-&gt;</span> c)</span>
<span id="cb474-5"><a href="#cb474-5" aria-hidden="true" tabindex="-1"></a>f <span class="op">=&gt;=</span> g <span class="ot">=</span> \(<span class="dt">Prod</span> e a) <span class="ot">-&gt;</span> <span class="kw">let</span> b <span class="ot">=</span> f (<span class="dt">Prod</span> e a)</span>
<span id="cb474-6"><a href="#cb474-6" aria-hidden="true" tabindex="-1"></a>                             c <span class="ot">=</span> g (<span class="dt">Prod</span> e b)</span>
<span id="cb474-7"><a href="#cb474-7" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">in</span> c</span></code></pre></div>
<p> <code>extract</code>の実装は環境を単に無視する。</p>
<div class="sourceCode" id="cb475"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb475-1"><a href="#cb475-1" aria-hidden="true" tabindex="-1"></a>extract (<span class="dt">Prod</span> e a) <span class="ot">=</span> a</span></code></pre></div>
<p>
驚くまでもなく、積コモナドではreaderモナドと全く同じ計算が実行できる。ある意味で、環境をコモナドで実装するのはより自然だ――「文脈付き計算」の精神に則っている。一方、モナドは<code>do</code>記法という便利な糖衣構文を備えている。</p>
<p>readerモナドと積コモナドの関係はさらに深く、reader関手が積関手の右随伴であるという事実に関連している。しかし、一般的には、コモナドはモナドとは異なる計算の概念を扱う。さらなる例について後で説明する。</p>
<p>積コモナド<code>Product</code>は、組やレコードを含む任意の直積型へ簡単に一般化できる。</p>
<h2 data-number="23.3" id="合成の分析"><span
class="header-section-number">23.3</span> 合成の分析</h2>
<p>双対化のプロセスを続けることで、さらに進めてモナド的なbindとjoinを直接双対化することも可能かもしれない。その代わりに、それらを得るためにモナドで用いたプロセスを繰り返すこともできる。そこではfish演算子の解剖学を研究した。そのアプローチの方が啓発的に思える。</p>
<p>出発点は、合成演算子は<code>w a</code>を取り<code>c</code>を生成する余クライスリ射を生成しなければならないという認識だ。<code>c</code>を生成する唯一の方法は、第2の関数を型<code>w b</code>の引数に適用することだ。</p>
<div class="sourceCode" id="cb476"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb476-1"><a href="#cb476-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(=&gt;=) ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (w b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (w a <span class="ot">-&gt;</span> c)</span>
<span id="cb476-2"><a href="#cb476-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">=&gt;=</span> g <span class="ot">=</span> g <span class="op">...</span></span></code></pre></div>
<p>
だが、<code>g</code>に与えうる型<code>w b</code>の値はどうすれば生成できるだろうか？　型<code>w a</code>の引数と関数<code>f :: w a -&gt; b</code>は自由に使える。答えはbindの双対を定義することだ。それはextendと呼ばれる。</p>
<div class="sourceCode" id="cb477"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb477-1"><a href="#cb477-1" aria-hidden="true" tabindex="-1"></a><span class="ot">extend ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</span></code></pre></div>
<p> <code>extend</code>を使えば合成を実装できる。</p>
<div class="sourceCode" id="cb478"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb478-1"><a href="#cb478-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">=&gt;=</span> g <span class="ot">=</span> g <span class="op">.</span> extend f</span></code></pre></div>
<p>
次は<code>extend</code>を解剖できるだろうか？　なぜ単に関数<code>w a -&gt; b</code>を引数<code>w a</code>に適用しないのか、と言いたくなるかもしれない。しかし、結果として得られる<code>b</code>を<code>w b</code>に変換する方法がないことにすぐ気付くだろう。コモナドは値を持ち上げる手段を提供しないことを思い出してほしい。この時点で、モナドについての類似した構成では<code>fmap</code>を用いていた。ここで<code>fmap</code>が使えるとすれば、型<code>w (w a)</code>の何かが自由に使える場合だけだ。<code>w a</code>を<code>w (w a)</code>に変えられさえすればよい。そして、便利なことに、それはまさに<code>join</code>の双対であればよい。それは<code>duplicate</code>と呼ばれる。</p>
<div class="sourceCode" id="cb479"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb479-1"><a href="#cb479-1" aria-hidden="true" tabindex="-1"></a><span class="ot">duplicate ::</span> w a <span class="ot">-&gt;</span> w (w a)</span></code></pre></div>
<p>
したがって、モナドと同様に、コモナドにも3つの等価な定義がある。すなわち、余クライスリ射によるものと、<code>extend</code>によるものと、<code>duplicate</code>によるものだ。Haskellの<code>Control.Comonad</code>ライブラリーから直接引用した定義を以下に示す。</p>
<div class="sourceCode" id="cb480"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb480-1"><a href="#cb480-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> w <span class="ot">=&gt;</span> <span class="dt">Comonad</span> w <span class="kw">where</span></span>
<span id="cb480-2"><a href="#cb480-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  extract ::</span> w a <span class="ot">-&gt;</span> a</span>
<span id="cb480-3"><a href="#cb480-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  duplicate ::</span> w a <span class="ot">-&gt;</span> w (w a)</span>
<span id="cb480-4"><a href="#cb480-4" aria-hidden="true" tabindex="-1"></a>  duplicate <span class="ot">=</span> extend <span class="fu">id</span></span>
<span id="cb480-5"><a href="#cb480-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  extend ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</span>
<span id="cb480-6"><a href="#cb480-6" aria-hidden="true" tabindex="-1"></a>  extend f <span class="ot">=</span> <span class="fu">fmap</span> f <span class="op">.</span> duplicate</span></code></pre></div>
<p>
<code>extend</code>のデフォルト実装が<code>duplicate</code>によって提供され、逆も同様だ。したがって、どちらか1つをオーバーライドするだけでよい。</p>
<p>これらの関数の背景にある直観は、一般にコモナドは型<code>a</code>の値で満たされたコンテナーと見なせるという考えに基づいている（積コモナドは値が1つしかない特殊なケースだ）。「現在の」値という概念があり、それは<code>extract</code>によって簡単にアクセスできる。余クライスリ射は現在の値に焦点を合わせて計算を実行するものの、周囲のすべての値にアクセスできる。コンウェイのライフゲームを考えてみてほしい。各セルには値（通常は単に<code>True</code>か<code>False</code>）が含まれる。ライフゲームに対応するコモナドは「現在の」セルに焦点が合っているようなセルのグリッドになるだろう。</p>
<p>では<code>duplicate</code>は何をするのだろう？　それはコモナド的なコンテナー<code>w a</code>を取ってコンテナーのコンテナー<code>w (w a)</code>を生成する。つまり、それぞれのコンテナーが<code>w a</code>内部の異なる<code>a</code>に焦点を合わせているという考え方だ。ライフゲームでは、グリッドのグリッドが得られる。外側のグリッドの各セルには、個別のセルに焦点を合わせた内側のグリッドが含まれている。</p>
<p>次に<code>extend</code>を見てみよう。それは、余クライスリ射と、複数の<code>a</code>で満たされたコモナド的コンテナー<code>w a</code>を取る。そして、すべての<code>a</code>に計算を適用して<code>b</code>に置き換える。結果は複数の<code>b</code>で満たされたコモナド的コンテナーとなる。これを実現するために<code>extend</code>は焦点を合わせる<code>a</code>を次々にシフトしていき、それぞれに余クライスリ射を適用する。ライフゲームでは、余クライスリ射は現在のセルの新しい状態を計算する。そのために文脈（すなわち最近傍セル）に注目する。<code>extend</code>のデフォルト実装はこの過程を示している。まず<code>duplicate</code>を呼び出して可能な焦点をすべて生成し、次にそのそれぞれに<code>f</code>を適用する。</p>
<h2 data-number="23.4" id="streamコモナド"><span
class="header-section-number">23.4</span> Streamコモナド</h2>
<p>コンテナー内で焦点を合わせる要素を次々にシフトしていくこのプロセスを最もうまく説明できる例は無限ストリームだ。そういったストリームはリストにそっくりだが、空のコンストラクターがない点で異なる。</p>
<div class="sourceCode" id="cb481"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb481-1"><a href="#cb481-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stream</span> a <span class="ot">=</span> <span class="dt">Cons</span> a (<span class="dt">Stream</span> a)</span></code></pre></div>
<p> これが<code>Functor</code>であるのは自明だ。</p>
<div class="sourceCode" id="cb482"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb482-1"><a href="#cb482-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Stream</span> <span class="kw">where</span></span>
<span id="cb482-2"><a href="#cb482-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Cons</span> a as) <span class="ot">=</span> <span class="dt">Cons</span> (f a) (<span class="fu">fmap</span> f as)</span></code></pre></div>
<p>
ストリームの焦点はその最初の要素なので、<code>extract</code>の実装は次のようになる。</p>
<div class="sourceCode" id="cb483"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb483-1"><a href="#cb483-1" aria-hidden="true" tabindex="-1"></a>extract (<span class="dt">Cons</span> a _) <span class="ot">=</span> a</span></code></pre></div>
<p>
<code>duplicate</code>は、それぞれ異なる要素に焦点を合わせた複数のストリームからなるストリームを1つ生成する。</p>
<div class="sourceCode" id="cb484"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb484-1"><a href="#cb484-1" aria-hidden="true" tabindex="-1"></a>duplicate (<span class="dt">Cons</span> a as) <span class="ot">=</span> <span class="dt">Cons</span> (<span class="dt">Cons</span> a as) (duplicate as)</span></code></pre></div>
<p>
1番目の要素はもとのストリーム、2番目の要素はもとのストリームのtail、3番目の要素はさらにそのtail、というように無限に続く。</p>
<p>完全なインスタンス宣言を以下に示す。</p>
<div class="sourceCode" id="cb485"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb485-1"><a href="#cb485-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Comonad</span> <span class="dt">Stream</span> <span class="kw">where</span></span>
<span id="cb485-2"><a href="#cb485-2" aria-hidden="true" tabindex="-1"></a>    extract (<span class="dt">Cons</span> a _) <span class="ot">=</span> a</span>
<span id="cb485-3"><a href="#cb485-3" aria-hidden="true" tabindex="-1"></a>    duplicate (<span class="dt">Cons</span> a as) <span class="ot">=</span> <span class="dt">Cons</span> (<span class="dt">Cons</span> a as) (duplicate as)</span></code></pre></div>
<p>
これは非常に関数的な観点でのストリームの捉え方だ。命令型言語なら、ストリームを1要素だけシフトするような<code>advance</code>メソッドから始めただろう。しかし、ここでの<code>duplicate</code>はシフトされたすべてのストリームを一気に生成する。Haskellの遅延評価がこれを可能にし、望ましいものにさえしている。もちろん、<code>Stream</code>を実用的なものにするために、<code>advance</code>に類似したものも実装しよう。</p>
<div class="sourceCode" id="cb486"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb486-1"><a href="#cb486-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span><span class="ot"> ::</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> a</span>
<span id="cb486-2"><a href="#cb486-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span> (<span class="dt">Cons</span> a as) <span class="ot">=</span> as</span></code></pre></div>
<p> ただし、これはコモナドのインターフェイスの一部では決してない。</p>
<p>デジタル信号処理の経験があればすぐ分かるとおり、ストリームについての余クライスリ射は単なるデジタルフィルターであり、<code>extend</code>はフィルターされたストリームを生成する。</p>
<p>簡単な例として、移動平均フィルターを実装してみよう。ストリームの<code>n</code>個の要素を合計する関数はこう書ける。</p>
<div class="sourceCode" id="cb487"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb487-1"><a href="#cb487-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sumS ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb487-2"><a href="#cb487-2" aria-hidden="true" tabindex="-1"></a>sumS n (<span class="dt">Cons</span> a as) <span class="ot">=</span> <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> a <span class="op">+</span> sumS (n <span class="op">-</span> <span class="dv">1</span>) as</span></code></pre></div>
<p>
そして、ストリームの最初から<code>n</code>個の要素の平均を計算する関数はこう書ける。</p>
<div class="sourceCode" id="cb488"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb488-1"><a href="#cb488-1" aria-hidden="true" tabindex="-1"></a><span class="ot">average ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb488-2"><a href="#cb488-2" aria-hidden="true" tabindex="-1"></a>average n stm <span class="ot">=</span> (sumS n stm) <span class="op">/</span> (<span class="fu">fromIntegral</span> n)</span></code></pre></div>
<p>
部分適用された<code>average n</code>は余クライスリ射なので、ストリーム全体に<code>extend</code>できる。</p>
<div class="sourceCode" id="cb489"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb489-1"><a href="#cb489-1" aria-hidden="true" tabindex="-1"></a><span class="ot">movingAvg ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> a</span>
<span id="cb489-2"><a href="#cb489-2" aria-hidden="true" tabindex="-1"></a>movingAvg n <span class="ot">=</span> extend (average n)</span></code></pre></div>
<p> 結果は移動平均のストリームとなる。</p>
<p>ストリームは単方向1次元コモナドの例だ。これは簡単に双方向にしたり多次元に拡張したりできる。</p>
<h2 data-number="23.5" id="圏論から見たコモナド"><span
class="header-section-number">23.5</span> 圏論から見たコモナド</h2>
<p>圏論でコモナドを定義することは双対性についての簡単な練習問題になる。モナドと同様に、自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>から始めることにする。モナドを定義する2つの自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>は、コモナドでは単に反転される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>ε</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>T</mi><mo>→</mo><mi>I</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>δ</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>T</mi><mo>→</mo><msup><mi>T</mi><mn>2</mn></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\varepsilon &amp;\Colon T \to I \\
\delta &amp;\Colon T \to T^2
\end{aligned}
</annotation></semantics></math>
これらの変換の成分は、<code>extract</code>および<code>duplicate</code>に対応する。コモナド則は鏡に映ったモナド則だ。驚くまでもない。</p>
<p>そして、モナドは随伴から導出できる。双対性は随伴を反転させる。つまり、左随伴と右随伴が入れ替わる。また、合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R \circ L</annotation></semantics></math>がモナドを定義するので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \circ R</annotation></semantics></math>はコモナドを定義するに違いない。随伴の余単位
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>∷</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">\varepsilon \Colon L \circ R \to I</annotation></semantics></math>
は、コモナドの定義で見たものと同じだ。すなわち、成分で見ればHaskellにおける<code>extract</code>と同じだ。随伴の単位
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>∷</mo><mi>I</mi><mo>→</mo><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\eta \Colon I \to R \circ L</annotation></semantics></math>
も、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \circ R</annotation></semantics></math>の途中に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">R \circ L</annotation></semantics></math>を挿入して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \circ R \circ L \circ R</annotation></semantics></math>を作成するのに使える。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>［訳注：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">= L \circ R</annotation></semantics></math>］から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>T</mi><mn>2</mn></msup><annotation encoding="application/x-tex">T^2</annotation></semantics></math>を作ると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>が定義され、コモナドの定義が完成する。</p>
<p>モナドがモノイドであることもすでに見た。この双対について述べるにはコモノイドを使う必要があるだろうが、ではコモノイドとは何だろう？　モノイドとは単一対象圏であるという当初の定義を双対化しても興味深いものは何も得られない。すべての自己射を逆向きにしても、別のモノイドが得られるだけだ。しかし、思い出してほしい。モナドへのアプローチで用いた定義は、モノイドとはモノイダル圏における対象であるという、より一般化されたものだった。その構成は2つの射に基づいていた。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>μ</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>m</mi><mo>⊗</mo><mi>m</mi><mo>→</mo><mi>m</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>η</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>i</mi><mo>→</mo><mi>m</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\mu &amp;\Colon m \otimes m \to m \\
\eta &amp;\Colon i \to m
\end{aligned}
</annotation></semantics></math>
これらの射を反転させるとモノイダル圏におけるコモノイドができる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>δ</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>m</mi><mo>→</mo><mi>m</mi><mo>⊗</mo><mi>m</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>ε</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>m</mi><mo>→</mo><mi>i</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\delta &amp;\Colon m \to m \otimes m \\
\varepsilon &amp;\Colon m \to i
\end{aligned}
</annotation></semantics></math> コモノイドの定義をHaskellで書くと</p>
<div class="sourceCode" id="cb490"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb490-1"><a href="#cb490-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Comonoid</span> m <span class="kw">where</span></span>
<span id="cb490-2"><a href="#cb490-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  split   ::</span> m <span class="ot">-&gt;</span> (m, m)</span>
<span id="cb490-3"><a href="#cb490-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  destroy ::</span> m <span class="ot">-&gt;</span> ()</span></code></pre></div>
<p>
となるが、むしろ自明なものとなってしまう。明らかに<code>destroy</code>は引数を無視する。</p>
<div class="sourceCode" id="cb491"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb491-1"><a href="#cb491-1" aria-hidden="true" tabindex="-1"></a>destroy _ <span class="ot">=</span> ()</span></code></pre></div>
<p> また、<code>split</code>は単に関数のペアだ。</p>
<div class="sourceCode" id="cb492"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb492-1"><a href="#cb492-1" aria-hidden="true" tabindex="-1"></a>split x <span class="ot">=</span> (f x, g x)</span></code></pre></div>
<p>
ここで、モノイドの単位律と双対関係にあるコモノイド則について考えてみよう。</p>
<div class="sourceCode" id="cb493"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb493-1"><a href="#cb493-1" aria-hidden="true" tabindex="-1"></a>lambda <span class="op">.</span> bimap destroy <span class="fu">id</span> <span class="op">.</span> split <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb493-2"><a href="#cb493-2" aria-hidden="true" tabindex="-1"></a>rho <span class="op">.</span> bimap <span class="fu">id</span> destroy <span class="op">.</span> split <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<p>
ここで、<code>lambda</code>は左単位積子で<code>rho</code>は右単位積子だ
(<a
href="#monads-categorically">モノイダル圏</a>の定義を参照)。定義を代入すると</p>
<div class="sourceCode" id="cb494"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb494-1"><a href="#cb494-1" aria-hidden="true" tabindex="-1"></a>lambda (bimap destroy <span class="fu">id</span> (split x))</span>
<span id="cb494-2"><a href="#cb494-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> lambda (bimap destroy <span class="fu">id</span> (f x, g x))</span>
<span id="cb494-3"><a href="#cb494-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> lambda ((), g x)</span>
<span id="cb494-4"><a href="#cb494-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> g x</span></code></pre></div>
<p>
となり、<code>g = id</code>が示される。同様に、2番目の規則は<code>f = id</code>へと展開される。結論として</p>
<div class="sourceCode" id="cb495"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb495-1"><a href="#cb495-1" aria-hidden="true" tabindex="-1"></a>split x <span class="ot">=</span> (x, x)</span></code></pre></div>
<p>
となり、Haskell（および一般に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>圏）では、どの対象も自明なコモナドだと示される。</p>
<p>幸い、モノイダル圏のなかには、コモノイドを定義することがもっと興味深いものが他にある。そのひとつは自己関手の圏だ。そこで分かることとして、モナドが自己関手からなる圏におけるモノイドであるのと同様に、</p>
<blockquote>
<p>コモナドは自己関手からなる圏におけるコモノイドである。</p>
</blockquote>
<h2 data-number="23.6" id="storeコモナド"><span
class="header-section-number">23.6</span> Storeコモナド</h2>
<p>コモナドのもう1つの重要な例はstateモナドの双対だ。それはcostateコモナド、あるいはstoreコモナドと呼ばれる。</p>
<p>以前、冪を定義する随伴によってstateモナドが生成されるのを見た。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>L</mi><mi>z</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mi>z</mi><mo>×</mo><mrow></mrow><mi>s</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>R</mi><mi>a</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mi>s</mi><mo>⇒</mo><mi>a</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
L z &amp;= z\times{}s \\
R a &amp;= s \Rightarrow a
\end{aligned}
</annotation></semantics></math>
同じ随伴をcostateコモナドを定義するのに使うことにしよう。コモナドは合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>∘</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">L \circ R</annotation></semantics></math>によって定義される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false" form="prefix">(</mo><mi>R</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>⇒</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">L (R a) = (s \Rightarrow a)\times{}s</annotation></semantics></math>
これをHaskellに変換するには、<code>Product</code>左関手と<code>Reader</code>右関手との間の随伴から始める。<code>Product</code>を<code>Reader</code>の後に合成するのは次の定義と等価だ。</p>
<div class="sourceCode" id="cb496"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb496-1"><a href="#cb496-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Store</span> s a <span class="ot">=</span> <span class="dt">Store</span> (s <span class="ot">-&gt;</span> a) s</span></code></pre></div>
<p> 対象<code>a</code>におけるこの随伴の余単位は次の射だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mi>a</mi></msub><mo>∷</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>s</mi><mo>⇒</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>s</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">\varepsilon_a \Colon ((s \Rightarrow a)\times{}s) \to a</annotation></semantics></math>
あるいは、Haskellの記法だとこうなる。</p>
<div class="sourceCode" id="cb497"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb497-1"><a href="#cb497-1" aria-hidden="true" tabindex="-1"></a>counit (<span class="dt">Prod</span> (<span class="dt">Reader</span> f, s)) <span class="ot">=</span> f s</span></code></pre></div>
<p> これから<code>extract</code>を得られる。</p>
<div class="sourceCode" id="cb498"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb498-1"><a href="#cb498-1" aria-hidden="true" tabindex="-1"></a>extract (<span class="dt">Store</span> f s) <span class="ot">=</span> f s</span></code></pre></div>
<p> 随伴の単位</p>
<div class="sourceCode" id="cb499"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb499-1"><a href="#cb499-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unit ::</span> a <span class="ot">-&gt;</span> <span class="dt">Reader</span> s (<span class="dt">Product</span> a, s)</span>
<span id="cb499-2"><a href="#cb499-2" aria-hidden="true" tabindex="-1"></a>unit a <span class="ot">=</span> <span class="dt">Reader</span> (\s <span class="ot">-&gt;</span> <span class="dt">Prod</span> (a, s))</span></code></pre></div>
<p> は、部分適用されたデータ構成子として書き直せる。</p>
<div class="sourceCode" id="cb500"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb500-1"><a href="#cb500-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Store</span><span class="ot"> f ::</span> s <span class="ot">-&gt;</span> <span class="dt">Store</span> f s</span></code></pre></div>
<p>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>、すなわち<code>duplicate</code>を以下の水平合成として構成しよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>δ</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo>→</mo><mi>L</mi><mo>∘</mo><mi>R</mi><mo>∘</mo><mi>L</mi><mo>∘</mo><mi>R</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>δ</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mi>L</mi><mo>∘</mo><mi>η</mi><mo>∘</mo><mi>R</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\delta &amp;\Colon L \circ R \to L \circ R \circ L \circ R \\
\delta &amp;= L \circ \eta \circ R
\end{aligned}
</annotation></semantics></math>
一番左の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>越しに<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>をくすねる必要がある。この<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>は<code>Product</code>関手だ。これは、ペアの左側の要素に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>すなわち<code>Store f</code>を作用させることを意味する（これが<code>Product</code>の<code>fmap</code>が行うことだ）。すると、次の結果が得られる。</p>
<div class="sourceCode" id="cb501"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb501-1"><a href="#cb501-1" aria-hidden="true" tabindex="-1"></a>duplicate (<span class="dt">Store</span> f s) <span class="ot">=</span> <span class="dt">Store</span> (<span class="dt">Store</span> f) s</span></code></pre></div>
<p>
（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>の式での<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>は恒等自然変換を表し、成分が恒等射であることを思い出してほしい）。</p>
<p><code>Store</code>コモナドの完全な定義を以下に示す。</p>
<div class="sourceCode" id="cb502"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb502-1"><a href="#cb502-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Comonad</span> (<span class="dt">Store</span> s) <span class="kw">where</span></span>
<span id="cb502-2"><a href="#cb502-2" aria-hidden="true" tabindex="-1"></a>  extract (<span class="dt">Store</span> f s) <span class="ot">=</span> f s</span>
<span id="cb502-3"><a href="#cb502-3" aria-hidden="true" tabindex="-1"></a>  duplicate (<span class="dt">Store</span> f s) <span class="ot">=</span> <span class="dt">Store</span> (<span class="dt">Store</span> f) s</span></code></pre></div>
<p>
<code>Store</code>の<code>Reader</code>の部分は、一般化されたコンテナーに型<code>s</code>の要素をキーにして<code>a</code>が格納されていると見なせる。たとえば、<code>s</code>が<code>Int</code>なら、<code>Reader Int a</code>は<code>a</code>の双方向無限ストリームだ。<code>Store</code>はこのコンテナーとキー型の値とをペアにする。また、たとえば、<code>Reader Int a</code>はある<code>Int</code>とペアになっている。この場合、<code>extract</code>はその整数を使って無限ストリームにインデックスを作成する。<code>Store</code>の2番目の要素は現在位置と見なせる。</p>
<p>この例についてさらに述べると、<code>duplicate</code>は<code>Int</code>でインデックスされた新しい無限ストリームを作成する。このストリームは要素としてストリームを含む。特に、現在位置にはもとのストリームが含まれている。しかし、他の（正負を問わない）<code>Int</code>をキーとして使うと、その新しいインデックスの位置へシフトされたストリームが得られる。</p>
<p>一般に、<code>duplicate</code>された<code>Store</code>に<code>extract</code>が作用すると、もとの<code>Store</code>が生成されることを確認できる（実際、コモナドの恒等律では<code>extract . duplicate = id</code>と規定されている）。</p>
<p><code>Store</code>コモナドは<code>lens</code>ライブラリーの理論的基盤として重要だ<a
href="#fn145" class="footnote-ref" id="fnref145"
role="doc-noteref"><sup>145</sup></a>。概念としては、<code>Store s a</code>のようにコモナドを用いることは、型<code>s</code>をインデックスとしてデータ型<code>a</code>の特定の部分構造に（レンズのように）「焦点を合わせる」という考え方をカプセル化している<a
href="#fn146" class="footnote-ref" id="fnref146"
role="doc-noteref"><sup>146</sup></a>。特に、ある関数の型が</p>
<div class="sourceCode" id="cb503"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb503-1"><a href="#cb503-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> <span class="dt">Store</span> s a</span></code></pre></div>
<p> なら、以下の関数のペアと等価だ。</p>
<div class="sourceCode" id="cb504"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb504-1"><a href="#cb504-1" aria-hidden="true" tabindex="-1"></a><span class="ot">set ::</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb504-2"><a href="#cb504-2" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> a <span class="ot">-&gt;</span> s</span></code></pre></div>
<p>
<code>a</code>が直積型なら、<code>set</code>は、<code>a</code>内の型<code>s</code>のフィールドをセットしつつ変更版の<code>a</code>を返すように実装できる。同様に、<code>get</code>は<code>s</code>フィールドの値を<code>a</code>から読み取るように実装できる。これらの考え方については次章で詳しく説明する。</p>
<aside id="footnotes-73" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="145">
<li id="fn145"><p>監訳注：興味のある読者はRussel O’Connorの “Functor is
to Lens as Applicative is to Biplate: Introducing Multiplate” (<a
href="https://doi.org/10.48550/arXiv.1103.2841"
class="uri">https://doi.org/10.48550/arXiv.1103.2841</a>)
を参照のこと。この論文はWGP
11に採録されたが諸事情により論文集には含まれていない。参考：<a
href="https://r6.ca/blog/20110930T012533Z.html"
class="uri">https://r6.ca/blog/20110930T012533Z.html</a><a
href="#fnref145" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn146"><p>監訳注：一般には部分構造に限定されない。<a
href="#fnref146" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="23.7" id="課題-17"><span
class="header-section-number">23.7</span> 課題</h2>
<ol type="1">
<li><code>Store</code>コモナドを用いてコンウェイのライフゲームを実装せよ。ヒント：<code>s</code>の型は何がよいだろうか？</li>
</ol>
<h1 data-number="24" id="f-代数"><span
class="header-section-number">24</span>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数</h1>
<p>モノイドについて、集合や、単一対象圏や、モノイダル圏の対象としての定式化をすでに見た。この単純な概念からさらにどれだけの果汁を搾り取れるだろうか？</p>
<p>やってみよう。次の関数のペアを持つ集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>としてのモノイドの定義を取り上げる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>μ</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>m</mi><mo>×</mo><mrow></mrow><mi>m</mi><mo>→</mo><mi>m</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>η</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mn>1</mn><mo>→</mo><mi>m</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\mu &amp;\Colon m\times{}m \to m \\
\eta &amp;\Colon 1 \to m
\end{aligned}
</annotation></semantics></math>
ここで、1は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>の終対象――単元集合だ。1つ目の関数は乗算（要素のペアを取って積を返す）を定義し、2つ目の関数は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>から単位元を選択する。これらのシグネチャーを持つ2つの関数ならどれでもモノイドになるわけではない。結合律と単位律という追加の条件を課す必要がある。しかし、それはしばらく忘れて「潜在的なモノイド」について考えてみよう。関数のペアは、2つの関数集合のデカルト積の要素だ。それらの集合が冪対象として表現できるのは知っている。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>μ</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∈</mo><msup><mi>m</mi><mrow><mi>m</mi><mo>×</mo><mrow></mrow><mi>m</mi></mrow></msup></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>η</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∈</mo><msup><mi>m</mi><mn>1</mn></msup></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\mu &amp;\in m^{m\times{}m} \\
\eta &amp;\in m^1
\end{aligned}
</annotation></semantics></math>
これら2つの集合のデカルト積は次のとおりだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>m</mi><mrow><mi>m</mi><mo>×</mo><mrow></mrow><mi>m</mi></mrow></msup><mo>×</mo><mrow></mrow><msup><mi>m</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">m^{m\times{}m}\times{}m^1</annotation></semantics></math>
高校代数（どのデカルト閉圏でも有効）を使えば次のように書き直せる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>m</mi><mrow><mi>m</mi><mo>×</mo><mrow></mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msup><annotation encoding="application/x-tex">m^{m\times{}m + 1}</annotation></semantics></math>
記号
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>+</mi><annotation encoding="application/x-tex">+</annotation></semantics></math>
は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>の余積を表す。これは関数のペアを次のような単一の関数――集合の要素――に置き換えたということだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mrow></mrow><mi>m</mi><mo>+</mo><mn>1</mn><mo>→</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m\times{}m + 1 \to m</annotation></semantics></math>
この関数集合のどの要素も潜在的なモノイドだ。</p>
<p>この定式化の利点は、興味深い一般化を導くことだ。たとえば、この言語を使って群
(group)
を記述するにはどうすればよいだろうか？　群は、モノイドのどの要素に対しても逆元を対応させる関数を追加したものだ。その関数は型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>→</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m \to m</annotation></semantics></math>の関数である。例を挙げると、整数は群を形成し、二項演算として加算、単位元として0、逆として正負反転を持つ。群を定義するには次の3つの関数から始めてもよい。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mi>m</mi><mo>×</mo><mrow></mrow><mi>m</mi><mo>→</mo><mi>m</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>m</mi><mo>→</mo><mi>m</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mn>1</mn><mo>→</mo><mi>m</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
m\times{}m \to m \\
m \to m \\
1 \to m
\end{aligned}
</annotation></semantics></math>
前と同様に、この3つ組を結合して1つの関数集合にできる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>×</mo><mrow></mrow><mi>m</mi><mo>+</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo>→</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">m\times{}m + m + 1 \to m</annotation></semantics></math>
1つの二項演算子（加算）、1つの単項演算子（正負反転）、1つの零項演算子（恒等射――ここでは0）から始めた。そして、それらを1つの関数に統合した。このシグネチャーを持つすべての関数は、潜在的な群を定義する。</p>
<p>同様のことを続けられる。たとえば、環を定義するにはもう1つの二項演算子と1つの零項演算子を追加する、などだ。毎回、左辺が冪乗（0乗――終対象――を含んでよい）の和で、右辺がその集合自体である関数型が得られる。</p>
<p>いまや一般化に夢中になってしまうだろう。まず、集合を対象に、関数を射に置き換えられる。n項演算子はn項積からの射として定義できる。これは有限積
(finite product)
をサポートする圏が必要であることを意味する。零項演算子に対しては終対象が存在する必要がある。したがって、デカルト圏が必要だ<a
href="#fn147" class="footnote-ref" id="fnref147"
role="doc-noteref"><sup>147</sup></a>。これらの演算子を組み合わせるには冪が必要なので、必要なのはデカルト閉圏となる。最終的に、この代数的な悪ふざけを完成させるには余積が必要になる。</p>
<p>あるいは、式の導出方法を忘れて、最終成果物に集中してもよい。我々の射の左辺にある積の和は、自己関手を定義している。その代わりとして任意の自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>を選ぶとどうなるだろう？　その場合は圏に制約を課す必要はない。こうして得られたものは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数と呼ばれる。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数は、1つの自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>、1つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と、次の1つの射からなる3つ組だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">F a \to a</annotation></semantics></math>
ここでの対象はしばしば台 (carrier, underlying object)
と呼ばれ、プログラミングの文脈ではキャリア<em>型</em>と呼ばれる。また、射は評価射
(evaluation function, structure map)
と呼ばれることが多い。関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>が式を形成し、それを射が評価すると考えてほしい。</p>
<p>Haskellによる<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数の定義を示す。</p>
<div class="sourceCode" id="cb505"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb505-1"><a href="#cb505-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Algebra</span> f a <span class="ot">=</span> f a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p> これは代数とその評価関数を同一視している。</p>
<p>モノイドの例では、問題の関手は次のようになる。</p>
<div class="sourceCode" id="cb506"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb506-1"><a href="#cb506-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MonF</span> a <span class="ot">=</span> <span class="dt">MEmpty</span> <span class="op">|</span> <span class="dt">MAppend</span> a a</span></code></pre></div>
<p>
これはHaskellで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mi>a</mi><mo>×</mo><mrow></mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">1 + a \times{}a</annotation></semantics></math>を表したものだ（<a
href="#simple-algebraic-data-types">代数的データ構造</a>（第6章）について思い出してほしい）。</p>
<p>環は次の関手を使って定義される。</p>
<div class="sourceCode" id="cb507"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb507-1"><a href="#cb507-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RingF</span> a <span class="ot">=</span> <span class="dt">RZero</span></span>
<span id="cb507-2"><a href="#cb507-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">ROne</span></span>
<span id="cb507-3"><a href="#cb507-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">RAdd</span> a a</span>
<span id="cb507-4"><a href="#cb507-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">RMul</span> a a</span>
<span id="cb507-5"><a href="#cb507-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">RNeg</span> a</span></code></pre></div>
<p>
これはHaskellで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>1</mn><mo>+</mo><mi>a</mi><mo>×</mo><mrow></mrow><mi>a</mi><mo>+</mo><mi>a</mi><mo>×</mo><mrow></mrow><mi>a</mi><mo>+</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">1 + 1 + a \times{}a + a \times{}a + a</annotation></semantics></math>を表したものだ。</p>
<p>環の例としては整数の集合が挙げられる。<code>Integer</code>をキャリア型に選ぶと、評価関数を次のように定義できる。</p>
<div class="sourceCode" id="cb508"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb508-1"><a href="#cb508-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evalZ ::</span> <span class="dt">Algebra</span> <span class="dt">RingF</span> <span class="dt">Integer</span></span>
<span id="cb508-2"><a href="#cb508-2" aria-hidden="true" tabindex="-1"></a>evalZ <span class="dt">RZero</span>      <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb508-3"><a href="#cb508-3" aria-hidden="true" tabindex="-1"></a>evalZ <span class="dt">ROne</span>       <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb508-4"><a href="#cb508-4" aria-hidden="true" tabindex="-1"></a>evalZ (<span class="dt">RAdd</span> m n) <span class="ot">=</span> m <span class="op">+</span> n</span>
<span id="cb508-5"><a href="#cb508-5" aria-hidden="true" tabindex="-1"></a>evalZ (<span class="dt">RMul</span> m n) <span class="ot">=</span> m <span class="op">*</span> n</span>
<span id="cb508-6"><a href="#cb508-6" aria-hidden="true" tabindex="-1"></a>evalZ (<span class="dt">RNeg</span> n)   <span class="ot">=</span> <span class="op">-</span>n</span></code></pre></div>
<p>
同じ関手<code>RingF</code>に基づく<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数は他にもたくさんある。たとえば、多項式も正方行列も環をなす。</p>
<p>ご覧のとおり、関手の役割は、評価に代数の評価子 (evaluator)
を使えるような式を生成することだ。ここまでは、非常に単純な式しか見てこなかった。しかし、より複雑な、再帰を使って定義できる式に関心があることも多い。</p>
<h2 data-number="24.1" id="再帰"><span
class="header-section-number">24.1</span> 再帰</h2>
<p>任意の式木を生成する方法の1つは、関手の定義内の変数<code>a</code>を再帰で置き換えることだ。たとえば、環における任意の式は、木状のデータ構造によって生成される。</p>
<div class="sourceCode" id="cb509"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb509-1"><a href="#cb509-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">RZero</span></span>
<span id="cb509-2"><a href="#cb509-2" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">ROne</span></span>
<span id="cb509-3"><a href="#cb509-3" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">RAdd</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb509-4"><a href="#cb509-4" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">RMul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb509-5"><a href="#cb509-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">RNeg</span> <span class="dt">Expr</span></span></code></pre></div>
<p> もとの環の評価子は再帰版に置き換えられる。</p>
<div class="sourceCode" id="cb510"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb510-1"><a href="#cb510-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evalZ ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb510-2"><a href="#cb510-2" aria-hidden="true" tabindex="-1"></a>evalZ <span class="dt">RZero</span>        <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb510-3"><a href="#cb510-3" aria-hidden="true" tabindex="-1"></a>evalZ <span class="dt">ROne</span>         <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb510-4"><a href="#cb510-4" aria-hidden="true" tabindex="-1"></a>evalZ (<span class="dt">RAdd</span> e1 e2) <span class="ot">=</span> evalZ e1 <span class="op">+</span> evalZ e2</span>
<span id="cb510-5"><a href="#cb510-5" aria-hidden="true" tabindex="-1"></a>evalZ (<span class="dt">RMul</span> e1 e2) <span class="ot">=</span> evalZ e1 <span class="op">*</span> evalZ e2</span>
<span id="cb510-6"><a href="#cb510-6" aria-hidden="true" tabindex="-1"></a>evalZ (<span class="dt">RNeg</span> e)     <span class="ot">=</span> <span class="op">-</span>(evalZ e)</span></code></pre></div>
<p>
これはまだあまり実用的ではない。すべての整数を1の和で表現するのが強制されているからだ。もっとも、緊急時には役に立つ。</p>
<p>それにしても、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数の言葉で式木を記述するにはどうすればよいだろうか？　関手の定義において、いままさに行っている置換の結果で自由型変数を再帰的に置き換えるプロセスを、何らかの形で形式化する必要がある。これを段階的に行うことを考えてみよう。まず、深さ1の木を次のように定義する。</p>
<div class="sourceCode" id="cb511"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb511-1"><a href="#cb511-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RingF1</span> a <span class="ot">=</span> <span class="dt">RingF</span> (<span class="dt">RingF</span> a)</span></code></pre></div>
<p>
<code>RingF</code>の定義の穴を、<code>RingF a</code>によって生成された深さ0の木で埋めている。深さ2の木も同様にして得られる。</p>
<div class="sourceCode" id="cb512"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb512-1"><a href="#cb512-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RingF2</span> a <span class="ot">=</span> <span class="dt">RingF</span> (<span class="dt">RingF</span> (<span class="dt">RingF</span> a))</span></code></pre></div>
<p> これは次のようにも書ける。</p>
<div class="sourceCode" id="cb513"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb513-1"><a href="#cb513-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RingF2</span> a <span class="ot">=</span> <span class="dt">RingF</span> (<span class="dt">RingF1</span> a)</span></code></pre></div>
<p> このプロセスを繰り返すことで、シンボリックな等式を書ける。</p>
<div class="sourceCode">
<pre
class="sourceCode haskell"><code class="sourceCode haskell">type RingF<sub>n+1</sub> a = RingF (RingF<sub>n</sub> a)</code></pre>
</div>
<p>概念的には、このプロセスを無限に繰り返すことで<code>Expr</code>が得られる。<code>Expr</code>は<code>a</code>に依存しないことに注意してほしい。旅の出発点によらず、いつも同じ場所に辿り着く。これは任意の圏の任意の自己関手に常に当てはまるわけではないが、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>圏ではうまくいく。</p>
<p>当然、これは大雑把な議論なので、後でより厳密に説明する。</p>
<p>自己関手を無限回適用すると、<span id="fixed_point"
class="keyword"><em>不動点</em></span> (fixed point)
が得られる。これは次のように定義される対象のひとつだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐹</mi><mi>𝑖</mi><mi>𝑥</mi></mrow><mspace width="0.222em"></mspace><mi>f</mi><mo>=</mo><mi>f</mi><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝐹</mi><mi>𝑖</mi><mi>𝑥</mi></mrow><mspace width="0.222em"></mspace><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{Fix}\ f = f\ (\mathit{Fix}\ f)</annotation></semantics></math>
この定義の背景には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐹</mi><mi>𝑖</mi><mi>𝑥</mi></mrow><mspace width="0.222em"></mspace><mi>f</mi></mrow><annotation encoding="application/x-tex">\mathit{Fix}\ f</annotation></semantics></math>を得るために<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を無限回適用しているので、さらにもう1回適用しても何も変わらない、という直観がある。Haskellでは、不動点の定義は次のようになる。</p>
<div class="sourceCode" id="cb514"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb514-1"><a href="#cb514-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> (f (<span class="dt">Fix</span> f))</span></code></pre></div>
<p>
おそらく、次のように、定義されている型の名前がコンストラクターの名前と別ならば、もっと読みやすくなっただろう。</p>
<div class="sourceCode" id="cb515"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb515-1"><a href="#cb515-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">In</span> (f (<span class="dt">Fix</span> f))</span></code></pre></div>
<p>
しかし、ここでは広く使われている表記に従うことにする。構成子<code>Fix</code>（あるいは好みによっては<code>In</code>）は関数と見なせる。</p>
<div class="sourceCode" id="cb516"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb516-1"><a href="#cb516-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Fix</span><span class="ot"> ::</span> f (<span class="dt">Fix</span> f) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span></code></pre></div>
<p> また、関手適用を1層だけ剥がす関数もある。</p>
<div class="sourceCode" id="cb517"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb517-1"><a href="#cb517-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unFix ::</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> f (<span class="dt">Fix</span> f)</span>
<span id="cb517-2"><a href="#cb517-2" aria-hidden="true" tabindex="-1"></a>unFix (<span class="dt">Fix</span> x) <span class="ot">=</span> x</span></code></pre></div>
<p> 2つの関数は互いに逆だ。これらの関数は後で使うことになる。</p>
<aside id="footnotes-74" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="147">
<li
id="fn147"><p>訳注：n項演算子を表すだけならモノイダル圏で十分だが、ここではモノイダル積が圏論的な積であることを想定しており、その場合のモノイダル圏はデカルト圏と呼ばれる。<a
href="#fnref147" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="24.2" id="f-代数の圏"><span
class="header-section-number">24.2</span>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数の圏</h2>
<p>この本の中で最も古いトリックについて述べよう。何か新しい対象を構築する方法を思いついたら、それらが圏をなすかどうかを常に確認すべし。驚くまでもなく、任意の自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>上の代数は圏をなす。その圏の対象は代数だ――台対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">F a \to a</annotation></semantics></math>からなるペアで、どちらももとの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>からのものだ。</p>
<p>この描像を完全なものにするには、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数の圏における射を定義する必要がある。射は、ある代数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, f)</annotation></semantics></math>
を別の代数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(b, g)</annotation></semantics></math>
に写さなければならない。これを、台を写す射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>――もとの圏で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>へ向かう射――として定義する。どの射でもよいわけではなく、2つの評価子と互換性がなければならない。（構造を保存するそのような射を<span
id="homomorphism" class="keyword"><em>準同型</em></span>と呼ぶ。）
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数の準同型を定義する方法は次のとおりだ。まず、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>を次の写像へと持ち上げられることに注目してほしい。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>m</mi><mo>∷</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>F</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">F m \Colon F a \to F b</annotation></semantics></math>
それから<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>を辿ると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>に行き着く。同様に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">F a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>に移ってから<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>を辿ってもよい。2つの経路が等しくなるようにしたい。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>F</mi><mi>m</mi><mo>=</mo><mi>m</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">g \circ F m = m \circ f</annotation></semantics></math>
<a href="images/alg.png"><img src="images/alg.png" style="width:30.0%"
alt="alg" /></a> </p>
<p>
これが本当に圏であることは簡単に確認できる（ヒント：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の恒等射については問題なく、また、準同型の合成は準同型だ）。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数の圏に始対象が存在するなら、それは<span
id="initial_algebra" class="keyword"><em>始代数</em></span> (initial
algebra)
と呼ばれる。この始代数の台を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>と呼び、その評価子を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>∷</mo><mi>F</mi><mi>i</mi><mo>→</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">j \Colon F i \to i</annotation></semantics></math>と呼ぼう。始代数の評価子である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>は同型射だと分かる。この結果はランベック
(Lambek)
の定理として知られている。その証明は始対象の定義に依存している。始対象の定義より、他の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数への一意な準同型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>が存在する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>が準同型なので、次の図式が可換でなければならない。</p>
<p> <a href="images/alg2.png"><img src="images/alg2.png"
style="width:30.0%" alt="alg2" /></a> </p>
<p>
次に、台が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">F i</annotation></semantics></math>である代数を構成しよう。そのような代数の評価子は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>i</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F (F i)</annotation></semantics></math>
から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">F i</annotation></semantics></math>への射でなければならない。このような評価子は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>を持ち上げるだけで簡単に構成できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>j</mi><mo>∷</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>F</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">F j \Colon F (F i) \to F i</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math>
は始代数なので、そこから
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>i</mi><mo>,</mo><mi>F</mi><mi>j</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(F i, F j)</annotation></semantics></math>
への一意な準同型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>が必要だ。次の図式が可換でなければならない。</p>
<p> <a href="images/alg3a.png"><img src="images/alg3a.png"
style="width:30.0%" alt="alg3a" /></a> </p>
<p>
しかし、次のような自明な可換図式もある（どちらの経路も同じだ！）。</p>
<p> <a href="images/alg3.png"><img src="images/alg3.png"
style="width:30.0%" alt="alg3" /></a> </p>
<p>
これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>が代数の準同型であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>i</mi><mo>,</mo><mi>F</mi><mi>j</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(F i, F j)</annotation></semantics></math>
を
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math>
に写すことを示していると解釈できる。これら2つの図式をつなぐと次のようになる。</p>
<p> <a href="images/alg4.png"><img src="images/alg4.png"
style="width:60.0%" alt="alg4" /></a> </p>
<p>
この図式は、同様に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>∘</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">j \circ m</annotation></semantics></math>が代数の準同型であることを示していると解釈できる。この場合については2つの代数は同じだ。さらに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>j</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(i, j)</annotation></semantics></math>
は始代数なので、それ自身から自身への準同型は1つしか存在できず、それは恒等射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>i</mi></msub><annotation encoding="application/x-tex">\mathbf{id}_i</annotation></semantics></math>に他ならない。この恒等射が代数の準同型であることは分かっている。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>∘</mo><mi>m</mi><mo>=</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">j \circ m = \mathbf{id}_i</annotation></semantics></math>となる。この事実と左側の図式の可換性を用いて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∘</mo><mi>j</mi><mo>=</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mrow><mi>F</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">m \circ j=\mathbf{id}_{Fi}</annotation></semantics></math>であることを証明できる。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>の逆であることを示しているため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">F i</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>の間の同型射だと言える。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>i</mi><mo>≅</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">F i \cong i</annotation></semantics></math>
しかし、これはまさに<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>の不動点だと言っている。以上が最初の大雑把な議論の背景にある形式的証明だ。</p>
<p>Haskellに戻ろう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>は<code>Fix f</code>で、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>はコンストラクター<code>Fix</code>、その逆は<code>unFix</code>だと理解できる。ランベックの定理における同型からは、始代数を得るには関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を取って引数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を<code>Fix f</code>に置き換えればよいことが分かる<a
href="#fn148" class="footnote-ref" id="fnref148"
role="doc-noteref"><sup>148</sup></a>。また、不動点が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>によらない理由も分かる。</p>
<aside id="footnotes-75" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="148">
<li
id="fn148"><p>監訳注：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">\bot</annotation></semantics></math>があるHaskellでは<code>Fix f</code>が始代数の台に対応しているとは限らない。詳細は第24章6節を参照。<a
href="#fnref148" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="24.3" id="自然数"><span
class="header-section-number">24.3</span> 自然数</h2>
<p>自然数も<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数として定義できる。出発点は次のような射のペアだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>z</mi><mi>e</mi><mi>r</mi><mi>o</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mn>1</mn><mo>→</mo><mi>N</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>s</mi><mi>u</mi><mi>c</mi><mi>c</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>N</mi><mo>→</mo><mi>N</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
zero &amp;\Colon 1 \to N \\
succ &amp;\Colon N \to N
\end{aligned}
</annotation></semantics></math>
1つ目は0を選択し、2つ目はすべての数をその次の数に写す。前と同じように、この2つは1つにまとめられる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mi>N</mi><mo>→</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">1 + N \to N</annotation></semantics></math>
左辺は関手を定義し、Haskellでは次のように書ける。</p>
<div class="sourceCode" id="cb518"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb518-1"><a href="#cb518-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NatF</span> a <span class="ot">=</span> <span class="dt">ZeroF</span> <span class="op">|</span> <span class="dt">SuccF</span> a</span></code></pre></div>
<p>
この関手の不動点（この関手が生成する始代数）は、Haskellでは次のように表現できる。</p>
<div class="sourceCode" id="cb519"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb519-1"><a href="#cb519-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Zero</span> <span class="op">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span></span></code></pre></div>
<p>
自然数は、0か、ある数の次の数かのどちらかだ。これは自然数のペアノ表現として知られている。</p>
<h2 data-number="24.4" id="catamorphism"><span
class="header-section-number">24.4</span> Catamorphism</h2>
<p>始代数の条件をHaskellの表記で書き直してみよう。始代数を<code>Fix f</code>と呼ぶことにする。その評価子はコンストラクター<code>Fix</code>だ。始代数から他の任意の代数への一意な射<code>m</code>が同じ関手上に存在する。台が<code>a</code>であり評価子が<code>alg</code>である代数を考えてみよう。</p>
<p> <a href="images/alg5.png"><img src="images/alg5.png"
style="width:40.0%" alt="alg5" /></a> </p>
<p>
ところで、<code>m</code>が何なのかに注目してほしい。これは不動点の評価子であり、再帰的な式木全体の評価子だ。これを実装するための汎用的な方法を探してみよう。</p>
<p>ランベックの定理はコンストラクター<code>Fix</code>が同型射であることを示している。その逆は<code>unFix</code>と呼ばれる。したがって、この図式で矢印の1つを反転して次のようにできる。</p>
<p> <a href="images/alg6.png"><img src="images/alg6.png"
style="width:40.0%" alt="alg6" /></a> </p>
<p> この図式の可換条件を書こう。</p>
<div class="sourceCode" id="cb520"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb520-1"><a href="#cb520-1" aria-hidden="true" tabindex="-1"></a>m <span class="ot">=</span> alg <span class="op">.</span> <span class="fu">fmap</span> m <span class="op">.</span> unFix</span></code></pre></div>
<p>
この等式は<code>m</code>の再帰的な定義として解釈できる。再帰は関手<code>f</code>を使って作成されたすべての有限木に対して停止する。そのことは、<code>fmap m</code>が関手<code>f</code>の最上層の下層で動作することに着目すれば分かる。言い換えると、それはもとの木の子に対して機能する。子は常にもとの木より1レベル浅くなる。</p>
<p><code>Fix f</code>を使って構築された木に<code>m</code>を適用するとどうなるか述べよう。まず、<code>unFix</code>の作用によってコンストラクターが剥がれ、木の最上位があらわになる。次に、最上位ノードのすべての子に<code>m</code>を適用する。それにより、型<code>a</code>の結果が生成される。最後に、非再帰的評価子<code>alg</code>を適用することで、これらの結果を結合する。重要な点は、評価子<code>alg</code>が単純な非再帰関数であることだ。</p>
<p>これは任意の代数<code>alg</code>に対して行えるので、代数をパラメーターに取って<code>m</code>と呼ばれる関数を返す高階関数を定義するのは筋が通っている。この高階関数はcatamorphismと呼ばれる。</p>
<div class="sourceCode" id="cb521"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb521-1"><a href="#cb521-1" aria-hidden="true" tabindex="-1"></a><span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb521-2"><a href="#cb521-2" aria-hidden="true" tabindex="-1"></a>cata alg <span class="ot">=</span> alg <span class="op">.</span> <span class="fu">fmap</span> (cata alg) <span class="op">.</span> unFix</span></code></pre></div>
<p> 例を見てみよう。自然数を定義する関手を考える。</p>
<div class="sourceCode" id="cb522"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb522-1"><a href="#cb522-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NatF</span> a <span class="ot">=</span> <span class="dt">ZeroF</span> <span class="op">|</span> <span class="dt">SuccF</span> a</span></code></pre></div>
<p>
キャリア型として<code>(Int, Int)</code>を選択し、代数を次のように定義する。</p>
<div class="sourceCode" id="cb523"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb523-1"><a href="#cb523-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">NatF</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb523-2"><a href="#cb523-2" aria-hidden="true" tabindex="-1"></a>fib <span class="dt">ZeroF</span> <span class="ot">=</span> (<span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb523-3"><a href="#cb523-3" aria-hidden="true" tabindex="-1"></a>fib (<span class="dt">SuccF</span> (m, n)) <span class="ot">=</span> (n, m <span class="op">+</span> n)</span></code></pre></div>
<p>
この代数のcatamorphismである<code>cata fib</code>でフィボナッチ数が計算されることは簡単に納得できる。</p>
<p>一般に、<code>NatF</code>の代数は漸化式を定義する。つまり、現在の要素の値を前の要素によって表す。そして、catamorphismは数列のn番目の要素の値を求める。</p>
<h2 data-number="24.5" id="fold"><span
class="header-section-number">24.5</span> fold</h2>
<p>型<code>e</code>のリストは次の関手の始代数だ。</p>
<div class="sourceCode" id="cb524"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb524-1"><a href="#cb524-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ListF</span> e a <span class="ot">=</span> <span class="dt">NilF</span> <span class="op">|</span> <span class="dt">ConsF</span> e a</span></code></pre></div>
<p>
実際、再帰の結果（<code>List e</code>と呼ぶことにする）で変数<code>a</code>を置き換えると、次のようになる。</p>
<div class="sourceCode" id="cb525"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb525-1"><a href="#cb525-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> e <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> e (<span class="dt">List</span> e)</span></code></pre></div>
<p>
リスト関手の代数は、特定のキャリア型を選択し、リストの2つのコンストラクターについてパターンマッチングを行う関数を定義する。その関数の<code>NilF</code>に対する値は空リストを評価する方法を表し、<code>ConsF</code>に対する値は現在の要素をそれ以前の累積値と組み合わせる方法を表す。</p>
<p>たとえば、以下はリストの長さを計算するために使える代数だ（キャリア型は<code>Int</code>だ）。</p>
<div class="sourceCode" id="cb526"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb526-1"><a href="#cb526-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lenAlg ::</span> <span class="dt">ListF</span> e <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb526-2"><a href="#cb526-2" aria-hidden="true" tabindex="-1"></a>lenAlg (<span class="dt">ConsF</span> e n) <span class="ot">=</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb526-3"><a href="#cb526-3" aria-hidden="true" tabindex="-1"></a>lenAlg <span class="dt">NilF</span> <span class="ot">=</span> <span class="dv">0</span></span></code></pre></div>
<p>
実際、結果として得られる<code>cata lenAlg</code>というcatamorphismによってリストの長さを計算できる。評価関数は、(1)
リストの要素と累積値を受け取って新しい累積値を返す関数と、(2)
開始値（ここでは0）とを組み合わせたものであることに注目してほしい。開始値の型と累積値の型はキャリア型によって与えられる。</p>
<p>これを従来のHaskellの定義と比較してみよう。</p>
<div class="sourceCode" id="cb527"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb527-1"><a href="#cb527-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> <span class="ot">=</span> <span class="fu">foldr</span> (\e n <span class="ot">-&gt;</span> n <span class="op">+</span> <span class="dv">1</span>) <span class="dv">0</span></span></code></pre></div>
<p> <code>foldr</code>の2つの引数は代数の2つの成分そのものだ。</p>
<p>別の例を見てみよう。</p>
<div class="sourceCode" id="cb528"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb528-1"><a href="#cb528-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sumAlg ::</span> <span class="dt">ListF</span> <span class="dt">Double</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb528-2"><a href="#cb528-2" aria-hidden="true" tabindex="-1"></a>sumAlg (<span class="dt">ConsF</span> e s) <span class="ot">=</span> e <span class="op">+</span> s</span>
<span id="cb528-3"><a href="#cb528-3" aria-hidden="true" tabindex="-1"></a>sumAlg <span class="dt">NilF</span> <span class="ot">=</span> <span class="fl">0.0</span></span></code></pre></div>
<p> 再び、これを次のものと比較する。</p>
<div class="sourceCode" id="cb529"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb529-1"><a href="#cb529-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> <span class="ot">=</span> <span class="fu">foldr</span> (\e s <span class="ot">-&gt;</span> e <span class="op">+</span> s) <span class="fl">0.0</span></span></code></pre></div>
<p>
ご覧のとおり、<code>foldr</code>はリストに対してcatamorphismを特殊化して便利にしたものにすぎない<a
href="#fn149" class="footnote-ref" id="fnref149"
role="doc-noteref"><sup>149</sup></a>。</p>
<aside id="footnotes-76" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="149">
<li
id="fn149"><p>訳注：翻訳時点での事実上標準のHaskell処理系GHCの標準ライブラリー（base）における<code>foldr</code>の型は<code>foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b</code>である。本文中ではリストに対する<code>foldr</code>について言及している。<a
href="#fnref149" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="24.6" id="余代数"><span
class="header-section-number">24.6</span> 余代数</h2>
<p>いつものように、F-余代数という双対構成があり、射が逆向きになっている。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">a \to F a</annotation></semantics></math>
任意の関手についての余代数も、その余代数的構造を保存する準同型を伴った圏をなす。その圏の終対象
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>t</mi><mo>,</mo><mi>u</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(t, u)</annotation></semantics></math>
は終余代数 (terminal / final coalgebra) と呼ばれる。他のすべての代数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, f)</annotation></semantics></math>
に対し、次の図式を可換にする一意な準同型<code>m</code>が存在する。</p>
<p> <a href="images/alg7.png"><img src="images/alg7.png"
style="width:40.0%" alt="alg7" /></a> </p>
<p>
終余代数は、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>∷</mo><mi>t</mi><mo>→</mo><mi>F</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">u \Colon t \to F t</annotation></semantics></math>が同型射である（余代数に関するランベックの定理）という意味で関手の不動点である。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>t</mi><mo>≅</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">F t \cong t</annotation></semantics></math>
終余代数は、プログラミングでは通常、（無限でもよい）データ構造または遷移系を生成するためのレシピとして解釈される。</p>
<p>始代数の評価にcatamorphismが使えるのと同様に、終余代数の余評価にはanamorphismが使える。</p>
<div class="sourceCode" id="cb530"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb530-1"><a href="#cb530-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ana ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span>
<span id="cb530-2"><a href="#cb530-2" aria-hidden="true" tabindex="-1"></a>ana coalg <span class="ot">=</span> <span class="dt">Fix</span> <span class="op">.</span> <span class="fu">fmap</span> (ana coalg) <span class="op">.</span> coalg</span></code></pre></div>
<p>
余代数のカノニカルな例は、その不動点が型<code>e</code>の要素の無限ストリームであるような関手に基づく。これがその関手だ。</p>
<div class="sourceCode" id="cb531"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb531-1"><a href="#cb531-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">StreamF</span> e a <span class="ot">=</span> <span class="dt">StreamF</span> e a</span>
<span id="cb531-2"><a href="#cb531-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p> そして、これがその不動点だ。</p>
<div class="sourceCode" id="cb532"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb532-1"><a href="#cb532-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stream</span> e <span class="ot">=</span> <span class="dt">Stream</span> e (<span class="dt">Stream</span> e)</span></code></pre></div>
<p>
<code>StreamF e</code>の余代数は、型<code>a</code>のシードを取り、ある要素と次のシードからなるペアを生成する関数だ（ペアを<code>StreamF</code>という飾った名前で呼んでいる）。</p>
<p>無限数列を生成する余代数の簡単な例はすぐ生成できる。たとえば、2乗のリストや逆数のリストなどだ。</p>
<p>もっと興味深い例としては、素数のリストを生成する余代数がある。無限リストを台として使うのが秘訣だ。最初のシードはリスト<code>[2..]</code>になる。次のシードはこのリストのtailから2の倍数をすべて除いたものになる。これは奇数のリストであり、3から始まる。次の段階では、このリストのtailを取って3の倍数をすべて除く。エラトステネスの篩を作っているのに気付いただろう<a
href="#fn150" class="footnote-ref" id="fnref150"
role="doc-noteref"><sup>150</sup></a>。この余代数は次の関数で実装される。</p>
<div class="sourceCode" id="cb533"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb533-1"><a href="#cb533-1" aria-hidden="true" tabindex="-1"></a><span class="ot">era ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">StreamF</span> <span class="dt">Int</span> [<span class="dt">Int</span>]</span>
<span id="cb533-2"><a href="#cb533-2" aria-hidden="true" tabindex="-1"></a>era (p <span class="op">:</span> ns) <span class="ot">=</span> <span class="dt">StreamF</span> p (<span class="fu">filter</span> (notdiv p) ns)</span>
<span id="cb533-3"><a href="#cb533-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> notdiv p n <span class="ot">=</span> n <span class="ot">`mod`</span> p <span class="op">/=</span> <span class="dv">0</span></span></code></pre></div>
<p> この余代数のanamorphismは素数のリストを生成する。</p>
<div class="sourceCode" id="cb534"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb534-1"><a href="#cb534-1" aria-hidden="true" tabindex="-1"></a>primes <span class="ot">=</span> ana era [<span class="dv">2</span><span class="op">..</span>]</span></code></pre></div>
<p>
ストリームは無限リストなので、Haskellのリストに変換できるはずだ。そのためには、同じ関手<code>StreamF</code>を使って代数を形成したうえでcatamorphismを実行すればよい。たとえば、次のcatamorphismはストリームをリストに変換する。</p>
<div class="sourceCode" id="cb535"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb535-1"><a href="#cb535-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toListC ::</span> <span class="dt">Fix</span> (<span class="dt">StreamF</span> e) <span class="ot">-&gt;</span> [e]</span>
<span id="cb535-2"><a href="#cb535-2" aria-hidden="true" tabindex="-1"></a>toListC <span class="ot">=</span> cata al</span>
<span id="cb535-3"><a href="#cb535-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">where</span><span class="ot"> al ::</span> <span class="dt">StreamF</span> e [e] <span class="ot">-&gt;</span> [e]</span>
<span id="cb535-4"><a href="#cb535-4" aria-hidden="true" tabindex="-1"></a>         al (<span class="dt">StreamF</span> e a) <span class="ot">=</span> e <span class="op">:</span> a</span></code></pre></div>
<p> ここでは、同じ不動点が同じ自己関手の始代数でもあり終余代数でもある<a
href="#fn151" class="footnote-ref" id="fnref151"
role="doc-noteref"><sup>151</sup></a>。これは任意の圏で常に成り立つわけではない。一般に、自己関手には不動点が多数あり得る（不動点がないこともある）。始代数はいわゆる最小不動点で、終余代数は最大不動点だ。ただし、Haskellでは両方とも同じ式で定義されて一致する。</p>
<p>リストのanamorphismはunfoldと呼ばれる。有限リストを作成するには、ペアについての<code>Maybe</code>を生成するように関手を改変する。</p>
<div class="sourceCode" id="cb536"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb536-1"><a href="#cb536-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p> <code>Nothing</code>の値でリストの生成が終了する。</p>
<p>余代数の面白い例として、レンズに関するものが挙げられる。レンズはゲッターとセッターのペアとして表せる。</p>
<div class="sourceCode" id="cb537"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb537-1"><a href="#cb537-1" aria-hidden="true" tabindex="-1"></a><span class="ot">set ::</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb537-2"><a href="#cb537-2" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> a <span class="ot">-&gt;</span> s</span></code></pre></div>
<p>
ここで、通常、<code>a</code>は型<code>s</code>のフィールドを持つ直積データ型だ<a
href="#fn152" class="footnote-ref" id="fnref152"
role="doc-noteref"><sup>152</sup></a>。ゲッターはそのフィールドの値を取得し、セッターはそのフィールドを新しい値に置き換える。これら2つの関数は1つにまとめられる。</p>
<div class="sourceCode" id="cb538"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb538-1"><a href="#cb538-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> (s, s <span class="ot">-&gt;</span> a)</span></code></pre></div>
<p> この関数はさらに次のように書き直せる。</p>
<div class="sourceCode" id="cb539"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb539-1"><a href="#cb539-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> <span class="dt">Store</span> s a</span></code></pre></div>
<p> ここで次のような関手を定義した。</p>
<div class="sourceCode" id="cb540"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb540-1"><a href="#cb540-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Store</span> s a <span class="ot">=</span> <span class="dt">Store</span> (s <span class="ot">-&gt;</span> a) s</span></code></pre></div>
<p>
これは積の和から構成される単純な代数的関手ではないことに注意してほしい。これには冪<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>a</mi><mi>s</mi></msup><annotation encoding="application/x-tex">a^s</annotation></semantics></math>が含まれる。</p>
<p>レンズはこの関手の余代数であり、キャリア型は<code>a</code>だ。<code>Store s</code>がコモナドでもあることは以前にも見た。とても振る舞いの良いレンズは、コモナドの構造と適合する余代数に対応することが分かる。これについては次章で説明する。</p>
<aside id="footnotes-77" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="150">
<li
id="fn150"><p>監訳注：計算量の観点からは関数<code>era</code>は本来のエラトステネスの篩と大きく異なる。より詳しくは、<code>era</code>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>以下の素数を求めるのに<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒪</mi><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mn>2</mn></msup><mi>/</mi><mo stretchy="false" form="prefix">(</mo><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mrow></mrow><mi>n</mi><msup><mo stretchy="false" form="postfix">)</mo><mn>2</mn></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n^2 / (\log{}n)^2)</annotation></semantics></math>時間かかるが、エラトステネスの篩は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝒪</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mrow></mrow><mrow><mi>log</mi><mo>&#8289;</mo></mrow><mrow></mrow><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n\log{}\log{}n)</annotation></semantics></math>時間である。</p>
<p>参考：Melissa E. O’Neill: <em>The Genuine Sieve of Eratosthenes</em>.
J. Funct. Program. 19(1): 95-106 (2009) <a
href="https://doi.org/10.1017/S0956796808007004"
class="uri">https://doi.org/10.1017/S0956796808007004</a><a
href="#fnref150" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn151"><p>監訳注：これは結構微妙なところである。</p>
<p>たとえば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">\bot</annotation></semantics></math>があるが<code>seq</code>のないHaskellを考えたときに、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>−</mi></mrow><annotation encoding="application/x-tex">a \times -</annotation></semantics></math>は始代数を持たない。では、<code>StreamF a</code>が始代数をもたないのかというとそうではなく、実は<code>StreamF a e</code>は圏論的な積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">a \times e</annotation></semantics></math>ではないので、上記の議論はあてはまらず始代数を持つ。</p>
<p>酒井政裕氏の修士論文「非正格関数に対して適用可能な融合変換」では、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>が始代数を持つための条件は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>m</mi><mi>a</mi><mi>p</mi><mi>f</mi><mi>⊥</mi><mo>=</mo><mi>⊥</mi></mrow><annotation encoding="application/x-tex">fmap f \bot = \bot</annotation></semantics></math>であることを示している。<a
href="#fnref151" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn152"><p>監訳注：Haskellの<code>lens</code>の典型的用法についてはそうかもしれないが、一般のレンズについてはそのようなことはない。<a
href="#fnref152" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="24.7" id="課題-18"><span
class="header-section-number">24.7</span> 課題</h2>
<ol type="1">
<li>1変数多項式の環について評価関数を実装せよ。多項式は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>の冪乗の係数のリストとして表せる。たとえば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><msup><mi>x</mi><mn>2</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">4x^2-1</annotation></semantics></math>は、（0乗項から始めて）<code>[-1, 0, 4]</code>と表される。</li>
<li>前の構成を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>x</mi><mn>2</mn></msup><mi>y</mi><mo>−</mo><mn>3</mn><msup><mi>y</mi><mn>3</mn></msup><mi>z</mi></mrow><annotation encoding="application/x-tex">x^2y-3y^3z</annotation></semantics></math>のような、独立変数を多数含む多項式に一般化せよ。</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>×</mo><mrow></mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2\times{}2</annotation></semantics></math>行列の環について代数を実装せよ。</li>
<li>自然数の2乗のリストを生成するようなanamorphismを持つ余代数を定義せよ。</li>
<li><code>unfoldr</code>を使って、最初の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>個の素数のリストを生成せよ。</li>
</ol>
<h1 data-number="25" id="algebras-for-monads"><span
class="header-section-number">25</span> モナドの代数</h1>
<p>もし自己関手を式の定義方法だと解釈するなら、代数は式を評価し、モナドは式を生成し操作する方法だということになる。代数とモナドを組み合わせることで、多くの機能が得られるだけでなく、いくつかの興味深い質問にも答えられる。</p>
<p>そのような疑問の1つはモナドと随伴の関係に関するものだ。これまで見てきたように、すべての随伴はモナド（およびコモナド）を<a
href="#monads-categorically">定義する</a>。問題は、すべてのモナド（コモナド）は随伴から導出可能なのかだ。答えは可能だ。任意のモナドを生成する随伴の族が存在する。そのような随伴を2つ紹介したい。</p>
<p> <img src="images/pigalg.png" style="width:25.0%" /> </p>
<p>
定義を確認しよう。モナドは、あるコヒーレンス条件を満たす2つの自然変換を伴う自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>だ。それらの変換の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>における成分は次のとおりだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>η</mi><mi>a</mi></msub></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>a</mi><mo>→</mo><mi>m</mi><mspace width="0.222em"></mspace><mi>a</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>μ</mi><mi>a</mi></msub></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>m</mi><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mspace width="0.222em"></mspace><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>m</mi><mspace width="0.222em"></mspace><mi>a</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\eta_a &amp;\Colon a \to m\ a \\
\mu_a &amp;\Colon m\ (m\ a) \to m\ a
\end{aligned}
</annotation></semantics></math>
同じ自己関手についての代数は、次の射を伴ったある特定の対象――台<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>――の選択だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow><mo>∷</mo><mi>m</mi><mspace width="0.222em"></mspace><mi>a</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">\mathit{alg} \Colon m\ a \to a</annotation></semantics></math>
まず注目すべきは、代数が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\eta_a</annotation></semantics></math>とは逆行していることだ。直観では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>η</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\eta_a</annotation></semantics></math>は型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の値から自明な式を作る。第1のコヒーレンス条件は、代数をモナドと整合するものにし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を台とするその代数を用いてその式を評価するともとの値が返ることを保証する。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow><mo>∘</mo><msub><mi>η</mi><mi>a</mi></msub><mo>=</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">\mathit{alg} \circ \eta_a = \mathbf{id}_a</annotation></semantics></math>
第2の条件は、2重にネストされた式<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mspace width="0.222em"></mspace><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">m\ (m\ a)</annotation></semantics></math>
を評価する方法が2つある、という事実に基づく。まず<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\mu_a</annotation></semantics></math>を適用して式をフラット化し、次に代数の評価子を使ってもよい。あるいは、持ち上げられた評価子を適用して内側の式を評価してから、その結果に評価子を適用してもよい。これら2つの戦略を等価にしたい。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow><mo>∘</mo><msub><mi>μ</mi><mi>a</mi></msub><mo>=</mo><mrow><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow><mo>∘</mo><mi>m</mi><mspace width="0.222em"></mspace><mrow><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow></mrow><annotation encoding="application/x-tex">\mathit{alg} \circ \mu_a = \mathit{alg} \circ m\ \mathit{alg}</annotation></semantics></math>
ここで、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mspace width="0.222em"></mspace><mrow><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow></mrow><annotation encoding="application/x-tex">m\ \mathit{alg}</annotation></semantics></math>は関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>を使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow><annotation encoding="application/x-tex">\mathit{alg}</annotation></semantics></math>を持ち上げた結果だ。次の可換図式はこれら2つの条件を示している（後のことを想定して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>に置き換えた）。</p>
<div style="display:flex">
<script type="text/tikz">
\begin{tikzcd}[column sep=large, row sep=large]
  a \arrow[rd, equal] \arrow[r, "\eta_a"]
  & Ta \arrow[d, "\mathit{alg}"] \\
  & a
\end{tikzcd}
</script>
<script type="text/tikz">
\begin{tikzcd}[column sep=large, row sep=large]
  T(Ta) \arrow[r, "T \mathit{alg}"] \arrow[d, "\mu_a"]
  & Ta \arrow[d, "\mathit{alg}"] \\
  Ta \arrow[r, "\mathit{alg}"]
  & a
\end{tikzcd}
</script>
</div>
<p> これらの条件はHaskellでも表現できる。</p>
<div class="sourceCode" id="cb541"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb541-1"><a href="#cb541-1" aria-hidden="true" tabindex="-1"></a>alg <span class="op">.</span> <span class="fu">return</span> <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb541-2"><a href="#cb541-2" aria-hidden="true" tabindex="-1"></a>alg <span class="op">.</span> join <span class="ot">=</span> alg <span class="op">.</span> <span class="fu">fmap</span> alg</span></code></pre></div>
<p>
簡単な例を見てみよう。リスト自己関手の代数は、ある型<code>a</code>と、<code>a</code>のリストから<code>a</code>を生成する関数とで構成される。この関数は<code>foldr</code>を使って表せる。そのためには、要素の型とアキュムレーターの型を、両方とも同じ<code>a</code>になるように選ぶ。</p>
<div class="sourceCode" id="cb542"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb542-1"><a href="#cb542-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>
この特定の代数は、2つの引数を取る関数<code>f</code>と値<code>z</code>によって規定される。リスト関手はたまたまモナドでもあり、その<code>return</code>は値を単要素リストに変換する。ここでの代数<code>foldr f z</code>を<code>return</code>の後に合成したものは<code>x</code>を受け取るとこうなる。</p>
<div class="sourceCode" id="cb543"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb543-1"><a href="#cb543-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> f z [x] <span class="ot">=</span> x <span class="ot">`f`</span> z</span></code></pre></div>
<p>
ここで、<code>f</code>の作用を中置記法で表した。代数がモナドと整合するのは、すべての<code>x</code>に対して次のコヒーレンス条件が満たされる場合だ。</p>
<div class="sourceCode" id="cb544"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb544-1"><a href="#cb544-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">`f`</span> z <span class="ot">=</span> x</span></code></pre></div>
<p>
<code>f</code>を二項演算子と見なすと、この条件は<code>z</code>が右単位元であることを示している。</p>
<p>第2のコヒーレンス条件はリストのリストを扱っている。<code>join</code>の作用は個々のリストを連接する。その後で結果のリストをfoldすることもできる。一方で、まず個々のリストをfoldし、次に結果のリストをfoldすることもできる。ここでも、<code>f</code>を二項演算子と見なすと、このコヒーレンス条件はその二項演算が結合的であることを述べている。これらの条件は<code>(a, f, z)</code>がモノイドである場合には確実に満たされる。</p>
<h2 data-number="25.1" id="t-代数"><span
class="header-section-number">25.1</span>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>-代数</h2>
<p>数学者はモナドを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>と呼ぶのを好むので、それらと整合する代数を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>-代数と呼ぶ。圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>における任意のモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>についての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>-代数は圏をなす。この圏はアイレンバーグ・ムーア
(Eilenberg-Moore)
圏と呼ばれ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐂</mi><mi>T</mi></msup><annotation encoding="application/x-tex">\mathbf{C}^T</annotation></semantics></math>と表記されることが多い。この圏の射は代数の準同型だ。それらは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>-代数に対して定義されていた準同型と同じものだ。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>-代数は台対象と評価子からなるペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, f)</annotation></semantics></math>
だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐂</mi><mi>T</mi></msup><annotation encoding="application/x-tex">\mathbf{C}^T</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>への自明な忘却関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>U</mi><mi>T</mi></msup><annotation encoding="application/x-tex">U^T</annotation></semantics></math>が存在し、それは
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, f)</annotation></semantics></math>
を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>に写す。また、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>-代数の準同型を、対応する台対象間の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>における射に写す。随伴について議論したとき、忘却関手への左随伴は自由関手と呼ばれると述べたのを覚えているだろう。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>U</mi><mi>T</mi></msup><annotation encoding="application/x-tex">U^T</annotation></semantics></math>に対する左随伴は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mi>T</mi></msup><annotation encoding="application/x-tex">F^T</annotation></semantics></math>と呼ばれる。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐂</mi><mi>T</mi></msup><annotation encoding="application/x-tex">\mathbf{C}^T</annotation></semantics></math>内の自由代数に写す。この自由代数の台は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">T a</annotation></semantics></math>だ。その評価子は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">T (T a)</annotation></semantics></math>
から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">T a</annotation></semantics></math>へ戻る射だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>はモナドなので、モナド的な<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\mu_a</annotation></semantics></math>（Haskellでの<code>join</code>）を評価子として使える。</p>
<p>さらに、これが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>-代数であることも示す必要がある。そのためには、次の2つのコヒーレンス条件が満たされなければならない。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mrow><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mi>∘</mi><msub><mi>η</mi><mrow><mi>T</mi><mi>a</mi></mrow></msub><mo>=</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mrow><mi>T</mi><mi>a</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mrow><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mi>∘</mi><msub><mi>μ</mi><mi>a</mi></msub><mo>=</mo><mrow><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow><mo>∘</mo><mi>T</mi><mrow><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\mathit{alg} &amp;\circ \eta_{Ta} = \mathbf{id}_{Ta} \\
\mathit{alg} &amp;\circ \mu_a = \mathit{alg} \circ T \mathit{alg}
\end{aligned}
</annotation></semantics></math>
しかし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>を代数に代入すれば、これらはモナド則にすぎない。</p>
<p>覚えているかもしれないが、すべての随伴はモナドを定義する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mi>T</mi></msup><annotation encoding="application/x-tex">F^T</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>U</mi><mi>T</mi></msup><annotation encoding="application/x-tex">U^T</annotation></semantics></math>の間の随伴は、アイレンバーグ・ムーア圏の構成で使われたまさにそのモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>を定義することが知られている。この構成はすべてのモナドに対して行えるので、すべてのモナドは随伴から生成できる、と言える。後ほど、同じモナドを生成する別の随伴が存在することを示す。</p>
<p>計画はこうだ。まず、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mi>T</mi></msup><annotation encoding="application/x-tex">F^T</annotation></semantics></math>が実際に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>U</mi><mi>T</mi></msup><annotation encoding="application/x-tex">U^T</annotation></semantics></math>の左随伴であることを示す。そのために、この随伴の単位と余単位を定義し、対応する三角恒等式が満たされているのを証明する。次に、この随伴によって生成されるモナドが、実際にもとのモナドであることを示す。</p>
<p>随伴の単位は次の自然変換だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>∷</mo><mi>I</mi><mo>→</mo><msup><mi>U</mi><mi>T</mi></msup><mo>∘</mo><msup><mi>F</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">\eta \Colon I \to U^T \circ F^T</annotation></semantics></math>
この変換の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>における成分を計算してみよう。恒等関手によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>が得られる。自由関手は自由代数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mi>a</mi><mo>,</mo><msub><mi>μ</mi><mi>a</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(T a, \mu_a)</annotation></semantics></math>
を生成し、忘却関手はそれを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">T a</annotation></semantics></math>に簡約する。以上により、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">T a</annotation></semantics></math>への写像が得られる。単にモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>の単位をこの随伴の単位として使うことにする。</p>
<p>余単位を見てみよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>∷</mo><msup><mi>F</mi><mi>T</mi></msup><mo>∘</mo><msup><mi>U</mi><mi>T</mi></msup><mo>→</mo><mi>I</mi></mrow><annotation encoding="application/x-tex">\varepsilon \Colon F^T \circ U^T \to I</annotation></semantics></math>
ある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>-代数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, f)</annotation></semantics></math>
における成分を計算してみよう。忘却関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を忘れており、自由関手はペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mi>a</mi><mo>,</mo><msub><mi>μ</mi><mi>a</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(T a, \mu_a)</annotation></semantics></math>
を生成する。だから、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, f)</annotation></semantics></math>
における余単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>を定義するには、アイレンバーグ・ムーア圏内の適切な射、すなわち次のような<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>-代数の準同型が必要となる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mi>a</mi><mo>,</mo><msub><mi>μ</mi><mi>a</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(T a, \mu_a) \to (a, f)</annotation></semantics></math>
このような準同型は台<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">T a</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>に写す必要がある。忘却された評価子<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を単に復活させることにしよう。今度はそれを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>-代数の準同型として使う。実際、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>-代数にしたのと同じ可換図式は、それが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>-代数の準同型だと示すものとも見なせる。</p>
<script type="text/tikz">
\begin{tikzcd}[column sep=large, row sep=large]
  T(Ta) \arrow[r, "T f"] \arrow[d, "\mu_a"]
  & Ta \arrow[d, "f"] \\
  Ta \arrow[r, "f"]
  & a
\end{tikzcd}
</script>
<p>
このようにして、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, f)</annotation></semantics></math>（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>-代数の圏の対象）における余単位の自然変換の成分<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>と定義できた。</p>
<p>随伴を完成させるには、単位と余単位が三角恒等式を満たすことも示す必要がある。それらの三角形はこう描ける。</p>
<div style="display:flex">
<script type="text/tikz">
\begin{tikzcd}[column sep=large, row sep=large]
  Ta \arrow[rd, equal] \arrow[r, "T \eta_a"]
  & T(Ta) \arrow[d, "\mu_a"] \\
  & Ta
\end{tikzcd}
</script>
<script type="text/tikz">
\begin{tikzcd}[column sep=large, row sep=large]
  a \arrow[rd, equal] \arrow[r, "\eta_a"]
  & Ta \arrow[d, "f"] \\
  & a
\end{tikzcd}
</script>
</div>
<p>
1つ目のものはモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>の単位律より成り立つ。2つ目のものは単に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>-代数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, f)</annotation></semantics></math>
の規則［訳注：コヒーレンス条件］だ。</p>
<p>以上より、これら2つの関手が随伴をなすことが示せた。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mi>T</mi></msup><mo>⊣</mo><msup><mi>U</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">F^T \dashv U^T</annotation></semantics></math>
すべての随伴はモナドを生成する。往復旅行
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>U</mi><mi>T</mi></msup><mo>∘</mo><msup><mi>F</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">U^T \circ F^T</annotation></semantics></math>
は、対応するモナドを生成する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の自己関手だ。対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>に対する作用を見てみよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mi>T</mi></msup><annotation encoding="application/x-tex">F^T</annotation></semantics></math>によって作られる自由代数は
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mi>a</mi><mo>,</mo><msub><mi>μ</mi><mi>a</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(T a, \mu_a)</annotation></semantics></math>
だ。忘却関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>U</mi><mi>T</mi></msup><annotation encoding="application/x-tex">U^T</annotation></semantics></math>は評価子を削除する。したがって、確かに次のものが得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>U</mi><mi>T</mi></msup><mo>∘</mo><msup><mi>F</mi><mi>T</mi></msup><mo>=</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">U^T \circ F^T = T</annotation></semantics></math>
予想どおり、随伴の単位はモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>の単位だ。</p>
<p>随伴の余単位からモナドの乗算が次の式によって得られるのを覚えているかもしれない。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>=</mo><mi>R</mi><mo>∘</mo><mi>ε</mi><mo>∘</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\mu = R \circ \varepsilon \circ L</annotation></semantics></math>
これは3つの自然変換の水平合成であり、そのうち2つは恒等自然変換で、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>に写すものと<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>に写すものだ。真ん中のものは余単位で、ある代数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, f)</annotation></semantics></math>
における成分が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>であるような自然変換だ。</p>
<p>成分<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\mu_a</annotation></semantics></math>を計算してみよう。まず、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mi>T</mi></msup><annotation encoding="application/x-tex">F^T</annotation></semantics></math>［訳注：すなわち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>］の後に水平合成すると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mi>T</mi></msup><mi>a</mi></mrow><annotation encoding="application/x-tex">F^T a</annotation></semantics></math>における<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>の成分が得られる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mi>T</mi></msup><annotation encoding="application/x-tex">F^T</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を代数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mi>a</mi><mo>,</mo><msub><mi>μ</mi><mi>a</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(T a, \mu_a)</annotation></semantics></math>
に渡し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>は評価子を選択するので、結果は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>μ</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\mu_a</annotation></semantics></math>になる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>U</mi><mi>T</mi></msup><annotation encoding="application/x-tex">U^T</annotation></semantics></math>［訳注：すなわち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>］による左水平合成は何も変更しない。なぜなら、射に対する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>U</mi><mi>T</mi></msup><annotation encoding="application/x-tex">U^T</annotation></semantics></math>の作用は自明だからだ。したがって、実際に、随伴から得られる<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>はもとのモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>と同じだ。</p>
<h2 data-number="25.2" id="クライスリ圏-2"><span
class="header-section-number">25.2</span> クライスリ圏</h2>
<p>クライスリ圏についてはすでに見た。別の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>とモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>で構成された圏だ。この圏を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐂</mi><mi>T</mi></msub><annotation encoding="application/x-tex">\mathbf{C}_T</annotation></semantics></math>と呼ぼう。クライスリ圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐂</mi><mi>T</mi></msub><annotation encoding="application/x-tex">\mathbf{C}_T</annotation></semantics></math>の対象たちは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の対象たちだが、射は異なっている。クライスリ圏での<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>𝐊</mi></msub><annotation encoding="application/x-tex">f_{\mathbf{K}}</annotation></semantics></math>は、もとの圏での<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">T b</annotation></semantics></math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>に対応する。この射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>へのクライスリ射と呼ぶ。</p>
<p>クライスリ圏における射の合成はクライスリ射のモナド的な合成によって定義される。例として、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>g</mi><mi>𝐊</mi></msub><annotation encoding="application/x-tex">g_{\mathbf{K}}</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>𝐊</mi></msub><annotation encoding="application/x-tex">f_{\mathbf{K}}</annotation></semantics></math>の後に合成するとする。クライスリ圏において
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>f</mi><mi>𝐊</mi></msub><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>g</mi><mi>𝐊</mi></msub><mo>∷</mo><mi>b</mi><mo>→</mo><mi>c</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
f_{\mathbf{K}} \Colon a \to b \\
g_{\mathbf{K}} \Colon b \to c
\end{gathered}
</annotation></semantics></math>
があるとき、これらは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>における以下の2つの射に対応している。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>T</mi><mi>b</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>g</mi><mo>∷</mo><mi>b</mi><mo>→</mo><mi>T</mi><mi>c</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
f \Colon a \to T b \\
g \Colon b \to T c
\end{gathered}
</annotation></semantics></math> 合成
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>h</mi><mi>𝐊</mi></msub><mo>=</mo><msub><mi>g</mi><mi>𝐊</mi></msub><mo>∘</mo><msub><mi>f</mi><mi>𝐊</mi></msub></mrow><annotation encoding="application/x-tex">h_{\mathbf{K}} = g_{\mathbf{K}} \circ f_{\mathbf{K}}</annotation></semantics></math>
を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>における以下のクライスリ射として定義する。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>h</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>a</mi><mo>→</mo><mi>T</mi><mi>c</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>h</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>=</mo><mi>μ</mi><mo>∘</mo><mo stretchy="false" form="prefix">(</mo><mi>T</mi><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo>∘</mo><mi>f</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
h &amp;\Colon a \to T c \\
h &amp;= \mu \circ (T g) \circ f
\end{aligned}
</annotation></semantics></math> Haskellでは次のように記述できる。</p>
<div class="sourceCode" id="cb545"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb545-1"><a href="#cb545-1" aria-hidden="true" tabindex="-1"></a>h <span class="ot">=</span> join <span class="op">.</span> <span class="fu">fmap</span> g <span class="op">.</span> f</span></code></pre></div>
<p>
対象に対しては自明な作用を持つ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐂</mi><mi>T</mi></msub><annotation encoding="application/x-tex">\mathbf{C}_T</annotation></semantics></math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>が存在する。射に対しては、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>の戻り値を装飾するクライスリ射を作成することによって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐂</mi><mi>T</mi></msub><annotation encoding="application/x-tex">\mathbf{C}_T</annotation></semantics></math>内の射に写す。次のような射
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to b</annotation></semantics></math>
が与えられたとき、対応するクライスリ射を使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐂</mi><mi>T</mi></msub><annotation encoding="application/x-tex">\mathbf{C}_T</annotation></semantics></math>内の射ができる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">\eta \circ f</annotation></semantics></math>
Haskellでは次のように記述できる。</p>
<div class="sourceCode" id="cb546"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb546-1"><a href="#cb546-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> <span class="op">.</span> f</span></code></pre></div>
<p>
また、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐂</mi><mi>T</mi></msub><annotation encoding="application/x-tex">\mathbf{C}_T</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>へ戻る関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>も定義できる。それはクライスリ圏から対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を取り、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">T a</annotation></semantics></math>に写す。クライスリ射
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>T</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to T b</annotation></semantics></math>
に相当する射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>f</mi><mi>𝐊</mi></msub><annotation encoding="application/x-tex">f_{\mathbf{K}}</annotation></semantics></math>について、この関手の作用は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の射
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>a</mi><mo>→</mo><mi>T</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">T a \to T b</annotation></semantics></math>
であり、これはまず<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>を持ち上げてから<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>を適用することで得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mrow><mi>T</mi><mi>b</mi></mrow></msub><mo>∘</mo><mi>T</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">\mu_{T b} \circ T f</annotation></semantics></math>
Haskellの記法だと次のようになる。</p>
<div class="sourceCode">
<pre
class="sourceCode haskell"><code class="sourceCode haskell">G f<sub>T</sub> = join . fmap f</code></pre>
</div>
<p>これはモナド的なbindの<code>join</code>に基づく定義であると確認できるだろう。</p>
<p>2つの関手が随伴を形成しているのは容易に理解できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>⊣</mo><mi>G</mi></mrow><annotation encoding="application/x-tex">F \dashv G</annotation></semantics></math>
そして、それらの合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>∘</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">G \circ F</annotation></semantics></math>はもとのモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>を再現する。</p>
<p>したがって、これは同じモナドを生成する2番目の随伴だ。実際に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐀</mi><mi>𝐝</mi><mi>𝐣</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo>,</mo><mi>T</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Adj}(\mathbf{C}, T)</annotation></semantics></math>
という、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>における同じモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>を生成するような随伴全体の圏が存在する。その圏では、いま見たクライスリ随伴が始対象で、アイレンバーグ・ムーア随伴が終対象だ。</p>
<h2 data-number="25.3" id="コモナドの余代数"><span
class="header-section-number">25.3</span> コモナドの余代数</h2>
<p>同様の構成は任意の<a
href="#comonads">コモナド</a><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>に対して行える。コモナドと整合する余代数の圏を定義できる。それらの余代数は次の図式を可換にする。</p>
<div style="display:flex">
<script type="text/tikz">
\begin{tikzcd}[column sep=large, row sep=large]
  a \arrow[rd, equal]
  & Wa \arrow[l, "\varepsilon_a"'] \\
  & a \arrow[u, "\mathit{coa}"']
\end{tikzcd}
</script>
<script type="text/tikz">
\begin{tikzcd}[column sep=large, row sep=large]
  W(Wa)
  & Wa \arrow[l, "W \mathit{coa}"'] \\
  Wa \arrow[u, "\delta_a"]
  & a \arrow[u, "\mathit{coa}"] \arrow[l, "\mathit{coa}"']
\end{tikzcd}
</script>
</div>
<p>
ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑐</mi><mi>𝑜</mi><mi>𝑎</mi></mrow><annotation encoding="application/x-tex">\mathit{coa}</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を台とする余代数の余評価射
(coevaluation morphism) である。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑐</mi><mi>𝑜</mi><mi>𝑎</mi></mrow><mo>∷</mo><mi>a</mi><mo>→</mo><mi>W</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\mathit{coa} \Colon a \to W a</annotation></semantics></math>
そして、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>δ</mi><annotation encoding="application/x-tex">\delta</annotation></semantics></math>はコモナドを定義する2つの自然変換である（Haskellでは、これらの成分は<code>extract</code>および<code>duplicate</code>と呼ばれる）。</p>
<p>これらの余代数がなす圏から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>へは自明な忘却関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>U</mi><mi>W</mi></msup><annotation encoding="application/x-tex">U^W</annotation></semantics></math>が存在する。それはただ余評価を忘却している。その右随伴<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mi>W</mi></msup><annotation encoding="application/x-tex">F^W</annotation></semantics></math>について考えよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>U</mi><mi>W</mi></msup><mo>⊣</mo><msup><mi>F</mi><mi>W</mi></msup></mrow><annotation encoding="application/x-tex">U^W \dashv F^W</annotation></semantics></math>
忘却関手のこの右随伴は余自由関手 (cofree functor)
と呼ばれる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mi>W</mi></msup><annotation encoding="application/x-tex">F^W</annotation></semantics></math>は余自由余代数
(cofree coalgebra)
を生成する。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>に余代数
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>W</mi><mi>a</mi><mo>,</mo><msub><mi>δ</mi><mi>a</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(W a, \delta_a)</annotation></semantics></math>
を割り当てる。この随伴はもとのコモナドを合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mi>W</mi></msup><mo>∘</mo><msup><mi>U</mi><mi>W</mi></msup></mrow><annotation encoding="application/x-tex">F^W \circ U^W</annotation></semantics></math>として再生成する。</p>
<p>同様に、余クライスリ射から余クライスリ圏を構築でき、対応する随伴からコモナドを再生成できる。</p>
<h2 data-number="25.4" id="レンズ"><span
class="header-section-number">25.4</span> レンズ</h2>
<p>レンズの話に戻ろう。レンズは余代数として書ける。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑐</mi><mi>𝑜</mi><mi>𝑎</mi><mi>𝑙</mi><msub><mi>𝑔</mi><mi>𝑠</mi></msub></mrow><mo>∷</mo><mi>a</mi><mo>→</mo><mrow><mi>𝑆</mi><mi>𝑡</mi><mi>𝑜</mi><mi>𝑟</mi><mi>𝑒</mi></mrow><mspace width="0.222em"></mspace><mi>s</mi><mspace width="0.222em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">\mathit{coalg_s} \Colon a \to \mathit{Store}\ s\ a</annotation></semantics></math>
ここで関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑆</mi><mi>𝑡</mi><mi>𝑜</mi><mi>𝑟</mi><mi>𝑒</mi></mrow><mspace width="0.222em"></mspace><mi>s</mi></mrow><annotation encoding="application/x-tex">\mathit{Store}\ s</annotation></semantics></math>は次のとおりだ。</p>
<div class="sourceCode" id="cb547"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb547-1"><a href="#cb547-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Store</span> s a <span class="ot">=</span> <span class="dt">Store</span> (s <span class="ot">-&gt;</span> a) s</span></code></pre></div>
<p> この余代数は、以下の関数のペアとしても表せる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>s</mi><mi>e</mi><mi>t</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>a</mi><mo>→</mo><mi>s</mi><mo>→</mo><mi>a</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>g</mi><mi>e</mi><mi>t</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>a</mi><mo>→</mo><mi>s</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
set &amp;\Colon a \to s \to a \\
get &amp;\Colon a \to s
\end{aligned}
</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>は「すべて」(all)
を表し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>はその「小さな」(small)
一部だと考えてほしい)。このペアに関して、次が成り立つ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑐</mi><mi>𝑜</mi><mi>𝑎</mi><mi>𝑙</mi><msub><mi>𝑔</mi><mi>𝑠</mi></msub></mrow><mspace width="0.222em"></mspace><mi>a</mi><mo>=</mo><mrow><mi>𝑆</mi><mi>𝑡</mi><mi>𝑜</mi><mi>𝑟</mi><mi>𝑒</mi></mrow><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝑠</mi><mi>𝑒</mi><mi>𝑡</mi></mrow><mspace width="0.222em"></mspace><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><mrow><mi>𝑔</mi><mi>𝑒</mi><mi>𝑡</mi></mrow><mspace width="0.222em"></mspace><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{coalg_s}\ a = \mathit{Store}\ (\mathit{set}\ a)\ (\mathit{get}\ a)</annotation></semantics></math>
ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>は型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の値だ。部分適用された<code>set</code>は関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">s \to a</annotation></semantics></math>であることに注意してほしい。</p>
<p>また、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑆</mi><mi>𝑡</mi><mi>𝑜</mi><mi>𝑟</mi><mi>𝑒</mi></mrow><mspace width="0.222em"></mspace><mi>s</mi></mrow><annotation encoding="application/x-tex">\mathit{Store}\ s</annotation></semantics></math>がコモナドなのも分かっている。</p>
<div class="sourceCode" id="cb548"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb548-1"><a href="#cb548-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Comonad</span> (<span class="dt">Store</span> s) <span class="kw">where</span></span>
<span id="cb548-2"><a href="#cb548-2" aria-hidden="true" tabindex="-1"></a>  extract (<span class="dt">Store</span> f s) <span class="ot">=</span> f s</span>
<span id="cb548-3"><a href="#cb548-3" aria-hidden="true" tabindex="-1"></a>  duplicate (<span class="dt">Store</span> f s) <span class="ot">=</span> <span class="dt">Store</span> (<span class="dt">Store</span> f) s</span></code></pre></div>
<p>
問題は、あるレンズがこのコモナドの余代数になる条件は何かということだ。第1のコヒーレンス条件
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mi>a</mi></msub><mo>∘</mo><mrow><mi>𝑐</mi><mi>𝑜</mi><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow><mo>=</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">\varepsilon_a \circ \mathit{coalg} = %
\mathbf{id}_{a}%
</annotation></semantics></math> は、次のように解釈できる。</p>
<div class="sourceCode" id="cb549"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb549-1"><a href="#cb549-1" aria-hidden="true" tabindex="-1"></a>set a (get a) <span class="ot">=</span> a</span></code></pre></div>
<p>
このレンズ則は、データ構造<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>のフィールドをもともとの値に設定しても何も変わらないという事実を表す<a
href="#fn153" class="footnote-ref" id="fnref153"
role="doc-noteref"><sup>153</sup></a>。</p>
<p>第2の条件
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑓</mi><mi>𝑚</mi><mi>𝑎</mi><mi>𝑝</mi></mrow><mspace width="0.222em"></mspace><mrow><mi>𝑐</mi><mi>𝑜</mi><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow><mo>∘</mo><mrow><mi>𝑐</mi><mi>𝑜</mi><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow><mo>=</mo><msub><mi>δ</mi><mi>a</mi></msub><mo>∘</mo><mrow><mi>𝑐</mi><mi>𝑜</mi><mi>𝑎</mi><mi>𝑙</mi><mi>𝑔</mi></mrow></mrow><annotation encoding="application/x-tex">\mathit{fmap}\ \mathit{coalg} \circ \mathit{coalg} = \delta_a \circ \mathit{coalg}</annotation></semantics></math>
は、もう少し手間がかかる。まず、<code>store</code>関手の<code>fmap</code>の定義を思い出してほしい。</p>
<div class="sourceCode" id="cb550"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb550-1"><a href="#cb550-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> g (<span class="dt">Store</span> f s) <span class="ot">=</span> <span class="dt">Store</span> (g <span class="op">.</span> f) s</span></code></pre></div>
<p>
<code>fmap coalg</code>を<code>coalg</code>の結果に適用すると、次のようになる。</p>
<div class="sourceCode" id="cb551"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb551-1"><a href="#cb551-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Store</span> (coalg <span class="op">.</span> set a) (get a)</span></code></pre></div>
<p>
一方、<code>duplicate</code>を<code>coalg</code>の結果に適用すると、次のようになる。</p>
<div class="sourceCode" id="cb552"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb552-1"><a href="#cb552-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Store</span> (<span class="dt">Store</span> (set a)) (get a)</span></code></pre></div>
<p>
これら2つの式が等しくなるには、<code>Store</code>の下の2つの関数はどのような<code>s</code>に作用しても等しくなければならない。</p>
<div class="sourceCode" id="cb553"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb553-1"><a href="#cb553-1" aria-hidden="true" tabindex="-1"></a>coalg (set a s) <span class="ot">=</span> <span class="dt">Store</span> (set a) s</span></code></pre></div>
<p> <code>coalg</code>を展開すると、次が得られる。</p>
<div class="sourceCode" id="cb554"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb554-1"><a href="#cb554-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Store</span> (set (set a s)) (get (set a s)) <span class="ot">=</span> <span class="dt">Store</span> (set a) s</span></code></pre></div>
<p> これは残り2つのレンズ則と等価だ。1つ目</p>
<div class="sourceCode" id="cb555"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb555-1"><a href="#cb555-1" aria-hidden="true" tabindex="-1"></a>set (set a s) <span class="ot">=</span> set a</span></code></pre></div>
<p>
は、フィールドの値を2回設定するのは1回設定するのと同じだということを表す<a
href="#fn154" class="footnote-ref" id="fnref154"
role="doc-noteref"><sup>154</sup></a>。2つ目</p>
<div class="sourceCode" id="cb556"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb556-1"><a href="#cb556-1" aria-hidden="true" tabindex="-1"></a>get (set a s) <span class="ot">=</span> s</span></code></pre></div>
<p>
は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>に設定されたフィールドの値を取得すると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>が返されることを表す<a
href="#fn155" class="footnote-ref" id="fnref155"
role="doc-noteref"><sup>155</sup></a>。</p>
<p>言い換えれば、とても振る舞いの良い (very well behaved)
レンズはまさに<code>store</code>関手のコモナド余代数だ<a href="#fn156"
class="footnote-ref" id="fnref156"
role="doc-noteref"><sup>156</sup></a>。</p>
<aside id="footnotes-78" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="153">
<li
id="fn153"><p>訳注：以下の参考文献に従い、このレンズ則をGETPUTと呼ぶ。
参考：J. Nathan Foster, Michael B. Greenwald, Jonathan T. Moore,
Benjamin C. Pierce, and Alan Schmitt. 2007. <em>Combinators for
bidirectional tree transformations: A linguistic approach to the
view-update problem</em>. ACM Trans. Program. Lang. Syst. 29, 3 (May
2007), 17–es. <a href="https://doi.org/10.1145/1232420.1232424"
class="uri">https://doi.org/10.1145/1232420.1232424</a><a
href="#fnref153" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn154"><p>訳注：同じく、PUTPUTと呼ぶ。<a href="#fnref154"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn155"><p>訳注：同じく、PUTGETと呼ぶ。<a href="#fnref155"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn156"><p>訳注：GETPUTとPUTGETを満たすレンズをwell-behavedと呼び、さらにPUTPUTも満たすレンズをvery
well behavedと呼ぶ。<a href="#fnref156" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="25.5" id="課題-19"><span
class="header-section-number">25.5</span> 課題</h2>
<ol type="1">
<li>自由関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mi>T</mi></msup><mo>∷</mo><mi>C</mi><mo>→</mo><msup><mi>C</mi><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">F^T \Colon C \to C^T</annotation></semantics></math>の射に対する作用は何か。ヒント：モナドの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>について自然性条件を使う。</li>
<li>次の随伴を定義せよ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>U</mi><mi>W</mi></msup><mo>⊣</mo><msup><mi>F</mi><mi>W</mi></msup></mrow><annotation encoding="application/x-tex">U^W \dashv F^W</annotation></semantics></math></li>
<li>上記の随伴がもとのコモナドを再現することを証明せよ。</li>
</ol>
<h1 data-number="26" id="ends-and-coends"><span
class="header-section-number">26</span> エンドとコエンド</h1>
<p>圏内の射に当てはまる直観はたくさんあるが、誰もが同意できるのは、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への射があれば、2つの対象には何らかの「関係がある」というものだ。ある意味で、射はこの関係の証明だ。このことは任意の半順序集合を圏と見なしたものにおいては一目瞭然となる。そこでは射が［訳注：半順序］関係<em>そのものである</em>からだ。一般に、2対象間の同一の関係についてもその「証明」は複数あり得る。それらの証明は我々がhom集合と呼んでいた集合をなす。対象を変化させていくことで、対象のペアから「証明」の集合への写像が得られる。この写像は関手的だ――1番目の引数については反変で、2番目の引数については共変だ。このことは、その圏内の対象間に大域的な関係を確立していると見なせる。この関係は次のhom関手で表せる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo>,</mo><mo>=</mo><mo stretchy="false" form="postfix">)</mo><mo>∷</mo><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>×</mo><mrow></mrow><mi>𝐂</mi><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{C}(-, =) \Colon \mathbf{C}^\mathit{op}\times{}\mathbf{C} \to \mathbf{Set}</annotation></semantics></math>
一般に、このような関手はすべて、圏内の対象間の関係を確立するものとして解釈できる。関係には2つの異なる圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>が含まれる場合もある。その場合の関手は、そのような関係を表すことになり、次のようなシグネチャーを持ち、プロ関手
(profunctor) と呼ばれる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>∷</mo><msup><mi>𝐃</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>×</mo><mrow></mrow><mi>𝐂</mi><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">p \Colon \mathbf{D}^\mathit{op}\times{}\mathbf{C} \to \mathbf{Set}</annotation></semantics></math>
数学者はこれを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>へのプロ関手（反転に注意）と呼んでいて、斜線付き矢印で表記する。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo>↛</mo><mi>𝐃</mi></mrow><annotation encoding="application/x-tex">\mathbf{C} \nrightarrow \mathbf{D}</annotation></semantics></math>
プロ関手は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>の対象と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の対象の間の<span
id="proof-relevant_relation"
class="keyword"><em>証明を区別する関係</em></span> (proof-relevant
relation)
と見なせる。ここで、集合の要素は関係の証明を記号化している。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">p\ a\ b</annotation></semantics></math>が空の場合は常に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の間に関係はない。関係は対称である必要はないことに注意してほしい。</p>
<p>もう1つの有用な直観は、自己関手はコンテナーであるという考え方の一般化だ。型が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">p\ a\ b</annotation></semantics></math>のプロ関手の値は、型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の要素をキーとする<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>のコンテナーと見なせる。特に、homプロ関手の要素は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への関数だ。</p>
<p>Haskellでは、プロ関手は2引数の型構成子<code>p</code>として定義され、関数のペアを持ち上げる<code>dimap</code>と呼ばれるメソッドを備えている。そのペアのうち1番目の関数は「間違った」方向を向いている。</p>
<div class="sourceCode" id="cb557"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb557-1"><a href="#cb557-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Profunctor</span> p <span class="kw">where</span></span>
<span id="cb557-2"><a href="#cb557-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    dimap ::</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p c d</span></code></pre></div>
<p>
プロ関手の関手性は、<code>a</code>が<code>b</code>に関係しているという証明があれば、<code>c</code>が<code>d</code>に関係しているという証明も、<code>c</code>から<code>a</code>への射と<code>b</code>から<code>d</code>への別の射がある限り手に入ることを示している。あるいは、1番目の関数は新しいキーを古いキーに変換し、2番目の関数はコンテナーの内容を変更するとも見なせる。</p>
<p>1つの圏内で作用するプロ関手では、型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">p\ a\ a</annotation></semantics></math>の対角要素からかなり多くの情報が取り出せる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>に関係していることは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">b \to a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \to c</annotation></semantics></math>という射のペアがある限り証明できる。さらには、たった1つの射を使って非対角値に到達することもできる。たとえば、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to b</annotation></semantics></math>があれば、ペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>f</mi><mo>,</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>b</mi></msub><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle f, %
\mathbf{id}_{b}%
 \rangle</annotation></semantics></math>を持ち上げることで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>b</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">p\ b\ b</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">p\ a\ b</annotation></semantics></math>へ向かえる。</p>
<div class="sourceCode" id="cb558"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb558-1"><a href="#cb558-1" aria-hidden="true" tabindex="-1"></a>dimap f <span class="fu">id</span><span class="ot"> pbb ::</span> p a b</span></code></pre></div>
<p>
あるいは、ペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle %
\mathbf{id}_{a}%
, f \rangle</annotation></semantics></math>を持ち上げることでも<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">p\ a\ a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">p\ a\ b</annotation></semantics></math>へ向かえる。</p>
<div class="sourceCode" id="cb559"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb559-1"><a href="#cb559-1" aria-hidden="true" tabindex="-1"></a>dimap <span class="fu">id</span> f<span class="ot"> paa ::</span> p a b</span></code></pre></div>
<h2 data-number="26.1" id="対角自然変換"><span
class="header-section-number">26.1</span> 対角自然変換</h2>
<p>プロ関手は関手なので、それらの間の自然変換は通常の方法で定義できる。ただし、多くの場合は2つのプロ関手の対角要素間の写像を定義するだけで十分だ。このような変換は、対角要素を非対角要素に接続できる2つの方法を反映した可換条件を満たす場合、対角自然変換
(dinatural transformation)
と呼ばれる。関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>×</mo><mrow></mrow><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}\mathbf{C}^\mathit{op}\times{}\mathbf{C}, \mathbf{Set}{]}</annotation></semantics></math>の要素である2つのプロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>について、その間の対角自然変換は射の族
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>a</mi></msub><mo>∷</mo><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>a</mi><mo>→</mo><mi>q</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">\alpha_a \Colon p\ a\ a \to q\ a\ a</annotation></semantics></math>
で、任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to b</annotation></semantics></math>について次の図式が可換となるようなものだ。</p>
<p> <img src="images/end.jpg" style="width:35.0%" /> </p>
<p>
これは厳密に自然性条件より弱いことに注意してほしい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>×</mo><mrow></mrow><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}\mathbf{C}^\mathit{op}\times{}\mathbf{C}, \mathbf{Set}{]}</annotation></semantics></math>内の自然変換だったなら、前記の図式は2つの自然性の正方図式と1つの関手性条件（プロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>が合成を保存すること）から構成できただろう。</p>
<p> <img src="images/end-1.jpg" style="width:40.0%" /> </p>
<p>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><msup><mi>𝐂</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>×</mo><mrow></mrow><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}\mathbf{C}^\mathit{op}\times{}\mathbf{C}, \mathbf{Set}{]}</annotation></semantics></math>内の自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>についての成分は、対象のペアによって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mrow><mi>a</mi><mi>b</mi></mrow></msub><annotation encoding="application/x-tex">\alpha_{a b}</annotation></semantics></math>のように添字付けされていることに注意してほしい。一方で、対角自然変換は1つの対象によって添字付けされる。対応するプロ関手の対角要素のみを写すからだ。</p>
<h2 data-number="26.2" id="エンド"><span
class="header-section-number">26.2</span> エンド</h2>
<p>いまや「代数」から圏論の「微積分」と見なせるものへ進む準備ができた。エンド（およびコエンド）の微積分は、古典的な微積分から、その概念だけでなく記法さえいくつか借用している。特に、コエンドは無限和あるいは積分として理解でき、エンドは無限積に類似している。ディラックのデルタ関数に似たものさえある。</p>
<p>エンドは極限を一般化したもので、関手がプロ関手に置き換えられている。錐の代わりに、くさび
(wedge)
がある。くさびの底面はプロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>の対角要素によって形成される。くさびの頂点は対象（ここでは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>値のプロ関手を想定しているため、集合）であり、側面は頂点を底面内の集合に写す関数の族だ。この族は、1つの多相関数――戻り値の型が多相である関数――と見なせる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∷</mo><mo>∀</mo><mi>a</mi><mspace width="0.222em"></mspace><mi>.</mi><mspace width="0.222em"></mspace><mrow><mi>𝑎</mi><mi>𝑝</mi><mi>𝑒</mi><mi>𝑥</mi></mrow><mo>→</mo><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">\alpha \Colon \forall a\ .\ \mathit{apex} \to p\ a\ a</annotation></semantics></math>
錐とは違って、くさびには底面の頂点同士を接続する関数はない。しかし、すでに見たとおり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の任意の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to b</annotation></semantics></math>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">p\ a\ a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>b</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">p\ b\ b</annotation></semantics></math>の両方を共通の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">p\ a\ b</annotation></semantics></math>に接続できる。したがって、次の図式が可換だと主張できる。</p>
<p> <img src="images/end-2.jpg" style="width:40.0%" /> </p>
<p> これは<span id="wedge_condition"
class="keyword"><em>くさび条件</em></span> (wedge condition)
と呼ばれる。これは次のように書ける。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub><mspace width="0.222em"></mspace><mi>f</mi><mo>∘</mo><msub><mi>α</mi><mi>a</mi></msub><mo>=</mo><mi>p</mi><mspace width="0.222em"></mspace><mi>f</mi><mspace width="0.222em"></mspace><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>b</mi></msub><mo>∘</mo><msub><mi>α</mi><mi>b</mi></msub></mrow><annotation encoding="application/x-tex">p\ %
\mathbf{id}_{a}%
\ f \circ \alpha_a = p\ f\ %
\mathbf{id}_{b}%
 \circ \alpha_b</annotation></semantics></math>
あるいは、Haskellの記法を使うと次のようになる。</p>
<div class="sourceCode" id="cb560"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb560-1"><a href="#cb560-1" aria-hidden="true" tabindex="-1"></a>dimap <span class="fu">id</span> f <span class="op">.</span> alpha <span class="ot">=</span> dimap f <span class="fu">id</span> <span class="op">.</span> alpha</span></code></pre></div>
<p>
ここで普遍的構成を使って進み、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>のエンドを普遍くさび
(universal wedge)
として定義できる。これは集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math>に関数の族<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math>を伴ったもので、頂点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と族<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>の組からなる他のすべてのくさびについて、すべての三角図式を可換にする一意な関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">h \Colon a \to e</annotation></semantics></math>が存在するようなものだ。すなわち、
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>a</mi></msub><mo>∘</mo><mi>h</mi><mo>=</mo><msub><mi>α</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">\pi_a \circ h = \alpha_a</annotation></semantics></math></p>
<p> <img src="images/end-21.jpg" style="width:40.0%" /> </p>
<p> エンドの記号は、下付きの「積分変数」を添えた積分記号だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mi>c</mi></msub><mi>p</mi><mspace width="0.222em"></mspace><mi>c</mi><mspace width="0.222em"></mspace><mi>c</mi></mrow><annotation encoding="application/x-tex">\int_c p\ c\ c</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>π</mi><annotation encoding="application/x-tex">\pi</annotation></semantics></math>の成分はエンドの射影写像
(projection map) と呼ばれる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mi>a</mi></msub><mo>∷</mo><msub><mo>∫</mo><mi>c</mi></msub><mi>p</mi><mspace width="0.222em"></mspace><mi>c</mi><mspace width="0.222em"></mspace><mi>c</mi><mo>→</mo><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">\pi_a \Colon \int_c p\ c\ c \to p\ a\ a</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>が離散圏（恒等射以外の射がない）の場合、エンドは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>全体にわたる<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>のすべての対角要素の大域的な積になる。後ほど説明するが、より一般には、この積とエンドの間には等化子を介した関係がある。</p>
<p>Haskellでは、エンドの式は全称量化子 (universal quantifier)
に直接変換される。</p>
<div class="sourceCode" id="cb561"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb561-1"><a href="#cb561-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> a<span class="op">.</span> p a a</span></code></pre></div>
<p>
厳密に言うと、これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>のすべての対角要素の積にすぎないが、くさび条件は<a
href="https://bartoszmilewski.com/2017/04/11/profunctor-parametricity/">パラメトリシティ</a><a
href="#fn157" class="footnote-ref" id="fnref157"
role="doc-noteref"><sup>157</sup></a>によって自動的に満たされる。任意の関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to b</annotation></semantics></math>について、くさび条件は次のようになる。</p>
<div class="sourceCode" id="cb562"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb562-1"><a href="#cb562-1" aria-hidden="true" tabindex="-1"></a>dimap f <span class="fu">id</span> <span class="op">.</span> <span class="fu">pi</span> <span class="ot">=</span> dimap <span class="fu">id</span> f <span class="op">.</span> <span class="fu">pi</span></span></code></pre></div>
<p> あるいは、型注釈を付けると次のようになる。</p>
<div class="sourceCode">
<pre
class="sourceCode haskell"><code class="sourceCode haskell">dimap f id<sub>b</sub> . pi<sub>b</sub> = dimap id<sub>a</sub> f . pi<sub>a</sub></code></pre>
</div>
<p> この式の両辺の型は</p>
<div class="sourceCode" id="cb563"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb563-1"><a href="#cb563-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> (<span class="kw">forall</span> c<span class="op">.</span> p c c) <span class="ot">-&gt;</span> p a b</span></code></pre></div>
<p> であり、<code>pi</code>は多相射影だ。</p>
<div class="sourceCode" id="cb564"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb564-1"><a href="#cb564-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pi</span><span class="ot"> ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> <span class="kw">forall</span> c<span class="op">.</span> (<span class="kw">forall</span> a<span class="op">.</span> p a a) <span class="ot">-&gt;</span> p c c</span>
<span id="cb564-2"><a href="#cb564-2" aria-hidden="true" tabindex="-1"></a><span class="fu">pi</span> e <span class="ot">=</span> e</span></code></pre></div>
<p>
ここで、型推論によって自動的に<code>e</code>の正しい成分が選択される。</p>
<p>錐のすべての可換条件を1つの自然変換として表せたように、すべてのくさび条件も1つの対角自然変換にまとめられる。そのためには、定関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>を、対象のすべてのペアを単一の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>に写し射のすべてのペアをその対象の恒等射に写すような定プロ関手
(constant profunctor) へと一般化する必要がある。
くさびは、その関手からプロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>への対角自然変換だ。実際、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>がすべての射を単一の恒等関数に持ち上げることに気付けば、対角自然性の六角形はくさびのダイヤモンドへと収縮できる。</p>
<p>行き先の圏が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>でなくてもその圏に対してエンドを定義できるが、これ以降では集合値プロ関手
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>-valued
profunctor) とそのエンドのみを扱う。</p>
<aside id="footnotes-79" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="157">
<li id="fn157"><p><a
href="https://bartoszmilewski.com/2017/04/11/profunctor-parametricity/"
class="uri">https://bartoszmilewski.com/2017/04/11/profunctor-parametricity/</a><a
href="#fnref157" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="26.3" id="等化子としてのエンド"><span
class="header-section-number">26.3</span> 等化子としてのエンド</h2>
<p>エンドの定義における可換条件は等化子を用いて書ける。まず、2つの関数を定義しよう（ここでは数学的記法はあまりユーザーフレンドリーではないと思うので、Haskellの記法を用いる）。それらの関数はくさび条件での収束する2つの分岐に対応する。</p>
<div class="sourceCode" id="cb565"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb565-1"><a href="#cb565-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lambda ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> p a a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a b</span>
<span id="cb565-2"><a href="#cb565-2" aria-hidden="true" tabindex="-1"></a>lambda paa f <span class="ot">=</span> dimap <span class="fu">id</span> f paa</span>
<span id="cb565-3"><a href="#cb565-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb565-4"><a href="#cb565-4" aria-hidden="true" tabindex="-1"></a><span class="ot">rho ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> p b b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a b</span>
<span id="cb565-5"><a href="#cb565-5" aria-hidden="true" tabindex="-1"></a>rho pbb f <span class="ot">=</span> dimap f <span class="fu">id</span> pbb</span></code></pre></div>
<p>
どちらの関数もプロ関手<code>p</code>の対角要素を次の型の多相関数に写す。</p>
<div class="sourceCode" id="cb566"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb566-1"><a href="#cb566-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ProdP</span> p <span class="ot">=</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a b</span></code></pre></div>
<p>
これらの関数の型は異なる。しかし、<code>p</code>のすべての対角要素を集めて大きな直積型を1つ形成すれば、それらの型を単一化できる。</p>
<div class="sourceCode" id="cb567"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb567-1"><a href="#cb567-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">DiaProd</span> p <span class="ot">=</span> <span class="dt">DiaProd</span> (<span class="kw">forall</span> a<span class="op">.</span> p a a)</span></code></pre></div>
<p>
関数<code>lambda</code>と<code>rho</code>はこの直積型からの写像を2つ導出する。</p>
<div class="sourceCode" id="cb568"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb568-1"><a href="#cb568-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lambdaP ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> <span class="dt">DiaProd</span> p <span class="ot">-&gt;</span> <span class="dt">ProdP</span> p</span>
<span id="cb568-2"><a href="#cb568-2" aria-hidden="true" tabindex="-1"></a>lambdaP (<span class="dt">DiaProd</span> paa) <span class="ot">=</span> lambda paa</span>
<span id="cb568-3"><a href="#cb568-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb568-4"><a href="#cb568-4" aria-hidden="true" tabindex="-1"></a><span class="ot">rhoP ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> <span class="dt">DiaProd</span> p <span class="ot">-&gt;</span> <span class="dt">ProdP</span> p</span>
<span id="cb568-5"><a href="#cb568-5" aria-hidden="true" tabindex="-1"></a>rhoP (<span class="dt">DiaProd</span> pbb) <span class="ot">=</span> rho pbb</span></code></pre></div>
<p>
<code>p</code>のエンドはこれら2つの関数の等化子だ。等化子は2つの関数が等しい最大の部分集合を選択することを思い出してほしい。ここでは、すべての対角要素たちの積の部分集合でくさびの図式を可換にするものが選択される。</p>
<h2 data-number="26.4" id="エンドとしての自然変換"><span
class="header-section-number">26.4</span> エンドとしての自然変換</h2>
<p>エンドの最も重要な例は自然変換の集合だ。2つの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>G</mi><annotation encoding="application/x-tex">G</annotation></semantics></math>の間の自然変換は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>a</mi><mo>,</mo><mi>G</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(F a, G a)</annotation></semantics></math>
という形式のhom集合から選択された射の族だ。もし自然性条件がなければ、自然変換の集合はこれらすべてのhom集合の積にすぎないだろう。実際、Haskellでは次のようになる。</p>
<div class="sourceCode" id="cb569"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb569-1"><a href="#cb569-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> a<span class="op">.</span> f a <span class="ot">-&gt;</span> g a</span></code></pre></div>
<p>
Haskellでこれが動作する理由は、自然性がパラメトリシティから導かれるためだ。ただし、Haskell以外では、このようなhom集合に渡るすべての対角要素が自然変換を生成するとは限らない。しかし、写像
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">⟩</mo><mo>↦</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>a</mi><mo>,</mo><mi>G</mi><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\langle a, b \rangle \mapsto \mathbf{C}(F a, G b)</annotation></semantics></math>
がプロ関手であることに注目すれば、そのエンドを研究するのは意味がある。くさび条件は次のとおりだ。</p>
<p> <img src="images/end1.jpg" style="width:40.0%" /> </p>
<p>
集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mi>c</mi></msub><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>c</mi><mo>,</mo><mi>G</mi><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\int_c \mathbf{C}(F c, G c)</annotation></semantics></math>
から要素を1つだけ選択しよう。この要素は2つの射影によって特定の変換の2つの成分に写される。それらを次のように呼ぼう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>τ</mi><mi>a</mi></msub></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>F</mi><mi>a</mi><mo>→</mo><mi>G</mi><mi>a</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>τ</mi><mi>b</mi></msub></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>F</mi><mi>b</mi><mo>→</mo><mi>G</mi><mi>b</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\tau_a &amp;\Colon F a \to G a \\
\tau_b &amp;\Colon F b \to G b
\end{aligned}
</annotation></semantics></math>
図式の左側の分岐では、hom関手を使って射のペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub><mo>,</mo><mi>G</mi><mi>f</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle %
\mathbf{id}_{a}%
, G f \rangle</annotation></semantics></math>を持ち上げる。このような持ち上げを前合成と後合成として一度に実装したのを思い出してほしい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\tau_a</annotation></semantics></math>に作用するとき、持ち上げられたペアから次が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>f</mi><mo>∘</mo><msub><mi>τ</mi><mi>a</mi></msub><mo>∘</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">G f \circ \tau_a \circ %
\mathbf{id}_{a}%
</annotation></semantics></math>
図式のもう一方の分岐からは次が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>b</mi></msub><mo>∘</mo><msub><mi>τ</mi><mi>b</mi></msub><mo>∘</mo><mi>F</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">%
\mathbf{id}_{b}%
 \circ \tau_b \circ F f</annotation></semantics></math>
くさび条件が要求するこれらの等しさは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>の自然性条件に他ならない。</p>
<h2 data-number="26.5" id="コエンド"><span
class="header-section-number">26.5</span> コエンド</h2>
<p>予想どおり、エンドの双対はコエンドと呼ばれる。それはくさびの双対で構成され、余くさび
(cowedge)
と呼ばれる（cowedgeの発音はco-wedgeで、cow-edgeではない）。</p>
<figure>
<img src="images/end-31.jpg" title="エッジの効いた牛 (An edgy cow)？"
style="width:25.0%" alt="エッジの効いた牛 (An edgy cow)？" />
<figcaption aria-hidden="true">エッジの効いた牛 (An edgy
cow)？</figcaption>
</figure>
<p> コエンドの記号は、上付きの「積分変数」を添えた積分記号だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>∫</mo><mi>c</mi></msup><mi>p</mi><mspace width="0.222em"></mspace><mi>c</mi><mspace width="0.222em"></mspace><mi>c</mi></mrow><annotation encoding="application/x-tex">\int^c p\ c\ c</annotation></semantics></math>
エンドが積に関連しているのと同様に、コエンドは余積すなわち和に関連している（この観点でコエンドは和の極限である積分に似ている）。射影を持つのではなく、プロ関手の対角要素からコエンドに向かう入射を持つ。余くさび条件がなければ、プロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>のコエンドは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">p\ a\ a</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>b</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">p\ b\ b</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>c</mi><mspace width="0.222em"></mspace><mi>c</mi></mrow><annotation encoding="application/x-tex">p\ c\ c</annotation></semantics></math>などのどれかだと言えただろう。あるいは、コエンドが単なる集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">p\ a\ a</annotation></semantics></math>になるような<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>が存在すると言えただろう。エンドの定義で使った全称量化子は、コエンドでは存在量化子
(existential quantifier) になる。</p>
<p>このため、擬似Haskellでは、コエンドを次のように定義する。</p>
<div class="sourceCode" id="cb570"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb570-1"><a href="#cb570-1" aria-hidden="true" tabindex="-1"></a>exists a<span class="op">.</span> p a a</span></code></pre></div>
<p>
Haskellで存在量化子を実装する標準的な方法では、全称量化されたデータ構成子を用いる<a
href="#fn158" class="footnote-ref" id="fnref158"
role="doc-noteref"><sup>158</sup></a>。したがって、次のように定義できる。</p>
<div class="sourceCode" id="cb571"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb571-1"><a href="#cb571-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Coend</span> p <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Coend</span> (p a a)</span></code></pre></div>
<p>
この背後にあるロジックは、型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">p\ a\ a</annotation></semantics></math>の族のうちどれからでも、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の選択によらずにコエンドを構築できるというものだ。</p>
<p>エンドが等化子を使って定義できるのと同様に、コエンドは<span
id="coequalizer" class="keyword"><em>余等化子</em></span> (coequalizer)
を使って記述できる。すべての余くさび条件は、要約すると、可能なすべての関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">b \to a</annotation></semantics></math>について<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">p\ a\ b</annotation></semantics></math>の単一の巨大な余積を取ることだ。これはHaskellでは存在型
(existential type) として表現される。</p>
<div class="sourceCode" id="cb572"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb572-1"><a href="#cb572-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SumP</span> p <span class="ot">=</span> <span class="kw">forall</span> a b<span class="op">.</span> <span class="dt">SumP</span> (b <span class="ot">-&gt;</span> a) (p a b)</span></code></pre></div>
<p>
この直和型を評価する方法は2つある。<code>dimap</code>を使って関数を持ち上げる方法と、プロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>に適用する方法だ。</p>
<div class="sourceCode" id="cb573"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb573-1"><a href="#cb573-1" aria-hidden="true" tabindex="-1"></a>lambda,<span class="ot"> rho ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> <span class="dt">SumP</span> p <span class="ot">-&gt;</span> <span class="dt">DiagSum</span> p</span>
<span id="cb573-2"><a href="#cb573-2" aria-hidden="true" tabindex="-1"></a>lambda (<span class="dt">SumP</span> f pab) <span class="ot">=</span> <span class="dt">DiagSum</span> (dimap f <span class="fu">id</span> pab)</span>
<span id="cb573-3"><a href="#cb573-3" aria-hidden="true" tabindex="-1"></a>rho    (<span class="dt">SumP</span> f pab) <span class="ot">=</span> <span class="dt">DiagSum</span> (dimap <span class="fu">id</span> f pab)</span></code></pre></div>
<p>
ここで、<code>DiagSum</code>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>の対角要素の和だ。</p>
<div class="sourceCode" id="cb574"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb574-1"><a href="#cb574-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DiagSum</span> p <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">DiagSum</span> (p a a)</span></code></pre></div>
<p>
これら2つの関数の余等化子はコエンドだ。余等化子は<code>DiagSum p</code>から、<code>lambda</code>または<code>rho</code>を同じ引数に対して適用することで得られる値を同一視することで得られる。ここで、引数は関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">b \to a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">p\ a\ b</annotation></semantics></math>の要素のペアだ。<code>lambda</code>と<code>rho</code>を適用すると、異なるかもしれない2つの値が生成され、それらの型は<code>DiagSum p</code>だ。コエンドでは、これらの2つの値が同一視され、余くさび条件が自動的に満たされる。</p>
<p>集合内の関連する要素を同一視するこのプロセスは形式的には、商を取る、と呼ばれる。商を定義するには<span
id="equivalence_relation" class="keyword"><em>同値関係</em></span>
(equivalence relation)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∼</mo><annotation encoding="application/x-tex">\sim</annotation></semantics></math>、つまり、反射律・対称律・推移律を満たすような関係が必要となる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mi>a</mi><mo>∼</mo><mi>a</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mi>a</mi><mo>∼</mo><mi>b</mi><mspace width="0.222em"></mspace><mtext mathvariant="normal">ならば</mtext><mspace width="0.222em"></mspace><mi>b</mi><mo>∼</mo><mi>a</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mi>a</mi><mo>∼</mo><mi>b</mi><mspace width="0.222em"></mspace><mtext mathvariant="normal">かつ</mtext><mspace width="0.222em"></mspace><mi>b</mi><mo>∼</mo><mi>c</mi><mspace width="0.222em"></mspace><mtext mathvariant="normal">ならば</mtext><mspace width="0.222em"></mspace><mi>a</mi><mo>∼</mo><mi>c</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
&amp;a \sim a \\
&amp;a \sim b\ \text{ならば}\ b \sim a \\
&amp;a \sim b\ \text{かつ}\ b \sim c\ \text{ならば}\ a \sim c
\end{aligned}
</annotation></semantics></math> このような関係は集合を同値類
(equivalence class)
に分割する。各同値類は相互に関連する要素たちで構成される。商集合は各同値類から1つの代表を選んで作られる。古典的な例は、以下の同値関係を持つ整数のペア（ただし2つ目は非ゼロ）の集合としての有理数の集合の定義だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>∼</mo><mo stretchy="false" form="prefix">(</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy="false" form="postfix">)</mo><mspace width="0.222em"></mspace><mtext mathvariant="normal">iff</mtext><mspace width="0.222em"></mspace><mi>a</mi><mo>*</mo><mi>d</mi><mo>=</mo><mi>b</mi><mo>*</mo><mi>c</mi><mo>,</mo><mspace width="0.222em"></mspace><mi>b</mi><mo>≠</mo><mn>0</mn><mo>,</mo><mspace width="0.222em"></mspace><mi>d</mi><mo>≠</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(a, b) \sim (c, d)\ \text{iff}\ a * d = b * c,\ b \neq 0,\ d \neq 0</annotation></semantics></math>
これが同値関係なのは簡単に確認できる。ペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a, b)</annotation></semantics></math>
は分数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mi>a</mi><mi>b</mi></mfrac><annotation encoding="application/x-tex">\frac{a}{b}</annotation></semantics></math>と見なせて、分子と分母が公約数を持つものは同一視される。有理数はそのような分数の同値類だ。</p>
<p>極限と余極限についての以前の議論から、hom関手は連続的、すなわち極限を保存することを思い出してほしい。双対性より、反変hom関手は余極限を極限に変える。これらの特性はエンドとコエンドに一般化できる。これらは、それぞれ極限と余極限を一般化したものだ。特に、コエンドをエンドに変換するのに非常に便利な恒等式が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><msup><mo>∫</mo><mi>x</mi></msup><mi>p</mi><mspace width="0.222em"></mspace><mi>x</mi><mspace width="0.222em"></mspace><mi>x</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><msub><mo>∫</mo><mi>x</mi></msub><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mspace width="0.222em"></mspace><mi>x</mi><mspace width="0.222em"></mspace><mi>x</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Set}(\int^x p\ x\ x, c) \cong \int_x \mathbf{Set}(p\ x\ x, c)</annotation></semantics></math>
擬似Haskellで見てみよう。</p>
<div class="sourceCode">
<pre
class="sourceCode haskell"><code class="sourceCode haskell">(exists x. p x x) -> c ≅ forall x. p x x -> c</code></pre>
</div>
<p>これは、存在型を取る関数はある多相関数と等価だと示している。これは完全に理にかなっている。そのような関数は、存在型として表される可能性のある型ならどれでも処理できるようになっている必要があるからだ。これは、直和型を受け入れる関数についての、すべての型に対応したハンドラーの組を持ったcase式として実装される、という原則と同じものだ。ここでは、直和型はコエンドに置き換えられ、ハンドラーの族はエンドすなわち多相関数になる。</p>
<aside id="footnotes-80" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="158">
<li
id="fn158"><p>監訳注：個人的な好みの範疇だが、存在量化のための全称量化子を使うのは混乱するので、後述のGADT構文を使って以下のようにするのがおすすめである。</p>
<p><code>data Coend p where</code></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace></mrow><annotation encoding="application/x-tex">\ \ </annotation></semantics></math><code>Coend :: p a a -&gt; Coend p</code><a
href="#fnref158" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="26.6" id="忍者米田の補題"><span
class="header-section-number">26.6</span> 忍者米田の補題</h2>
<p>米田の補題に現れる自然変換の集合はエンドを使って表せて、結果としてこう定式化できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mi>z</mi></msub><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>F</mi><mi>z</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\int_z \mathbf{Set}(\mathbf{C}(a, z), F z) \cong F a</annotation></semantics></math>
双対として次の式も存在する。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>∫</mo><mi>z</mi></msup><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>F</mi><mi>z</mi><mo>≅</mo><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\int^z \mathbf{C}(z, a)\times{}F z \cong F a</annotation></semantics></math>
この恒等式はディラックのデルタ関数の式（関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>−</mo><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\delta(a - z)</annotation></semantics></math>、というより<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">a = z</annotation></semantics></math>に無限大のピークを持つ分布）を強く連想させる。ここでは、hom関手がデルタ関数の役割を果たしている。</p>
<p>これら2つの恒等式を合わせて忍者米田の補題 (Ninja Yoneda lemma)
と呼ぶことがある<a href="#fn159" class="footnote-ref" id="fnref159"
role="doc-noteref"><sup>159</sup></a>。</p>
<p>2番目の式を証明するには米田埋め込みからのある帰結を使う。つまり、2つの対象が同型となるのは、それらのhom関手が同型である場合に限られる。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≅</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \cong b</annotation></semantics></math>となるのは、次の型の自然変換
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mo>=</mo><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(a, -), \mathbf{C}(b, =))</annotation></semantics></math>
があって同型射である場合だけだ。</p>
<p>まず、証明したい同型の左辺を、任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>に向かうhom関手の内側に挿入する。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><msup><mo>∫</mo><mi>z</mi></msup><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>F</mi><mi>z</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Set}(\int^z \mathbf{C}(z, a)\times{}F z, c)</annotation></semantics></math>
連続性の議論を使うと、コエンドをエンドに置き換えられる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mi>z</mi></msub><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>F</mi><mi>z</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\int_z \mathbf{Set}(\mathbf{C}(z, a)\times{}F z, c)</annotation></semantics></math>
これで積と冪の間の随伴を利用できるようになった。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mi>z</mi></msub><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msup><mi>c</mi><mrow><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\int_z \mathbf{Set}(\mathbf{C}(z, a), c^{(F z)})</annotation></semantics></math>
米田の補題を使って「積分を実行」し、次が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mrow><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">c^{(F a)}</annotation></semantics></math>
(関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>c</mi><mrow><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>z</mi><mo stretchy="false" form="postfix">)</mo></mrow></msup><annotation encoding="application/x-tex">c^{(F z)}</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>について反変なので、米田の補題の反変版を使っていることに注意してほしい。)
この冪対象は次のhom集合と同型だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Set}(F a, c)</annotation></semantics></math>
最後に、米田埋め込みを利用して以下の同型に辿り着く。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mo>∫</mo><mi>z</mi></msup><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>z</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>F</mi><mi>z</mi><mo>≅</mo><mi>F</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">\int^z \mathbf{C}(z, a)\times{}F z \cong F a</annotation></semantics></math></p>
<aside id="footnotes-81" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="159">
<li
id="fn159"><p>訳注：この名前は、圏論に造詣が深いオーストラリアの数学者たちをレンスター
(Tom Leinster)
が「忍者圏論家たち」と形容したことに由来する。ただし、忍者圏論家たち自身は単に米田の定理と呼んでいた。<a
href="https://mathoverflow.net/questions/20445/coend-computation/20451#20451"
class="uri">https://mathoverflow.net/questions/20445/coend-computation/20451#20451</a>を参照のこと。なお、レンスターは『ベーシック圏論』の著者。<a
href="#fnref159" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="26.7" id="プロ関手の合成"><span
class="header-section-number">26.7</span> プロ関手の合成</h2>
<p>プロ関手が記述するのは関係――より正確には証明を区別する関係――だ、という考え方をさらに探求してみよう。つまり、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>b</mi></mrow><annotation encoding="application/x-tex">p\ a\ b</annotation></semantics></math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>に関連する証明の集合を表す。2つの関係<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>があるなら、それらを合成できる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mspace width="0.222em"></mspace><mi>b</mi><mspace width="0.222em"></mspace><mi>c</mi></mrow><annotation encoding="application/x-tex">q\ b\ c</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mspace width="0.222em"></mspace><mi>c</mi><mspace width="0.222em"></mspace><mi>a</mi></mrow><annotation encoding="application/x-tex">p\ c\ a</annotation></semantics></math>が両方とも空でないような中間対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>が存在するとき、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>q</mi><annotation encoding="application/x-tex">q</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>の後に合成したものを介して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>に関連していると言うことにする。この新しい関係の証明はすべて、個々の関係の証明の任意のペアである。したがって、存在量化子はコエンドに対応し、2つの集合のデカルト積は「証明のペア」に対応するという理解に基づいて、次の方法でプロ関手の合成を定義できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>q</mi><mo>∘</mo><mi>p</mi><mo stretchy="false" form="postfix">)</mo><mspace width="0.222em"></mspace><mi>a</mi><mspace width="0.222em"></mspace><mi>b</mi><mo>=</mo><msup><mo>∫</mo><mi>c</mi></msup><mi>p</mi><mspace width="0.222em"></mspace><mi>c</mi><mspace width="0.222em"></mspace><mi>a</mi><mo>×</mo><mrow></mrow><mi>q</mi><mspace width="0.222em"></mspace><mi>b</mi><mspace width="0.222em"></mspace><mi>c</mi></mrow><annotation encoding="application/x-tex">(q \circ p)\ a\ b = \int^c p\ c\ a\times{}q\ b\ c</annotation></semantics></math>
Haskellの<code>Data.Profunctor.Composition</code>における、プロ関手の同等の定義は以下のとおりだ。ただし、名前が多少変更されている。</p>
<div class="sourceCode" id="cb575"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb575-1"><a href="#cb575-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Procompose</span> q p a b <span class="kw">where</span></span>
<span id="cb575-2"><a href="#cb575-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Procompose</span><span class="ot"> ::</span> q a c <span class="ot">-&gt;</span> p c b <span class="ot">-&gt;</span> <span class="dt">Procompose</span> q p a b</span></code></pre></div>
<p> これは一般化代数的データ型 (generalized algebraic data
type、略称GADT)
の構文を使っており、自由型変数（ここでは<code>c</code>）が自動的に存在量化される。したがって、（非カリー化された）データ・コンストラクター<code>Procompose</code>は次と等価だ。</p>
<div class="sourceCode" id="cb576"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb576-1"><a href="#cb576-1" aria-hidden="true" tabindex="-1"></a>exists c<span class="op">.</span> (q a c, p c b)</span></code></pre></div>
<p>
こうして定義された合成の単位元はhom関手だ――これは忍者米田の補題から直ちに帰結される。そこで、プロ関手が射の役割を果たす圏があるかを問うのは理にかなっている。ある、というのがその問いの答えだ。ただし、プロ関手の合成に関する結合律と恒等律は自然同型を除いてのみ満たされることに注意する必要がある。それらの結合律と恒等律が同型を除いて満たされる圏は、双圏
(bicategory)
と呼ばれる（これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏より一般的である）。すなわち、双圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐏</mi><mi>𝐫</mi><mi>𝐨</mi><mi>𝐟</mi></mrow><annotation encoding="application/x-tex">\mathbf{Prof}</annotation></semantics></math>では、対象は圏であり、射はプロ関手であり、射同士の間の射
(別名2-セル)
は自然変換だ。実際には、さらに先へも進める。プロ関手以外にも圏間の射としての通常の関手があるからだ。2種類の射を持つ圏は二重圏
(double category) と呼ばれる。</p>
<p>プロ関手はHaskellの<code>lens</code>ライブラリーと<code>arrow</code>ライブラリーで重要な役割を果たしている<a
href="#fn160" class="footnote-ref" id="fnref160"
role="doc-noteref"><sup>160</sup></a><a href="#fn161"
class="footnote-ref" id="fnref161"
role="doc-noteref"><sup>161</sup></a>。</p>
<aside id="footnotes-82" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="160">
<li
id="fn160"><p>訳注：少なくとも標準ライブラリー（base）に含まれる<code>Control.Arrow</code>にはプロ関手についての陽な言及はない。しかしながら、arrowはプロ関手と関連が深く、（<code>Arrow</code>のメソッド<code>first :: p a b -&gt; p (a, c) (b, c)</code>
に対応する）strengthと呼ばれる演算を持つようなプロ関手たちの圏におけるモノイド対象となっている。参考：</p>
<ul>
<li>Exequiel Rivas, Mauro Jaskelioff: Notions of computation as monoids.
J. Funct. Program. 27: e21 (2017)</li>
<li>Bart Jacobs, Chris Heunen, Ichiro Hasuo: Categorical semantics for
arrows. J. Funct. Program. 19(3-4): 403-438 (2009)</li>
</ul>
<a href="#fnref160" class="footnote-back" role="doc-backlink">↩︎</a></li>
<li id="fn161"><p>監訳注：興味のある読者は、profunctor
opticsというプロ関手を用いたレンズやその関連概念の抽象化についても調べるとよい。</p>
<ul>
<li>Matthew Pickering, Jeremy Gibbons, and Nicolas Wu: Profunctor
Optics: Modular Data Accessors, The Art, Science, and Engineering of
Programming, 2017, Vol. 1, Issue 2, Article 7. <a
href="https://doi.org/10.22152/programming-journal.org/2017/1/7"
class="uri">https://doi.org/10.22152/programming-journal.org/2017/1/7</a></li>
<li><a href="https://hackage.haskell.org/package/profunctor-optics"
class="uri">https://hackage.haskell.org/package/profunctor-optics</a></li>
</ul>
<a href="#fnref161" class="footnote-back" role="doc-backlink">↩︎</a></li>
</ol>
</aside>
<h1 data-number="27" id="カン拡張"><span
class="header-section-number">27</span> カン拡張</h1>
<p>ここまでは、主に1つの圏または1対の圏を扱ってきた。しかし、それでは制約が強すぎる場合もある。</p>
<p>たとえば、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>で極限を定義するとき、添字圏
(index category)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>を導入し、錐の基礎となるパターンのテンプレートとした。錐の頂点のテンプレートとしては、別の自明な圏を導入した方が理にかなっていただろう。それなのに、代わりに<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>への定関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>を使った。</p>
<p>この不自然さを正す時が来た。極限を3つの圏を使って定義しよう。初めに、添字圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>について考える。これは錐の底面を指す関手――図式関手
(diagram functor) だ。</p>
<p> <img src="images/kan2.jpg" style="width:40.0%" /> </p>
<p>
新しく追加するのは、単一の対象（および単一の恒等射）を含むような圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟏</mn><annotation encoding="application/x-tex">\mathbf{1}</annotation></semantics></math>である。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>からこの圏への関手は1つしかない（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>と呼ぶ）。その関手は、すべての対象を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟏</mn><annotation encoding="application/x-tex">\mathbf{1}</annotation></semantics></math>内の唯一の対象に写し、すべての射をその対象に対する恒等射に写す。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟏</mn><annotation encoding="application/x-tex">\mathbf{1}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>へのどの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>も、ここでの錐の潜在的な頂点を指す。</p>
<p> <img src="images/kan15.jpg" style="width:40.0%" /> </p>
<p>
錐は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∘</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">F \circ K</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>への自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>となる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∘</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">F \circ K</annotation></semantics></math>はもとの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi mathvariant="normal">Δ</mi><mi>c</mi></msub><annotation encoding="application/x-tex">\Delta_c</annotation></semantics></math>と全く同じことを行うことに留意する。次の図式はこの変換を示している。</p>
<p> <img src="images/kan3-e1492120491591.jpg" style="width:40.0%" />
</p>
<p>
さて、ここで、このような関手のうち「最も優れた」関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>を選択するような普遍性を定義できる。この<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟏</mn><annotation encoding="application/x-tex">\mathbf{1}</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>の極限である対象に写し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∘</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">F \circ K</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>への自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>がそれに対応する射影を提供することになる。この普遍関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>に沿った<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>の右カン拡張
(right Kan extension)
と呼ばれ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi></mrow><annotation encoding="application/x-tex">\mathbf{Ran}_{K}D</annotation></semantics></math>で表される。</p>
<p>普遍性を定式化しよう。錐がもう1つあるとする――別の関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mo>′</mo></msup><annotation encoding="application/x-tex">F&#39;</annotation></semantics></math>と、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>′</mo></msup><mo>∘</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">F&#39; \circ K</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>への自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ε</mi><mo>′</mo></msup><annotation encoding="application/x-tex">\varepsilon&#39;</annotation></semantics></math>から構成された錐だ。</p>
<p> <img src="images/kan31-e1492120512209.jpg" style="width:40.0%" />
</p>
<p>
カン拡張<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>=</mo><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi></mrow><annotation encoding="application/x-tex">F = \mathbf{Ran}_{K}D</annotation></semantics></math>が存在するなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mo>′</mo></msup><annotation encoding="application/x-tex">F&#39;</annotation></semantics></math>からそれへの一意な自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math>が必ず存在し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ε</mi><mo>′</mo></msup><annotation encoding="application/x-tex">\varepsilon&#39;</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>を通じて次のように分解される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ε</mi><mo>′</mo></msup><mo>=</mo><mi>ε</mi><mo>⋅</mo><mo stretchy="false" form="prefix">(</mo><mi>σ</mi><mo>∘</mo><mi>K</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\varepsilon&#39; = \varepsilon \cdot (\sigma \circ K)</annotation></semantics></math>
ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>∘</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\sigma \circ K</annotation></semantics></math>は2つの自然変換の水平合成である（片方は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>における恒等自然変換である）。この変換はその後<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>と垂直合成される。</p>
<p> <img src="images/kan5.jpg" style="width:40.0%" /> </p>
<p>
成分でみると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>に作用するとき、次が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><msup><mi>ε</mi><mo>′</mo></msup><mi>i</mi></msub><mo>=</mo><msub><mi>ε</mi><mi>i</mi></msub><mo>∘</mo><msub><mi>σ</mi><mrow><mi>K</mi><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varepsilon&#39;_i = \varepsilon_i \circ \sigma_{K i}</annotation></semantics></math>
この例において、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math>の成分は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟏</mn><annotation encoding="application/x-tex">\mathbf{1}</annotation></semantics></math>の単一の対象に対応する1つ［訳注：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>σ</mi><mrow><mi>K</mi><mi>i</mi></mrow></msub><annotation encoding="application/x-tex">\sigma_{K i}</annotation></semantics></math>］しかない。そして、それは確かに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mo>′</mo></msup><annotation encoding="application/x-tex">F&#39;</annotation></semantics></math>が定義する錐の頂点から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi></mrow><annotation encoding="application/x-tex">\mathbf{Ran}_{K}D</annotation></semantics></math>が定義する普遍錐の頂点へ向かう一意な射となっている。その可換条件はまさに極限の定義で求められているものとなっている。</p>
<p>ただし、ここで重要なのは、自明な圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟏</mn><annotation encoding="application/x-tex">\mathbf{1}</annotation></semantics></math>を任意の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐀</mi><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math>に自由に置き換えたとしても、右カン拡張の定義は有効なままだということだ。</p>
<h2 data-number="27.1" id="右カン拡張"><span
class="header-section-number">27.1</span> 右カン拡張</h2>
<p>関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>∷</mo><mi>𝐈</mi><mo>→</mo><mi>𝐀</mi></mrow><annotation encoding="application/x-tex">K \Colon \mathbf{I} \to \mathbf{A}</annotation></semantics></math>に沿った関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>∷</mo><mi>𝐈</mi><mo>→</mo><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">D \Colon \mathbf{I} \to \mathbf{C}</annotation></semantics></math>の右カン拡張は、以下に述べるような自然変換を伴う関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∷</mo><mi>𝐀</mi><mo>→</mo><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">F \Colon \mathbf{A} \to \mathbf{C}</annotation></semantics></math>である（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi></mrow><annotation encoding="application/x-tex">\mathbf{Ran}_{K}D</annotation></semantics></math>と書く）。その自然変換
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>∷</mo><mi>F</mi><mo>∘</mo><mi>K</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">\varepsilon \Colon F \circ K \to D</annotation></semantics></math>
では、他のどの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>F</mi><mo>′</mo></msup><mo>∷</mo><mi>𝐀</mi><mo>→</mo><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">F&#39; \Colon \mathbf{A} \to \mathbf{C}</annotation></semantics></math>と自然変換
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ε</mi><mo>′</mo></msup><mo>∷</mo><msup><mi>F</mi><mo>′</mo></msup><mo>∘</mo><mi>K</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">\varepsilon&#39; \Colon F&#39; \circ K \to D</annotation></semantics></math>
についても、一意な自然変換
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>∷</mo><msup><mi>F</mi><mo>′</mo></msup><mo>→</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">\sigma \Colon F&#39; \to F</annotation></semantics></math>
が存在し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ε</mi><mo>′</mo></msup><annotation encoding="application/x-tex">\varepsilon&#39;</annotation></semantics></math>を
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>ε</mi><mo>′</mo></msup><mo>=</mo><mi>ε</mi><mo>⋅</mo><mo stretchy="false" form="prefix">(</mo><mi>σ</mi><mo>∘</mo><mi>K</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\varepsilon&#39; = \varepsilon \cdot (\sigma \circ K)</annotation></semantics></math>
のように分解する。
これはかなり長ったらしいが、図式ならすっきりと描ける。</p>
<p> <img src="images/kan7.jpg" style="width:40.0%" /> </p>
<p>
この図式の興味深い見方のひとつは、ある意味で、カン拡張が「関手の積」の逆のように作用していることだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi></mrow><annotation encoding="application/x-tex">\mathbf{Ran}_{K}D</annotation></semantics></math>に対して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">D/K</annotation></semantics></math>という表記を使う著者さえいる。実際、その表記なら、右カン拡張の余単位とも呼ばれる<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>の定義は単なる［訳注：積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∘</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">\circ K</annotation></semantics></math>の］取り消しのように見える。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>∷</mo><mi>D</mi><mi>/</mi><mi>K</mi><mo>∘</mo><mi>K</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">\varepsilon \Colon D/K \circ K \to D</annotation></semantics></math>
カン拡張には別の解釈もある。関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>が圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐀</mi><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math>の中に埋め込む場合について考える。最も単純なケースでは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>は単に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐀</mi><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math>の部分圏になる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>に写す関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>があるとする。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐀</mi><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math>全体で定義された関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>に拡張できるだろうか？　理想的には、そのような拡張によって合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∘</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">F \circ K</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>と同型となる。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>の域を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐀</mi><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math>に拡張することになる。しかし、本格的な同型は通常求めすぎで、半分で十分だ。つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∘</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">F \circ K</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>への片道の自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">\varepsilon</annotation></semantics></math>だけでよい。（逆方向は左カン拡張に対応する。）</p>
<p> <img src="images/kan6.jpg" style="width:40.0%" /> </p>
<p>
当然、この埋め込みの図は、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>が対象の単射ではなかったり、あるいはhom集合について忠実でなかったりする場合には当てはまらない。それこそ、極限の例［訳注：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">A = 1</annotation></semantics></math>であった］のように。そのような場合、カン拡張は失われた情報を推定するために最善を尽くす。</p>
<h2 data-number="27.2" id="随伴としてのカン拡張"><span
class="header-section-number">27.2</span> 随伴としてのカン拡張</h2>
<p>さて、右カン拡張が任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>（および固定された<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>）に対して存在するとしよう。この場合、（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>をダッシュで置き換えた）<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mo>−</mo></mrow><annotation encoding="application/x-tex">\mathbf{Ran}_{K}-</annotation></semantics></math>は関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐈</mi><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}\mathbf{I}, \mathbf{C}{]}</annotation></semantics></math>から関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐀</mi><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}\mathbf{A}, \mathbf{C}{]}</annotation></semantics></math>への関手となる。実はこの関手は前合成関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>−</mi><mo>∘</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">- \circ K</annotation></semantics></math>に対する右随伴になっている。この前合成関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐀</mi><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}\mathbf{A}, \mathbf{C}{]}</annotation></semantics></math>内の関手を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐈</mi><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}\mathbf{I}, \mathbf{C}{]}</annotation></semantics></math>内の関手に写す。この随伴は次のとおりだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐈</mi><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mo>∘</mo><mi>K</mi><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mo stretchy="false" form="prefix">[</mo><mi>𝐀</mi><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mo>,</mo><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\mathbf{I}, \mathbf{C}](F&#39; \circ K, D) \cong [\mathbf{A}, \mathbf{C}](F&#39;, \mathbf{Ran}_{K}D)</annotation></semantics></math>
これは、［訳注：右Kan拡張の定義において］<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>ε</mi><mo>′</mo></msup><annotation encoding="application/x-tex">\varepsilon&#39;</annotation></semantics></math>と呼んでいたどの自然変換も、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math>と呼んでいた一意な自然変換に対応しているという事実を単に言い換えたものだ。</p>
<p> <img src="images/kan92.jpg" style="width:40.0%" /> </p>
<p>
さらに、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と同じになるように選んだ場合は、恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mi>𝐂</mi></msub><annotation encoding="application/x-tex">I_{\mathbf{C}}</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>に代入できる。すると、次の恒等式が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐂</mi><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mo>∘</mo><mi>K</mi><mo>,</mo><msub><mi>I</mi><mi>𝐂</mi></msub><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mo stretchy="false" form="prefix">[</mo><mi>𝐀</mi><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mo>,</mo><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><msub><mi>I</mi><mi>𝐂</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{C}](F&#39; \circ K, I_{\mathbf{C}}) \cong [\mathbf{A}, \mathbf{C}](F&#39;, \mathbf{Ran}_{K}I_{\mathbf{C}})</annotation></semantics></math>
これで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mo>′</mo></msup><annotation encoding="application/x-tex">F&#39;</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><msub><mi>I</mi><mi>𝐂</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{Ran}_{K}I_{\mathbf{C}}</annotation></semantics></math>と同じになるように選べる。その場合、右辺は恒等自然変換を含み、その恒等自然変換に対応するものとして左辺から次の自然変換が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>∷</mo><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><msub><mi>I</mi><mi>𝐂</mi></msub><mo>∘</mo><mi>K</mi><mo>→</mo><msub><mi>I</mi><mi>𝐂</mi></msub></mrow><annotation encoding="application/x-tex">\varepsilon \Colon \mathbf{Ran}_{K}I_{\mathbf{C}} \circ K \to I_{\mathbf{C}}</annotation></semantics></math>
これは随伴の余単位によく似ている。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><msub><mi>I</mi><mi>𝐂</mi></msub><mo>⊣</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\mathbf{Ran}_{K}I_{\mathbf{C}} \dashv K</annotation></semantics></math>
実際、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>に沿った恒等関手の右カン拡張を使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>の左随伴を計算できる。そのためには、もう1つの条件が必要だ。すなわち、右カン拡張が関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>によって保存されなければならない。このカン拡張の保存が意味するのは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>に当該関手を前合成したもののカン拡張を計算すると、もとのカン拡張を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>に前合成したのと同じ結果が得られるということだ。ここでは、この条件は次のように単純化できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>∘</mo><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><msub><mi>I</mi><mi>𝐂</mi></msub><mo>≅</mo><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>K</mi></mrow><annotation encoding="application/x-tex">K \circ \mathbf{Ran}_{K}I_{\mathbf{C}} \cong \mathbf{Ran}_{K}K</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>による除算で表記すると、前述の随伴は次のように記述できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>/</mi><mi>K</mi><mo>⊣</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">I/K \dashv K</annotation></semantics></math>
これは随伴がある種の逆を表しているという直観を裏付ける。また、保存の条件は次のようになる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>∘</mo><mi>I</mi><mi>/</mi><mi>K</mi><mo>≅</mo><mi>K</mi><mi>/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">K \circ I/K \cong K/K</annotation></semantics></math>
ある関手自身に沿った右カン拡張<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mi>/</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">K/K</annotation></semantics></math>は余稠密モナド
(codensity monad) と呼ばれる。</p>
<p>この随伴の式は重要な結果だ。これからすぐ見るように、エンド（コエンド）を使ってカン拡張を計算でき、そこから右（左）随伴を見つける実用的な手段が得られるからだ。</p>
<h2 data-number="27.3" id="左カン拡張"><span
class="header-section-number">27.3</span> 左カン拡張</h2>
<p>左カン拡張を与えるような双対構成が存在する。直観を得るために、余極限の定義から始めて、単元圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟏</mn><annotation encoding="application/x-tex">\mathbf{1}</annotation></semantics></math>を使うようにそれを再構築するとしよう。余錐を作るには、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mo>∷</mo><mi>𝐈</mi><mo>→</mo><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">D \Colon \mathbf{I} \to \mathbf{C}</annotation></semantics></math>を使って底面を形成し、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∷</mo><mn>𝟏</mn><mo>→</mo><mi>𝐂</mi></mrow><annotation encoding="application/x-tex">F \Colon \mathbf{1} \to \mathbf{C}</annotation></semantics></math>を使って頂点を選択する。</p>
<p> <img src="images/kan81.jpg" style="width:40.0%" /> </p>
<p>
余錐の側面、つまり入射たちはどれも、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∘</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">F \circ K</annotation></semantics></math>への自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>の成分になっている。</p>
<p> <img src="images/kan10a.jpg" style="width:40.0%" /> </p>
<p>
余極限は普遍余錐だ。したがって、他のすべての関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mo>′</mo></msup><annotation encoding="application/x-tex">F&#39;</annotation></semantics></math>と自然変換
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>η</mi><mo>′</mo></msup><mo>∷</mo><mi>D</mi><mo>→</mo><msup><mi>F</mi><mo>′</mo></msup><mo>∘</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\eta&#39; \Colon D \to F&#39; \circ K</annotation></semantics></math></p>
<p> <img src="images/kan10b.jpg" style="width:40.0%" /> </p>
<p>
について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mo>′</mo></msup><annotation encoding="application/x-tex">F&#39;</annotation></semantics></math>への一意な自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></p>
<p> <img src="images/kan14.jpg" style="width:40.0%" /> </p>
<p> が存在する。ただし、
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>η</mi><mo>′</mo></msup><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>σ</mi><mo>∘</mo><mi>K</mi><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta&#39; = (\sigma \circ K) \cdot \eta</annotation></semantics></math>
これは次の図式で表される。</p>
<p> <img src="images/kan112.jpg" style="width:40.0%" /> </p>
<p>
単元圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟏</mn><annotation encoding="application/x-tex">\mathbf{1}</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐀</mi><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math>に置き換えると、この定義は左カン拡張の定義へと自然に一般化される。左カン拡張は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐋</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi></mrow><annotation encoding="application/x-tex">\mathbf{Lan}_{K}D</annotation></semantics></math>と表記される。</p>
<p> <img src="images/kan12.jpg" style="width:40.0%" /> </p>
<p> 自然変換
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>∷</mo><mi>D</mi><mo>→</mo><msub><mrow><mi>𝐋</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi><mo>∘</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\eta \Colon D \to \mathbf{Lan}_{K}D \circ K</annotation></semantics></math>
は左カン拡張の単位と呼ばれる。</p>
<p>先ほどと同様に、自然変換の間の1対1の対応関係
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>η</mi><mo>′</mo></msup><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>σ</mi><mo>∘</mo><mi>K</mi><mo stretchy="false" form="postfix">)</mo><mo>⋅</mo><mi>η</mi></mrow><annotation encoding="application/x-tex">\eta&#39; = (\sigma \circ K) \cdot \eta</annotation></semantics></math>
を随伴を用いて書き直せる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐀</mi><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><msub><mrow><mi>𝐋</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi><mo>,</mo><msup><mi>F</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mo stretchy="false" form="prefix">[</mo><mi>𝐈</mi><mo>,</mo><mi>𝐂</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>D</mi><mo>,</mo><msup><mi>F</mi><mo>′</mo></msup><mo>∘</mo><mi>K</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\mathbf{A}, \mathbf{C}](\mathbf{Lan}_{K}D, F&#39;) \cong [\mathbf{I}, \mathbf{C}](D, F&#39; \circ K)</annotation></semantics></math>
言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>の前合成［訳注：をするような関手］に対して、左カン拡張は左随伴となり、右カン拡張は右随伴となる。</p>
<p>恒等関手の右カン拡張が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>の左随伴を計算するのに使えたように、恒等関手の左カン拡張は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>の右随伴となる（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>は随伴の単位となる）。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>⊣</mo><msub><mrow><mi>𝐋</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><msub><mi>I</mi><mi>𝐂</mi></msub></mrow><annotation encoding="application/x-tex">K \dashv \mathbf{Lan}_{K}I_{\mathbf{C}}</annotation></semantics></math>
2つの結果を組み合わせると、次が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><msub><mi>I</mi><mi>𝐂</mi></msub><mo>⊣</mo><mi>K</mi><mo>⊣</mo><msub><mrow><mi>𝐋</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><msub><mi>I</mi><mi>𝐂</mi></msub></mrow><annotation encoding="application/x-tex">\mathbf{Ran}_{K}I_{\mathbf{C}} \dashv K \dashv \mathbf{Lan}_{K}I_{\mathbf{C}}</annotation></semantics></math></p>
<h2 data-number="27.4" id="エンドとしてのカン拡張"><span
class="header-section-number">27.4</span> エンドとしてのカン拡張</h2>
<p>カン拡張の真の力は、エンド（およびコエンド）を使って計算できるという事実に由来する。簡単のため行き先の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>である場合に注目するが、どの公式も任意の圏に拡張できる。</p>
<p>カン拡張を使えば関手の作用をもとの域の外側に拡張できる、という理解を再検討してみよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐀</mi><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math>の中に埋め込むとする。関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>D</mi><annotation encoding="application/x-tex">D</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐈</mi><annotation encoding="application/x-tex">\mathbf{I}</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>に写す。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>の像内の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>、すなわち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>=</mo><mi>K</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">a = K i</annotation></semantics></math>であるような対象について、拡張された関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">D i</annotation></semantics></math>に写すと言えるだろう。問題は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>の像の外側にある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐀</mi><annotation encoding="application/x-tex">\mathbf{A}</annotation></semantics></math>内の対象をどうするかだ。着想は、そのような対象はどれもたくさんの射を通じて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>の像内のすべての対象と潜在的につながっている、ということにある。関手はそれらの射を保存しなければならない。対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>K</mi><annotation encoding="application/x-tex">K</annotation></semantics></math>の像への射の全体は次のhom関手によって特徴づけられる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>K</mi><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{A}(a, K -)</annotation></semantics></math></p>
<p> <img src="images/kan13.jpg" style="width:40.0%" /> </p>
<p> このhom関手は2つの関手の合成であることに注意してほしい。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>K</mi><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>∘</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">\mathbf{A}(a, K -) = \mathbf{A}(a, -) \circ K</annotation></semantics></math>
右カン拡張は関手合成の右随伴だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐈</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mo>∘</mo><mi>K</mi><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mo stretchy="false" form="prefix">[</mo><mi>𝐀</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mo>,</mo><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\mathbf{I}, \mathbf{Set}](F&#39; \circ K, D) \cong [\mathbf{A}, \mathbf{Set}](F&#39;, \mathbf{Ran}_{K}D)</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>F</mi><mo>′</mo></msup><annotation encoding="application/x-tex">F&#39;</annotation></semantics></math>を上記のhom関手に置き換えるとどうなるか見てみよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐈</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>∘</mo><mi>K</mi><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mo stretchy="false" form="prefix">[</mo><mi>𝐀</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\mathbf{I}, \mathbf{Set}](\mathbf{A}(a, -) \circ K, D) \cong [\mathbf{A}, \mathbf{Set}](\mathbf{A}(a, -), \mathbf{Ran}_{K}D)</annotation></semantics></math>
そして、合成をまとめると次のようになる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐈</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>K</mi><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mo stretchy="false" form="prefix">[</mo><mi>𝐀</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\mathbf{I}, \mathbf{Set}](\mathbf{A}(a, K -), D) \cong [\mathbf{A}, \mathbf{Set}](\mathbf{A}(a, -), \mathbf{Ran}_{K}D)</annotation></semantics></math>
右辺は米田の補題を使って簡潔にできる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐈</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>K</mi><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>D</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">[\mathbf{I}, \mathbf{Set}](\mathbf{A}(a, K -), D) \cong \mathbf{Ran}_{K}D a</annotation></semantics></math>
ここで、［訳注：左辺の］自然変換の集合をエンドで書き直すと、右カン拡張に対する非常に便利な公式が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi><mi>a</mi><mo>≅</mo><msub><mo>∫</mo><mi>i</mi></msub><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>K</mi><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>D</mi><mi>i</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Ran}_{K}D a \cong \int_i \mathbf{Set}(\mathbf{A}(a, K i), D i)</annotation></semantics></math>
左カン拡張に対しても、コエンドによって同様の公式が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐋</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi><mi>a</mi><mo>=</mo><msup><mo>∫</mo><mi>i</mi></msup><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>K</mi><mi>i</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>D</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">\mathbf{Lan}_{K}D a = \int^i \mathbf{A}(K i, a)\times{}D i</annotation></semantics></math>
確認のため、これが実際に関手合成に対する左随伴であること
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐀</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><msub><mrow><mi>𝐋</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi><mo>,</mo><msup><mi>F</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mo stretchy="false" form="prefix">[</mo><mi>𝐈</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>D</mi><mo>,</mo><msup><mi>F</mi><mo>′</mo></msup><mo>∘</mo><mi>K</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\mathbf{A}, \mathbf{Set}](\mathbf{Lan}_{K}D, F&#39;) \cong [\mathbf{I}, \mathbf{Set}](D, F&#39; \circ K)</annotation></semantics></math>
を証明しよう。前述の式で左辺を置換してみよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐀</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><msup><mo>∫</mo><mi>i</mi></msup><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>K</mi><mi>i</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>D</mi><mi>i</mi><mo>,</mo><msup><mi>F</mi><mo>′</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\mathbf{A}, \mathbf{Set}](\int^i \mathbf{A}(K i, -)\times{}D i, F&#39;)</annotation></semantics></math>
これは自然変換の集合なので、エンドに書き直せる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mi>a</mi></msub><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><msup><mo>∫</mo><mi>i</mi></msup><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>K</mi><mi>i</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>D</mi><mi>i</mi><mo>,</mo><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\int_a \mathbf{Set}(\int^i \mathbf{A}(K i, a)\times{}D i, F&#39; a)</annotation></semantics></math>
Hom関手の連続性を使って、コエンドをエンドに置き換えられる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mi>a</mi></msub><msub><mo>∫</mo><mi>i</mi></msub><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>K</mi><mi>i</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>D</mi><mi>i</mi><mo>,</mo><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\int_a \int_i \mathbf{Set}(\mathbf{A}(K i, a)\times{}D i, F&#39; a)</annotation></semantics></math>
積と冪についての随伴が使える。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mi>a</mi></msub><msub><mo>∫</mo><mi>i</mi></msub><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>K</mi><mi>i</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi><msup><mo stretchy="false" form="postfix">)</mo><mrow><mi>D</mi><mi>i</mi></mrow></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\int_a \int_i \mathbf{Set}(\mathbf{A}(K i, a),\ (F&#39; a)^{D i})</annotation></semantics></math>
この冪は対応するhom集合と同型である。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mi>a</mi></msub><msub><mo>∫</mo><mi>i</mi></msub><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>K</mi><mi>i</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mspace width="0.222em"></mspace><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>D</mi><mi>i</mi><mo>,</mo><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\int_a \int_i \mathbf{Set}(\mathbf{A}(K i, a),\ \mathbf{Set}(D i, F&#39; a))</annotation></semantics></math>
ここで、フビニの定理と呼ばれる、この2つのエンドが交換可能であるという定理を利用できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mi>i</mi></msub><msub><mo>∫</mo><mi>a</mi></msub><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>K</mi><mi>i</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mspace width="0.222em"></mspace><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>D</mi><mi>i</mi><mo>,</mo><msup><mi>F</mi><mo>′</mo></msup><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\int_i \int_a \mathbf{Set}(\mathbf{A}(K i, a),\ \mathbf{Set}(D i, F&#39; a))</annotation></semantics></math>
内側のエンドは2つの関手間の自然変換の集合を表しているので、米田の補題を使える。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∫</mo><mi>i</mi></msub><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>D</mi><mi>i</mi><mo>,</mo><msup><mi>F</mi><mo>′</mo></msup><mo stretchy="false" form="prefix">(</mo><mi>K</mi><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\int_i \mathbf{Set}(D i, F&#39; (K i))</annotation></semantics></math>
これは、まさに証明しようとしていた随伴の右辺をなす自然変換の集合となっている。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐈</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>D</mi><mo>,</mo><msup><mi>F</mi><mo>′</mo></msup><mo>∘</mo><mi>K</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">[\mathbf{I}, \mathbf{Set}](D, F&#39; \circ K)</annotation></semantics></math>
このようなエンドとコエンドと米田の補題を使った計算は、エンドの「微積分」としてはごく典型的なものだ。</p>
<h2 data-number="27.5" id="haskellにおけるカン拡張"><span
class="header-section-number">27.5</span> Haskellにおけるカン拡張</h2>
<p>カン拡張のエンド・コエンドの式はHaskellに簡単に変換できる。右カン拡張から始めよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐑</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi><mi>a</mi><mo>≅</mo><msub><mo>∫</mo><mi>i</mi></msub><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>K</mi><mi>i</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>D</mi><mi>i</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Ran}_{K}D a \cong \int_i \mathbf{Set}(\mathbf{A}(a, K i), D i)</annotation></semantics></math>
エンドを全称量化子に、hom集合を関数型に置き換える。</p>
<div class="sourceCode" id="cb577"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb577-1"><a href="#cb577-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Ran</span> k d a <span class="ot">=</span> <span class="dt">Ran</span> (<span class="kw">forall</span> i<span class="op">.</span> (a <span class="ot">-&gt;</span> k i) <span class="ot">-&gt;</span> d i)</span></code></pre></div>
<p>
この定義を見ると、<code>Ran</code>には、［訳注：<code>(a -&gt; k i)</code>
型の］関数を適用できる型<code>a</code>の値と、2つの関手<code>k</code>と<code>d</code>の間の自然変換が含まれている必要があることは明らかだ。たとえば、<code>k</code>が木関手<a
href="#fn162" class="footnote-ref" id="fnref162"
role="doc-noteref"><sup>162</sup></a>、<code>d</code>がリスト関手だとして、<code>Ran Tree [] String</code>が与えられたとする。もし、これに関数</p>
<div class="sourceCode" id="cb578"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb578-1"><a href="#cb578-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span></span></code></pre></div>
<p>
を渡したなら<code>Int</code>のリストが返ってくる。右カン拡張はこの関数を使って木を生成し、再パッケージしてリストにする。たとえば、文字列から構文解析木を生成するパーサーを渡したときに、その木の深さ優先探索順に対応するリストが得られるかもしれない。</p>
<p>右カン拡張は、関手<code>d</code>を恒等関手に置き換えれば、任意の関手の左随伴を計算するために使える。これにより、関手<code>k</code>の左随伴であって次の型の多相関数の集合で表されるようなものが得られる。</p>
<div class="sourceCode" id="cb579"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb579-1"><a href="#cb579-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> i<span class="op">.</span> (a <span class="ot">-&gt;</span> k i) <span class="ot">-&gt;</span> i</span></code></pre></div>
<p>
<code>k</code>がモノイドの圏からの忘却関手だとする。そうすると、全称量化子はすべてのモノイドに及ぶ。もちろんHaskellではモノイド則を表現できないが、以下は結果の自由関手の適切な近似になっている（忘却関手<code>k</code>は対象については恒等写像になっている）。</p>
<div class="sourceCode" id="cb580"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb580-1"><a href="#cb580-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Lst</span> a <span class="ot">=</span> <span class="kw">forall</span> i<span class="op">.</span> <span class="dt">Monoid</span> i <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> i) <span class="ot">-&gt;</span> i</span></code></pre></div>
<p> 期待どおり、自由モノイド、すなわちHaskellのリストが得られる。</p>
<div class="sourceCode" id="cb581"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb581-1"><a href="#cb581-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toLst ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Lst</span> a</span>
<span id="cb581-2"><a href="#cb581-2" aria-hidden="true" tabindex="-1"></a>toLst as <span class="ot">=</span> \f <span class="ot">-&gt;</span> <span class="fu">foldMap</span> f as</span>
<span id="cb581-3"><a href="#cb581-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb581-4"><a href="#cb581-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fromLst ::</span> <span class="dt">Lst</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb581-5"><a href="#cb581-5" aria-hidden="true" tabindex="-1"></a>fromLst f <span class="ot">=</span> f (\a <span class="ot">-&gt;</span> [a])</span></code></pre></div>
<p> 一方、この左カン拡張はコエンドだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐋</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>K</mi></msub><mi>D</mi><mi>a</mi><mo>=</mo><msup><mo>∫</mo><mi>i</mi></msup><mi>𝐀</mi><mo stretchy="false" form="prefix">(</mo><mi>K</mi><mi>i</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>D</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">\mathbf{Lan}_{K}D a = \int^i \mathbf{A}(K i, a)\times{}D i</annotation></semantics></math>
なので、存在量化子へと翻訳できる。記号的に表すとこうなる。</p>
<div class="sourceCode" id="cb582"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb582-1"><a href="#cb582-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Lan</span> k d a <span class="ot">=</span> exists i<span class="op">.</span> (k i <span class="ot">-&gt;</span> a, d i)</span></code></pre></div>
<p>
これはHaskellではGADTを使うか、次のように全称量化されたデータ構成子を使って表現できる。</p>
<div class="sourceCode" id="cb583"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb583-1"><a href="#cb583-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Lan</span> k d a <span class="ot">=</span> <span class="kw">forall</span> i<span class="op">.</span> <span class="dt">Lan</span> (k i <span class="ot">-&gt;</span> a) (d i)</span></code></pre></div>
<p>
このデータ構造を解釈すると、<code>Lan</code>は不特定の<code>i</code>たちを含むコンテナーを取って<code>a</code>を1つ生成する関数を含むものだと言える。また、それらの<code>i</code>たちを含む別のコンテナーも持つ。<code>i</code>が何かは分からないので、このデータ構造で唯一できるのは、<code>i</code>のコンテナーを取得し、自然変換を使って関手<code>k</code>で定義されたコンテナーに再パックし、関数を呼んで<code>a</code>を得ることだけだ。たとえば、<code>d</code>が木で<code>k</code>がリストの場合は、木を直列化して得られるリストで関数を呼べば<code>a</code>が得られる。</p>
<p>左カン拡張は関手の右随伴を計算するために使える。積関手の右随伴が冪なのは知っているので、カン拡張を使って実装してみよう。</p>
<div class="sourceCode" id="cb584"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb584-1"><a href="#cb584-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Exp</span> a b <span class="ot">=</span> <span class="dt">Lan</span> ((,) a) <span class="dt">Identity</span> b</span></code></pre></div>
<p>
これが実際に関数型と同型であることは、次の関数のペアが証拠になっている。</p>
<div class="sourceCode" id="cb585"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb585-1"><a href="#cb585-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toExp ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Exp</span> a b</span>
<span id="cb585-2"><a href="#cb585-2" aria-hidden="true" tabindex="-1"></a>toExp f <span class="ot">=</span> <span class="dt">Lan</span> (f <span class="op">.</span> <span class="fu">fst</span>) (<span class="dt">Identity</span> ())</span>
<span id="cb585-3"><a href="#cb585-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb585-4"><a href="#cb585-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fromExp ::</span> <span class="dt">Exp</span> a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)</span>
<span id="cb585-5"><a href="#cb585-5" aria-hidden="true" tabindex="-1"></a>fromExp (<span class="dt">Lan</span> f (<span class="dt">Identity</span> x)) <span class="ot">=</span> \a <span class="ot">-&gt;</span> f (a, x)</span></code></pre></div>
<p>
すでに一般的な場合について説明したとおり、［訳注：<code>fromExp</code>において］次のような段階を経たことに注意してほしい。</p>
<ol type="1">
<li>まず、<code>x</code>のコンテナー（ここでは単なる自明な恒等コンテナー）と関数<code>f</code>を取り出した。</li>
<li>次に、そのコンテナーを、恒等関手と関手のペアとの間の自然変換を使って再パックした。</li>
<li>最後に、関数<code>f</code>を呼んだ。</li>
</ol>
<aside id="footnotes-83" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="162">
<li
id="fn162"><p>訳注：これがどういった木であるかはここでは規定されていない。たとえば、第8章4節で出てきた<code>Tree</code>のようなもの。<a
href="#fnref162" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="27.6" id="自由関手"><span
class="header-section-number">27.6</span> 自由関手</h2>
<p>カン拡張の興味深い応用として自由関手 (free functor)
の構成がある。これは以下のような実際的な問題の解となる。型構成子、つまり対象の写像があるとする。その型構成子に基づいて関手を定義可能だろうか？　言い換えると、その型構成子を完全な自己関手へと拡張するような射の写像を定義できるだろうか？</p>
<p>鍵となる観察は、型構成子は離散圏を域とする関手として表現できることだ。離散圏は恒等射以外の射を持たない。任意の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>について、単に恒等射以外の射を捨て去ることで、常に離散圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix" mathvariant="bold">|</mo><mi>𝐂</mi><mo stretchy="false" form="prefix" mathvariant="bold">|</mo></mrow><annotation encoding="application/x-tex">\mathbf{|C|}</annotation></semantics></math>を構成できる。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix" mathvariant="bold">|</mo><mi>𝐂</mi><mo stretchy="false" form="prefix" mathvariant="bold">|</mo></mrow><annotation encoding="application/x-tex">\mathbf{|C|}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>は、対象の単純な写像、すなわちHaskellで型構成子と呼ばれるものになる。また、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix" mathvariant="bold">|</mo><mi>𝐂</mi><mo stretchy="false" form="prefix" mathvariant="bold">|</mo></mrow><annotation encoding="application/x-tex">\mathbf{|C|}</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内へ注入するような正統な関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>も存在する。それは対象についての（および恒等射についても）恒等写像になっている。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>J</mi><annotation encoding="application/x-tex">J</annotation></semantics></math>に沿った左カン拡張は、存在するなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>への関手である。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐋</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><mi>J</mi></msub><mi>F</mi><mi>a</mi><mo>=</mo><msup><mo>∫</mo><mi>i</mi></msup><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>J</mi><mi>i</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>F</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">\mathbf{Lan}_{J}F a = \int^i \mathbf{C}(J i, a)\times{}F i</annotation></semantics></math>
これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>に基づく自由関手と呼ばれる。</p>
<p>Haskellでは、次のように書ける。</p>
<div class="sourceCode" id="cb586"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb586-1"><a href="#cb586-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FreeF</span> f a <span class="ot">=</span> <span class="kw">forall</span> i<span class="op">.</span> <span class="dt">FMap</span> (i <span class="ot">-&gt;</span> a) (f i)</span></code></pre></div>
<p>
実際、すべての型構成子<code>f</code>について<code>FreeF f</code>は関手となる。</p>
<div class="sourceCode" id="cb587"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb587-1"><a href="#cb587-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">FreeF</span> f) <span class="kw">where</span></span>
<span id="cb587-2"><a href="#cb587-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> g (<span class="dt">FMap</span> h fi) <span class="ot">=</span> <span class="dt">FMap</span> (g <span class="op">.</span> h) fi</span></code></pre></div>
<p>
ご覧のとおり、自由関手は、関数と引数の両方を記録することで関数の持ち上げを偽装する。それは、関数合成を記録することによって、持ち上げられた関数を累積する。関手則は自動的に満たされる。この構成は論文<a
href="http://okmij.org/ftp/Haskell/extensible/more.pdf">Freer Monads,
More Extensible Effects</a><a href="#fn163" class="footnote-ref"
id="fnref163" role="doc-noteref"><sup>163</sup></a><a href="#fn164"
class="footnote-ref" id="fnref164"
role="doc-noteref"><sup>164</sup></a>で使われたものだ。</p>
<p>別の方法として、右カン拡張も同じ目的に使える。</p>
<div class="sourceCode" id="cb588"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb588-1"><a href="#cb588-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">FreeF</span> f a <span class="ot">=</span> <span class="dt">FreeF</span> (<span class="kw">forall</span> i<span class="op">.</span> (a <span class="ot">-&gt;</span> i) <span class="ot">-&gt;</span> f i)</span></code></pre></div>
<p> これが実際に関手であることは簡単に確認できる。</p>
<div class="sourceCode" id="cb589"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb589-1"><a href="#cb589-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">FreeF</span> f) <span class="kw">where</span></span>
<span id="cb589-2"><a href="#cb589-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> g (<span class="dt">FreeF</span> r) <span class="ot">=</span> <span class="dt">FreeF</span> (\bi <span class="ot">-&gt;</span> r (bi <span class="op">.</span> g))</span></code></pre></div>
<aside id="footnotes-84" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="163">
<li id="fn163"><p><a
href="http://okmij.org/ftp/Haskell/extensible/more.pdf"
class="uri">http://okmij.org/ftp/Haskell/extensible/more.pdf</a><a
href="#fnref163" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn164"><p>監訳注：Oleg Kiselyov, Hiromi Ishii: Freer monads,
more extensible effects. Haskell 2015: 94-105. <a
href="https://doi.org/10.1145/2804302.2804319"
class="uri">https://doi.org/10.1145/2804302.2804319</a>.</p>
<p>なお、freerモナドとは型構成子<code>f</code>から</p>
<p><code>data Freer f a where</code></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace></mrow><annotation encoding="application/x-tex">\ \ </annotation></semantics></math><code>Pure :: a -&gt; Freer f a</code></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace></mrow><annotation encoding="application/x-tex">\ \ </annotation></semantics></math><code>Bind :: f a -&gt; (a -&gt; Freer f b) -&gt; Freer f b</code></p>
<p>で定義されるモナドのこと。そう呼ばれるのは、関手<code>f</code>に対してFreeモナドが</p>
<p><code>data Free f a where</code></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace></mrow><annotation encoding="application/x-tex">\ \ </annotation></semantics></math><code>Pure :: a -&gt; Free f a</code></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mspace width="0.222em"></mspace><mspace width="0.222em"></mspace></mrow><annotation encoding="application/x-tex">\ \ </annotation></semantics></math><code>Nest :: f (Free f a) -&gt; Free f a</code></p>
<p>で定義されることとの対比による。<a href="#fnref164"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 data-number="28" id="豊穣圏"><span
class="header-section-number">28</span> 豊穣圏</h1>
<p>圏が<em>小さい</em>とは、対象たちが集合をなすことだ。しかし、集合より大きいものの存在も知られている。有名な話として、すべての集合の集合は、標準的な集合論（ツェルメロ＝フレンケル集合論を指し、選択公理
(Axiom of Choice) を議論に含めることもある）では形成できない<a
href="#fn165" class="footnote-ref" id="fnref165"
role="doc-noteref"><sup>165</sup></a>。なので、すべての集合からなる圏は大きくなければならない。グロタンディーク宇宙
(Grothendieck universe)
などの数学的トリックがいくつかあって、集合を超える集まりを定義するのに使える。それらのトリックによって大きい圏について語れるようになる。</p>
<p>圏が<em>局所的に小さい</em>とは、任意の2つの対象間の射たちが集合をなすことをいう。それらが集合をなさないなら、いくつかの定義は再考する必要がある。特に、射を集合から取ってくることさえできない場合、射の合成とは何を意味するのだろう？　解決策はhom集合たち（つまり<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内の対象たち）を他の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>の<em>対象</em>たちで置き換えることによってブートストラップすることだ。変わる点としては、一般には対象は要素を持たないため、もはや個々の射については語れなくなる。<span
id="enriched2" class="keyword"><em>豊穣</em></span>圏 (enriched
category)
のすべての性質を、hom対象全体についての行える操作によって定義する必要がある。そのためには、hom対象を提供する圏は、追加の構造を持たなければならない。すなわち、モノイダル圏でなければならない。このモノイダル圏を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>と呼ぶことで、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>上の豊穣圏について語れるようになる。</p>
<p>大きさの理由に加えて、hom集合をただの集合以上の構造があるものへと一般化することも興味深そうだ。たとえば、従来の圏には対象間の距離という概念はない。2つの対象は射によって接続されているかいないかのどちらかだ。ある対象に接続されているすべての対象は近傍と呼ばれる。現実の人生とは違って、圏においては、友人の友人の友人は、親友と同じくらい近しい。だが、適切な豊穣圏では、対象間の距離を定義できる。</p>
<p>豊穣圏について経験を積むべき極めて実用的な理由はもう1つある。それは、圏に関する知識の非常に有用なオンライン情報源である<a
href="https://ncatlab.org/">nLab</a><a href="#fn166"
class="footnote-ref" id="fnref166"
role="doc-noteref"><sup>166</sup></a>が主に豊穣圏について書かれているからだ。</p>
<h2 data-number="28.1" id="なぜモノイダル圏か"><span
class="header-section-number">28.1</span> なぜモノイダル圏か？</h2>
<p>豊穣圏を構築する際には、該当するモノイダル圏を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>に置き換え、hom対象をhom集合に置き換えれば、通常の定義を復元できることに留意する必要がある。豊穣圏の構築を実現する一番良い方法は、通常の定義から始めて、ポイントフリーな方法で――つまり、集合の要素に名前を付けずに――再定式化しつづけることだ。</p>
<p>まず、合成の定義から始めよう。通常は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(b, c)</annotation></semantics></math>
からの射1つと<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
からの射1つからなる射のペアを取り、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, c)</annotation></semantics></math>
からの射に写す。言い換えれば、次の写像だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>×</mo><mrow></mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(b, c)\times{}\mathbf{C}(a, b) \to \mathbf{C}(a, c)</annotation></semantics></math>
これは集合間の関数だ――片方は2つのhom集合のデカルト積だ。この式は、デカルト積をより一般的な何かに置き換えれば容易に一般化できる。圏論的な積でもよいが、さらに進んで、完全に一般的なテンソル積を使うこともできる。</p>
<p>次は恒等射の番だ。hom集合から個々の要素を取り出す代わりに、単元集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟏</mn><annotation encoding="application/x-tex">\mathbf{1}</annotation></semantics></math>からの関数を使って定義できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>j</mi><mi>a</mi></msub><mo>∷</mo><mn>𝟏</mn><mo>→</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">j_a \Colon \mathbf{1} \to \mathbf{C}(a, a)</annotation></semantics></math>
ここでも単元集合は終対象に置き換えられるが、さらに進んでテンソル積の単位元<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>にも置き換えられる。</p>
<p>ご覧のように、あるモノイダル圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>から取った対象は、hom集合を置き換える候補として適している。</p>
<aside id="footnotes-85" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="165">
<li
id="fn165"><p>訳注：素朴集合論ではすべての集合の集合を考えられるせいでラッセルのパラドックスなどの矛盾が生じる。<a
href="#fnref165" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn166"><p><a href="https://ncatlab.org/"
class="uri">https://ncatlab.org/</a><a href="#fnref166"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="28.2" id="モノイダル圏-1"><span
class="header-section-number">28.2</span> モノイダル圏</h2>
<p>モノイダル圏については前にも述べたが、定義をもう一度述べておく価値はある。モノイダル圏は、双関手であるテンソル積を定義する。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>⊗</mi><mo>∷</mo><mi>𝐕</mi><mo>×</mo><mrow></mrow><mi>𝐕</mi><mo>→</mo><mi>𝐕</mi></mrow><annotation encoding="application/x-tex">\otimes \Colon \mathbf{V}\times{}\mathbf{V} \to \mathbf{V}</annotation></semantics></math>
このテンソル積は結合的なのが望ましいが、自然同型を除いた結合律さえ満たせば十分だ。この同型射は結合切替子と呼ばれる。その成分：
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow></msub><mo>∷</mo><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>⊗</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mi>c</mi><mo>→</mo><mi>a</mi><mo>⊗</mo><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>⊗</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\alpha_{a b c} \Colon (a \otimes b) \otimes c \to a \otimes (b \otimes c)</annotation></semantics></math>
は3つの引数すべてにおいて自然である必要がある。</p>
<p>モノイダル圏はまた、テンソル積の単位元として機能する特別な単位対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>を、これも自然同型を除いて一意に定義する必要がある。これら2つの同型は、それぞれ左単位積子・右単位積子と呼ばれ、次の構成要素を持つ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>λ</mi><mi>a</mi></msub></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>i</mi><mo>⊗</mo><mi>a</mi><mo>→</mo><mi>a</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msub><mi>ρ</mi><mi>a</mi></msub></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>a</mi><mo>⊗</mo><mi>i</mi><mo>→</mo><mi>a</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
\lambda_a &amp;\Colon i \otimes a \to a \\
\rho_a &amp;\Colon a \otimes i \to a
\end{aligned}
</annotation></semantics></math>
結合切替子と単位積子はコヒーレンス条件を満たす必要がある。</p>
<script type="text/tikz">
\begin{tikzcd}[row sep=large]
  ((a \otimes b) \otimes c) \otimes d
  \arrow[d, "\alpha_{(a \otimes b)cd}"]
  \arrow[rr, "\alpha_{abc} \otimes \mathbf{id}_d"]
  & & (a \otimes (b \otimes c)) \otimes d
  \arrow[d, "\alpha_{a(b \otimes c)d}"] \\
  (a \otimes b) \otimes (c \otimes d)
  \arrow[rd, "\alpha_{ab(c \otimes d)}"]
  & & a \otimes ((b \otimes c) \otimes d)
  \arrow[ld, "\mathbf{id}_a \otimes \alpha_{bcd}"] \\
  & a \otimes (b \otimes (c \otimes d))
\end{tikzcd}
</script>
<script type="text/tikz">
\begin{tikzcd}[row sep=large]
  (a \otimes i) \otimes b
  \arrow[dr, "\rho_{a} \otimes \mathbf{id}_b"']
  \arrow[rr, "\alpha_{aib}"]
  & & a \otimes (i \otimes b)
  \arrow[dl, "\mathbf{id}_a \otimes \lambda_b"] \\
  & a \otimes b
\end{tikzcd}
</script>
<p> モノイダル圏が<span id="symmetric"
class="keyword"><em>対称</em></span> (symmetric)
と呼ばれる条件は、以下の成分
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mrow><mi>a</mi><mi>b</mi></mrow></msub><mo>∷</mo><mi>a</mi><mo>⊗</mo><mi>b</mi><mo>→</mo><mi>b</mi><mo>⊗</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">\gamma_{a b} \Colon a \otimes b \to b \otimes a</annotation></semantics></math>
の自然同型を持ち、その2乗が恒等射であり
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mrow><mi>b</mi><mi>a</mi></mrow></msub><mo>∘</mo><msub><mi>γ</mi><mrow><mi>a</mi><mi>b</mi></mrow></msub><mo>=</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mrow><mi>a</mi><mo>⊗</mo><mi>b</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\gamma_{b a} \circ \gamma_{a b} = %
\mathbf{id}_{a \otimes b}%
</annotation></semantics></math>
かつモノイドの構造と整合していることだ。</p>
<p>モノイダル圏に関して興味深いのは、内部hom（関数対象）をテンソル積に対する右随伴として定義できる場合があることだ。関数対象、すなわち冪の標準的な定義は、圏論的な積［訳注：関手］に対する右随伴によるものだったのを思い出してほしい。そのような対象が任意の対象のペアについて存在する圏をデカルト閉圏と呼んだ。モノイダル圏の内部homを定義する随伴は次のとおりだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐕</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>⊗</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>∼</mo><mi>𝐕</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mo stretchy="false" form="prefix">[</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{V}(a \otimes b, c) \sim \mathbf{V}(a, [b, c])</annotation></semantics></math>
<a href="http://www.tac.mta.ca/tac/reprints/articles/10/tr10.pdf">G. M.
Kelly</a><a href="#fn167" class="footnote-ref" id="fnref167"
role="doc-noteref"><sup>167</sup></a>にならって、内部homを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}b, c{]}</annotation></semantics></math>と表記しよう。この随伴の余単位は自然変換であり、その成分は評価射
(evaluation morphism) と呼ばれる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mrow><mi>a</mi><mi>b</mi></mrow></msub><mo>∷</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo><mo>⊗</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">\varepsilon_{a b} \Colon ([a, b] \otimes a) \to b</annotation></semantics></math>
テンソル積が非対称なら、次の随伴を使って、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}{[}a, c{]}{]}</annotation></semantics></math>で示される別の内部homを定義できる場合があることに注目してほしい。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐕</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>⊗</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>∼</mo><mi>𝐕</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mo stretchy="false" form="prefix">[</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{V}(a \otimes b, c) \sim \mathbf{V}(b, [[a, c]])</annotation></semantics></math>
両方が定義されているモノイダル圏は<span id="biclosed"
class="keyword"><em>双閉</em></span> (biclosed)
と呼ばれる。双閉ではない圏の例としては、関手合成をテンソル積とした<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内の自己関手の圏がある。この圏はモナドを定義するのに使った。</p>
<aside id="footnotes-86" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="167">
<li id="fn167"><p><a
href="http://www.tac.mta.ca/tac/reprints/articles/10/tr10.pdf"
class="uri">http://www.tac.mta.ca/tac/reprints/articles/10/tr10.pdf</a><a
href="#fnref167" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="28.3" id="豊饒圏"><span
class="header-section-number">28.3</span> 豊饒圏</h2>
<p>モノイダル圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>上の豊穣圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>は、hom集合をhom対象で置き換えたものだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>のすべてのペアに対し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
を関連付けよう。hom集合に使ったのと同じ表記をhom対象にも使うことにする。ただし、hom対象が射を含まないことには注意が必要だ。一方で、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>はhom集合と射を持つ通常の（豊穣化されていない）圏だ。したがって、集合を完全に一掃したわけではない――絨毯で覆って見えなくしただけだ。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の個々の射については語れないため、射の合成は以下のような<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>内の射の族に置き換わる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∘</mi><mo>∷</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\circ \Colon \mathbf{C}(b, c) \otimes \mathbf{C}(a, b) \to \mathbf{C}(a, c)</annotation></semantics></math></p>
<p> <img src="images/composition.jpg" style="width:40.0%" /> </p>
<p>
同様に、恒等射は以下のような<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>内の射の族に置き換わる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>j</mi><mi>a</mi></msub><mo>∷</mo><mi>i</mi><mo>→</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">j_a \Colon i \to \mathbf{C}(a, a)</annotation></semantics></math>
ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>内のテンソル単位元だ。</p>
<p> <img src="images/id.jpg" style="width:40.0%" /> </p>
<p>
合成の結合律は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>内の結合切替子によって定義される。</p>
<script type="text/tikz">
\begin{tikzcd}[column sep=large]
  (\mathbf{C}(c,d) \otimes \mathbf{C}(b,c)) \otimes \mathbf{C}(a,b)
  \arrow[r, "\circ\otimes\mathbf{id}"]
  \arrow[dd, "\alpha"]
  & \mathbf{C}(b,d) \otimes \mathbf{C}(a,b)
  \arrow[dr, "\circ"] \\
  & & \mathbf{C}(a,d) \\
  \mathbf{C}(c,d) \otimes (\mathbf{C}(b,c) \otimes \mathbf{C}(a,b))
  \arrow[r, "\mathbf{id}\otimes\circ"]
  & \mathbf{C}(c,d) \otimes \mathbf{C}(a,c)
  \arrow[ur, "\circ"]
\end{tikzcd}
</script>
<p> 単位律も同様に単位積子によって表現される。</p>
<div style="display:flex">
<script type="text/tikz">
\begin{tikzcd}[row sep=large]
  \mathbf{C}(a,b) \otimes i
  \arrow[rr, "\mathbf{id} \otimes j_a"]
  \arrow[dr, "\rho"]
  & & \mathbf{C}(a,b) \otimes \mathbf{C}(a,a)
  \arrow[dl, "\circ"] \\
  & \mathbf{C}(a,b)
\end{tikzcd}
</script>
<script type="text/tikz">
\begin{tikzcd}[row sep=large]
  i \otimes \mathbf{C}(a,b)
  \arrow[rr, "j_b \otimes \mathbf{id}"]
  \arrow[dr, "\lambda"]
  & & \mathbf{C}(b,b) \otimes \mathbf{C}(a,b)
  \arrow[dl, "\circ"] \\
  & \mathbf{C}(a,b)
\end{tikzcd}
</script>
</div>
<h2 data-number="28.4" id="前順序"><span
class="header-section-number">28.4</span> 前順序</h2>
<p>前順序は細い圏として定義されていた。つまり、どのhom集合も空集合か単元集合であるような圏だ。非空集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>以下であることの証明と解釈される。そのような圏は、2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐹</mi><mi>𝑎</mi><mi>𝑙</mi><mi>𝑠</mi><mi>𝑒</mi></mrow><annotation encoding="application/x-tex">\mathit{False}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑇</mi><mi>𝑟</mi><mi>𝑢</mi><mi>𝑒</mi></mrow><annotation encoding="application/x-tex">\mathit{True}</annotation></semantics></math>とも呼ばれる）だけを含む非常に単純なモノイダル圏上の豊穣圏だと解釈できる。必須の恒等射に加えて、この圏には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>への単一の射がある。これを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \to 1</annotation></semantics></math>と呼ぶことにする。ここで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>の単純な算術（すなわち、積が非ゼロになるのは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>⊗</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \otimes 1</annotation></semantics></math>のみ）をモデル化するようなテンソル積を考えると、単純なモノイドの構造をその中に確立できる。この圏の恒等対象は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>だ。これは厳密なモノイダル圏である。つまり、結合切替子と単位積子は恒等射だ。</p>
<p>前順序のhom集合は空集合か単元集合なので、このちっぽけな圏におけるhom対象に簡単に置き換えられる。豊穣化された前順序<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>は、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の任意のペアについてのhom対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
を持つ。この対象は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>以下なら<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>で、そうでなければ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>だ。</p>
<p>合成を見てみよう。任意の2つの対象のテンソル積は通常は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>で、両方が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>のときだけ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>となる。テンソル積が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>の場合、合成射には2つの候補がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mn>0</mn></msub><annotation encoding="application/x-tex">%
\mathbf{id}_{0}%
</annotation></semantics></math>または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \to 1</annotation></semantics></math>のいずれかだ<a
href="#fn168" class="footnote-ref" id="fnref168"
role="doc-noteref"><sup>168</sup></a>。しかし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>の場合、候補は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mn>1</mn></msub><annotation encoding="application/x-tex">%
\mathbf{id}_{1}%
</annotation></semantics></math>だけだ。これを再翻訳して関係に戻すと、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant b</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">b \leqslant c</annotation></semantics></math>の場合は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \leqslant c</annotation></semantics></math>となり、必要としていた推移律そのものになる。</p>
<p>恒等射についてはどうだろう？　それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
への射だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>からの射は1つだけで、恒等射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mn>1</mn></msub><annotation encoding="application/x-tex">%
\mathbf{id}_{1}%
</annotation></semantics></math>なので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>である必要がある。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a \leqslant a</annotation></semantics></math>であることを意味する。すなわち、前順序の反射律だ。したがって、前順序を豊饒圏として実装すると、推移律と反射律の両方が自動的に強制される。</p>
<aside id="footnotes-87" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="168">
<li
id="fn168"><p>訳注：<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a \leqslant b</annotation></semantics></math>または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">b \leqslant c</annotation></semantics></math>の少なくとも一方が成り立っていない場合は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a \leqslant c</annotation></semantics></math>は成り立たないかもしれないし（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mn>0</mn></msub><annotation encoding="application/x-tex">%
\mathbf{id}_{0}%
</annotation></semantics></math>）、成り立つかもしれない（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \to 1</annotation></semantics></math>）。<a
href="#fnref168" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="28.5" id="距離空間"><span
class="header-section-number">28.5</span> 距離空間</h2>
<p><a
href="http://www.tac.mta.ca/tac/reprints/articles/1/tr1.pdf">ウィリアム・ローヴェア</a><a
href="#fn169" class="footnote-ref" id="fnref169"
role="doc-noteref"><sup>169</sup></a> (William Lawvere)
による興味深い例がある。ローヴェアは豊穣圏を使って距離空間 (metric
space)
を定義できることに気付いた。距離空間は任意の2対象間の距離を定義する。この距離は非負実数だ。取り得る値に無限大を含めると便利だ。距離が無限大の場合、始点となる対象から終点となる対象へ到達する方法はない。</p>
<p>距離には、満たさなければならない自明な性質がいくつかある。その1つは、ある対象からそれ自身への距離は0でなければならないことである<a
href="#fn170" class="footnote-ref" id="fnref170"
role="doc-noteref"><sup>170</sup></a>。もう1つは三角不等式で、直線距離は中継地点同士の距離の合計を超えないことである。
距離が対称であることは要求しない<a href="#fn171" class="footnote-ref"
id="fnref171"
role="doc-noteref"><sup>171</sup></a>。これは、最初は奇妙に思えるかもしれないが、ローヴェアが説明したように、ある方向へは坂を上り、逆方向へは坂を下るのを想像すればよい。いずれにしても、対称性は追加の制約として後から課してもよい。</p>
<p>さて、どうすれば距離空間を圏論の言葉で語れるだろうか？　それには、hom対象が距離であるような圏を構築する必要がある。注意してほしいのは、距離は射ではなくhom対象だということだ。一体どうすればhom対象が数になるだろう？　それらの数が対象であるようなモノイダル圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>さえ構築できればよい。非負実数たち（に無限大を追加したもの）は全順序をなすので、細い圏として扱える。このような2つの数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>の間の射は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≥</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \geqslant y</annotation></semantics></math>の場合だけ存在する（注：これは前順序の定義での伝統的な向きとは逆だ）。モノイドの構造は加算で与えられ、0が単位対象として機能する。言い換えると、2つの数値のテンソル積はそれらの合計だ。</p>
<p>距離空間は、このようなモノイダル圏上の豊穣圏だ。対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>へのhom対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
は、非負の（無限大かもしれない）数であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への距離と呼ばれる。このような圏で恒等射と合成から何が分かるか見てみよう。</p>
<p>我々の定義から、0という数であるテンソル単位元からhom対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
への射は次の関係になる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≥</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">0 \geqslant \mathbf{C}(a, a)</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
は非負の数であるため、この条件は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>への距離が常に0であることを示す。良し！</p>
<p>では合成について語ろう。隣接する2つのhom対象のテンソル積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(b, c) \otimes \mathbf{C}(a, b)</annotation></semantics></math>
から始める。テンソル積は、2つの距離の合計として定義された。合成はこの積から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, c)</annotation></semantics></math>
への<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>内の射だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>内の射は「以上」関係として定義されている。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への距離と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>への距離の合計は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>への距離以上になる。もっとも、これは標準的な三角不等式にすぎない。良し！</p>
<p>距離空間を豊饒圏の言葉で再構成することにより、三角不等式と自己距離が0であることが「無料で」得られる。</p>
<aside id="footnotes-88" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="169">
<li id="fn169"><p><a
href="http://www.tac.mta.ca/tac/reprints/articles/1/tr1.pdf"
class="uri">http://www.tac.mta.ca/tac/reprints/articles/1/tr1.pdf</a><a
href="#fnref169" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li
id="fn170"><p>訳注：通常の距離空間の定義では、距離が0ならば2つの対象は等しいことも要求される。<a
href="#fnref170" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn171"><p>訳注：通常の距離空間の定義では対称性が要求される。<a
href="#fnref171" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="28.6" id="豊穣関手"><span
class="header-section-number">28.6</span> 豊穣関手</h2>
<p>関手の定義には射の写像が含まれる。豊穣化された設定では、個々の射という概念がないため、hom対象を一括して扱う必要がある。hom対象はモノイダル圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>内の対象であり、それらの間には自由に使える射がある。したがって、同一のモノイダル圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>上の複数の豊穣圏について、それらの間に豊穣関手を定義することは理にかなっている。そうすれば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>内の射を使って2つの豊穣圏の間でhom対象を写せる。</p>
<p>2つの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐃</mi><annotation encoding="application/x-tex">\mathbf{D}</annotation></semantics></math>の間の<span
id="enriched_functor" class="keyword"><em>豊穣関手</em></span> (enriched
functor)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>は、対象を対象に写すだけでなく、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の対象のすべてのペアに対して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>内の射を割り当てる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mrow><mi>a</mi><mi>b</mi></mrow></msub><mo>∷</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>𝐃</mi><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>a</mi><mo>,</mo><mi>F</mi><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F_{a b} \Colon \mathbf{C}(a, b) \to \mathbf{D}(F a, F b)</annotation></semantics></math>
関手は構造を保持する写像だ。通常の関手では、それは合成と恒等射を保存することを意味した。豊穣化された設定においては、合成の保存とは次の図式が可換であることを意味する。</p>
<script type="text/tikz">
\begin{tikzcd}[column sep=large, row sep=large]
  \mathbf{C}(b,c) \otimes \mathbf{C}(a,b)
  \arrow[r, "\circ"]
  \arrow[d, "F_{bc} \otimes F_{ab}"]
  & \mathbf{C}(a,c)
  \arrow[d, "F_{ac}"] \\
  \mathbf{D}(F b, F c) \otimes \mathbf{D}(F a, F b)
  \arrow[r,  "\circ"]
  & \mathbf{D}(F a, F c)
\end{tikzcd}
</script>
<p>
恒等射の保存は、恒等射を「選択」するような<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐕</mi><annotation encoding="application/x-tex">\mathbf{V}</annotation></semantics></math>内の射の保存に置き換えられる。</p>
<script type="text/tikz">
\begin{tikzcd}[row sep=large]
  & i \arrow[dl, "j_a"'] \arrow[dr, "j_{F a}"] & \\
  \mathbf{C}(a,a)
  \arrow[rr, "F_{aa}"]
  & & \mathbf{D}(F a, F a)
\end{tikzcd}
</script>
<h2 data-number="28.7" id="自己豊穣化"><span
class="header-section-number">28.7</span> 自己豊穣化</h2>
<p>対称モノイダル閉圏は、hom集合を内部hom（前述の定義を参照）に置き換えることによって自己豊穣化できる。そのためには、内部homについての合成律を定義する必要がある。言い換えると、次のシグネチャーを持つ射を実装する必要がある。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mo>⊗</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo><mo>→</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[b, c] \otimes [a, b] \to [a, c]</annotation></semantics></math>
これはプログラミングでの他のタスクと大差ない。ただし、圏論では通常はポイントフリー実装を使う。まず、これを要素とするような集合を指定する。ここでは、次のhom集合の元だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐕</mi><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">[</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mo>⊗</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo><mo>,</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{V}([b, c] \otimes [a, b], [a, c])</annotation></semantics></math>
このhom集合は次と同型だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐕</mi><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">[</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mo>⊗</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{V}(([b, c] \otimes [a, b]) \otimes a, c)</annotation></semantics></math>
ここで、内部homである<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">{[}a, c{]}</annotation></semantics></math>の定義で出てきた随伴を使った。この新しい集合に射を構築できるなら、随伴はもとの集合の射を指し示してくれる。そして、その射は合成として使える。この射は、自由に使えるいくつかの射を合成することによって構築される。まず、結合切替子<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>α</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo><mspace width="0.222em"></mspace><mi>a</mi></mrow></msub><annotation encoding="application/x-tex">\alpha_{[b, c]\ [a, b]\ a}</annotation></semantics></math>を使って左側の式の結合を変えられる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">[</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mo>⊗</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mi>a</mi><mo>→</mo><mo stretchy="false" form="prefix">[</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mo>⊗</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo><mo>⊗</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">([b, c] \otimes [a, b]) \otimes a \to [b, c] \otimes ([a, b] \otimes a)</annotation></semantics></math>
続けて、随伴の余単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ε</mi><mrow><mi>a</mi><mi>b</mi></mrow></msub><annotation encoding="application/x-tex">\varepsilon_{a b}</annotation></semantics></math>を使える。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mo>⊗</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo><mo>⊗</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mo stretchy="false" form="prefix">[</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mo>⊗</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">[b, c] \otimes ([a, b] \otimes a) \to [b, c] \otimes b</annotation></semantics></math>
もう一度余単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ε</mi><mrow><mi>b</mi><mi>c</mi></mrow></msub><annotation encoding="application/x-tex">\varepsilon_{b c}</annotation></semantics></math>を使うと<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>が得られる。以上より射：
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mrow><mi>b</mi><mi>c</mi></mrow></msub><mo>∘</mo><mo stretchy="false" form="prefix">(</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mrow><mo stretchy="false" form="prefix">[</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo></mrow></msub><mo>⊗</mo><msub><mi>ε</mi><mrow><mi>a</mi><mi>b</mi></mrow></msub><mo stretchy="false" form="postfix">)</mo><mo>∘</mo><msub><mi>α</mi><mrow><mo stretchy="false" form="prefix">[</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo><mi>a</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varepsilon_{b c} \circ (%
\mathbf{id}_{{[b, c]}}%
 \otimes \varepsilon_{a b}) \circ \alpha_{[b, c] [a, b] a}</annotation></semantics></math>
が構築できた。これは次のhom集合の要素だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐕</mi><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">[</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">]</mo><mo>⊗</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo><mo>⊗</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{V}(([b, c] \otimes [a, b]) \otimes a, c)</annotation></semantics></math>
その後、随伴によって、目指していた合成律が得られる。</p>
<p>同様に、恒等射
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>j</mi><mi>a</mi></msub><mo>∷</mo><mi>i</mi><mo>→</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">j_a \Colon i \to [a, a]</annotation></semantics></math>
は次のhom集合の元だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐕</mi><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo>,</mo><mo stretchy="false" form="prefix">[</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{V}(i, [a, a])</annotation></semantics></math>
これは、随伴を通じて、次と同型だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐕</mi><mo stretchy="false" form="prefix">(</mo><mi>i</mi><mo>⊗</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{V}(i \otimes a, a)</annotation></semantics></math>
このhom集合は左単位積子<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>λ</mi><mi>a</mi></msub><annotation encoding="application/x-tex">\lambda_a</annotation></semantics></math>を含むことが分かっている。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>j</mi><mi>a</mi></msub><annotation encoding="application/x-tex">j_a</annotation></semantics></math>は随伴の下の像として定義できる。</p>
<p>自己豊穣化の実際的な例としては、プログラミング言語における型の原型として機能する圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>が挙げられる。以前、それがデカルト積についてのモノイダル閉圏であることを見た。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>では、任意の2集合間のhom集合はそれ自体が集合である。つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内の対象である。それが冪対象と同型であることは分かっているので、外部homと内部homは等価となる。さらに、自己豊穣化を通じて、冪対象をhom対象として使えて合成を冪対象のデカルト積によって表現できることも分かった。</p>
<h2 data-number="28.8" id="圏との関係"><span
class="header-section-number">28.8</span> 2-圏との関係</h2>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏については、（小さい）圏の圏である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>の文脈において説明した。圏の間の射は関手だが、追加の構造がある。関手間の自然変換だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏では、対象は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-セル、射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セル、射間の射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セルと呼ばれることが多い。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-セルは圏、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルは関手、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セルは自然変換だ。</p>
<p>しかし、2つの圏の間の関手も圏をなすことに注意してほしい。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>に実際にあるのは、hom集合というより<em>hom圏</em>だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>上の豊穣圏として扱えるのと同様に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>上の豊穣圏として扱えることが知られている。さらに一般的に、すべての圏が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>上の豊穣圏として扱えるのと同様に、すべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>上の豊穣圏と見なせる。</p>
<h1 data-number="29" id="トポイ"><span
class="header-section-number">29</span> トポイ</h1>
<p>プログラミングから離れてハードコアな数学に飛び込んでしまったかもしれないのは分かっている。しかし、プログラミングにおける次の大きな革命が何をもたらすのか、理解のためにどんな数学が必要となるのかは、誰にも分からない。すでにいくつか非常に興味深いアイデアがある。連続時間<a
href="#fn172" class="footnote-ref" id="fnref172"
role="doc-noteref"><sup>172</sup></a>での関数型リアクティブプログラミング、Haskellの型システムの依存型による拡張、ホモトピー型理論のプログラミングにおける探究などだ。</p>
<p>ここまでは、値の<em>集合</em>を使って気楽に型を区別してきた。これは厳密には正しくない。なぜなら、このようなアプローチはある事実を考慮していないからだ。それは、プログラミングでは値を<em>計算</em>し、そして計算は時間のかかるプロセスであり、極端な場合には停止しない可能性がある、という事実だ。すべてのチューリング完全な言語は発散計算
(divergent computation) を含む。</p>
<p>また、集合論には、計算機科学の基礎として、そして数学自体の基礎としても、最適とは言い難い根本的な理由がある。良い比喩としては、集合論は特定のアーキテクチャに結び付けられたアセンブリー言語だと言える。別のアーキテクチャで計算を実行したいなら、より一般的なツールを使う必要がある。</p>
<p>可能性の1つは、集合の代わりに空間 (space)
を使うことだ。空間は構造がより豊かで、集合を使わずに定義できる。通常、空間に関連付けられるものの1つは位相
(topology)
で、連続性などを定義するために必要だ。位相への従来のアプローチは、ご想像のとおり、集合論によるものだ。特に、部分集合は位相の中心的な概念だ。驚くまでもなく、圏論の研究者たちはこの概念を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>以外の圏に一般化した。集合論に代わるものとしてふさわしい性質を持つ圏の型は<span
id="topos" class="keyword"><em>トポス</em></span>（topos,
複数形：トポイtopoi）と呼ばれ、部分集合を一般化した概念などを提供する。</p>
<h2 data-number="29.1" id="部分対象分類子"><span
class="header-section-number">29.1</span> 部分対象分類子</h2>
<p>要素ではなく関数を使って部分集合の概念を表現することから始めよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への任意の関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の部分集合――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>の下にある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の像――を定義する。しかし、同一の部分集合を定義する関数はたくさんある。もっと具体的にする必要がある。まず初めに、単射関数
(injective function)
――複数の要素を1つに潰さない関数に焦点を当てよう。単射関数はある集合を別の集合に「注入」する。有限集合における単射関数は、ある集合の要素を別の集合の要素に接続する平行な射として視覚化できる。当然、1番目の集合を2番目の集合より大きくはできない。そうでないと射は必然的に収束する。まだ曖昧さは残っている。別の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>a</mi><mo>′</mo></msup><annotation encoding="application/x-tex">a&#39;</annotation></semantics></math>と、その集合から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への別の単射関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>f</mi><mo>′</mo></msup><annotation encoding="application/x-tex">f&#39;</annotation></semantics></math>があって、同じ部分集合が選ばれる可能性がある。しかし、そのような集合が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と同型でなければならないことは簡単に納得できる。この事実を利用して、部分集合を、余域の同型によって関連付けられた単射関数の族として定義できる。より正確には、2つの単射関数
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>f</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msup><mi>f</mi><mo>′</mo></msup></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><msup><mi>a</mi><mo>′</mo></msup><mo>→</mo><mi>b</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
f &amp;\Colon a \to b \\
f&#39; &amp;\Colon a&#39; \to b
\end{aligned}
</annotation></semantics></math> が等価になるのは、同型射
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>∷</mo><mi>a</mi><mo>→</mo><msup><mi>a</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">h \Colon a \to a&#39;</annotation></semantics></math>
が存在する場合だ。ただし、
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><msup><mi>f</mi><mo>′</mo></msup><mo>∘</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">f = f&#39; \circ h</annotation></semantics></math>
このような等価な単射の族は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の部分集合を定義する。</p>
<p> <img src="images/subsetinjection.jpg" style="width:40.0%" /> </p>
<p> この定義は、単射関数をモノ射 (monomorphism)
に置き換えることで任意の圏に持ち上げられる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>へのモノ射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>は普遍性によって定義されることを思い出してほしい。任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>c</mi><annotation encoding="application/x-tex">c</annotation></semantics></math>および任意の射のペア
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><mi>g</mi></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>c</mi><mo>→</mo><mi>a</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right; padding-right: 0"><msup><mi>g</mi><mo>′</mo></msup></mtd><mtd columnalign="left" style="text-align: left; padding-left: 0"><mo>∷</mo><mi>c</mi><mo>→</mo><mi>a</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{aligned}
g &amp;\Colon c \to a \\
g&#39; &amp;\Colon c \to a
\end{aligned}
</annotation></semantics></math> のうち
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>∘</mo><mi>g</mi><mo>=</mo><mi>m</mi><mo>∘</mo><msup><mi>g</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">m \circ g = m \circ g&#39;</annotation></semantics></math>
を満たすものについては<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>=</mo><msup><mi>g</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">g = g&#39;</annotation></semantics></math>である必要がある。</p>
<p> <img src="images/monomorphism.jpg" style="width:40.0%" /> </p>
<p>
集合においてこの定義をより理解しやすくするには、関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>がモノ射で<em>ない</em>ことが何を意味するかを考えるとよい。その場合は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の2つの異なる要素が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の1つの要素に写されるだろう。そして、それら2つの要素についてのみ違いがある2つの関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>g</mi><mo>′</mo></msup><annotation encoding="application/x-tex">g&#39;</annotation></semantics></math>を見つけられる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>に後合成すると、その違いは見えなくなる。</p>
<p> <img src="images/notmono.jpg" style="width:40.0%" /> </p>
<p> 部分集合を定義する別の方法もある。特性関数 (characteristic function)
と呼ばれる単一の関数を使う方法だ。これは、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>から二元集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>への関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>χ</mi><annotation encoding="application/x-tex">\chi</annotation></semantics></math>だ。二元集合の片方の要素には
“true” が、もう片方には “false”
が指定されている。この関数は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の要素のうち部分集合の元である要素に
“true” を割り当て、そうでない要素に “false” を割り当てる。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>の要素を
“true”
に指定することの意味を明確にする必要が残る。ここで標準的なトリックが使える。すなわち、単元集合から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>への関数を使えばよい。この関数を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑡</mi><mi>𝑟</mi><mi>𝑢</mi><mi>𝑒</mi></mrow><annotation encoding="application/x-tex">\mathit{true}</annotation></semantics></math>と呼ぼう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑡</mi><mi>𝑟</mi><mi>𝑢</mi><mi>𝑒</mi></mrow><mo>∷</mo><mn>1</mn><mo>→</mo><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\mathit{true} \Colon 1 \to \Omega</annotation></semantics></math></p>
<p> <img src="images/true.jpg" style="width:40.0%" /> </p>
<p> これらの定義の組み合わせ方によっては、部分対象 (subobject)
が何であるかだけでなく、特別な対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>についても要素に触れずに定義できる。ここでのアイデアは、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑡</mi><mi>𝑟</mi><mi>𝑢</mi><mi>𝑒</mi></mrow><annotation encoding="application/x-tex">\mathit{true}</annotation></semantics></math>が「総称」部分対象を表すようにしたい、というものだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>では、これは2要素の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>から1要素の部分集合を選ぶ。これは最大限に総称的だ。ここで選ばれたものがれっきとした部分集合なのは明らかだ。なぜなら、この部分集合には<em>ない</em>要素が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>にはもう1つあるからだ。</p>
<p>より一般的な条件では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑡</mi><mi>𝑟</mi><mi>𝑢</mi><mi>𝑒</mi></mrow><annotation encoding="application/x-tex">\mathit{true}</annotation></semantics></math>を終対象から<em>分類対象</em>
(classifying object)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>へのモノ射として定義する。ただし、分類対象の定義が必要になる。つまり、この対象を特性関数に結びつける普遍性が必要だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>では、特性関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>χ</mi><annotation encoding="application/x-tex">\chi</annotation></semantics></math>に沿った<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑡</mi><mi>𝑟</mi><mi>𝑢</mi><mi>𝑒</mi></mrow><annotation encoding="application/x-tex">\mathit{true}</annotation></semantics></math>の引き戻しが、部分集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>とそれを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>に埋め込む単射関数の両方を定義することが知られている。その引き戻し図式を以下に示す。</p>
<p> <img src="images/pullback.jpg" style="width:40.0%" /> </p>
<p> この図式を分析してみよう。引き戻しの式は次のとおりだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑡</mi><mi>𝑟</mi><mi>𝑢</mi><mi>𝑒</mi></mrow><mo>∘</mo><mrow><mi>𝑢</mi><mi>𝑛</mi><mi>𝑖</mi><mi>𝑡</mi></mrow><mo>=</mo><mi>χ</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">\mathit{true} \circ \mathit{unit} = \chi \circ f</annotation></semantics></math>
関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑡</mi><mi>𝑟</mi><mi>𝑢</mi><mi>𝑒</mi></mrow><mo>∘</mo><mrow><mi>𝑢</mi><mi>𝑛</mi><mi>𝑖</mi><mi>𝑡</mi></mrow></mrow><annotation encoding="application/x-tex">\mathit{true} \circ \mathit{unit}</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>のすべての要素を
“true”
に写す。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>のすべての要素を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の要素のうち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>χ</mi><annotation encoding="application/x-tex">\chi</annotation></semantics></math>が
“true”
であるものに写す必要がある。定義より、これらは特性関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>χ</mi><annotation encoding="application/x-tex">\chi</annotation></semantics></math>によって指定される部分集合の要素だ。つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>の像はまさに求めていた部分集合だ。引き戻しの普遍性によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>は単射だと保証される。</p>
<p>この引き戻し図式は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>以外の圏の分類対象を定義するのに使える。そのような圏には終対象が必要で、それによってモノ射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑡</mi><mi>𝑟</mi><mi>𝑢</mi><mi>𝑒</mi></mrow><annotation encoding="application/x-tex">\mathit{true}</annotation></semantics></math>を定義できる。また、引き戻しも必要だ――実際の要件は、すべての有限の極限を持つことだ（引き戻しは有限の極限の一例だ）。これらの仮定の下で、分類対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>を、すべてのモノ射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>について引き戻し図式を完成させる一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>χ</mi><annotation encoding="application/x-tex">\chi</annotation></semantics></math>が存在する、という特性によって定義する。</p>
<p>この特性を分析しよう。引き戻しを構築するとき、3つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>と、2つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑡</mi><mi>𝑟</mi><mi>𝑢</mi><mi>𝑒</mi></mrow><annotation encoding="application/x-tex">\mathit{true}</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>χ</mi><annotation encoding="application/x-tex">\chi</annotation></semantics></math>が与えられる。引き戻しの存在は、図式を可換にするような2つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑢</mi><mi>𝑛</mi><mi>𝑖</mi><mi>𝑡</mi></mrow><annotation encoding="application/x-tex">\mathit{unit}</annotation></semantics></math>（後者は終対象の定義によって一意に決定される）を伴った最適な対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を見つけられることを意味する。</p>
<p>ここでは連立微分方程式を解いていることになる。つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math><em>と</em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の両方を変化させることで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑡</mi><mi>𝑟</mi><mi>𝑢</mi><mi>𝑒</mi></mrow><annotation encoding="application/x-tex">\mathit{true}</annotation></semantics></math>について解いている。与えられた<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>および<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>について、モノ射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to b</annotation></semantics></math>がある場合とない場合がある。だが、もしあるなら、何らかの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>χ</mi><annotation encoding="application/x-tex">\chi</annotation></semantics></math>の引き戻しにしたい。さらに、この<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>χ</mi><annotation encoding="application/x-tex">\chi</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>によって一意に決定されるようにしたい。</p>
<p>モノ射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>と特性関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>χ</mi><annotation encoding="application/x-tex">\chi</annotation></semantics></math>の間に1対1の対応関係があるとは言えない。なぜなら、引き戻しは同型を除いて一意なだけだからだ。しかし、部分集合を等価な単射の族として以前定義したのを思い出してほしい。これを一般化するには、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の部分対象を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への等価なモノ射の族として定義すればよい。このモノ射の族は、先ほどの図式における等価な引き戻しの族と1対1で対応している。</p>
<p>したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の部分対象の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑆</mi><mi>𝑢</mi><mi>𝑏</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{Sub}(b)</annotation></semantics></math>
をモノ射の族として定義でき、それが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>への射の集合と同型だと分かる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑆</mi><mi>𝑢</mi><mi>𝑏</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>b</mi><mo>,</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{Sub}(b) \cong \mathbf{C}(b, \Omega)</annotation></semantics></math>
偶然にも、これは2つの関手の自然同型だ。言い換えれば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑆</mi><mi>𝑢</mi><mi>𝑏</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{Sub}(-)</annotation></semantics></math>
は表現可能（反変）関手であり、その表現は対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>だ。</p>
<aside id="footnotes-89" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="172">
<li
id="fn172"><p>訳注：離散時間（飛び飛びの時刻値のみを扱う）ではないという意味。<a
href="#fnref172" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h2 data-number="29.2" id="トポス"><span
class="header-section-number">29.2</span> トポス</h2>
<p>トポスは次のような圏だ。</p>
<ol type="1">
<li>デカルト閉である。つまり、積・終対象・（積の右随伴として定義される）冪のすべてを持つ。</li>
<li>すべての有限図式について極限を持つ。</li>
<li>部分対象分類子<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>がある。</li>
</ol>
<p>これらの特性によって、トポスはほとんどの用途で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>の代わりになる。さらに、定義から導かれる追加の特性もある。たとえば、トポスは始対象も含めてすべての有限の余極限を持つ。</p>
<p>部分対象分類子を終対象2つの余積（和）として――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>におけるのと同様に――定義するのは魅力的だが、もっと一般化したい。これが当てはまるトポイはブーリアンと呼ばれる。</p>
<h2 data-number="29.3" id="トポイと論理"><span
class="header-section-number">29.3</span> トポイと論理</h2>
<p>集合論では、特性関数は、集合の要素の特性――<span id="predicate2"
class="keyword"><em>述語</em></span> (predicate)
を定義するものと解釈されうる。述語は、一部の要素に対しては真となり、他の要素に対しては偽となる。述語<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑖</mi><mi>𝑠</mi><mi>𝐸</mi><mi>𝑣</mi><mi>𝑒</mi><mi>𝑛</mi></mrow><annotation encoding="application/x-tex">\mathit{isEven}</annotation></semantics></math>は自然数の集合から偶数の部分集合を選択する。トポスでは、述語の概念を対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>への射に一般化できる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Ω</mi><annotation encoding="application/x-tex">\Omega</annotation></semantics></math>が真偽対象
(truth object) と呼ばれることがあるのはこのためだ。</p>
<p>述語は論理の構成要素だ。トポスには、論理を研究するのに必要な全装備が揃っている。積は連言（conjunction,
論理<em>積</em>）に対応し、余積は選言（disjunction,
論理<em>和</em>）に対応し、冪は含意 (implication)
に対応する。排中律（または、等価なものとして、二重否定除去）を除く論理学の標準的な公理すべてがトポスに含まれている。これが、トポスの論理が構成的論理
(constructive logic) あるいは直観主義論理 (intuitionistic logic)
に対応する理由だ。</p>
<p>直観主義論理は計算機科学から予想外に支持され、着実に定着していっている。排中律という古典的な概念は、絶対的な真実があるという信念に基づいている。つまり、すべての記述は真か偽のいずれかであり、古代ローマ人が言ったように、<em>tertium
non
datur</em>（第3の道はない）ということだ。しかし、何かの真偽を知るための方法は、それを証明または反証できるかどうかだけだ。証明とはプロセスであり、計算だ――そして、知ってのとおり、計算には時間とリソースがかかる。場合によっては、停止しないこともある。有限の時間で証明できない命題を真だと主張するのは無意味だ。トポスにはより繊細な真偽対象があるので、より一般的な枠組みを提供して興味深い論理をモデル化できる。</p>
<h2 data-number="29.4" id="課題-20"><span
class="header-section-number">29.4</span> 課題</h2>
<ol type="1">
<li>特性関数に沿った<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑡</mi><mi>𝑟</mi><mi>𝑢</mi><mi>𝑒</mi></mrow><annotation encoding="application/x-tex">\mathit{true}</annotation></semantics></math>の引き戻しである関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>は単射でなければならないことを示せ。</li>
</ol>
<h1 data-number="30" id="ローヴェアセオリー"><span
class="header-section-number">30</span> ローヴェア・セオリー</h1>
<p>最近では、モナドに言及せずには関数プログラミングについて語れない。しかし、並行宇宙においては、エウジニオ・モッジがモナドではなくローヴェアのセオリー
(Lawvere theory)
に着目した可能性もあっただろう。そのような宇宙を探検しよう。</p>
<h2 data-number="30.1" id="普遍代数"><span
class="header-section-number">30.1</span> 普遍代数</h2>
<p>代数を様々な抽象レベルで記述する方法はたくさんある。モノイド・群・環などを記述するための汎用言語を見つけたい。最も単純なレベルでは、これらのすべての構造によって、集合の要素に対する<em>演算</em>と、それらの演算によって満たされなければならないいくつかの<em>規則</em>が定義される。たとえば、モノイドは結合律を満たす二項演算によって定義できる。単位元と単位律もある。しかし、少し想像力を働かせれば、単位元は零項演算――引数を取らず集合の特別な要素を返す操作――に変えられる。群について述べたければ、受け取った要素の逆を返す単項演算子を追加する。それに対応する左逆元律と右逆元律がある。環では2つの二項演算子とさらにいくつかの規則が定義される。以下同様だ。</p>
<p>大枠としては、代数はさまざまな値の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>についての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>項演算の集合と、恒等式の集合によって定義される。これらの恒等式はすべて全称量化されている。たとえば、結合律の式はすべての可能な3要素の組み合わせについて満たされる必要がある、などだ。</p>
<p>ちなみに、0（加算での単位元）が乗算での逆を持たないという単純な理由から、体
(field) は考慮から除外される。体の逆元律は全称量化できない。</p>
<p>この普遍代数の定義は、演算（関数）を射に置き換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>以外の圏にも拡張できる。集合の代わりに、（総称対象と呼ばれる）対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を選ぶ。単項演算は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の自己射にすぎない。しかし、それ以外の<span
id="arity" class="keyword"><em>アリティ</em></span>（arity,
演算の引数の数）についてはどうだろう？　二項演算（アリティ2）は、積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mrow></mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a \times{}a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>へ戻る射として定義できる。一般の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>項演算は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>乗から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>への射だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>n</mi></msub><mo>∷</mo><msup><mi>a</mi><mi>n</mi></msup><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">\alpha_n \Colon a^n \to a</annotation></semantics></math>
零項演算は、終対象（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の0乗）からの射だ。したがって、あらゆる代数を定義するために必要なのはある圏だけで、その圏の対象は1つの特別な対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の冪乗だ。特定の代数は、この圏のhom集合として表されている。これがローヴェア・セオリーの概略だ。</p>
<p>ローヴェア・セオリーの導出は多くのステップを経るため、道順を示しておく。</p>
<ol type="1">
<li>有限集合の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐅</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{FinSet}</annotation></semantics></math>。</li>
<li>そのスケルトン<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>。</li>
<li>その反対圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation></semantics></math>。</li>
<li>ローヴェア・セオリー<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>:
圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mi>𝐚</mi><mi>𝐰</mi></mrow><annotation encoding="application/x-tex">\mathbf{Law}</annotation></semantics></math>内のある対象。</li>
<li>ローヴェア圏のモデル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>:
圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐋</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L},\mathbf{Set})</annotation></semantics></math>
内のある対象。</li>
</ol>
<p> <img src="images/lawvere1.png" style="width:80.0%" /> </p>
<h2 data-number="30.2" id="ローヴェアセオリー-1"><span
class="header-section-number">30.2</span> ローヴェア・セオリー</h2>
<p>複数あるローヴェア・セオリーはすべて共通のバックボーンを共有している。ローヴェア・セオリーにおけるすべての対象は、ただ1つの対象から積を使って生成される（実際に、ただの冪乗だ）。しかし、一般の圏では、これらの積をどのように定義するのだろうか？　より単純な圏からの写像を使って積を定義できることが知られている。実際には、より単純なこの圏は積ではなく余積を定義することもあり、その場合は<em>反変</em>関手を使ってそれらを行き先の圏に埋め込む。反変関手は、余積を積に変換し、入射を射影に変換する。</p>
<p>ローヴェア圏のバックボーンとして自然な選択肢は、有限集合の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐅</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{FinSet}</annotation></semantics></math>だ。これは空集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⌀</mi><annotation encoding="application/x-tex">\varnothing</annotation></semantics></math>、単元集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>、二元集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>などを含む。この圏の対象はすべて、余積を使って単元集合から生成できる（空集合は零項余積の特殊なケースとして扱う）。たとえば、二元集合は2つの単元集合の和<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>=</mo><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 = 1 + 1</annotation></semantics></math>だ。Haskellでも次のように表現される。</p>
<div class="sourceCode" id="cb590"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb590-1"><a href="#cb590-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Two</span> <span class="ot">=</span> <span class="dt">Either</span> () ()</span></code></pre></div>
<p>
しかし、空集合は1つしかないと考えるのが自然だとしても、単元集合は異なるものが多数あり得る。典型的な例として、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mi>⌀</mi></mrow><annotation encoding="application/x-tex">1 + \varnothing</annotation></semantics></math>と集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>⌀</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\varnothing + 1</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>はどれも同型であるにもかかわらず、それぞれ異なる。集合の圏の余積は結合律を満たさない。この状況を解決するには、すべての同型集合を同一視する圏を構成すればよい。そのような圏は<span
id="skeleton" class="keyword"><em>スケルトン</em></span> (skeleton)
と呼ばれる。言い換えれば、すべてのローヴェア・セオリーのバックボーンは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐅</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{FinSet}</annotation></semantics></math>のスケルトン<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>だ。この圏の対象は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐅</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{FinSet}</annotation></semantics></math>の要素数に対応した（0を含む）自然数と同一視できる。余積は加算の役割を果たす。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>内の射は有限集合間の関数に対応する。例として、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⌀</mi><annotation encoding="application/x-tex">\varnothing</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>への（空集合を始対象とする）一意な射があり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⌀</mi><annotation encoding="application/x-tex">\varnothing</annotation></semantics></math>への射は（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>⌀</mi><mo>→</mo><mi>⌀</mi></mrow><annotation encoding="application/x-tex">\varnothing \to \varnothing</annotation></semantics></math>を除いて）なく、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>への射（単射）は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>あり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>への射は1つある、などが挙げられる。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>内のある対象を表し、同型によって同一視された<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐅</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{FinSet}</annotation></semantics></math>内のすべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>要素集合に対応する。</p>
<p>圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>を使うと、<span
id="lawvere_theory"
class="keyword"><em>ローヴェア・セオリー</em></span>を、次の特別な関手を伴う圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>として形式的に定義できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>𝐋</mi></msub><mo>∷</mo><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>→</mo><mi>𝐋</mi></mrow><annotation encoding="application/x-tex">I_{\mathbf{L}} \Colon \mathbf{F}^\mathit{op}\to \mathbf{L}</annotation></semantics></math>
この関手は対象の全単射である必要があり、有限積を保存する必要がある（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation></semantics></math>内の積と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>内の余積は同じだ）。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mi>𝐋</mi></msub><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo>×</mo><mrow></mrow><mi>n</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msub><mi>I</mi><mi>𝐋</mi></msub><mi>m</mi><mo>×</mo><mrow></mrow><msub><mi>I</mi><mi>𝐋</mi></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">I_{\mathbf{L}} (m\times{}n) = I_{\mathbf{L}} m\times{}I_{\mathbf{L}} n</annotation></semantics></math>
この関手は対象における恒等関係と見なされることがある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>内と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内とで対象が同じであることを表すからだ。そこで、これらに同じ名前を使うことにし、自然数で表そう。ただし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>内の対象は集合と同じではないことに注意してほしい（それらは同型集合のクラスだ）。</p>
<p>一般に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内のhom集合は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation></semantics></math>内のhom集合よりも豊穣だ。これらは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐅</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{FinSet}</annotation></semantics></math>内の関数に対応する射（<span
id="basic_product_operations"
class="keyword"><em>基本的な積操作</em></span> (basic product operation)
とも呼ばれる）以外の射も含むことがある。ローヴェア・セオリーの等式規則はそれらの射として表されている。</p>
<p>鍵となる観察は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>内の単元集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内で同じく<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>と呼ばれる対象に写され、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内の他のすべての対象が自動的にこの対象の冪乗になることだ。たとえば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>内の二元集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>は余積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1+1</annotation></semantics></math>であるため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内の積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \times 1</annotation></semantics></math>（または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mn>1</mn><mn>2</mn></msup><annotation encoding="application/x-tex">1^2</annotation></semantics></math>）に写される必要がある。この意味で、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>の対数のように振る舞う。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内の射には、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mi>𝐋</mi></msub><annotation encoding="application/x-tex">I_{\mathbf{L}}</annotation></semantics></math>によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>から転送されたものもある。それらは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>で構造としての役割を果たす。特に、余積の入射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>i</mi><mi>k</mi></msub><annotation encoding="application/x-tex">i_k</annotation></semantics></math>は積の射影<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>k</mi></msub><annotation encoding="application/x-tex">p_k</annotation></semantics></math>になる。直観として有用なのは、射影
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>p</mi><mi>k</mi></msub><mo>∷</mo><msup><mn>1</mn><mi>n</mi></msup><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p_k \Colon 1^n \to 1</annotation></semantics></math>
を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>個の変数のうち第<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>番目以外のすべてを無視するような関数のプロトタイプとして想像することだ。逆に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>内の定常射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \to 1</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内では対角射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><msup><mn>1</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">1 \to 1^n</annotation></semantics></math>になる。これらは変数の複製に相当する。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内の射のうちで興味深いのは、射影以外の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>項演算を定義するものだ。それらの射によって、あるローヴェア・セオリーと別のものとが区別される。それらは乗算・加算・単位元の選択などで、代数を定義する。しかし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>を完全な圏にするためには、複合操作<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>→</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \to m</annotation></semantics></math>（あるいは、等価なものとして、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>1</mn><mi>n</mi></msup><mo>→</mo><msup><mn>1</mn><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">1^n \to 1^m</annotation></semantics></math>）も必要だ。圏の構造が単純なため、これらは型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n \to 1</annotation></semantics></math>のより単純な射の積だと分かる。これは、積を返す関数は関数の積である（あるいは、前に見たように、hom関手は連続である）という言明を一般化したものだ。</p>
<figure>
<img src="images/lawvere1.png"
title="ローヴェア・セオリー$\cat{L}$は$\Fop$に基づいており、積を定義する「退屈な」射はそこから継承されている。それは$n$項操作（点線の矢印）を記述するような「興味深い」射を追加する。"
style="width:80.0%"
alt="ローヴェア・セオリー\mathbf{L}は\mathbf{F}^\mathit{op}に基づいており、積を定義する「退屈な」射はそこから継承されている。それはn項操作（点線の矢印）を記述するような「興味深い」射を追加する。" />
<figcaption
aria-hidden="true">ローヴェア・セオリー<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation></semantics></math>に基づいており、積を定義する「退屈な」射はそこから継承されている。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>項操作（点線の矢印）を記述するような「興味深い」射を追加する。</figcaption>
</figure>
<p></p>
<p>ローヴェア・セオリーは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mi>𝐚</mi><mi>𝐰</mi></mrow><annotation encoding="application/x-tex">\mathbf{Law}</annotation></semantics></math>をなす。この圏の射は、有限積を保存し関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>I</mi><annotation encoding="application/x-tex">I</annotation></semantics></math>と可換な関手だ。そのような2つのセオリー
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐋</mi><mo>,</mo><msub><mi>I</mi><mi>𝐋</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{L}, I_{\mathbf{L}})</annotation></semantics></math>
と
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>𝐋</mi><mo mathvariant="bold">′</mo></msup><mo>,</mo><msub><msup><mi>I</mi><mo>′</mo></msup><msup><mi>𝐋</mi><mo mathvariant="bold">′</mo></msup></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf{L&#39;}, I&#39;_{\mathbf{L&#39;}})</annotation></semantics></math>
が与えられたとき、それらの間の射は以下を満たす関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo>∷</mo><mi>𝐋</mi><mo>→</mo><msup><mi>𝐋</mi><mo mathvariant="bold">′</mo></msup></mrow><annotation encoding="application/x-tex">F \Colon \mathbf{L} \to \mathbf{L&#39;}</annotation></semantics></math>となる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo>×</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>F</mi><mi>m</mi><mo>×</mo><mi>F</mi><mi>n</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>F</mi><mo>∘</mo><msub><mi>I</mi><mi>𝐋</mi></msub><mo>=</mo><msub><msup><mi>I</mi><mo>′</mo></msup><msup><mi>𝐋</mi><mo mathvariant="bold">′</mo></msup></msub></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
F (m \times n) = F m \times F n \\
F \circ I_{\mathbf{L}} = I&#39;_{\mathbf{L&#39;}}
\end{gathered}
</annotation></semantics></math>
ローヴェア・セオリーの間の射は、あるセオリーを別のセオリーの中で解釈するという概念を要約したものだ。たとえば、群の乗算は逆を無視すればモノイドの乗算として解釈できる。</p>
<p>ローヴェア圏の最も単純で自明な例は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation></semantics></math>自体だ（これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mi>𝐋</mi></msub><annotation encoding="application/x-tex">I_{\mathbf{L}}</annotation></semantics></math>についての恒等関手の選択に対応する）。演算や規則を持たないこのローヴェア・セオリーは、たまたま<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mi>𝐚</mi><mi>𝐰</mi></mrow><annotation encoding="application/x-tex">\mathbf{Law}</annotation></semantics></math>の始対象でもある。</p>
<p>この時点でローヴェア・セオリーの自明でない例を示せば非常に有益だろうが、モデルとは何かを先に理解しておかなければ、説明が困難だ。</p>
<h2 data-number="30.3" id="ローヴェアセオリーにおけるモデル"><span
class="header-section-number">30.3</span>
ローヴェア・セオリーにおけるモデル</h2>
<p>ローヴェア・セオリーを理解するための鍵は、ある1つのセオリーは同じ構造を共有する多くの個別の代数を一般化している、と理解することだ。たとえば、モノイドのローヴェア・セオリーは、モノイドであることの本質を説明している。それはすべてのモノイドで有効である必要がある。特定のモノイドはそのようなセオリーのモデルとなる。あるモデルは、ローヴェア・セオリー<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>から集合の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への関手として定義される。（モデルに他の圏を使う一般化されたローヴェア・セオリーもあるが、ここでは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>だけに集中する。）
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>の構造は積に大きく依存するため、そのような関手は有限積を保存する必要がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>のモデルは、ローヴェア・セオリー<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>の上の代数とも呼ばれ、次の関手によって定義される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>M</mi><mo>∷</mo><mi>𝐋</mi><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>M</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>×</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>M</mi><mi>a</mi><mo>×</mo><mi>M</mi><mi>b</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
M \Colon \mathbf{L} \to \mathbf{Set}\\
M (a \times b) \cong M a \times M b
\end{gathered}
</annotation></semantics></math>
積の保存は<em>同型を除いて</em>のみ必要であることに注意してほしい。積を厳密に保存するとほとんどの興味深いセオリーが棄却されるので、これは非常に重要だ。</p>
<p>モデルによる積の保存は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>の像が、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">M 1</annotation></semantics></math>――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>からの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>の像――の冪乗によって生成された一連の集合であることを意味する。この集合を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と呼ぼう。(この集合は<em>ソート</em>
(sort) と呼ばれることがあり、このような代数は<span id="single-sorted"
class="keyword"><em>シングルソート</em></span> (single-sorted)
と呼ばれる。ローヴェア・セオリーのマルチソート代数 (multi-sorted
algebra) への一般化も存在する。)
特に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>からの二項演算は次の関数に写される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>a</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a \times a \to a</annotation></semantics></math>
あらゆる関手でそうであるように、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内の複数の射が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内の同じ関数に潰されることがある。</p>
<p>ちなみに、すべての規則は全称量化された等しさであるという事実は、すべてのローヴェア・セオリーが自明なモデルを持つことを意味する。その自明なモデルは定関手で、すべての対象を単元集合へ、すべての射をその上の恒等関数へ写す。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>→</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \to n</annotation></semantics></math>という形式を取る一般の射は、次の関数に写される。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>m</mi></msup><mo>→</mo><msup><mi>a</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">a^m \to a^n</annotation></semantics></math>
2つの異なるモデル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>がある場合、それらの間の自然変換は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>で添字付けされた関数の族になる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>n</mi></msub><mo>∷</mo><mi>M</mi><mi>n</mi><mo>→</mo><mi>N</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">\mu_n \Colon M n \to N n</annotation></semantics></math>
または、等価なものとして
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>μ</mi><mi>n</mi></msub><mo>∷</mo><msup><mi>a</mi><mi>n</mi></msup><mo>→</mo><msup><mi>b</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">\mu_n \Colon a^n \to b^n</annotation></semantics></math>
ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mo>=</mo><mi>N</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">b = N 1</annotation></semantics></math>だ。</p>
<p>自然性条件によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>項演算の保存が保証されることに注意してほしい。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mi>f</mi><mo>∘</mo><msub><mi>μ</mi><mi>n</mi></msub><mo>=</mo><msub><mi>μ</mi><mn>1</mn></msub><mo>∘</mo><mi>M</mi><mi>f</mi></mrow><annotation encoding="application/x-tex">N f \circ \mu_n = \mu_1 \circ M f</annotation></semantics></math>
ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>n</mi><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f \Colon n \to 1</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>における<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>項演算だ。</p>
<p>モデルを定義する関数はモデルの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐋</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L}, \mathbf{Set})</annotation></semantics></math>
をなし、自然変換が射となる。</p>
<p>自明なローヴェア圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation></semantics></math>のモデルを考えてみよう。そのようなモデルは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>での値<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">M 1</annotation></semantics></math>によって完全に決定される。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">M 1</annotation></semantics></math>は任意の集合でよいため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>が含む集合と同じ数のモデルがある。さらに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{F}^\mathit{op}, \mathbf{Set})</annotation></semantics></math>
内の射（関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>の間の自然変換）はどれも<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">M 1</annotation></semantics></math>における成分によって一意に決定される。逆に、関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mn>1</mn><mo>→</mo><mi>N</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">M 1 \to N 1</annotation></semantics></math>はどれも2つのモデル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>の間に自然変換を引き起こす。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{F}^\mathit{op}, \mathbf{Set})</annotation></semantics></math>
は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>と同値だ。</p>
<h2 data-number="30.4" id="モノイドのセオリー"><span
class="header-section-number">30.4</span> モノイドのセオリー</h2>
<p>ローヴェア・セオリーの最も単純で重要な例は、モノイドの構造を記述することだ。それは、すべての可能なモノイドの構造を抽出した単一のセオリーだ。つまり、そのモデルはモノイドの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>全体に及ぶ。すでに述べた<a
href="#free-monoids">普遍的構成</a>は、射の部分集合を同一視すれば、すべてのモノイドが適切な自由モノイドから得られることを示していた。したがって、1つの自由モノイドですべてのモノイドがすでに一般化されている。しかし、自由モノイドは無数に存在する。モノイドに対するローヴェア・セオリー<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐋</mi><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow></msub><annotation encoding="application/x-tex">\mathbf{L}_{\mathbf{Mon}}</annotation></semantics></math>は、それらすべてを1つのエレガントな構成にまとめる。</p>
<p>すべてのモノイドは単位元を持つので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐋</mi><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow></msub><annotation encoding="application/x-tex">\mathbf{L}_{\mathbf{Mon}}</annotation></semantics></math>内には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>への特別な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>が必要だ。これに対応する射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>内には存在しないことに注意してほしい。仮にそのような射が存在するなら、逆向きの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>への射になるので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐅</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{FinSet}</annotation></semantics></math>内では単元集合から空集合への関数になるだろう。しかし、そのような関数は存在しない。</p>
<p>次に、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2 \to 1</annotation></semantics></math>を考える。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐋</mi><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}_{\mathbf{Mon}}(2, 1)</annotation></semantics></math>
のメンバーで、すべての二項演算のプロトタイプを含む必要がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>𝐋</mi><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow></msub><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L}_{\mathbf{Mon}}, \mathbf{Set})</annotation></semantics></math>
でモデルを構成するとき、これらの射はデカルト積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mn>1</mn><mo>×</mo><mi>M</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">M 1 \times M 1</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">M 1</annotation></semantics></math>への関数に写される。言い換えると、引数2つを取る関数になる。</p>
<p>問題は、モノイダル演算子のみを使って何種類の2引数関数を実装できるかだ。2つの引数を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>と呼ぼう。両方の引数を無視してモノイダル単位元を返す関数が1つある。それから、それぞれ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>を返す2つの射影がある。さらに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mo>,</mo><mi>b</mi><mi>a</mi><mo>,</mo><mi>a</mi><mi>a</mi><mo>,</mo><mi>b</mi><mi>b</mi><mo>,</mo><mi>a</mi><mi>a</mi><mi>b</mi><mo>,</mo><mi>…</mi></mrow><annotation encoding="application/x-tex">ab, ba, aa, bb, aab, \ldots</annotation></semantics></math>などを返す関数が続く。実際には、このような2引数関数は、生成元<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>を伴う自由モノイドの要素と同じ数だけ存在する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐋</mi><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}_{\mathbf{Mon}}(2, 1)</annotation></semantics></math>
はモデルの1つが自由モノイドであるため、これらすべての射を含む必要があることに注意してほしい。自由モノイドでは、これらは別々の関数に対応する。他のモデルでは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐋</mi><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}_{\mathbf{Mon}}(2, 1)</annotation></semantics></math>
の複数の射が1つの関数へと潰される場合があるが、自由モノイドではそうならない。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>個の生成元<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>n</mi><mo>*</mo></msup><annotation encoding="application/x-tex">n^*</annotation></semantics></math>を使って自由モノイドを表せば、hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>2</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(2, 1)</annotation></semantics></math>
をモノイドの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>内のhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><mo stretchy="false" form="prefix">(</mo><msup><mn>1</mn><mo>*</mo></msup><mo>,</mo><msup><mn>2</mn><mo>*</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Mon}(1^*, 2^*)</annotation></semantics></math>
と同一視できる。一般に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝐋</mi><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow></msub><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}_{\mathbf{Mon}}(m, n)</annotation></semantics></math>
を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>n</mi><mo>*</mo></msup><mo>,</mo><msup><mi>m</mi><mo>*</mo></msup><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Mon}(n^*, m^*)</annotation></semantics></math>
として選ぶ。言い換えると、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>𝐋</mi><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow></msub><annotation encoding="application/x-tex">\mathbf{L}_{\mathbf{Mon}}</annotation></semantics></math>は自由モノイドの圏の逆だ。</p>
<p>モノイドに関するローヴェア・セオリーの<em>モデル</em>の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>𝐋</mi><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow></msub><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L}_{\mathbf{Mon}}, \mathbf{Set})</annotation></semantics></math>
は、モノイドすべての圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Mon}</annotation></semantics></math>と等価だ。</p>
<h2 data-number="30.5" id="ローヴェアセオリーとモナド"><span
class="header-section-number">30.5</span>
ローヴェア・セオリーとモナド</h2>
<p>覚えていると思うが、代数のセオリーはモナドを使って――典型的には<a
href="#algebras-for-monads">モナドの代数</a>で――記述できる。ローヴェア・セオリーとモナドがつながっているのは驚くべきことではない。</p>
<p>まず、ローヴェア・セオリーからモナドがどのように導出されるかを見てみよう。導出は忘却関手と自由関手の間の<a
href="#freeforgetful-adjunctions">随伴</a>を経る。忘却関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>は、ある集合を各モデルに割り当てる。その集合は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐋</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L}, \mathbf{Set})</annotation></semantics></math>
からの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math>を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>において評価することで得られる。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>を導出するもう1つの方法は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation></semantics></math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mi>𝐚</mi><mi>𝐰</mi></mrow><annotation encoding="application/x-tex">\mathbf{Law}</annotation></semantics></math>の始対象であるという事実を利用することだ。これは、すべてのローヴェア・セオリー<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>について、一意な関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>→</mo><mi>𝐋</mi></mrow><annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}\to \mathbf{L}</annotation></semantics></math>があることを意味する。この関手は、モデル上に逆向きの関手を引き起こす（モデルはセオリー<em>から</em>集合への関手だからだ）。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐋</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L}, \mathbf{Set}) \to \mathbf{Mod}(\mathbf{F}^\mathit{op}, \mathbf{Set})</annotation></semantics></math>
ただし、すでに議論したように、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation></semantics></math>のモデルの圏は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>と同値だ。したがって、次の忘却関手が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mo>∷</mo><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐋</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">U \Colon \mathbf{Mod}(\mathbf{L}, \mathbf{Set}) \to \mathbf{Set}</annotation></semantics></math>
このように定義された<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>U</mi><annotation encoding="application/x-tex">U</annotation></semantics></math>は左随伴としての自由関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>を常に持つことが示せる。</p>
<p>このことは有限集合の場合には簡単に分かる。自由関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>は自由代数を生成する。自由代数は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐋</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L}, \mathbf{Set})</annotation></semantics></math>
内の特定のモデルであり、生成元の有限集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>から生成される。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>は表現可能関手として実装できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>∷</mo><mi>𝐋</mi><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{L}(n, -) \Colon \mathbf{L} \to \mathbf{Set}</annotation></semantics></math>
これが本当に自由であることを示すには、忘却関手への左随伴であることさえ証明すればよい。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐌</mi><mi>𝐨</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>𝐋</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>M</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>U</mi><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L}, \mathbf{Set})(\mathbf{L}(n, -), M) \cong \mathbf{Set}(n, U(M))</annotation></semantics></math>
右辺を単純化しよう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>U</mi><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>M</mi><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mo stretchy="false" form="prefix">(</mo><mi>M</mi><mn>1</mn><msup><mo stretchy="false" form="postfix">)</mo><mi>n</mi></msup><mo>≅</mo><mi>M</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}(n, U(M)) \cong \mathbf{Set}(n, M 1) \cong (M 1)^n \cong M n</annotation></semantics></math>
（射の集合が冪と同型であり、ここでは単に積の反復であるという事実を使った。）
随伴は米田の補題の結果だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">[</mo><mi>𝐋</mi><mo>,</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="postfix">]</mo><mo stretchy="false" form="prefix">(</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>−</mi><mo stretchy="false" form="postfix">)</mo><mo>,</mo><mi>M</mi><mo stretchy="false" form="postfix">)</mo><mo>≅</mo><mi>M</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">[\mathbf{L}, \mathbf{Set}](\mathbf{L}(n, -), M) \cong M n</annotation></semantics></math>
まとめると、忘却関手と自由関手によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>上の<a
href="#monads-categorically">モナド</a><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mi>U</mi><mo>∘</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">T = U \circ F</annotation></semantics></math>が定義される。したがって、すべてのローヴェア・セオリーはモナドを生成する。</p>
<p>モデルに対する<a
href="#algebras-for-monads">モナドの代数</a>の圏はモデルの圏と同値だと分かる。</p>
<p>モナドを使って形成された式の評価方法はモナド代数によって定義されるのを思い出しただろう。ローヴェア・セオリーは、式の生成に使えるn項演算を定義する。モデルは、それらの式を評価する手段を提供する。</p>
<p>しかし、モナドとローヴェア・セオリーは双方向の関係にはない。有限的モナド
(finitary monad)
からのみローヴェア・セオリーが導出される。有限的モナドは有限的関手に基づく。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>上のある有限的関手は、有限集合への作用によって完全に決定される。任意の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>への作用は、次のコエンドを使って評価できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>a</mi><mo>=</mo><msup><mo>∫</mo><mi>n</mi></msup><msup><mi>a</mi><mi>n</mi></msup><mo>×</mo><mo stretchy="false" form="prefix">(</mo><mi>F</mi><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F a = \int^n a^n \times (F n)</annotation></semantics></math>
コエンドは余積すなわち和の一般化なので、この式は冪級数展開の一般化になる。あるいは、関手は一般化したコンテナーだ、という直観に頼ってもよい。その場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の有限的コンテナーは、形と内容の和として記述できる。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">F n</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>個の要素を格納するための形の集合だ。また、内容は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>要素の組であり、それ自体が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>a</mi><mi>n</mi></msup><annotation encoding="application/x-tex">a^n</annotation></semantics></math>の要素だ。たとえば、（関手としての）リストは有限的であり、アリティごとに1つの形を持つ。木はアリティごとにより多くの形を持つ、なども挙げられる。</p>
<p>まず第一に、ローヴェア・セオリーから生成されたすべてのモナドは有限的であり、コエンドとして表せる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>𝐋</mi></msub><mi>a</mi><mo>=</mo><msup><mo>∫</mo><mi>n</mi></msup><msup><mi>a</mi><mi>n</mi></msup><mo>×</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">T_{\mathbf{L}} a = \int^n a^n \times \mathbf{L}(n, 1)</annotation></semantics></math>
逆に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>上の任意の有限的モナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>に対してローヴェア・セオリーを構築できる。まず、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>についてのクライスリ圏を構築する。覚えていると思うが、クライスリ圏内での<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>への射は台となる圏内での射によって与えられる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>→</mo><mi>T</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">a \to T b</annotation></semantics></math>
有限集合に限定すると、これは次のようになる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>→</mo><mi>T</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">m \to T n</annotation></semantics></math>
このクライスリ圏の反対圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mrow><mi>𝐊</mi><mi>𝐥</mi></mrow><mi>T</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msubsup><annotation encoding="application/x-tex">\mathbf{Kl}^\mathit{op}_{T}</annotation></semantics></math>は、有限集合に限定されており、求めていたローヴェア・セオリーだ。典型的には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内のn項演算を記述するhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation></semantics></math>
はhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>𝐊</mi><mi>𝐥</mi></mrow><mi>T</mi></msub><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Kl}_{T}(1, n)</annotation></semantics></math>
によって与えられる。</p>
<p>プログラミングで遭遇するほとんどのモナドは有限的モナドであることが知られている。ただし、継続モナドという注目すべき例外は除く。また、ローヴェア・セオリーの概念は有限的演算を超えて拡張もできる。</p>
<h2 data-number="30.6" id="コエンドとしてのモナド"><span
class="header-section-number">30.6</span> コエンドとしてのモナド</h2>
<p>コエンドの式について詳しく見ていこう。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>𝐋</mi></msub><mi>a</mi><mo>=</mo><msup><mo>∫</mo><mi>n</mi></msup><msup><mi>a</mi><mi>n</mi></msup><mo>×</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">T_{\mathbf{L}} a = \int^n a^n \times \mathbf{L}(n, 1)</annotation></semantics></math>
まず初めに、このコエンドは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>内で次のように定義されたプロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>に引き継がれる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mi>n</mi><mi>m</mi><mo>=</mo><msup><mi>a</mi><mi>n</mi></msup><mo>×</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P n m = a^n \times \mathbf{L}(m, 1)</annotation></semantics></math>
このプロ関手は最初の引数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>について反変だ。これが射をどう持ち上げるかを考えよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐅</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{FinSet}</annotation></semantics></math>内の射は有限集合の写像<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>m</mi><mo>→</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">f \Colon m \to n</annotation></semantics></math>だ。このような写像は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>元集合1つから<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>個の要素を（重複は許容して）選択することを表している。これは次のように<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の冪乗間の写像へ持ち上げられる（方向に注意してほしい）。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>→</mo><msup><mi>a</mi><mi>m</mi></msup></mrow><annotation encoding="application/x-tex">a^n \to a^m</annotation></semantics></math>
この持ち上げは単に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>要素の組
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mi>…</mi><mrow></mrow><mo>,</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a_1, a_2, \ldots{}, a_n)</annotation></semantics></math>
から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>個の要素を（重複を許容して）選択する。</p>
<p> <img src="images/liftpower.png" style="width:50.0%" /> </p>
<p>
例として、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mi>k</mi></msub><mo>∷</mo><mn>1</mn><mo>→</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">f_k \Colon 1 \to n</annotation></semantics></math>を考えよう。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>元集合から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>番目の要素を選択したものだ。これを持ち上げると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>要素の組を取って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>番目の要素を返す関数となる。</p>
<p>あるいは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>m</mi><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f \Colon m \to 1</annotation></semantics></math>を考えよう。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>要素すべてを1に写す定数関数だ。これを持ち上げると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>の要素を1つ取って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>回複製する関数となる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mrow></mrow><mi>x</mi><mo>→</mo><mo stretchy="false" form="prefix">(</mo><munder><munder><mrow><mi>x</mi><mo>,</mo><mi>x</mi><mo>,</mo><mi>…</mi><mrow></mrow><mo>,</mo><mi>x</mi></mrow><mo accent="true">⏟</mo></munder><mi>m</mi></munder><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\lambda{}x \to (\underbrace{x, x, \ldots{}, x}_{m})</annotation></semantics></math>
いま扱っているプロ関手が2番目の引数について共変であることは、自明だとすぐには言えないことに気付いたと思う。hom関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(m, 1)</annotation></semantics></math>
なら<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>について反変なのは確かだ。しかし、いま扱っているコエンドは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>ではなく圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>のものだ。このコエンドの変数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>は有限集合（あるいはそのスケルトン）に渡る。圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>の反対圏を含む。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>内の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>→</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m \to n</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mi>m</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(n, m)</annotation></semantics></math>
の元だ（埋め込みは関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>I</mi><mi>𝐋</mi></msub><annotation encoding="application/x-tex">I_{\mathbf{L}}</annotation></semantics></math>から得られる）。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>への関手としての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(m, 1)</annotation></semantics></math>
について、関手性を確認しよう。関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>m</mi><mo>→</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">f \Colon m \to n</annotation></semantics></math>を持ち上げたいので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(m, 1)</annotation></semantics></math>
から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation></semantics></math>
への関数を実装するのが目標になる。関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>に対応して、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>への射が存在する（方向に注意してほしい）。この射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(m, 1)</annotation></semantics></math>
に前合成すると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation></semantics></math>
の部分集合が得られる。</p>
<script type="text/tikz">
\begin{tikzcd}[column sep=large]
  \mathbf{L}(m, 1) \arrow[r] & \mathbf{L}(n, 1)\\
  {}^m \bullet \arrow[r, "f"'] & \bullet^n
\end{tikzcd}
</script>
<p>
関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \to n</annotation></semantics></math>を持ち上げれば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(1, 1)</annotation></semantics></math>
から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation></semantics></math>
に移れることに注目してほしい。この事実は後で使う。</p>
<p>反変関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>a</mi><mi>n</mi></msup><annotation encoding="application/x-tex">a^n</annotation></semantics></math>と共変関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(m, 1)</annotation></semantics></math>
の積はプロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><mo>×</mo><mi>𝐅</mi><mo>→</mo><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow></mrow><annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}\times \mathbf{F} \to \mathbf{Set}</annotation></semantics></math>だ。コエンドをプロ関手の対角要素すべての余積（非交和）として定義できることを思い出してほしい。それらの対角要素のうちいくつかは同一視できる。この同一視は余くさび条件に対応している。</p>
<p>ここで、コエンドはすべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>に渡る集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>×</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a^n \times \mathbf{L}(n, 1)</annotation></semantics></math>
の非交和として始まる。同一視は<a
href="#ends-and-coends">コエンドを余等化子として</a>表現することで生成できる。ある非対角項<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>×</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>m</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a^n \times \mathbf{L}(m, 1)</annotation></semantics></math>
から始めよう。対角項を得るには、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>m</mi><mo>→</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">f \Colon m \to n</annotation></semantics></math>を積の1番目か2番目の成分に適用すればよい。そして2つの結果は同一視される。</p>
<script type="text/tikz">
\begin{tikzcd}
  & a^n \times \mathbf{L}(m, 1)
  \arrow[dl, "\langle f {,} \mathbf{id} \rangle"']
  \arrow[dr, "\langle \mathbf{id} {,} f \rangle"]
  & \\
  a^m \times \mathbf{L}(m, 1)
  & \sim
  & a^n \times \mathbf{L}(n, 1) \\
  & f :: m \to n &
\end{tikzcd}
</script>
<p>
前に示したように、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mn>1</mn><mo>→</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">f \Colon 1 \to n</annotation></semantics></math>を持ち上げると以下の2つの変換
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a^n \to a</annotation></semantics></math>
および
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>→</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(1, 1) \to \mathbf{L}(n, 1)</annotation></semantics></math>
が得られる。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>×</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a^n \times \mathbf{L}(1, 1)</annotation></semantics></math>
から始めて、以下の両方に到達できる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a \times \mathbf{L}(1, 1)</annotation></semantics></math>
は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mi>f</mi><mo>,</mo><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle f, \mathbf{id}\rangle</annotation></semantics></math>を持ち上げることで得られ、また
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>×</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a^n \times \mathbf{L}(n, 1)</annotation></semantics></math>
は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⟨</mo><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mo>,</mo><mi>f</mi><mo stretchy="false" form="postfix">⟩</mo></mrow><annotation encoding="application/x-tex">\langle \mathbf{id}, f \rangle</annotation></semantics></math>を持ち上げることで得られる。しかし、これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>×</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a^n \times \mathbf{L}(n, 1)</annotation></semantics></math>
の要素すべてが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a \times \mathbf{L}(1, 1)</annotation></semantics></math>
と同一視できるという意味ではない。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation></semantics></math>
の要素すべてが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(1, 1)</annotation></semantics></math>
から到達できるわけではないからだ。持ち上げられるのは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>からの射だけなのを思い出してほしい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐋</mi><annotation encoding="application/x-tex">\mathbf{L}</annotation></semantics></math>内の非自明な<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>項演算は射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mn>1</mn><mo>→</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">f \Colon 1 \to n</annotation></semantics></math>を持ち上げても構築できない。</p>
<p>言い換えると、同一視できるのは、基本射 (basic morphism)
を適用することによって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(1, 1)</annotation></semantics></math>
から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation></semantics></math>
に到達できるようなコエンド式のすべての加数 (addend)
だけだ。これらはすべて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>×</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a \times \mathbf{L}(1, 1)</annotation></semantics></math>
と同値だ。基本射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>内の射の像だ。</p>
<p>ローヴェア・セオリーの最も単純なケースである<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation></semantics></math>自体で、これがどのように機能するかを見てみよう。そのようなセオリーでは、すべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation></semantics></math>
が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(1, 1)</annotation></semantics></math>
から到達できる。なぜなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(1, 1)</annotation></semantics></math>
は恒等射だけを含む単元圏であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation></semantics></math>
は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>内の基本射<em>である</em>単射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>→</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \to n</annotation></semantics></math>に対応する射だけを含むからだ。したがって、余積に含まれる加数はすべて同値なので次が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>a</mi><mo>=</mo><mi>a</mi><mo>×</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>1</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">T a = a \times \mathbf{L}(1, 1) = a</annotation></semantics></math>
これは恒等モナドだ。</p>
<h2 data-number="30.7" id="副作用のローヴェアセオリー"><span
class="header-section-number">30.7</span>
副作用のローヴェア・セオリー</h2>
<p>モナドとローヴェア・セオリーは非常に強く結びついているので、プログラミングでローヴェア・セオリーをモナドの代わりとして使えるかを自然と問いたくなる。モナドの大きな問題点は合成しにくいことだ。モナド変換子を作るための汎用のレシピはない。その面でローヴェア・セオリーは有利で、余積とテンソル積を使って合成できる。一方、有限的モナドしかローヴェア・セオリーに容易に変換できない。ここでの例外は継続モナドだ。この分野での研究が進んでいる（参考文献を参照のこと）。</p>
<p>ローヴェア・セオリーが副作用の記述にどう使えるか説明するため、単純な例として、例外について説明する。それらは伝統的には<code>Maybe</code>モナドで実装される。</p>
<p><code>Maybe</code>モナドは零項演算<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \to 1</annotation></semantics></math>だけを伴うローヴェア・セオリーによって生成される。このセオリーのモデルは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>をある集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>に写し、零項演算を関数に写す関手だ。</p>
<div class="sourceCode" id="cb591"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb591-1"><a href="#cb591-1" aria-hidden="true" tabindex="-1"></a><span class="ot">    raise ::</span> () <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>
<code>Maybe</code>モナドはコエンド式を使って復元できる。零項演算を追加するとhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation></semantics></math>
にどんな影響があるか検討してみよう。新しく（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>𝐅</mi><mrow><mi>𝑜</mi><mi>𝑝</mi></mrow></msup><annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation></semantics></math>にはない）<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(0, 1)</annotation></semantics></math>
が作られる以外にも、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation></semantics></math>
に新しい射が追加される。これらは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>→</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \to 0</annotation></semantics></math>の型の射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>→</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0 \to 1</annotation></semantics></math>と合成した結果だ。このような寄与はすべて、コエンド式での<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mn>0</mn></msup><mo>×</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a^0 \times \mathbf{L}(0, 1)</annotation></semantics></math>
と同一視される。それらは
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>×</mo><mi>𝐋</mi><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">a^n \times \mathbf{L}(0, 1)</annotation></semantics></math>
を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>→</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0 \to n</annotation></semantics></math>によって2種類の方法で持ち上げれば得られるからだ。</p>
<script type="text/tikz">
\begin{tikzcd}
  & a^n \times \mathbf{L}(0, 1)
  \arrow[dl, "\langle f {,} \mathbf{id} \rangle"']
  \arrow[dr, "\langle \mathbf{id} {,} f \rangle"]
  & \\
  a^0 \times \mathbf{L}(0, 1)
  & \sim
  & a^n \times \mathbf{L}(n, 1) \\
  & f :: 0 \to n &
\end{tikzcd}
</script>
<p> このコエンドを簡約すると
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>𝐋</mi></msub><mi>a</mi><mo>=</mo><msup><mi>a</mi><mn>0</mn></msup><mo>+</mo><msup><mi>a</mi><mn>1</mn></msup></mrow><annotation encoding="application/x-tex">T_{\mathbf{L}} a = a^0 + a^1</annotation></semantics></math>
あるいは、Haskellの記法では</p>
<div class="sourceCode" id="cb592"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb592-1"><a href="#cb592-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Either</span> () a</span></code></pre></div>
<p> となり、次と等価だ。</p>
<div class="sourceCode" id="cb593"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb593-1"><a href="#cb593-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre></div>
<p>
このローヴェア・セオリーは例外の送出のみをサポートしており、例外の処理はサポートしていないことに注意してほしい。</p>
<h2 data-number="30.8" id="課題-21"><span
class="header-section-number">30.8</span> 課題</h2>
<ol type="1">
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐅</mi><annotation encoding="application/x-tex">\mathbf{F}</annotation></semantics></math>（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐅</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{FinSet}</annotation></semantics></math>のスケルトン）内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>への射をすべて列挙せよ。</li>
<li>モノイドのローヴェア・セオリーについてのモデルの圏が、リストモナドについてのモナド代数の圏と同値であることを示せ。</li>
<li>モノイドのローヴェア・セオリーはリストモナドを生成する。その二項演算は、対応するクライスリ射を使って生成できることを示せ。</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtext mathvariant="bold">𝐅𝐢𝐧𝐒𝐞𝐭</mtext><annotation encoding="application/x-tex">\textbf{FinSet}</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>の部分圏であり、それを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>に埋め込む関手が存在する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>の関手はすべて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐅</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{FinSet}</annotation></semantics></math>に制約できる。有限的関手がそれ自身の制限の左カン拡張であることを示せ。</li>
</ol>
<h2 data-number="30.9" id="参考文献-4"><span
class="header-section-number">30.9</span> 参考文献</h2>
<ol type="1">
<li><a
href="http://www.tac.mta.ca/tac/reprints/articles/5/tr5.pdf">Functorial
Semantics of Algebraic Theories</a><a href="#fn173" class="footnote-ref"
id="fnref173" role="doc-noteref"><sup>173</sup></a>, F. William
Lawvere</li>
<li><a
href="http://homepages.inf.ed.ac.uk/gdp/publications/Comp_Eff_Monads.pdf">Notions
of computation determine monads</a><a href="#fn174" class="footnote-ref"
id="fnref174" role="doc-noteref"><sup>174</sup></a>, Gordon Plotkin and
John Power</li>
</ol>
<aside id="footnotes-90" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="173">
<li id="fn173"><p><a
href="http://www.tac.mta.ca/tac/reprints/articles/5/tr5.pdf"
class="uri">http://www.tac.mta.ca/tac/reprints/articles/5/tr5.pdf</a><a
href="#fnref173" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn174"><p><a
href="http://homepages.inf.ed.ac.uk/gdp/publications/Comp_Eff_Monads.pdf"
class="uri">http://homepages.inf.ed.ac.uk/gdp/publications/Comp_Eff_Monads.pdf</a><a
href="#fnref174" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 data-number="31" id="モナドモノイド圏"><span
class="header-section-number">31</span> モナド・モノイド・圏</h1>
<p>区切り良く圏論の本を終わらせることはできない。学ぶべきことは常にある。圏論は広大な題材だ。それと同時に、同じテーマ・コンセプト・パターンが明らかに何度も繰り返されている。すべての概念はカン拡張である、という格言があるとおり、カン拡張を使えば極限・余極限・モナド・米田の補題などを導出できる。圏自体の概念は抽象化のあらゆるレベルに現れる。モノイドとモナドの概念も同様だ。最も基本となるものはどれだろうか？　結局のところ、それらはすべて相互に関連しており、抽象化の終わりのないサイクルで互いにつながっている。それらの相互関係を示すことが、この本を締めくくるのにふさわしいと判断した。</p>
<h2 data-number="31.1" id="双圏"><span
class="header-section-number">31.1</span> 双圏</h2>
<p>圏論で特に難しい側面の1つは、絶えず視点が切り替わることだ。たとえば、集合の圏を考えてみてほしい。我々は要素によって集合を定義することに慣れている。空集合には要素がない。単元集合には要素が1つある。2つの集合のデカルト積はペアの集合であり、以下同様だ。しかし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>圏について述べるとき、集合の内容を忘れて、代わりにそれらの間の射（矢）に集中するように頼んだ。時々、カバーの下を覗くことが許されたのは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内の特定の普遍的構成が要素の観点で何を記述しているか知るためだった。そうして、終対象は1つの要素からなる集合であることなどが分かった。しかし、それらは健全性チェックにすぎなかった。</p>
<p>関手は圏の写像として定義される。写像を圏内の射と見なすのは自然だ。関手は、圏（サイズに関する問題を避けたいなら、小さい圏）の圏の射だと分かった。関手を射として扱うと、圏の内部（対象と射）に対するその作用についての情報を失うことになる。これは、集合の要素に対する関数の作用についての情報が、その関数を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐞</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Set}</annotation></semantics></math>内の射として扱うと失われるのと同じだ。しかし、任意の2つの圏の間の関手も圏をなす。今度は、ある圏の射であったものを別の圏の対象と見なすことが求められる。関手圏では関手が対象であり、自然変換が射だ。同一のものが、ある圏では射であり、別の圏では対象であり得ることが発見された。対象を名詞とし射を動詞とする素朴な考え方は成り立たない。</p>
<p>2つの観点を切り替える代わりに、1つの観点に統合しようとしてもよい。そうすることで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏の概念が得られる。この圏では、対象を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-セル、射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セル、射間の射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セルと呼ぶ。</p>
<figure>
<img src="images/twocat.png"
title="$0$-セル$a, b$、$1$-セル$f, g$、および$2$-セル$\alpha$。"
style="width:35.0%"
alt="0-セルa, b、1-セルf, g、および2-セル\alpha。" />
<figcaption
aria-hidden="true"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a, b</annotation></semantics></math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>,</mo><mi>g</mi></mrow><annotation encoding="application/x-tex">f, g</annotation></semantics></math>、および<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>。</figcaption>
</figure>
<p>
圏の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>は端的な例だ。圏が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-セル、関手が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セル、自然変換が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セルとなる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏の規則が示すのは、任意の2つの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-セル間の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルが圏をなす（言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation></semantics></math>
はhom集合ではなくhom圏だ）ということだ。このことは、任意の2つの圏の間の関手は関手圏をなす、という以前の主張とよく一致している。</p>
<p>典型的には、任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-セルからそれ自体に戻る<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルもhom圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
という圏をなす。だが、その圏はさらに豊かな構造を持っている。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
のメンバーは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>内の射とも<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
内の対象とも見なせる。これらは射なので互いに合成できる。しかし、それらを対象として見ると、合成は対象のペアから対象への写像になる。それは実際に、積に――正確にはテンソル積に――非常によく似ている。このテンソル積は恒等<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルという単位元を持つ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏では、hom圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
は自動的にモノイダル圏になり、そのテンソル積は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルの合成として定義される。結合律と単位律は、対応する圏の規則から単に除かれる。</p>
<p>これが何を意味するのかを、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏のカノニカルな例である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>で見てみよう。hom圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{Cat}(a, a)</annotation></semantics></math>
は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>上の自己関手の圏だ。その中では、自己関手の合成がテンソル積の役割を果たしている。恒等関手はこの積の単位元だ。自己関手がモノイダル圏をなすことは以前にも見た（その事実をモナドの定義で使った）ものの、これはもっと一般的な現象だと分かる。つまり、すべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏内の自己-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルはモノイダル圏をなす。これについては、後でモナドを一般化するときに再度説明する。</p>
<p>覚えていると思うが、一般のモノイダル圏では、モノイド則がきちんと満たされていることは主張しなかった。多くの場合、単位律と結合律が同型を除いて満たされていれば十分だった。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
のモノイド則は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルの合成律から導かれる。これらの規則は厳密なので、厳密なモノイダル圏が常に得られる。しかし、これらの規則も緩和できる。たとえば、恒等<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub><annotation encoding="application/x-tex">%
\mathbf{id}_{a}%
</annotation></semantics></math>と別の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>∷</mo><mi>a</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">f \Colon a \to b</annotation></semantics></math>の合成は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math>と等しいと言わずに、同型だと言える。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルの同型は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セルを使って定義される。言い換えると、次のような<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セル
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ρ</mi><mo>∷</mo><mi>f</mi><mo>∘</mo><msub><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow><mi>a</mi></msub><mo>→</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">\rho \Colon f \circ %
\mathbf{id}_{a}%
 \to f</annotation></semantics></math> と、その逆が存在する。</p>
<figure>
<img src="images/bicat.png"
title="双圏の恒等律は同型（可逆な$2$-セル$\rho$）を除いて成り立つ。"
style="width:35.0%"
alt="双圏の恒等律は同型（可逆な2-セル\rho）を除いて成り立つ。" />
<figcaption
aria-hidden="true">双圏の恒等律は同型（可逆な<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>）を除いて成り立つ。</figcaption>
</figure>
<p>
左恒等射と結合律についても同様にできる。このような緩和された<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>𝟐</mn><annotation encoding="application/x-tex">\mathbf{2}</annotation></semantics></math>-圏は双圏と呼ばれる（いくつか追加のコヒーレンシーの規則があるが、ここでは省略する）。</p>
<p>予想どおり、双圏での自己-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルは、規則が厳密でない一般化されたモノイダル圏をなす。</p>
<p>双圏の興味深い例としてスパンの圏が挙げられる。2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>b</mi><annotation encoding="application/x-tex">b</annotation></semantics></math>の間のスパンは、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>および次の1対の射だ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>f</mi><mo>∷</mo><mi>x</mi><mo>→</mo><mi>a</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>g</mi><mo>∷</mo><mi>x</mi><mo>→</mo><mi>b</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
f \Colon x \to a \\
g \Colon x \to b
\end{gathered}
</annotation></semantics></math></p>
<p> <img src="images/span.png" style="width:35.0%" /> </p>
<p>
圏論的な積の定義でスパンを使ったことを覚えているだろう。ここでは、スパンを双圏での<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルと見なそう。最初のステップは、スパンの合成を定義することだ。隣接したスパンがあるとする。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><msup><mi>f</mi><mo>′</mo></msup><mo>∷</mo><mi>y</mi><mo>→</mo><mi>b</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msup><mi>g</mi><mo>′</mo></msup><mo>∷</mo><mi>y</mi><mo>→</mo><mi>c</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
f&#39; \Colon y \to b \\
g&#39; \Colon y \to c
\end{gathered}
</annotation></semantics></math></p>
<p> <img src="images/compspan.png" style="width:50.0%" /> </p>
<p>
それらの合成は第3のスパンになり、ある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>を頂点とする。最も自然な選択は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>f</mi><mo>′</mo></msup><annotation encoding="application/x-tex">f&#39;</annotation></semantics></math>に沿った<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>の引き戻しだ。引き戻しとは次の2つの射を伴う対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math>であることを思い出してほしい。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>h</mi><mo>∷</mo><mi>z</mi><mo>→</mo><mi>x</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msup><mi>h</mi><mo>′</mo></msup><mo>∷</mo><mi>z</mi><mo>→</mo><mi>y</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
h \Colon z \to x \\
h&#39; \Colon z \to y
\end{gathered}
</annotation></semantics></math> ただし、
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo>∘</mo><mi>h</mi><mo>=</mo><msup><mi>f</mi><mo>′</mo></msup><mo>∘</mo><msup><mi>h</mi><mo>′</mo></msup></mrow><annotation encoding="application/x-tex">g \circ h = f&#39; \circ h&#39;</annotation></semantics></math>
が、そのような対象すべてについて普遍だとする。</p>
<p> <img src="images/pullspan.png" style="width:35.0%" /> </p>
<p>
ここでは、集合の圏でのスパンに注目しよう。この場合、引き戻しはデカルト積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>×</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \times y</annotation></semantics></math>からのペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(p, q)</annotation></semantics></math>
の集合にすぎず、次のようになる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mspace width="0.222em"></mspace><mi>p</mi><mo>=</mo><msup><mi>f</mi><mo>′</mo></msup><mspace width="0.222em"></mspace><mi>q</mi></mrow><annotation encoding="application/x-tex">g\ p = f&#39;\ q</annotation></semantics></math>
同じ終点を共有する2つのスパンの間の射は頂点間の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>h</mi><annotation encoding="application/x-tex">h</annotation></semantics></math>として定義され、適切な三角形を可換にする。</p>
<figure>
<img src="images/morphspan.png" title="$\cat{Span}$内の$2$-セル。"
style="width:35.0%" alt="\mathbf{Span}内の2-セル。" />
<figcaption
aria-hidden="true"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐩</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Span}</annotation></semantics></math>内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セル。</figcaption>
</figure>
<p>
要約すると、双圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐩</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Span}</annotation></semantics></math>では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-セルは集合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルはスパン、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セルはスパン間の射だ。恒等<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルは、3つの対象すべてが同じで、2つの射が恒等射である退化スパン
(degenerate span) だ。</p>
<p>双圏の別の例もすでに見た。それは<a
href="#ends-and-coends">プロ関手</a>の双圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐏</mi><mi>𝐫</mi><mi>𝐨</mi><mi>𝐟</mi></mrow><annotation encoding="application/x-tex">\mathbf{Prof}</annotation></semantics></math>であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-セルは圏、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルはプロ関手、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セルは自然変換だ。プロ関手の合成はコエンドによって与えられる。</p>
<h2 data-number="31.2" id="モナド"><span
class="header-section-number">31.2</span> モナド</h2>
<p>ここまでで、自己関手の圏におけるモノイドとしてのモナドの定義にかなり精通しているはずだ。この定義を、自己関手の圏は双圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>内の自己-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルの小さいhom圏のひとつにすぎない、という新たな理解に沿って再検討してみよう。自己関手の圏がモノイダル圏であることは知っており、テンソル積は自己関手の合成に由来する。モノイドは、モノイダル圏内のある対象――ここでは自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>――が2つの射を伴ったものとして定義される。自己関手の間の射は自然変換だ。一方の射はモノイダル単位元――恒等自己関手――を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>に写す。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>η</mi><mo>∷</mo><mi>I</mi><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\eta \Colon I \to T</annotation></semantics></math>
もう一方の射はテンソル積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>⊗</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">T \otimes T</annotation></semantics></math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>に写す。このテンソル積は自己関手の合成によって与えられるため、次が得られる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi><mo>∷</mo><mi>T</mi><mo>∘</mo><mi>T</mi><mo>→</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">\mu \Colon T \circ T \to T</annotation></semantics></math></p>
<p> <img src="images/monad.png" style="width:30.0%" /> </p>
<p>
これらがモナドを定義する2つの操作である（Haskellでは<code>return</code>および<code>join</code>と呼ばれる）ことと、モノイド則がモナド則に変わったことが分かる。</p>
<p>さて、この定義から自己関手に関する記述をすべて取り除こう。まず双圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝐂</mi><annotation encoding="application/x-tex">\mathbf{C}</annotation></semantics></math>から始めて、その中で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>を選ぶ。すでに説明したように、hom圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
はモノイダル圏だ。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation></semantics></math>
のモノイドは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セル、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>T</mi><annotation encoding="application/x-tex">T</annotation></semantics></math>、および2つの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セルを、条件
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mi>η</mi><mo>∷</mo><mi>I</mi><mo>→</mo><mi>T</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>μ</mi><mo>∷</mo><mi>T</mi><mo>∘</mo><mi>T</mi><mo>→</mo><mi>T</mi></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
\eta \Colon I \to T \\
\mu \Colon T \circ T \to T
\end{gathered}
</annotation></semantics></math>
がモノイド則を満たすように選ぶことで定義できる。<em>これ</em>をモナドと呼ぶ。</p>
<p> <img src="images/bimonad.png" style="width:30.0%" /> </p>
<p>
これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-セルと<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルと<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セルだけを使って、はるかに一般的にモナドを定義する。双圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐂</mi><mi>𝐚</mi><mi>𝐭</mi></mrow><annotation encoding="application/x-tex">\mathbf{Cat}</annotation></semantics></math>に適用すると、これは通常のモナドへと簡約される。だが、他の双圏では何が起こるか見てみよう。</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐩</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Span}</annotation></semantics></math>でモナドを構築しよう。ここでは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>-セルを選択する。これは集合であり、すぐ明らかになる理由から、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mi>𝑏</mi></mrow><annotation encoding="application/x-tex">\mathit{Ob}</annotation></semantics></math>と呼ぶことにする。次に、自己-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セル（<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mi>𝑏</mi></mrow><annotation encoding="application/x-tex">\mathit{Ob}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mi>𝑏</mi></mrow><annotation encoding="application/x-tex">\mathit{Ob}</annotation></semantics></math>へ戻るスパン）を選択する。その頂点には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐴</mi><mi>𝑟</mi></mrow><annotation encoding="application/x-tex">\mathit{Ar}</annotation></semantics></math>と呼ばれる集合があり、次の2つの関数を伴う。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mrow><mi>𝑑</mi><mi>𝑜</mi><mi>𝑚</mi></mrow><mo>∷</mo><mrow><mi>𝐴</mi><mi>𝑟</mi></mrow><mo>→</mo><mrow><mi>𝑂</mi><mi>𝑏</mi></mrow></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mrow><mi>𝑐</mi><mi>𝑜</mi><mi>𝑑</mi></mrow><mo>∷</mo><mrow><mi>𝐴</mi><mi>𝑟</mi></mrow><mo>→</mo><mrow><mi>𝑂</mi><mi>𝑏</mi></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
\mathit{dom} \Colon \mathit{Ar} \to \mathit{Ob} \\
\mathit{cod} \Colon \mathit{Ar} \to \mathit{Ob}
\end{gathered}
</annotation></semantics></math></p>
<p> <img src="images/spanmonad.png" style="width:30.0%" /> </p>
<p>
集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐴</mi><mi>𝑟</mi></mrow><annotation encoding="application/x-tex">\mathit{Ar}</annotation></semantics></math>の要素を「射」と呼ぼう。さらに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mi>𝑏</mi></mrow><annotation encoding="application/x-tex">\mathit{Ob}</annotation></semantics></math>の要素を「対象」と呼ぼう、と言えば、目的地の手掛かりになるだろう。2つの関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑑</mi><mi>𝑜</mi><mi>𝑚</mi></mrow><annotation encoding="application/x-tex">\mathit{dom}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑐</mi><mi>𝑜</mi><mi>𝑑</mi></mrow><annotation encoding="application/x-tex">\mathit{cod}</annotation></semantics></math>は、域と余域を「射」に割り当てる。</p>
<p>スパンをモナドにするには2つの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>が必要だ。この場合のモノイダル単位元は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mi>𝑏</mi></mrow><annotation encoding="application/x-tex">\mathit{Ob}</annotation></semantics></math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mi>𝑏</mi></mrow><annotation encoding="application/x-tex">\mathit{Ob}</annotation></semantics></math>への自明なスパンであり、頂点は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mi>𝑏</mi></mrow><annotation encoding="application/x-tex">\mathit{Ob}</annotation></semantics></math>で、2つの恒等関数を伴う。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>は2つの頂点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mi>𝑏</mi></mrow><annotation encoding="application/x-tex">\mathit{Ob}</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐴</mi><mi>𝑟</mi></mrow><annotation encoding="application/x-tex">\mathit{Ar}</annotation></semantics></math>の間の関数だ。つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>は「射」をすべての「対象」に割り当てる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐩</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Span}</annotation></semantics></math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セルは可換条件を満たす必要がある。ここでは次のようになる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="center" style="text-align: center"><mrow><mi>𝑑</mi><mi>𝑜</mi><mi>𝑚</mi></mrow><mo>∘</mo><mi>η</mi><mo>=</mo><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mrow><mi>𝑐</mi><mi>𝑜</mi><mi>𝑑</mi></mrow><mo>∘</mo><mi>η</mi><mo>=</mo><mrow><mi>𝐢</mi><mi>𝐝</mi></mrow></mtd></mtr></mtable><annotation encoding="application/x-tex">
\begin{gathered}
\mathit{dom} \circ \eta = \mathbf{id}\\
\mathit{cod} \circ \eta = \mathbf{id}
\end{gathered}
</annotation></semantics></math></p>
<p> <img src="images/spanunit.png" style="width:40.0%" /> </p>
<p> 成分としては、これは次のようになる。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑑</mi><mi>𝑜</mi><mi>𝑚</mi></mrow><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><mi>η</mi><mspace width="0.222em"></mspace><mrow><mi>𝑜</mi><mi>𝑏</mi></mrow><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mrow><mi>𝑜</mi><mi>𝑏</mi></mrow><mo>=</mo><mrow><mi>𝑐</mi><mi>𝑜</mi><mi>𝑑</mi></mrow><mspace width="0.222em"></mspace><mo stretchy="false" form="prefix">(</mo><mi>η</mi><mspace width="0.222em"></mspace><mrow><mi>𝑜</mi><mi>𝑏</mi></mrow><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">\mathit{dom}\ (\eta\ \mathit{ob}) = \mathit{ob} = \mathit{cod}\ (\eta\ \mathit{ob})</annotation></semantics></math>
ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑜</mi><mi>𝑏</mi></mrow><annotation encoding="application/x-tex">\mathit{ob}</annotation></semantics></math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝑂</mi><mi>𝑏</mi></mrow><annotation encoding="application/x-tex">\mathit{Ob}</annotation></semantics></math>内の「対象」だ。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>η</mi><annotation encoding="application/x-tex">\eta</annotation></semantics></math>が割り当てるのは、すべての「対象」と、域と余域がその「対象」であるような「射」に対してだ。この特別な「射」が「恒等射」と呼ばれる。</p>
<p>2番目の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>は、それ自体とスパン<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐴</mi><mi>𝑟</mi></mrow><annotation encoding="application/x-tex">\mathit{Ar}</annotation></semantics></math>との合成に作用する。合成は引き戻しとして定義されているため、その要素は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐴</mi><mi>𝑟</mi></mrow><annotation encoding="application/x-tex">\mathit{Ar}</annotation></semantics></math>からの要素のペア――「射」のペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a_1, a_2)</annotation></semantics></math>
だ。引き戻し条件は次のとおりだ。
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi>𝑐</mi><mi>𝑜</mi><mi>𝑑</mi></mrow><mspace width="0.222em"></mspace><msub><mi>a</mi><mn>1</mn></msub><mo>=</mo><mrow><mi>𝑑</mi><mi>𝑜</mi><mi>𝑚</mi></mrow><mspace width="0.222em"></mspace><msub><mi>a</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\mathit{cod}\ a_1 = \mathit{dom}\ a_2</annotation></semantics></math>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mn>2</mn></msub><annotation encoding="application/x-tex">a_2</annotation></semantics></math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mn>1</mn></msub><annotation encoding="application/x-tex">a_1</annotation></semantics></math>が「合成可能」だと言われるのは、一方の域が他方の余域だからだ。</p>
<p> <img src="images/spanmul.png" style="width:50.0%" /> </p>
<p>
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>は、合成可能な矢のペア
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a_1, a_2)</annotation></semantics></math>
を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐴</mi><mi>𝑟</mi></mrow><annotation encoding="application/x-tex">\mathit{Ar}</annotation></semantics></math>からの単一の矢<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>a</mi><mn>3</mn></msub><annotation encoding="application/x-tex">a_3</annotation></semantics></math>に写す関数だ。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>μ</mi><annotation encoding="application/x-tex">\mu</annotation></semantics></math>は矢の合成を定義する。</p>
<p>モナド則が射の恒等律や結合律に対応していることは簡単に確認できる。以上で圏を定義できた（対象と射が集合をなす小さい圏であることは忘れないでほしい）。</p>
<p>つまり、まとめると、圏はスパンの双圏におけるモナドにすぎない。</p>
<p>この結果の驚くべき点は、圏がモナドやモノイドのような他の代数的構造と同じ基盤に置かれていることだ。圏であることは何も特別ではない。ただの2つの集合と4つの関数だ。実際に、対象ごとに個別の集合さえ必要ない。対象は恒等射と同一視できる（それらは1対1で対応している）からだ。つまり、実際にはひとつの集合といくつかの関数にすぎない。圏論がすべての数学において中心的役割を担っていることを考えると、これは非常に謙虚な認識だ。</p>
<h2 data-number="31.3" id="課題-22"><span
class="header-section-number">31.3</span> 課題</h2>
<ol type="1">
<li>双圏における自己-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>-セルの合成として定義されたテンソル積について、単位律と結合律を導出せよ。</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐩</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Span}</annotation></semantics></math>内のモナドについて、モナド則が、結果の圏内での恒等射と結合律に対応していることを確認せよ。</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐏</mi><mi>𝐫</mi><mi>𝐨</mi><mi>𝐟</mi></mrow><annotation encoding="application/x-tex">\mathbf{Prof}</annotation></semantics></math>内のモナドが、対象における恒等射の関手
(identity-on-objects functor) であることを示せ。</li>
<li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝐒</mi><mi>𝐩</mi><mi>𝐚</mi><mi>𝐧</mi></mrow><annotation encoding="application/x-tex">\mathbf{Span}</annotation></semantics></math>内のモナドについてのモナド代数とは何か？</li>
</ol>
<h2 data-number="31.4" id="参考文献-5"><span
class="header-section-number">31.4</span> 参考文献</h2>
<ol type="1">
<li><a
href="https://graphicallinearalgebra.net/2017/04/16/a-monoid-is-a-category-a-category-is-a-monad-a-monad-is-a-monoid/">Paweł
Sobocińskiのブログ</a><a href="#fn175" class="footnote-ref"
id="fnref175" role="doc-noteref"><sup>175</sup></a></li>
</ol>
<aside id="footnotes-91" class="footnotes footnotes-end-of-section"
role="doc-footnote">
<hr />
<ol start="175">
<li id="fn175"><p><a
href="https://graphicallinearalgebra.net/2017/04/16/a-monoid-is-a-category-a-category-is-a-monad-a-monad-is-a-monoid/"
class="uri">https://graphicallinearalgebra.net/2017/04/16/a-monoid-is-a-category-a-category-is-a-monad-a-monad-is-a-monoid/</a><a
href="#fnref175" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
<h1 class="unnumbered" id="索引">索引</h1>
<!-- 英数 -->
<ul>
<li><span epub:type="index-term"><a href="#factorizer"
epub:type="index-locator">factorizer</a></span></li>
<li><span epub:type="index-term"><a href="#hom-set"
epub:type="index-locator">hom集合</a></span></li>
<li><span epub:type="index-term"><a href="#modus_ponen"
epub:type="index-locator">modus ponens</a></span></li>
<li><span epub:type="index-term"><a href="#theorems_for_free"
epub:type="index-locator">theorems for free</a></span></li>
<li><span epub:type="index-term"><a href="#variant"
epub:type="index-locator">variant</a></span></li>
<li><span epub:type="index-term"><a href="#writer_monad"
epub:type="index-locator">writerモナド</a></span></li>
</ul>
<!-- あ -->
<ul>
<li><span epub:type="index-term"><a href="#ad_hoc_polymorphism"
epub:type="index-locator">アドホック多相</a></span></li>
<li><span epub:type="index-term"><a href="#arity"
epub:type="index-locator">アリティ</a></span></li>
<li><span epub:type="index-term"><a href="#one-to-one"
epub:type="index-locator">1対1</a></span></li>
<li><span epub:type="index-term"><a href="#one_way2"
epub:type="index-locator">一方向の</a></span></li>
<li>意味論
<ul>
<li><span epub:type="index-term"><a href="#operational_semantics"
epub:type="index-locator">操作的-</a></span></li>
<li><span epub:type="index-term"><a href="#denotational_semantics"
epub:type="index-locator">表示的-</a></span></li>
</ul></li>
<li><span epub:type="index-term"><a href="#instance"
epub:type="index-locator">インスタンス</a></span></li>
<li><span epub:type="index-term"><a href="#onto"
epub:type="index-locator">上への</a></span></li>
<li><span epub:type="index-term"><a href="#embedding"
epub:type="index-locator">埋め込み</a></span></li>
</ul>
<!-- か -->
<ul>
<li><span epub:type="index-term"><a href="#extensional"
epub:type="index-locator">外延的</a></span></li>
<li><span epub:type="index-term"><a href="#type_inference"
epub:type="index-locator">型推論</a></span></li>
<li><span epub:type="index-term"><a href="#currying"
epub:type="index-locator">カリー化</a></span></li>
<li><span epub:type="index-term"><a href="#ring"
epub:type="index-locator">環</a></span></li>
<li><span epub:type="index-term"><a href="#function_composition"
epub:type="index-locator">関数合成</a></span></li>
<li><span epub:type="index-term"><a href="#function_application"
epub:type="index-locator">関数適用</a></span></li>
<li><span epub:type="index-term"><a href="#basic_product_operations"
epub:type="index-locator">基本的な積操作</a></span></li>
<li><span epub:type="index-term"><a href="#wedge_condition"
epub:type="index-locator">くさび条件</a></span></li>
<li><span epub:type="index-term"><a href="#identity"
epub:type="index-locator">恒等射</a></span></li>
<li><span epub:type="index-term"><a href="#composable"
epub:type="index-locator">合成可能</a></span></li>
<li><span epub:type="index-term"><a href="#component"
epub:type="index-locator">成分</a></span></li>
</ul>
<!-- さ -->
<ul>
<li><span epub:type="index-term"><a href="#endofunctors"
epub:type="index-locator">自己関手</a></span></li>
<li><span epub:type="index-term"><a href="#natural"
epub:type="index-locator">自然</a></span></li>
<li><span epub:type="index-term"><a href="#natural_isomorphism"
epub:type="index-locator">自然同型</a></span></li>
<li><span epub:type="index-term"><a href="#naturality_condition"
epub:type="index-locator">自然性条件</a></span></li>
<li><span epub:type="index-term"><a href="#naturally_isomorphic"
epub:type="index-locator">naturally isomorphic</a></span></li>
<li><span epub:type="index-term"><a href="#initial_algebra"
epub:type="index-locator">始代数</a></span></li>
<li><span epub:type="index-term"><a href="#morphism"
epub:type="index-locator">射</a></span></li>
<li>自由
<ul>
<li><span epub:type="index-term"><a href="#free_functor"
epub:type="index-locator">-関手</a></span></li>
<li><span epub:type="index-term"><a href="#free_category"
epub:type="index-locator">-圏</a></span></li>
<li><span epub:type="index-term"><a href="#free_monoid"
epub:type="index-locator">-モノイド</a></span></li>
</ul></li>
<li>述語 – <span epub:type="index-term"><a href="#predicate"
epub:type="index-locator">a</a></span>, <span epub:type="index-term"><a
href="#predicate2" epub:type="index-locator">b</a></span></li>
<li><span epub:type="index-term"><a href="#pure_function"
epub:type="index-locator">純粋関数</a></span></li>
<li>準同型 – <span epub:type="index-term"><a href="#homomorphisms"
epub:type="index-locator">a</a></span>, <span epub:type="index-term"><a
href="#homomorphism" epub:type="index-locator">b</a></span></li>
<li><span epub:type="index-term"><a href="#proof-relevant_relation"
epub:type="index-locator">証明を区別する関係</a></span></li>
<li><span epub:type="index-term"><a href="#single-sorted"
epub:type="index-locator">シングルソート</a></span></li>
<li><span epub:type="index-term"><a href="#horizontal_composition"
epub:type="index-locator">水平合成</a></span></li>
<li>随伴
<ul>
<li><span epub:type="index-term"><a href="#left_adjoint"
epub:type="index-locator">左-</a></span></li>
<li><span epub:type="index-term"><a href="#right_adjoint"
epub:type="index-locator">右-</a></span></li>
</ul></li>
<li><span epub:type="index-term"><a href="#skeleton"
epub:type="index-locator">スケルトン</a></span></li>
<li><span epub:type="index-term"><a href="#linear_order"
epub:type="index-locator">線形順序</a></span></li>
<li><span epub:type="index-term"><a href="#surjective"
epub:type="index-locator">全射</a></span></li>
<li><span epub:type="index-term"><a href="#preorder"
epub:type="index-locator">前順序</a></span></li>
<li><span epub:type="index-term"><a href="#total_order"
epub:type="index-locator">全順序</a></span></li>
<li><span epub:type="index-term"><a href="#bicartesian_closed"
epub:type="index-locator">双デカルト閉</a></span></li>
<li><span epub:type="index-term"><a href="#bifunctor"
epub:type="index-locator">双関手</a></span></li>
<li>全単射 – <span epub:type="index-term"><a href="#bijections"
epub:type="index-locator">a</a></span>, <span epub:type="index-term"><a
href="#bijection" epub:type="index-locator">b</a></span></li>
<li><span epub:type="index-term"><a href="#biclosed"
epub:type="index-locator">双閉</a></span></li>
</ul>
<!-- た -->
<ul>
<li>台集合 - <span epub:type="index-term"><a href="#underlying"
epub:type="index-locator">a</a></span>, <span epub:type="index-term"><a
href="#underlying_set" epub:type="index-locator">b</a></span></li>
<li><span epub:type="index-term"><a href="#object"
epub:type="index-locator">対象</a></span></li>
<li><span epub:type="index-term"><a href="#symmetric"
epub:type="index-locator">対称</a></span></li>
<li><span epub:type="index-term"><a href="#injective"
epub:type="index-locator">単射</a></span></li>
<li><span epub:type="index-term"><a href="#chain"
epub:type="index-locator">チェイン</a></span></li>
<li><span epub:type="index-term"><a href="#Cartesian_closed"
epub:type="index-locator">デカルト閉</a></span></li>
<li><span epub:type="index-term"><a href="#Cartesian_product"
epub:type="index-locator">デカルト積</a></span></li>
<li><span epub:type="index-term"><a href="#point"
epub:type="index-locator">点</a></span></li>
<li><span epub:type="index-term"><a href="#template_template_parameter"
epub:type="index-locator">テンプレートテンプレート仮引数</a></span></li>
<li><span epub:type="index-term"><a href="#tensor_product"
epub:type="index-locator">テンソル積</a></span></li>
<li><span epub:type="index-term"><a href="#isomorphic"
epub:type="index-locator">同型</a></span>
<ul>
<li><span epub:type="index-term"><a href="#isomorphism"
epub:type="index-locator">-射</a></span></li>
<li><span epub:type="index-term"><a href="#up_to_isomorphism"
epub:type="index-locator">-を除いて</a></span></li>
</ul></li>
<li><span epub:type="index-term"><a href="#equational_reasoning"
epub:type="index-locator">等式による推論</a></span></li>
<li><span epub:type="index-term"><a href="#equivalence"
epub:type="index-locator">同値性</a></span></li>
<li><span epub:type="index-term"><a href="#equivalence_relation"
epub:type="index-locator">同値関係</a></span></li>
<li><span epub:type="index-term"><a href="#topos"
epub:type="index-locator">トポス</a></span></li>
</ul>
<!-- な -->
<ul>
<li><span epub:type="index-term"><a href="#internal"
epub:type="index-locator">内部</a></span></li>
</ul>
<!-- は -->
<ul>
<li><span epub:type="index-term"><a href="#parametric_polymorphism"
epub:type="index-locator">パラメトリック多相</a></span></li>
<li><span epub:type="index-term"><a href="#semiring"
epub:type="index-locator">半環</a></span></li>
<li><span epub:type="index-term"><a href="#partial_order"
epub:type="index-locator">半順序</a></span>
<ul>
<li><span epub:type="index-term"><a href="#poset"
epub:type="index-locator">-集合</a></span></li>
</ul></li>
<li><span epub:type="index-term"><a href="#opposite_category"
epub:type="index-locator">反対圏</a></span></li>
<li><span epub:type="index-term"><a href="#contravariant"
epub:type="index-locator">反変</a></span></li>
<li><span epub:type="index-term"><a href="#equality"
epub:type="index-locator">等しさ</a></span></li>
<li><span epub:type="index-term"><a href="#evaluation"
epub:type="index-locator">評価</a></span></li>
<li><span epub:type="index-term"><a href="#representation"
epub:type="index-locator">表現</a></span></li>
<li>表現可能 – <span epub:type="index-term"><a href="#representable"
epub:type="index-locator">a</a></span>, <span epub:type="index-term"><a
href="#representable2" epub:type="index-locator">b</a></span>
<ul>
<li><span epub:type="index-term"><a href="#representable_presheaf"
epub:type="index-locator">-前層</a></span></li>
</ul></li>
<li><span epub:type="index-term"><a href="#side_effect"
epub:type="index-locator">副作用</a></span></li>
<li><span epub:type="index-term"><a href="#fixed_point"
epub:type="index-locator">不動点</a></span></li>
<li><span epub:type="index-term"><a href="#universal_construction"
epub:type="index-locator">普遍的構成</a></span></li>
<li><span epub:type="index-term"><a href="#profunctor"
epub:type="index-locator">プロ関手</a></span></li>
<li><span epub:type="index-term"><a href="#contextual_computation"
epub:type="index-locator">文脈付き計算</a></span></li>
<li><span epub:type="index-term"><a href="#exponential"
epub:type="index-locator">冪</a></span></li>
<li><span epub:type="index-term"><a href="#point-free"
epub:type="index-locator">ポイントフリー</a></span></li>
<li>忘却関手 – <span epub:type="index-term"><a href="#forgetful_functor"
epub:type="index-locator">a</a></span>, <span epub:type="index-term"><a
href="#forgetful_functor2" epub:type="index-locator">b</a></span></li>
<li>豊穣 – <span epub:type="index-term"><a href="#enriched"
epub:type="index-locator">a</a></span>, <span epub:type="index-term"><a
href="#enriched2" epub:type="index-locator">b</a></span>
<ul>
<li><span epub:type="index-term"><a href="#enriched_functor"
epub:type="index-locator">-関手</a></span></li>
</ul></li>
<li><span epub:type="index-term"><a href="#bottom"
epub:type="index-locator">ボトム</a></span></li>
</ul>
<!-- ま -->
<ul>
<li><span epub:type="index-term"><a href="#lifted"
epub:type="index-locator">持ち上げられた</a></span></li>
<li><span epub:type="index-term"><a href="#monad"
epub:type="index-locator">モナド</a></span></li>
<li><span epub:type="index-term"><a href="#monoidal_category"
epub:type="index-locator">モノイダル圏</a></span></li>
</ul>
<!-- や -->
<ul>
<li><span epub:type="index-term"><a href="#arrow"
epub:type="index-locator">矢</a></span></li>
<li><span epub:type="index-term"><a href="#coequalizer"
epub:type="index-locator">余等化子</a></span></li>
<li><span epub:type="index-term"><a href="#Yoneda_embedding"
epub:type="index-locator">米田埋め込み</a></span></li>
</ul>
<!-- ら -->
<ul>
<li><span epub:type="index-term"><a href="#rig"
epub:type="index-locator">リグ</a></span></li>
<li><span epub:type="index-term"><a href="#record"
epub:type="index-locator">レコード</a></span></li>
<li><span epub:type="index-term"><a href="#lawvere_theory"
epub:type="index-locator">ローヴェア・セオリー</a></span></li>
</ul>
<!-- わ -->
<h1 class="unnumbered" id="謝辞">謝辞</h1>
<p>私の計算と論理をチェックしてくれたEdward KmettとGershom
Bazermanに感謝したい。誤りを訂正し、本書を改善してくれた大勢のボランティアに感謝している。</p>
<p>Andrew Suttonには、自身とBjarne
Stroustrupの最新の提案に沿ってC++のモノイドの概念コードを書き直してくれたことに感謝したい。</p>
<p>Eric
Nieblerには、草稿を読み、C++14の高度な機能を用いて型推論を進める<code>compose</code>の巧妙な実装を提供してくれたことに感謝している。昔ながらのテンプレートマジックを使って型トレイトと同じことをしていたセクションをすべてカットできた。
いい厄介払いだ！</p>
<p>Gershom
Bazermanには、有益なコメントのおかげで、いくつかの重要な点を明確にできたことにも感謝したい。</p>
<h1 class="unnumbered" id="ライセンス">ライセンス</h1>
<p>この作品は、クリエイティブ・コモンズの 表示 - 継承 4.0 国際
ライセンスで提供されています。ライセンスの写しをご覧になるには、<a
href="http://creativecommons.org/licenses/by-sa/4.0/deed.ja"
class="uri">http://creativecommons.org/licenses/by-sa/4.0/deed.ja</a>をご覧頂くか、Creative
Commons, PO Box 1866, Mountain View, CA 94042, USA
までお手紙をお送りください。</p>
            </div>
    </div>
  </div>
  <!-- <script src="https://vjs.zencdn.net/5.4.4/video.js"></script> -->

</body>
</html>
