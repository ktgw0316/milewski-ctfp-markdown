<!doctype html>
<html lang="ja-JP">

<head>

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!--[if lt IE 9]>
                <script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"></script>
        <![endif]-->
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />

  <!-- <link rel="stylesheet" type="text/css" href="template.css" /> -->
  <link rel="stylesheet" type="text/css"
    href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/template.css" />

  <link href="https://vjs.zencdn.net/5.4.4/video-js.css" rel="stylesheet" />

  <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script>
  <!-- <script type='text/javascript' src='menu/js/jquery.cookie.js'></script> -->
  <!-- <script type='text/javascript' src='menu/js/jquery.hoverIntent.minified.js'></script> -->
  <!-- <script type='text/javascript' src='menu/js/jquery.dcjqaccordion.2.7.min.js'></script> -->

  <!-- <link href="menu/css/skins/blue.css" rel="stylesheet" type="text/css" /> -->
  <!-- <link href="menu/css/skins/graphite.css" rel="stylesheet" type="text/css" /> -->
  <!-- <link href="menu/css/skins/grey.css" rel="stylesheet" type="text/css" /> -->

  <!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->


  <!-- <script src="script.js"></script> -->

  <!-- <script src="jquery.sticky-kit.js "></script> -->
  <script type='text/javascript'
    src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.cookie.js'></script>
  <script type='text/javascript'
    src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.hoverIntent.minified.js'></script>
  <script type='text/javascript'
    src='https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/js/jquery.dcjqaccordion.2.7.min.js'></script>

  <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/blue.css"
    rel="stylesheet" type="text/css" />
  <link
    href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/graphite.css"
    rel="stylesheet" type="text/css" />
  <link href="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/menu/css/skins/grey.css"
    rel="stylesheet" type="text/css" />

  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <script src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/script.js"></script>

  <script
    src="https://cdn.jsdelivr.net/gh/diversen/pandoc-bootstrap-adaptive-template@959c3622/jquery.sticky-kit.js"></script>
  <meta name="generator" content="pandoc" />
  <meta name="author" content="バルトシュ・ミレフスキー著 北川雅裕訳" />
  <title>プログラマーのための圏論</title>
  <style type="text/css">
    code {
      white-space: pre;
    }
  </style>
  <style type="text/css">
    pre>code.sourceCode {
      white-space: pre;
      position: relative;
    }

    pre>code.sourceCode>span {
      line-height: 1.25;
    }

    pre>code.sourceCode>span:empty {
      height: 1.2em;
    }

    .sourceCode {
      overflow: visible;
    }

    code.sourceCode>span {
      color: inherit;
      text-decoration: inherit;
    }

    div.sourceCode {
      margin: 1em 0;
    }

    pre.sourceCode {
      margin: 0;
    }

    @media screen {
      div.sourceCode {
        overflow: auto;
      }
    }

    @media print {
      pre>code.sourceCode {
        white-space: pre-wrap;
      }

      pre>code.sourceCode>span {
        text-indent: -5em;
        padding-left: 5em;
      }
    }

    pre.numberSource code {
      counter-reset: source-line 0;
    }

    pre.numberSource code>span {
      position: relative;
      left: -4em;
      counter-increment: source-line;
    }

    pre.numberSource code>span>a:first-child::before {
      content: counter(source-line);
      position: relative;
      left: -1em;
      text-align: right;
      vertical-align: baseline;
      border: none;
      display: inline-block;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      padding: 0 4px;
      width: 4em;
      color: #aaaaaa;
    }

    pre.numberSource {
      margin-left: 3em;
      border-left: 1px solid #aaaaaa;
      padding-left: 4px;
    }

    div.sourceCode {
      background-color: #f8f8f8;
    }

    @media screen {
      pre>code.sourceCode>span>a:first-child::before {
        text-decoration: underline;
      }
    }

    code span.al {
      color: #ef2929;
    }

    /* Alert */
    code span.an {
      color: #8f5902;
      font-weight: bold;
      font-style: italic;
    }

    /* Annotation */
    code span.at {
      color: #204a87;
    }

    /* Attribute */
    code span.bn {
      color: #0000cf;
    }

    /* BaseN */
    code span.cf {
      color: #204a87;
      font-weight: bold;
    }

    /* ControlFlow */
    code span.ch {
      color: #4e9a06;
    }

    /* Char */
    code span.cn {
      color: #8f5902;
    }

    /* Constant */
    code span.co {
      color: #8f5902;
      font-style: italic;
    }

    /* Comment */
    code span.cv {
      color: #8f5902;
      font-weight: bold;
      font-style: italic;
    }

    /* CommentVar */
    code span.do {
      color: #8f5902;
      font-weight: bold;
      font-style: italic;
    }

    /* Documentation */
    code span.dt {
      color: #204a87;
    }

    /* DataType */
    code span.dv {
      color: #0000cf;
    }

    /* DecVal */
    code span.er {
      color: #a40000;
      font-weight: bold;
    }

    /* Error */
    code span.ex {}

    /* Extension */
    code span.fl {
      color: #0000cf;
    }

    /* Float */
    code span.fu {
      color: #204a87;
      font-weight: bold;
    }

    /* Function */
    code span.im {}

    /* Import */
    code span.in {
      color: #8f5902;
      font-weight: bold;
      font-style: italic;
    }

    /* Information */
    code span.kw {
      color: #204a87;
      font-weight: bold;
    }

    /* Keyword */
    code span.op {
      color: #ce5c00;
      font-weight: bold;
    }

    /* Operator */
    code span.ot {
      color: #8f5902;
    }

    /* Other */
    code span.pp {
      color: #8f5902;
      font-style: italic;
    }

    /* Preprocessor */
    code span.sc {
      color: #ce5c00;
      font-weight: bold;
    }

    /* SpecialChar */
    code span.ss {
      color: #4e9a06;
    }

    /* SpecialString */
    code span.st {
      color: #4e9a06;
    }

    /* String */
    code span.va {
      color: #000000;
    }

    /* Variable */
    code span.vs {
      color: #4e9a06;
    }

    /* VerbatimString */
    code span.wa {
      color: #8f5902;
      font-weight: bold;
      font-style: italic;
    }

    /* Warning */
  </style>
  <link rel="stylesheet" href="base.css" />
</head>

<body>


  <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">プログラマーのための圏論</span>
        <ul class="nav pull-right doc-info">
          <li>
            <p class="navbar-text">バルトシュ・ミレフスキー著
              北川雅裕訳</p>
          </li>
          <li>
            <p class="navbar-text"><a href="https://github.com/ktgw0316/milewski-ctfp-markdown/"
                class="uri">https://github.com/ktgw0316/milewski-ctfp-markdown/</a></p>
          </li>
        </ul>
      </div>
    </div>
  </div>
  <div class="container">
    <div class="row">
      <div id="TOC" class="span3">
        <div class="well toc">

          <ul>
            <li><a href="#はじめに" id="toc-はじめに">はじめに</a></li>
            <li><a href="#圏-合成の本質" id="toc-圏-合成の本質"><span class="toc-section-number">1</span> 圏: 合成の本質</a>
              <ul>
                <li><a href="#関数としての射" id="toc-関数としての射"><span class="toc-section-number">1.1</span> 関数としての射</a></li>
                <li><a href="#合成の性質" id="toc-合成の性質"><span class="toc-section-number">1.2</span> 合成の性質</a></li>
                <li><a href="#合成はプログラミングの本質" id="toc-合成はプログラミングの本質"><span class="toc-section-number">1.3</span>
                    合成はプログラミングの本質</a></li>
                <li><a href="#課題" id="toc-課題"><span class="toc-section-number">1.4</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#types-and-functions" id="toc-types-and-functions"><span class="toc-section-number">2</span>
                型と関数</a>
              <ul>
                <li><a href="#型を必要とするのは誰か" id="toc-型を必要とするのは誰か"><span class="toc-section-number">2.1</span>
                    型を必要とするのは誰か？</a></li>
                <li><a href="#型は合成に関する" id="toc-型は合成に関する"><span class="toc-section-number">2.2</span> 型は合成に関する</a></li>
                <li><a href="#型とは何か" id="toc-型とは何か"><span class="toc-section-number">2.3</span> 型とは何か？</a></li>
                <li><a href="#なぜ数学モデルが必要なのか" id="toc-なぜ数学モデルが必要なのか"><span class="toc-section-number">2.4</span>
                    なぜ数学モデルが必要なのか？</a></li>
                <li><a href="#純粋関数と非純粋関数" id="toc-純粋関数と非純粋関数"><span class="toc-section-number">2.5</span>
                    純粋関数と非純粋関数</a></li>
                <li><a href="#型の例" id="toc-型の例"><span class="toc-section-number">2.6</span> 型の例</a></li>
                <li><a href="#課題-1" id="toc-課題-1"><span class="toc-section-number">2.7</span> 課題</a></li>
                <li><a href="#参考文献" id="toc-参考文献"><span class="toc-section-number">2.8</span> 参考文献</a></li>
              </ul>
            </li>
            <li><a href="#大きい圏から小さい圏まで" id="toc-大きい圏から小さい圏まで"><span class="toc-section-number">3</span> 大きい圏から小さい圏まで</a>
              <ul>
                <li><a href="#対象の不在" id="toc-対象の不在"><span class="toc-section-number">3.1</span> 対象の不在</a></li>
                <li><a href="#シンプルなグラフ" id="toc-シンプルなグラフ"><span class="toc-section-number">3.2</span> シンプルなグラフ</a></li>
                <li><a href="#順序" id="toc-順序"><span class="toc-section-number">3.3</span> 順序</a></li>
                <li><a href="#集合としてのモノイド" id="toc-集合としてのモノイド"><span class="toc-section-number">3.4</span>
                    集合としてのモノイド</a></li>
                <li><a href="#圏としてのモノイド" id="toc-圏としてのモノイド"><span class="toc-section-number">3.5</span>
                    圏としてのモノイド</a></li>
                <li><a href="#課題-2" id="toc-課題-2"><span class="toc-section-number">3.6</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#kleisli-categories" id="toc-kleisli-categories"><span class="toc-section-number">4</span>
                Kleisli圏</a>
              <ul>
                <li><a href="#ログの合成" id="toc-ログの合成"><span class="toc-section-number">4.1</span> ログの合成</a></li>
                <li><a href="#writer圏" id="toc-writer圏"><span class="toc-section-number">4.2</span> Writer圏</a></li>
                <li><a href="#haskellにおけるwriter" id="toc-haskellにおけるwriter"><span class="toc-section-number">4.3</span>
                    HaskellにおけるWriter</a></li>
                <li><a href="#kleisli圏" id="toc-kleisli圏"><span class="toc-section-number">4.4</span> Kleisli圏</a></li>
                <li><a href="#課題-3" id="toc-課題-3"><span class="toc-section-number">4.5</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#products-and-coproducts" id="toc-products-and-coproducts"><span
                  class="toc-section-number">5</span> 積と余積</a>
              <ul>
                <li><a href="#矢に従え" id="toc-矢に従え"><span class="toc-section-number">5.1</span> 矢に従え</a></li>
                <li><a href="#始対象" id="toc-始対象"><span class="toc-section-number">5.2</span> 始対象</a></li>
                <li><a href="#終対象" id="toc-終対象"><span class="toc-section-number">5.3</span> 終対象</a></li>
                <li><a href="#双対性" id="toc-双対性"><span class="toc-section-number">5.4</span> 双対性</a></li>
                <li><a href="#同型" id="toc-同型"><span class="toc-section-number">5.5</span> 同型</a></li>
                <li><a href="#積" id="toc-積"><span class="toc-section-number">5.6</span> 積</a></li>
                <li><a href="#余積" id="toc-余積"><span class="toc-section-number">5.7</span> 余積</a></li>
                <li><a href="#非対称性" id="toc-非対称性"><span class="toc-section-number">5.8</span> 非対称性</a></li>
                <li><a href="#課題-4" id="toc-課題-4"><span class="toc-section-number">5.9</span> 課題</a></li>
                <li><a href="#参考文献-1" id="toc-参考文献-1"><span class="toc-section-number">5.10</span> 参考文献</a></li>
              </ul>
            </li>
            <li><a href="#シンプルな代数的データ型" id="toc-シンプルな代数的データ型"><span class="toc-section-number">6</span> シンプルな代数的データ型</a>
              <ul>
                <li><a href="#直積型" id="toc-直積型"><span class="toc-section-number">6.1</span> 直積型</a></li>
                <li><a href="#レコード" id="toc-レコード"><span class="toc-section-number">6.2</span> レコード</a></li>
                <li><a href="#直和型" id="toc-直和型"><span class="toc-section-number">6.3</span> 直和型</a></li>
                <li><a href="#型の代数" id="toc-型の代数"><span class="toc-section-number">6.4</span> 型の代数</a></li>
                <li><a href="#課題-5" id="toc-課題-5"><span class="toc-section-number">6.5</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#functors" id="toc-functors"><span class="toc-section-number">7</span> 関手</a>
              <ul>
                <li><a href="#プログラミングにおける関手" id="toc-プログラミングにおける関手"><span class="toc-section-number">7.1</span>
                    プログラミングにおける関手</a></li>
                <li><a href="#コンテナとしての関手" id="toc-コンテナとしての関手"><span class="toc-section-number">7.2</span>
                    コンテナとしての関手</a></li>
                <li><a href="#関手の合成" id="toc-関手の合成"><span class="toc-section-number">7.3</span> 関手の合成</a></li>
                <li><a href="#課題-6" id="toc-課題-6"><span class="toc-section-number">7.4</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#functoriality" id="toc-functoriality"><span class="toc-section-number">8</span> 関手性</a>
              <ul>
                <li><a href="#双関手" id="toc-双関手"><span class="toc-section-number">8.1</span> 双関手</a></li>
                <li><a href="#積と余積の双関手" id="toc-積と余積の双関手"><span class="toc-section-number">8.2</span> 積と余積の双関手</a></li>
                <li><a href="#関手的代数的データ型" id="toc-関手的代数的データ型"><span class="toc-section-number">8.3</span>
                    関手的代数的データ型</a></li>
                <li><a href="#cでの関手-1" id="toc-cでの関手-1"><span class="toc-section-number">8.4</span> C++での関手</a></li>
                <li><a href="#writer関手" id="toc-writer関手"><span class="toc-section-number">8.5</span> Writer関手</a></li>
                <li><a href="#共変関手と反変関手" id="toc-共変関手と反変関手"><span class="toc-section-number">8.6</span>
                    共変関手と反変関手</a></li>
                <li><a href="#プロ関手" id="toc-プロ関手"><span class="toc-section-number">8.7</span> プロ関手</a></li>
                <li><a href="#hom関手" id="toc-hom関手"><span class="toc-section-number">8.8</span> Hom関手</a></li>
                <li><a href="#課題-7" id="toc-課題-7"><span class="toc-section-number">8.9</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#function-types" id="toc-function-types"><span class="toc-section-number">9</span> 関数型</a>
              <ul>
                <li><a href="#普遍的構成" id="toc-普遍的構成"><span class="toc-section-number">9.1</span> 普遍的構成</a></li>
                <li><a href="#カリー化" id="toc-カリー化"><span class="toc-section-number">9.2</span> カリー化</a></li>
                <li><a href="#冪乗" id="toc-冪乗"><span class="toc-section-number">9.3</span> 冪乗</a></li>
                <li><a href="#カルテシアン閉圏" id="toc-カルテシアン閉圏"><span class="toc-section-number">9.4</span> カルテシアン閉圏</a></li>
                <li><a href="#冪乗と代数的データ型" id="toc-冪乗と代数的データ型"><span class="toc-section-number">9.5</span>
                    冪乗と代数的データ型</a></li>
                <li><a href="#カリーハワード同型" id="toc-カリーハワード同型"><span class="toc-section-number">9.6</span>
                    カリー・ハワード同型</a></li>
                <li><a href="#参考文献-2" id="toc-参考文献-2"><span class="toc-section-number">9.7</span> 参考文献</a></li>
              </ul>
            </li>
            <li><a href="#natural-transformations" id="toc-natural-transformations"><span
                  class="toc-section-number">10</span> 自然変換</a>
              <ul>
                <li><a href="#多相関数" id="toc-多相関数"><span class="toc-section-number">10.1</span> 多相関数</a></li>
                <li><a href="#自然性を越えて" id="toc-自然性を越えて"><span class="toc-section-number">10.2</span> 自然性を越えて</a></li>
                <li><a href="#関手圏" id="toc-関手圏"><span class="toc-section-number">10.3</span> 関手圏</a></li>
                <li><a href="#圏" id="toc-圏"><span class="toc-section-number">10.4</span> 2-圏</a></li>
                <li><a href="#おわりに" id="toc-おわりに"><span class="toc-section-number">10.5</span> おわりに</a></li>
                <li><a href="#課題-8" id="toc-課題-8"><span class="toc-section-number">10.6</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#圏論と宣言的プログラミング" id="toc-圏論と宣言的プログラミング"><span class="toc-section-number">11</span>
                圏論と宣言的プログラミング</a>
              <ul>
                <li><a href="#第2部への導入" id="toc-第2部への導入"><span class="toc-section-number">11.1</span> 第2部への導入</a></li>
              </ul>
            </li>
            <li><a href="#limits-and-colimits" id="toc-limits-and-colimits"><span class="toc-section-number">12</span>
                極限と余極限</a>
              <ul>
                <li><a href="#自然同型としての極限" id="toc-自然同型としての極限"><span class="toc-section-number">12.1</span>
                    自然同型としての極限</a></li>
                <li><a href="#極限の例" id="toc-極限の例"><span class="toc-section-number">12.2</span> 極限の例</a></li>
                <li><a href="#余極限" id="toc-余極限"><span class="toc-section-number">12.3</span> 余極限</a></li>
                <li><a href="#連続性" id="toc-連続性"><span class="toc-section-number">12.4</span> 連続性</a></li>
                <li><a href="#課題-9" id="toc-課題-9"><span class="toc-section-number">12.5</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#free-monoids" id="toc-free-monoids"><span class="toc-section-number">13</span> 自由モノイド</a>
              <ul>
                <li><a href="#haskellにおける自由モノイド" id="toc-haskellにおける自由モノイド"><span class="toc-section-number">13.1</span>
                    Haskellにおける自由モノイド</a></li>
                <li><a href="#自由モノイドの普遍的構成" id="toc-自由モノイドの普遍的構成"><span class="toc-section-number">13.2</span>
                    自由モノイドの普遍的構成</a></li>
                <li><a href="#課題-10" id="toc-課題-10"><span class="toc-section-number">13.3</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#representable-functors" id="toc-representable-functors"><span
                  class="toc-section-number">14</span> 表現可能関手</a>
              <ul>
                <li><a href="#hom関手-1" id="toc-hom関手-1"><span class="toc-section-number">14.1</span> Hom関手</a></li>
                <li><a href="#表現可能関手" id="toc-表現可能関手"><span class="toc-section-number">14.2</span> 表現可能関手</a></li>
                <li><a href="#課題-11" id="toc-課題-11"><span class="toc-section-number">14.3</span> 課題</a></li>
                <li><a href="#参考文献-3" id="toc-参考文献-3"><span class="toc-section-number">14.4</span> 参考文献</a></li>
              </ul>
            </li>
            <li><a href="#the-yoneda-lemma" id="toc-the-yoneda-lemma"><span class="toc-section-number">15</span>
                米田の補題</a>
              <ul>
                <li><a href="#haskellにおける米田の補題" id="toc-haskellにおける米田の補題"><span class="toc-section-number">15.1</span>
                    Haskellにおける米田の補題</a></li>
                <li><a href="#余米田の補題" id="toc-余米田の補題"><span class="toc-section-number">15.2</span> 余米田の補題</a></li>
                <li><a href="#課題-12" id="toc-課題-12"><span class="toc-section-number">15.3</span> 課題</a></li>
                <li><a href="#参考文献-4" id="toc-参考文献-4"><span class="toc-section-number">15.4</span> 参考文献</a></li>
              </ul>
            </li>
            <li><a href="#yoneda-embedding" id="toc-yoneda-embedding"><span class="toc-section-number">16</span>
                米田埋め込み</a>
              <ul>
                <li><a href="#埋め込み" id="toc-埋め込み"><span class="toc-section-number">16.1</span> 埋め込み</a></li>
                <li><a href="#haskellへの応用" id="toc-haskellへの応用"><span class="toc-section-number">16.2</span>
                    Haskellへの応用</a></li>
                <li><a href="#前順序の例" id="toc-前順序の例"><span class="toc-section-number">16.3</span> 前順序の例</a></li>
                <li><a href="#自然性" id="toc-自然性"><span class="toc-section-number">16.4</span> 自然性</a></li>
                <li><a href="#課題-13" id="toc-課題-13"><span class="toc-section-number">16.5</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#射のすべて" id="toc-射のすべて"><span class="toc-section-number">17</span> 射のすべて</a>
              <ul>
                <li><a href="#関手" id="toc-関手"><span class="toc-section-number">17.1</span> 関手</a></li>
                <li><a href="#可換図式" id="toc-可換図式"><span class="toc-section-number">17.2</span> 可換図式</a></li>
                <li><a href="#自然変換" id="toc-自然変換"><span class="toc-section-number">17.3</span> 自然変換</a></li>
                <li><a href="#自然同型" id="toc-自然同型"><span class="toc-section-number">17.4</span> 自然同型</a></li>
                <li><a href="#hom集合" id="toc-hom集合"><span class="toc-section-number">17.5</span> Hom集合</a></li>
                <li><a href="#hom集合同型" id="toc-hom集合同型"><span class="toc-section-number">17.6</span> Hom集合同型</a></li>
                <li><a href="#hom集合の非対称性" id="toc-hom集合の非対称性"><span class="toc-section-number">17.7</span>
                    Hom集合の非対称性</a></li>
                <li><a href="#課題-14" id="toc-課題-14"><span class="toc-section-number">17.8</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#adjunctions" id="toc-adjunctions"><span class="toc-section-number">18</span> 随伴</a>
              <ul>
                <li><a href="#随伴と単位余単位ペア" id="toc-随伴と単位余単位ペア"><span class="toc-section-number">18.1</span>
                    随伴と単位/余単位ペア</a></li>
                <li><a href="#随伴とhom集合" id="toc-随伴とhom集合"><span class="toc-section-number">18.2</span> 随伴とhom集合</a></li>
                <li><a href="#随伴に基づく積" id="toc-随伴に基づく積"><span class="toc-section-number">18.3</span> 随伴に基づく積</a></li>
                <li><a href="#随伴に基づく冪乗" id="toc-随伴に基づく冪乗"><span class="toc-section-number">18.4</span> 随伴に基づく冪乗</a></li>
                <li><a href="#課題-15" id="toc-課題-15"><span class="toc-section-number">18.5</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#自由忘却随伴" id="toc-自由忘却随伴"><span class="toc-section-number">19</span> 自由/忘却随伴</a>
              <ul>
                <li><a href="#随伴に基づく自由モノイド" id="toc-随伴に基づく自由モノイド"><span class="toc-section-number">19.1</span>
                    随伴に基づく自由モノイド</a></li>
                <li><a href="#いくつかの直観" id="toc-いくつかの直観"><span class="toc-section-number">19.2</span> いくつかの直観</a></li>
                <li><a href="#課題-16" id="toc-課題-16"><span class="toc-section-number">19.3</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#モナド-プログラマーの定義" id="toc-モナド-プログラマーの定義"><span class="toc-section-number">20</span> モナド:
                プログラマーの定義</a>
              <ul>
                <li><a href="#kleisli圏-1" id="toc-kleisli圏-1"><span class="toc-section-number">20.1</span> Kleisli圏</a>
                </li>
                <li><a href="#fishの解剖" id="toc-fishの解剖"><span class="toc-section-number">20.2</span> Fishの解剖</a></li>
                <li><a href="#do記法" id="toc-do記法"><span class="toc-section-number">20.3</span>
                    <code>do</code>記法</a></li>
              </ul>
            </li>
            <li><a href="#モナドと作用" id="toc-モナドと作用"><span class="toc-section-number">21</span> モナドと作用</a>
              <ul>
                <li><a href="#問題" id="toc-問題"><span class="toc-section-number">21.1</span> 問題</a></li>
                <li><a href="#解決策" id="toc-解決策"><span class="toc-section-number">21.2</span> 解決策</a></li>
                <li><a href="#おわりに-1" id="toc-おわりに-1"><span class="toc-section-number">21.3</span> おわりに</a></li>
              </ul>
            </li>
            <li><a href="#圏論から見たモナド" id="toc-圏論から見たモナド"><span class="toc-section-number">22</span> 圏論から見たモナド</a>
              <ul>
                <li><a href="#モノイダル圏" id="toc-モノイダル圏"><span class="toc-section-number">22.1</span> モノイダル圏</a></li>
                <li><a href="#モノイダル圏におけるモノイド" id="toc-モノイダル圏におけるモノイド"><span class="toc-section-number">22.2</span>
                    モノイダル圏におけるモノイド</a></li>
                <li><a href="#モノイドとしてのモナド" id="toc-モノイドとしてのモナド"><span class="toc-section-number">22.3</span>
                    モノイドとしてのモナド</a></li>
                <li><a href="#随伴に基づくモナド" id="toc-随伴に基づくモナド"><span class="toc-section-number">22.4</span>
                    随伴に基づくモナド</a></li>
              </ul>
            </li>
            <li><a href="#コモナド" id="toc-コモナド"><span class="toc-section-number">23</span> コモナド</a>
              <ul>
                <li><a href="#コモナドでのプログラミング" id="toc-コモナドでのプログラミング"><span class="toc-section-number">23.1</span>
                    コモナドでのプログラミング</a></li>
                <li><a href="#積コモナド" id="toc-積コモナド"><span class="toc-section-number">23.2</span> 積コモナド</a></li>
                <li><a href="#合成の分析" id="toc-合成の分析"><span class="toc-section-number">23.3</span> 合成の分析</a></li>
                <li><a href="#streamコモナド" id="toc-streamコモナド"><span class="toc-section-number">23.4</span>
                    Streamコモナド</a></li>
                <li><a href="#圏論から見たコモナド" id="toc-圏論から見たコモナド"><span class="toc-section-number">23.5</span>
                    圏論から見たコモナド</a></li>
                <li><a href="#storeコモナド" id="toc-storeコモナド"><span class="toc-section-number">23.6</span> Storeコモナド</a>
                </li>
                <li><a href="#課題-17" id="toc-課題-17"><span class="toc-section-number">23.7</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#f-代数" id="toc-f-代数"><span class="toc-section-number">24</span> F-代数</a>
              <ul>
                <li><a href="#再帰" id="toc-再帰"><span class="toc-section-number">24.1</span> 再帰</a></li>
                <li><a href="#f-代数の圏" id="toc-f-代数の圏"><span class="toc-section-number">24.2</span> F-代数の圏</a></li>
                <li><a href="#自然数" id="toc-自然数"><span class="toc-section-number">24.3</span> 自然数</a></li>
                <li><a href="#カタモルフィズム" id="toc-カタモルフィズム"><span class="toc-section-number">24.4</span> カタモルフィズム</a></li>
                <li><a href="#畳み込み" id="toc-畳み込み"><span class="toc-section-number">24.5</span> 畳み込み</a></li>
                <li><a href="#余代数" id="toc-余代数"><span class="toc-section-number">24.6</span> 余代数</a></li>
                <li><a href="#課題-18" id="toc-課題-18"><span class="toc-section-number">24.7</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#モナドの代数" id="toc-モナドの代数"><span class="toc-section-number">25</span> モナドの代数</a>
              <ul>
                <li><a href="#t-代数" id="toc-t-代数"><span class="toc-section-number">25.1</span> T-代数</a></li>
                <li><a href="#kleisli圏-2" id="toc-kleisli圏-2"><span class="toc-section-number">25.2</span> Kleisli圏</a>
                </li>
                <li><a href="#コモナドの余代数" id="toc-コモナドの余代数"><span class="toc-section-number">25.3</span> コモナドの余代数</a></li>
                <li><a href="#レンズ" id="toc-レンズ"><span class="toc-section-number">25.4</span> レンズ</a></li>
                <li><a href="#課題-19" id="toc-課題-19"><span class="toc-section-number">25.5</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#ends-and-coends" id="toc-ends-and-coends"><span class="toc-section-number">26</span>
                エンドとコエンド</a>
              <ul>
                <li><a href="#対角自然変換" id="toc-対角自然変換"><span class="toc-section-number">26.1</span> 対角自然変換</a></li>
                <li><a href="#エンド" id="toc-エンド"><span class="toc-section-number">26.2</span> エンド</a></li>
                <li><a href="#イコライザとしてのエンド" id="toc-イコライザとしてのエンド"><span class="toc-section-number">26.3</span>
                    イコライザとしてのエンド</a></li>
                <li><a href="#エンドとしての自然変換" id="toc-エンドとしての自然変換"><span class="toc-section-number">26.4</span>
                    エンドとしての自然変換</a></li>
                <li><a href="#コエンド" id="toc-コエンド"><span class="toc-section-number">26.5</span> コエンド</a></li>
                <li><a href="#忍者米田の補題" id="toc-忍者米田の補題"><span class="toc-section-number">26.6</span> 忍者米田の補題</a></li>
                <li><a href="#プロ関手の合成" id="toc-プロ関手の合成"><span class="toc-section-number">26.7</span> プロ関手の合成</a></li>
              </ul>
            </li>
            <li><a href="#kan拡張" id="toc-kan拡張"><span class="toc-section-number">27</span> Kan拡張</a>
              <ul>
                <li><a href="#右kan拡張" id="toc-右kan拡張"><span class="toc-section-number">27.1</span> 右Kan拡張</a></li>
                <li><a href="#随伴としてのkan拡張" id="toc-随伴としてのkan拡張"><span class="toc-section-number">27.2</span>
                    随伴としてのKan拡張</a></li>
                <li><a href="#左kan拡張" id="toc-左kan拡張"><span class="toc-section-number">27.3</span> 左Kan拡張</a></li>
                <li><a href="#エンドとしてのkan拡張" id="toc-エンドとしてのkan拡張"><span class="toc-section-number">27.4</span>
                    エンドとしてのKan拡張</a></li>
                <li><a href="#haskellでのkan拡張" id="toc-haskellでのkan拡張"><span class="toc-section-number">27.5</span>
                    HaskellでのKan拡張</a></li>
                <li><a href="#自由関手" id="toc-自由関手"><span class="toc-section-number">27.6</span> 自由関手</a></li>
              </ul>
            </li>
            <li><a href="#豊穣圏" id="toc-豊穣圏"><span class="toc-section-number">28</span> 豊穣圏</a>
              <ul>
                <li><a href="#なぜモノイダル圏か" id="toc-なぜモノイダル圏か"><span class="toc-section-number">28.1</span>
                    なぜモノイダル圏か？</a></li>
                <li><a href="#モノイダル圏-1" id="toc-モノイダル圏-1"><span class="toc-section-number">28.2</span> モノイダル圏</a></li>
                <li><a href="#豊饒圏" id="toc-豊饒圏"><span class="toc-section-number">28.3</span> 豊饒圏</a></li>
                <li><a href="#前順序" id="toc-前順序"><span class="toc-section-number">28.4</span> 前順序</a></li>
                <li><a href="#距離空間" id="toc-距離空間"><span class="toc-section-number">28.5</span> 距離空間</a></li>
                <li><a href="#豊穣関手" id="toc-豊穣関手"><span class="toc-section-number">28.6</span> 豊穣関手</a></li>
                <li><a href="#自己豊穣化" id="toc-自己豊穣化"><span class="toc-section-number">28.7</span> 自己豊穣化</a></li>
                <li><a href="#mathbf2-圏との関係" id="toc-mathbf2-圏との関係"><span class="toc-section-number">28.8</span>
                    <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                      <semantics>
                        <mn>𝟐</mn>
                        <annotation encoding="application/x-tex">\mathbf{2}</annotation>
                      </semantics>
                    </math>-圏との関係</a></li>
              </ul>
            </li>
            <li><a href="#トポイ" id="toc-トポイ"><span class="toc-section-number">29</span> トポイ</a>
              <ul>
                <li><a href="#部分対象分類子" id="toc-部分対象分類子"><span class="toc-section-number">29.1</span> 部分対象分類子</a></li>
                <li><a href="#トポス" id="toc-トポス"><span class="toc-section-number">29.2</span> トポス</a></li>
                <li><a href="#トポイと論理" id="toc-トポイと論理"><span class="toc-section-number">29.3</span> トポイと論理</a></li>
                <li><a href="#課題-20" id="toc-課題-20"><span class="toc-section-number">29.4</span> 課題</a></li>
              </ul>
            </li>
            <li><a href="#ローヴェアセオリー" id="toc-ローヴェアセオリー"><span class="toc-section-number">30</span> ローヴェア・セオリー</a>
              <ul>
                <li><a href="#普遍代数" id="toc-普遍代数"><span class="toc-section-number">30.1</span> 普遍代数</a></li>
                <li><a href="#ローヴェアセオリー-1" id="toc-ローヴェアセオリー-1"><span class="toc-section-number">30.2</span>
                    ローヴェア・セオリー</a></li>
                <li><a href="#ローヴェアセオリーにおけるモデル" id="toc-ローヴェアセオリーにおけるモデル"><span class="toc-section-number">30.3</span>
                    ローヴェア・セオリーにおけるモデル</a></li>
                <li><a href="#モノイドのセオリー" id="toc-モノイドのセオリー"><span class="toc-section-number">30.4</span>
                    モノイドのセオリー</a></li>
                <li><a href="#ローヴェアセオリーとモナド" id="toc-ローヴェアセオリーとモナド"><span class="toc-section-number">30.5</span>
                    ローヴェア・セオリーとモナド</a></li>
                <li><a href="#コエンドとしてのモナド" id="toc-コエンドとしてのモナド"><span class="toc-section-number">30.6</span>
                    コエンドとしてのモナド</a></li>
                <li><a href="#副作用のローヴェアセオリー" id="toc-副作用のローヴェアセオリー"><span class="toc-section-number">30.7</span>
                    副作用のローヴェア・セオリー</a></li>
                <li><a href="#課題-21" id="toc-課題-21"><span class="toc-section-number">30.8</span> 課題</a></li>
                <li><a href="#参考文献-5" id="toc-参考文献-5"><span class="toc-section-number">30.9</span> 参考文献</a></li>
              </ul>
            </li>
            <li><a href="#モナドモノイド圏" id="toc-モナドモノイド圏"><span class="toc-section-number">31</span> モナド・モノイド・圏</a>
              <ul>
                <li><a href="#双圏" id="toc-双圏"><span class="toc-section-number">31.1</span> 双圏</a></li>
                <li><a href="#モナド" id="toc-モナド"><span class="toc-section-number">31.2</span> モナド</a></li>
                <li><a href="#課題-22" id="toc-課題-22"><span class="toc-section-number">31.3</span> 課題</a></li>
                <li><a href="#参考文献-6" id="toc-参考文献-6"><span class="toc-section-number">31.4</span> 参考文献</a></li>
              </ul>
            </li>
            <li><a href="#索引" id="toc-索引">索引</a></li>
            <li><a href="#謝辞" id="toc-謝辞">謝辞</a></li>
            <li><a href="#ライセンス" id="toc-ライセンス">ライセンス</a></li>
          </ul>

        </div>
      </div>
      <div class="span9">


        <h1 class="unnumbered" id="はじめに">はじめに</h1>
        <blockquote>
          <p>
            しばらく前から、プログラマーを対象とした圏論に関する本を書こうと考えていた。計算機科学者ではなくプログラマー、科学者ではなくエンジニア向けだということに注目してほしい。正気の沙汰ではないし、本当に恐ろしい。科学と工学の間に大きなギャップがあるのは否定できないと思う。自分自身がその分断の両側で仕事をしてきたからだ。それでも、物事を説明したいという強い衝動をいつも感じていた。簡潔な説明の達人だったリチャード・ファインマンを心から尊敬している。自分がファインマンではないことは分かっているが、最善を尽くしたい。まずはこの序文を公開することから始めようと思う。きっと読者にとって圏論を学ぶきっかけになるだろう。議論を始め、フィードバックを募れることを願っている。
          </p>
        </blockquote>
        <p>ここからの数段落で納得してもらいたいのは、この本はあなたのために書かれたものであり、数学のうちでも特に抽象的な分野を学ぶために「あり余る自由時間」を費やすことに異論を唱える根拠は全くないということだ。</p>
        <p>
          私の楽観論はいくつかの観察に基づいている。第1に、圏論は極めて有用なプログラミングのアイデアの宝庫だ。Haskellプログラマーたちは長い間この資源を利用していて、得られたアイデアは他の言語にゆっくりと浸透してきているが、プロセスが遅すぎる。もっとスピードを上げる必要がある。
        </p>
        <p>
          第2に、数学には多くの種類があり、それぞれ興味を惹く人も異なる。微積分や代数にアレルギーがあったとしても、圏論を楽しめないことにはならない。私は、圏論はプログラマーのマインドに特に合った数学であるとさえ主張したい。圏論は、細かい物事を扱うのではなく、構造を扱うからだ。それはプログラムを合成可能にするような構造を扱う。
        </p>
        <p>
          合成は圏論の根本にあり、圏そのものの定義の一部だ。そして私は、合成こそプログラミングの本質であると強く主張したい。我々は、偉大なエンジニアがサブルーチンのアイデアを思いつく遥か前から、ずっとものを合成してきた。かつて構造化プログラミングはプログラミングに革命をもたらした。コードのブロックを合成可能にしたからだ。続いてオブジェクト指向プログラミングが登場した。これはオブジェクトを合成することこそすべてだ。関数型プログラミングは、関数や代数的データ構造を合成するだけでなく、並行性を合成可能にする。これは他のプログラミングパラダイムでは事実上不可能だ。
        </p>
        <p>
          第3に、私には秘密兵器の「肉切り包丁」がある。それを使って数学を捌いて、プログラマーにとってさらに美味しいものにするつもりだ。プロの数学者なら、すべての仮定を確かめ、すべての命題を適切に述べ、すべての証明を厳密に構成するために、細心の注意を払う必要がある。それによって数学の論文や書籍は門外漢には非常に読みにくくなっている。一方で私は実践を通じた物理学者であり、物理学は形式的でない推論を用いて驚くべき進歩を遂げた学問だ。かつて数学者たちはディラックのデルタ関数を嗤った。デルタ関数は、偉大な物理学者であるP.A.M.
          ディラックが微分方程式を解く過程で作ったものだ。ディラックの洞察を形式化した微積分学のまったく新しい分野として超関数理論
          (distribuiton theory)
          を物理学者たちが発見したとき、彼らは嗤うのをやめた。</p>
        <p>
          当然ながら、身振り手振りで議論するときには明らかに間違ったことを言ってしまう危険があるので、本書では非公式な議論の背景にしっかりした数学的理論があることを確認するようにしたい。私のベッドサイドには、使い古されたソーンダーズ・マックレーンの『圏論の基礎』が置かれている。
        </p>
        <p>
          この本はプログラマーのための圏論なので、すべての主要な概念を説明するのにコンピューターのコードを使うことにしたい。ご存知かも知れないが、関数型言語は一般的な命令型言語よりも数学に近い。また、より強力な抽象化能力を提供する。そのため、自然な誘惑として「圏論の恩恵に浴するにはHaskellを学ばなければならない」と言いたくなるだろう。しかし、それは圏論が関数型プログラミング以外の用途を持たないことを意味しており、真実には程遠い。そこで、C++での例をたくさん載せようと思う。確かに、いくつかの醜い構文を克服しなければならず、雑然とした背景に紛れてパターンが目立たなくなったり、高度な抽象化の代わりにコピー＆ペーストに頼らなければならない場面もあるだろうが、それがC++プログラマーというものだ。
        </p>
        <p>
          だが、Haskellを考慮に入れたなら、運に見放されてはいない。Haskellプログラマーになる必要はないが、C++で実装しようとしているアイデアをスケッチしたり文書化したりするための言語としてHaskellが必要になる。私もそうやってHaskellを始めた。そして、簡潔な構文と強力な型システムが、C++のテンプレート、データ構造、アルゴリズムを理解し実装する上で大きな助けになることに気付いた。もっとも、読者がすでにHaskellを知っているとは期待できないので、ゆっくり紹介しながらすべてを説明していくつもりだ。
        </p>
        <p>プログラマーとしての経験が長い人は、次のように自問するかもしれない:
          ずっと圏論や関数型の手法を気にすることなくコーディングしてきたが、何が変わったのだろう？
          確かにそう思わずにいられないだろうが、関数型の新機能が続々と登場し、命令型言語に侵入していることに気付いてほしい。オブジェクト指向プログラミングの拠点であるJavaでさえ、ラムダを導入した。最近のC++は数年ごとの新しい標準という激動のペースで進化し、変化する世界に追いつこうとしている。これらはすべて、破壊的な変化、すなわち物理学者たちが相転移と呼ぶものに備えるための動きだ。お湯を温め続けると、やがて沸騰しはじめる。我々は今、その中のカエルの立場にいる。カエルはどんどん熱くなるお湯の中で泳ぎ続けるべきなのか、それとも何か別のものを探し始めるべきなのか、決めなければならない。
        </p>
        <p><img src="images/img_1299.jpg" style="width:50.0%" /></p>
        <p>
          大きな変化を引き起こしている力の1つがマルチコア革命だ。プログラミングパラダイムとして普及しているオブジェクト指向プログラミングは、並行・並列処理の領域では何のメリットもなく、その代わりに危険でバグを生じやすい設計を奨励している。オブジェクト指向の基本的前提であるデータ隠蔽は、データの共有や改変と組み合わされると、データ競合のレシピになる。mutexとそれが保護するデータを組み合わせるというアイデアは素晴らしい。しかし、残念ながらロックは合成できないし、ロックを隠すことでデッドロックが発生しやすくなり、デバッグが難しくなる。
        </p>
        <p>
          さらに、並行性が存在しないとしても、ソフトウェアシステムの複雑さが増すにつれて、命令パラダイムのスケーラビリティは限界が試されている。簡単に言うと、副作用が手に負えなくなってきている。確かに、副作用のある関数は便利だし簡単に書ける。それらの作用は、原理的には、名前やコメントに示しておける。SetPasswordやWriteFileなどと命名された関数は、明らかに何らかの状態を変化させ、副作用を発生させるが、我々はそれに対処するのには慣れている。副作用のある関数に副作用のある別の関数を合成し始めたときにだけ、物事は複雑になり始める。副作用が本質的に悪いわけではなく、隠れて見えないせいで大規模な管理が不可能になっているのだ。副作用はスケールせず、そして命令型プログラミングでは副作用こそすべてだ。
        </p>
        <p>
          ハードウェアの変化とソフトウェアの複雑さが増すことで、プログラミングの基礎を再考する必要に迫られている。ヨーロッパの偉大なゴシック大聖堂の建設者と同じように、我々は材料と構造の限界まで技術を磨き続けてきた。フランスには未完成のゴシック建築の<a
            href="https://en.wikipedia.org/wiki/Beauvais_Cathedral">ボーヴェ大聖堂</a>があり、この深く人間的な限界との闘いの証拠となっている。それまでの高さと軽さの記録をすべて破ることを目論んでいたが、相次ぐ崩壊に見舞われた。鉄筋や木製の支柱などの特別な手段で崩壊を防いでいるが、明らかに多くのことがうまくいかなかった。現代の視点から見ると、材料科学、コンピューターモデリング、有限要素解析、そして汎用的な数学と物理学の助けなしに、これほど多くのゴシック構造が成功裏に完成したことは奇跡だ。将来の世代が、複雑なオペレーティング・システム、Webサーバー、インターネット基盤を構築する際に我々が示してきたプログラミングのスキルを賞賛するようになるのを願っている。率直に言って、彼らはそうすべきだ。我々はそれらすべてを、非常に貧弱な理論的基盤に基づいて行ってきたのだから。前進するためには、これらの基盤を修復しなければならない。
        </p>
        <figure>
          <img src="images/beauvais_interior_supports.jpg" title="ボーヴェ大聖堂の崩壊を阻止するための応急処置" style="width:50.0%"
            alt="ボーヴェ大聖堂の崩壊を阻止するための応急処置" />
          <figcaption aria-hidden="true">ボーヴェ大聖堂の崩壊を阻止するための応急処置</figcaption>
        </figure>
        <h1 data-number="1" id="圏-合成の本質"><span class="header-section-number">1</span> 圏: 合成の本質</h1>
        <p>圏は、戸惑ってしまうほど単純な概念だ。圏 (category) は複数の<span id="object" class="keyword">対象</span> (object) とそれらをつなぐ<span
            id="arrow" class="keyword">矢</span> (arrow)
          で構成される。それが、圏を図として表すのが簡単な理由だ。対象は円または点として、射は矢印として描ける。(変化を付けるために、筆者は対象を子豚、矢をロケット花火として描くことがある。)
          しかし、圏の本質は<em>合成</em> (composition)
          にある。あるいは、合成の本質は圏だと言っても構わない。矢は合成できるので、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>A</mi>
              <annotation encoding="application/x-tex">A</annotation>
            </semantics>
          </math>から対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>B</mi>
              <annotation encoding="application/x-tex">B</annotation>
            </semantics>
          </math>への矢があって、さらに対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>B</mi>
              <annotation encoding="application/x-tex">B</annotation>
            </semantics>
          </math>から対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>C</mi>
              <annotation encoding="application/x-tex">C</annotation>
            </semantics>
          </math>への別の矢があるなら、それらを合成した、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>A</mi>
              <annotation encoding="application/x-tex">A</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>C</mi>
              <annotation encoding="application/x-tex">C</annotation>
            </semantics>
          </math>への矢が必ずある。</p>
        <figure>
          <img src="images/img_1330.jpg" style="width:80.0%"
            alt="圏では、AからBへの矢とBからCへの矢があるなら、それらを合成した、AからCへ直接向かう矢が必ずある。この図には恒等射 (後述) がないため、完全な圏ではない。" />
          <figcaption aria-hidden="true">圏では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>A</mi>
                <annotation encoding="application/x-tex">A</annotation>
              </semantics>
            </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>B</mi>
                <annotation encoding="application/x-tex">B</annotation>
              </semantics>
            </math>への矢と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>B</mi>
                <annotation encoding="application/x-tex">B</annotation>
              </semantics>
            </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>C</mi>
                <annotation encoding="application/x-tex">C</annotation>
              </semantics>
            </math>への矢があるなら、それらを合成した、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>A</mi>
                <annotation encoding="application/x-tex">A</annotation>
              </semantics>
            </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>C</mi>
                <annotation encoding="application/x-tex">C</annotation>
              </semantics>
            </math>へ直接向かう矢が必ずある。この図には恒等射
            (後述) がないため、完全な圏ではない。</figcaption>
        </figure>
        <h2 data-number="1.1" id="関数としての射"><span class="header-section-number">1.1</span> 関数としての射</h2>
        <p>すでに抽象的すぎて意味不明だろうか？
          投げ出さないでほしい。具体的な話をしよう。矢 (<span id="morphism" class="keyword">射</span> (morphism) とも呼ばれる)
          を関数として考えよう。関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>が型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>A</mi>
              <annotation encoding="application/x-tex">A</annotation>
            </semantics>
          </math>の引数を取って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>B</mi>
              <annotation encoding="application/x-tex">B</annotation>
            </semantics>
          </math>を返すとする。また、別の関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>B</mi>
              <annotation encoding="application/x-tex">B</annotation>
            </semantics>
          </math>を取って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>C</mi>
              <annotation encoding="application/x-tex">C</annotation>
            </semantics>
          </math>を返すとする。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>の結果を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>に渡せばそれらを合成できる。つまり<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>A</mi>
              <annotation encoding="application/x-tex">A</annotation>
            </semantics>
          </math>を取って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>C</mi>
              <annotation encoding="application/x-tex">C</annotation>
            </semantics>
          </math>を返す新たな関数を定義したことになる。</p>
        <p>数学では、このような合成を関数同士の間に小さな丸を書いて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>∘</mo>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">g \circ f</annotation>
            </semantics>
          </math>のように表す。合成の順序が右から左であることに注意してほしい。これが紛らわしいと感じる人もいるだろう。たとえば、次のようなUnixのパイプ:</p>
        <div class="sourceCode" id="cb1">
          <pre
            class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">lsof</span> <span class="kw">|</span> <span class="fu">grep</span> Chrome</span></code></pre>
        </div>
        <p>や、F#の前方合成演算子<code>&gt;&gt;</code>などの記法ならお馴染みだろう。どちらも左から右の向きだ。ところが、数学やHaskellの関数は右から左に合成する。<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>∘</mo>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">g \circ f</annotation>
            </semantics>
          </math>を
          “g after f” と読めば理解しやすくなる。</p>
        <p>もっとはっきりさせるために、C言語のコードを少々書こう。型<code>A</code>の引数を取って型<code>B</code>を返す関数<code>f</code>:</p>
        <div class="sourceCode" id="cb2">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>B f<span class="op">(</span>A a<span class="op">);</span></span></code></pre>
        </div>
        <p>と、別の関数:</p>
        <div class="sourceCode" id="cb3">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>C g<span class="op">(</span>B b<span class="op">);</span></span></code></pre>
        </div>
        <p>の合成は次のとおりだ:</p>
        <div class="sourceCode" id="cb4">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>C <span class="va">g_after_f</span><span class="op">(</span>A a<span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> g<span class="op">(</span>f<span class="op">(</span>a<span class="op">));</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>ここで再び、右から左への合成<code>g(f(a))</code>が、今回はC言語で現れた。</p>
        <p>C++の標準ライブラリには2つの関数を取って合成関数を返すテンプレートがある、と言えたら良かったのだが、そんなものはない。そこで、Haskellを少し試してみよう。ここにAからBへの関数の宣言がある:</p>
        <div class="sourceCode" id="cb5">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">B</span></span></code></pre>
        </div>
        <p>同様に:</p>
        <div class="sourceCode" id="cb6">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">C</span></span></code></pre>
        </div>
        <p>これらの合成は次のとおりだ:</p>
        <div class="sourceCode" id="cb7">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">.</span> f</span></code></pre>
        </div>
        <p>Haskellの単純さを見ると、C++で素直な関数の概念を表現できないのには少し当惑させられる。実際、Haskellではユニコード文字を使えるので、合成を次のようにも書ける:</p>
        <div class="sourceCode" id="cb8">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>g ∘ f</span></code></pre>
        </div>
        <p>ユニコードの二重コロンと矢印さえ使える<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。</p>
        <div class="sourceCode" id="cb9">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>f ∷ <span class="dt">A</span> → <span class="dt">B</span></span></code></pre>
        </div>
        <p>では、第1回目のHaskellのレッスンをまとめよう。二重コロンは「……の型を持つ」を意味する。関数型は2つの型の間に矢印を挿入することで作成される。2つの関数を合成するには、間にピリオド
          (あるいはユニコードの丸) を置く。</p>
        <aside id="footnotes" class="footnotes footnotes-end-of-section" role="doc-footnote">
          <hr />
          <ol>
            <li id="fn1">
              <p>訳註: ここでの合成演算子はRing Operator
                (U+2218)、二重コロンはProportion (U+2237)、矢印はRightwards Arrow
                (U+2192) を指す。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p>
            </li>
          </ol>
        </aside>
        <h2 data-number="1.2" id="合成の性質"><span class="header-section-number">1.2</span> 合成の性質</h2>
        <p>どんな圏においても合成が満たすべき非常に重要な性質が2つある。</p>
        <ol type="1">
          <li>
            <p>合成は結合的 (associative)
              である。3つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>f</mi>
                  <annotation encoding="application/x-tex">f</annotation>
                </semantics>
              </math>,
              <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>g</mi>
                  <annotation encoding="application/x-tex">g</annotation>
                </semantics>
              </math>,
              <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>h</mi>
                  <annotation encoding="application/x-tex">h</annotation>
                </semantics>
              </math>があり、それらが合成できる
              (つまり対象がend-to-endに一致している)
              なら、合成するときに括弧は要らない。数学の記法では次のように表される:
              <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mrow>
                    <mi>h</mi>
                    <mo>∘</mo>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>g</mi>
                      <mo>∘</mo>
                      <mi>f</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                    <mo>=</mo>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>h</mi>
                      <mo>∘</mo>
                      <mi>g</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                    <mo>∘</mo>
                    <mi>f</mi>
                    <mo>=</mo>
                    <mi>h</mi>
                    <mo>∘</mo>
                    <mi>g</mi>
                    <mo>∘</mo>
                    <mi>f</mi>
                  </mrow>
                  <annotation encoding="application/x-tex">h \circ (g \circ f) = (h \circ g) \circ f = h \circ g \circ f
                  </annotation>
                </semantics>
              </math>
              (擬似的な) Haskellでは次のように書ける:
            </p>
            <div class="sourceCode" id="cb10">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">B</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">C</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">h ::</span> <span class="dt">C</span> <span class="ot">-&gt;</span> <span class="dt">D</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>h <span class="op">.</span> (g <span class="op">.</span> f) <span class="op">==</span> (h <span class="op">.</span> g) <span class="op">.</span> f <span class="op">==</span> h <span class="op">.</span> g <span class="op">.</span> f</span></code></pre>
            </div>
            <p>(ここで「擬似的」と呼んだのは、関数に等価性が定義されていないからだ。)</p>
            <p>関数を扱うときは結合性は自明だが、その他の圏では自明ではないこともある。</p>
          </li>
          <li>
            <p>どんな対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>A</mi>
                  <annotation encoding="application/x-tex">A</annotation>
                </semantics>
              </math>にも、合成の単位
              (unit)
              となる矢が1つずつ存在する。その矢は対象から対象自身へとループを描く。合成の単位となる、というのは、<math display="inline"
                xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>A</mi>
                  <annotation encoding="application/x-tex">A</annotation>
                </semantics>
              </math>から始まるどんな矢と合成しても、あるいは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>A</mi>
                  <annotation encoding="application/x-tex">A</annotation>
                </semantics>
              </math>で終わるどんな矢と合成しても、元と同じ矢に戻るという意味だ。対象Aに対する単位となる矢は<math display="inline"
                xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <msub>
                    <mrow>
                      <mi>𝐢</mi>
                      <mi>𝐝</mi>
                    </mrow>
                    <mi>A</mi>
                  </msub>
                  <annotation encoding="application/x-tex">%
                    \mathbf{id}_{A}%
                  </annotation>
                </semantics>
              </math>
              (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>A</mi>
                  <annotation encoding="application/x-tex">A</annotation>
                </semantics>
              </math>上の<span id="identity" class="keyword">恒等射</span>、identity)
              と呼ばれる。数学の表記法では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>f</mi>
                  <annotation encoding="application/x-tex">f</annotation>
                </semantics>
              </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>A</mi>
                  <annotation encoding="application/x-tex">A</annotation>
                </semantics>
              </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>B</mi>
                  <annotation encoding="application/x-tex">B</annotation>
                </semantics>
              </math>へ向かうなら</p>
            <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mrow>
                    <mi>f</mi>
                    <mo>∘</mo>
                    <msub>
                      <mrow>
                        <mi>𝐢</mi>
                        <mi>𝐝</mi>
                      </mrow>
                      <mi>A</mi>
                    </msub>
                    <mo>=</mo>
                    <mi>f</mi>
                  </mrow>
                  <annotation encoding="application/x-tex">f \circ %
                    \mathbf{id}_{A}%
                    = f</annotation>
                </semantics>
              </math></p>
            <p>かつ</p>
            <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mrow>
                    <msub>
                      <mrow>
                        <mi>𝐢</mi>
                        <mi>𝐝</mi>
                      </mrow>
                      <mi>B</mi>
                    </msub>
                    <mo>∘</mo>
                    <mi>f</mi>
                    <mo>=</mo>
                    <mi>f</mi>
                  </mrow>
                  <annotation encoding="application/x-tex">%
                    \mathbf{id}_{B}%
                    \circ f = f</annotation>
                </semantics>
              </math></p>
          </li>
        </ol>
        <p>関数を扱うとき、恒等射は引数をそのまま返す恒等関数として実装される。この実装はどの型でも同じであり、この関数は普遍的に多相
          (universally polymorphic)
          であることを意味する。これはC++ではテンプレートとして定義できる:</p>
        <div class="sourceCode" id="cb11">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> T id<span class="op">(</span>T x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">;</span> <span class="op">}</span></span></code></pre>
        </div>
        <p>もちろん、C++ではそれほど単純ではない。何を渡すかだけでなく、どのように渡すか
          (つまり、値によって、参照によって、const参照によって、ムーブによって、など)
          も考慮する必要があるからだ。</p>
        <p>Haskellの恒等関数は、(Preludeと呼ばれる)
          標準ライブラリの一部だ。宣言と定義は以下のとおりだ:</p>
        <div class="sourceCode" id="cb12">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre>
        </div>
        <p>ご覧のとおり、Haskellの多相関数はごく簡単だ。宣言に使う型を型変数に置き換えるだけでよい。トリックは次のとおりだ:
          具体的な型の名前は常に大文字で始まり、型変数の名前は小文字で始まる。ここで<code>a</code>はすべての型を表している。</p>
        <p>Haskellの関数定義は、関数の名前とそれに続く形式パラメーター
          (ここでは<code>x</code>)
          で構成される。関数の本体は等号の後に続く。この簡潔さは、多くの初心者には衝撃的だが、すぐに完全に理にかなっていることが分かるだろう。関数定義と関数呼び出しは関数型プログラミングの必需品なので、構文は最小限に抑えられている。引数リストを括弧で囲まないだけでなく、引数間のカンマさえない
          (これについては後ほど複数の引数の関数を定義するときに説明する)。</p>
        <p>関数の本体は常に式であり、関数内に宣言はない。関数の結果はその式だ――ここでは単に<code>x</code>だ。</p>
        <p>これでHaskellのレッスンの第2回は終了だ。</p>
        <p>恒等条件は、(再び疑似Haskellで) 次のように書ける。</p>
        <div class="sourceCode" id="cb13">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">.</span> <span class="fu">id</span> <span class="op">==</span> f</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> <span class="op">.</span> f <span class="op">==</span> f</span></code></pre>
        </div>
        <p>誰が恒等関数――何もしない関数――をわざわざ使うのか、と疑問に思うかもしれない。では、なぜ0という数をわざわざ使うのだろうか？
          0は無の象徴だ。古代ローマ人は0のない数値体系を使っていたが、優れた道路や水路を建設することができ、その一部は今日まで残っている。</p>
        <p>0や<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐢</mi>
                <mi>𝐝</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{id}</annotation>
            </semantics>
          </math>のような中立の値は、記号変数を扱うときに非常に便利だ。これこそが、ローマ人は代数があまり得意ではなく、0の概念に精通していたアラビア人やペルシア人は得意だった理由だ。そのため、恒等関数は、高階関数
          (higher-order function)
          の引数として、あるいは高階関数からの戻り値として非常に便利になる。高階関数は、関数の記号操作を可能にする。それらは関数の代数だ。</p>
        <p>要約すると、圏は対象と矢 (射)
          で構成されている。矢は合成でき、その合成は結合性を持つ。すべての対象には、合成の単位として機能する恒等射がある。</p>
        <h2 data-number="1.3" id="合成はプログラミングの本質"><span class="header-section-number">1.3</span> 合成はプログラミングの本質</h2>
        <p>
          関数型プログラマーは、問題に独特の方法でアプローチする。彼らはまるで禅のような問いから始める。たとえば、対話型プログラムを設計するときは「対話とは何か？」と問うだろう。コンウェイのライフゲームを実行するときには、生命の意味について思索するだろう。そのような精神で「プログラミングとは何か？」と問いかけたい。最も基本的なレベルでは、プログラミングとはコンピューターに何をすべきかを指示することだ。「メモリアドレスxの内容を取り、レジスタEAXの内容に加えよ」のように。しかし、アセンブリでプログラムを作成する場合でも、コンピューターに与える指示は、もっと意味のあるものを表現している。解こうとしているの自明な問題ではないのだ
          (自明ならコンピューターの助けは不要だろう)。どうすれば問題を解けるだろうか？
          大きな問題を小さな問題に分解すればよい。小さくした問題がまだ大きすぎる場合は、それらをさらに分解する。最後に、小さな問題すべてについて、解決するコードを書く。そうしてプログラミングの本質が現れる。すなわち、それらのコードを合成し、より大きな問題に対する解決策を創造する。分解は、断片をもとの状態に戻すことができなければ意味がない。
        </p>
        <p>この階層的な分解と再合成のプロセスはコンピューターによって強制されているわけではない。それは人間の精神の限界を反映している。脳は一度に少しの概念しか扱えない。心理学で最も引用された論文の1つ、<a
            href="https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two">マジカルナンバー
            7プラスマイナス2</a>は、我々は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>7</mn>
                <mo>±</mo>
                <mn>2</mn>
              </mrow>
              <annotation encoding="application/x-tex">7 \pm 2</annotation>
            </semantics>
          </math>の「チャンク」の情報しか保持できないと仮定した。人間の短期記憶に関する我々の理解の詳細は変化しているかもしれないが、確かに限られていることはわかっている。要するに、我々はオブジェクトのスープやコードのスパゲッティを扱うことができないということだ。構造が必要なのは、よく構造化されたプログラムが見やすいからではなく、そうでなければ脳が効率的に処理できないからだ。コードの一部をエレガントあるいは美しいと表現することがよくあるが、本当に意味しているのは、人間の限界ある精神で処理するのが簡単だということだ。エレガントなコードは、ちょうど適切なサイズのチャンクを作成し、精神的消化器系がそれらを同化するのにちょうど適切な数のチャンクを生成する。
        </p>
        <p>
          では、プログラムの合成にとって適切なチャンクとは何だろうか。表面積は体積よりも必ずゆっくりと増加する。(私がこのたとえを気に入ったのは、幾何学的な対象の表面積はその大きさの二乗に比例して成長する――容積よりも遅く、容積はその大きさの三乗に比例して成長するという直観による)。表面積は、チャンクを構成するために必要な情報だ。体積は、それらを実装するために必要な情報だ。つまり、チャンクが実装されると、その実装の詳細を忘れて、他のチャンクとの相互作用に集中できるようになる。オブジェクト指向プログラミングでは、表面積は対象のクラス宣言、またはその抽象インターフェースだ。関数型プログラミングでは、これは関数の宣言だ。(ここでは少し単純化しているが、要点はこれだ。)
        </p>
        <p>
          圏論は、対象の中を見ることを積極的に思いとどまらせるという意味で極端だ。圏論における対象は、抽象的で漠然とした存在だ。対象について知り得るのは、他の対象たちとどのように関連しているか、つまり、どのように矢で接続しているかだけだ。これは、インターネット検索エンジンが流入リンクと流出リンクを分析してウェブサイトを順位付けする方法だ
          (不正行為がある場合は除く)。オブジェクト指向プログラミングでは、理想化された対象は、その抽象インターフェース
          (純粋な表面で、体積なし)
          を通してのみ見ることができ、メソッドが矢の役目を果たす。他のオブジェクトと合成する方法を理解するためにオブジェクトの実装を掘り下げなければならなくなった瞬間、このプログラミング・パラダイムの利点は失われてしまう。</p>
        <h2 data-number="1.4" id="課題"><span class="header-section-number">1.4</span> 課題</h2>
        <ol type="1">
          <li>
            <p>恒等関数を、好きな言語で
              (それがたまたまHaskellなら、2番目に好きな言語で)
              できるだけうまく実装せよ。</p>
          </li>
          <li>
            <p>合成関数を任意の言語で実装せよ。このメソッドは2つの関数を引数として受け取り、その合成である関数を返す。</p>
          </li>
          <li>
            <p>合成関数が恒等関数に対応しているかテストするプログラムを作成せよ。</p>
          </li>
          <li>
            <p>ワールドワイドウェブは、何らかの意味で圏だろうか？
              リンクは射だろうか？</p>
          </li>
          <li>
            <p>Facebookは人を対象とし友達関係を射とする圏だろうか？</p>
          </li>
          <li>
            <p>有向グラフが圏になるのはどのような場合だろうか？</p>
          </li>
        </ol>
        <h1 data-number="2" id="types-and-functions"><span class="header-section-number">2</span> 型と関数</h1>
        <p>型と関数の圏はプログラミングにおいて重要な役目を果たす。そこで、型とは何か、なぜ型が必要なのかについて説明しよう。</p>
        <h2 data-number="2.1" id="型を必要とするのは誰か"><span class="header-section-number">2.1</span> 型を必要とするのは誰か？</h2>
        <p>
          静的型付けと動的型付け、および強い型付けと弱い型付けの利点については、議論があるようだ。これらの選択肢を思考実験で説明しよう。コンピューターのキーボードを操作する何百万匹もの猿が、喜んでキーをランダムにたたき、プログラムを作成したり、コンパイルしたり、実行したりする様子を想像してみてほしい。
        </p>
        <p><img src="images/img_1329.jpg" style="width:30.0%" /></p>
        <p>
          機械語では、猿が生成するバイトの組み合わせはどれでも受け入れられて実行される。しかし、より高級な言語では、コンパイラが語彙や文法上の誤りを検出できるという事実を我々は理解している。多くの猿はバナナなしで去るだろうが、残されたプログラムは役に立つ可能性が高いだろう。型チェックも、無意味なプログラムに対するもう1つの防御壁となる。さらに、型の不一致は、動的型付け言語では実行時に発見されるのに対し、強く型付けされ静的にチェックされる言語ではコンパイル時に発見されるので、多くの不正なプログラムが実行される前に排除される。
        </p>
        <p>そこで、問題は次のようになる。猿を幸せにしたいのか、それとも正しいプログラムを作りたいのか？</p>
        <p>
          タイピング猿の思考実験における通常の目標はシェークスピア全集を作ることだ。スペルチェッカーと文法チェッカーをループに含めれば、勝算は大幅に上昇するだろう。型チェッカーに類するものを含めれば、さらなる前進が見込める。ロミオは人間である、と宣言されていれば、この主人公は決して葉を発芽したり、自身の強力な重力場に光子を閉じ込めたりはしない。
        </p>
        <h2 data-number="2.2" id="型は合成に関する"><span class="header-section-number">2.2</span> 型は合成に関する</h2>
        <p>圏論は矢を合成することに関する。しかし、2本の矢なら何でも合成できるわけではない。ある矢の終域
          (target) となる対象は、次の矢の始域 (source)
          となる対象と同じでなくてはならない。プログラミングでは、ある関数の結果を別の関数に渡す。後段の関数が前段の関数によって生成されたデータを正しく解釈できない場合、プログラムは機能しない。合成が機能するためには両端が適合しなければならない。言語の型システムが強力であればあるほど、この一致はよりよく記述され、機械的に検証される。
        </p>
        <p>
          強力な静的型チェックに対して私が耳にする唯一の重大な反対意見は、意味的に正しいプログラムを排除する可能性がある、というものだ。実際には、これが起こることは極めてまれであり、いずれにしても、どの言語にも、本当に必要な場合に型システムを迂回するための何らかのバックドアが用意されている。Haskellにさえ<code>unsafeCoerce</code>がある。しかし、このような装備は慎重に使うべきだ。フランツ・カフカの小説の主人公グレゴール・ザムザが、巨大なバグに変身したときに型システムを破壊し、どんな結末を迎えたかは誰もが知っている。
        </p>
        <p>私がよく耳にするもう1つの意見は、型を扱うのはプログラマーにとって負担が大きすぎる、というものだ。私もC++でイテレータの宣言をいくつか自分で書かなければならなかったら共感するだろう。もっとも、<span
            id="type_inference" class="keyword">型推論</span> (type inference)
          と呼ばれる技術があり、コンパイラはほとんどの型を文脈から推論できるようになっている。C++では、変数を<code>auto</code>で宣言してコンパイラにその型を認識させられるようになった。</p>
        <p>
          Haskellでは、稀な場合を除いて、型アノテーションは純粋にオプションだ。プログラマーはいずれにしても型アノテーションを使う傾向がある。なぜなら、コードのセマンティクスについて多くを伝えられ、コンパイル・エラーを理解しやすくできるからだ。Haskellでは、型を設計することからプロジェクトを始めるのが一般的な慣習だ。後々、型アノテーションは実装を駆動し、コンパイラによって強制されるコメントになる。
        </p>
        <p>
          強力な静的型付けはコードをテストしない言い訳としてよく使われる。Haskellのプログラマーが「コンパイルが通るなら正しいはずだ」と言っているのを耳にすることがあるだろう。しかし、型が正しいプログラムなら正しい出力を生成する、などという保証は当然ない。そのような無頓着な態度の結果、いくつかの研究では、Haskellは予想されるほど群を抜いてコード品質が高くはなかった。商用の環境では、バグを修正する圧力は特定の品質レベルまでしか働かないようだ。そのレベルは、ソフトウェア開発の経済性とエンドユーザーの許容度に深く関係し、プログラミング言語や方法論にはほとんど関係しない。より良い基準は、スケジュールより遅れているプロジェクトや、大幅に機能が削減されたプロジェクトの数を測定することだろう。
        </p>
        <p>
          単体テストによって強い型付けを置き換えられる、という意見に関しては、強い型付けの言語で一般的に行われているリファクタリング手法である、関数の引数の型の変更について考えてみてほしい。強い型付けの言語では、その関数の宣言を変更してから、すべてのビルド・ブレークを修正すれば十分だ。弱い型付けの言語では、関数が異なるデータを要求するようになったという事実は呼び出し側に伝わらない。単体テストはミスマッチのいくつかを捉えるかもしれないが、テストはほとんどの場合、確率論的なプロセスにすぎず、決定論的なプロセスではない。テストは証明の代わりにはならないのだ。
        </p>
        <h2 data-number="2.3" id="型とは何か"><span class="header-section-number">2.3</span> 型とは何か？</h2>
        <p>型とは、最も単純な直観としては、値の集合だ。型<code>Bool</code>は<code>True</code>と<code>False</code>の2要素集合だ
          (Haskellでは具体的な型は大文字で始まることを思い出してほしい)。<code>Char</code>型はaやąのようなユニコード文字すべての集合だ。</p>
        <p>集合は有限集合でも無限集合でもよい。<code>String</code>は、<code>Char</code>のリストの同義語で、その型は無限集合の例だ。</p>
        <p><code>x</code>を<code>Integer</code>として宣言しよう:</p>
        <div class="sourceCode" id="cb14">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">x ::</span> <span class="dt">Integer</span></span></code></pre>
        </div>
        <p>
          これは、整数集合の要素だと言っていることになる。Haskellの<code>Integer</code>は無限集合であり、任意の精度の演算に使える。また、C++の<code>int</code>と同様の、機械語の型に対応する有限集合<code>int</code>もある。
        </p>
        <p>
          いくつか微妙な点があるせいで、型と集合の区別は厄介なものになっている。循環定義を含む多相関数には問題があり、すべての集合の集合は存在できないという事実にも問題がある。だが、約束したとおり、私は数学にこだわるつもりはない。ありがたいことに、集合の圏が存在する。<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>と呼ばれるその圏をここでは扱う。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>では、対象は集合であり、射
          (矢) は関数だ。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>は非常に特別な圏だ。対象の内部を実際に見られ、そうすることで多くの直観が得られるからだ。たとえば、空集合には要素がないことがわかる。特別な1要素集合があることが分かっている。関数がある集合の要素を別の集合の要素に写すのも分かっていいる。関数は、2つの要素を1つに写すことはできるが、1つの要素を2つに写すことはできない。恒等関数が集合の各要素を自身に写すことなども分かっている。予定としては、これらすべての情報を徐々に忘れ、すべての概念を純粋に圏論の用語、つまり対象と矢によって表していく。
        </p>
        <p>
          理想的な世界では、Haskellの型は集合であり、Haskellの関数は集合間の数学的関数であると言えば済んだだろう。だが、1つだけ小さな問題がある。数学関数はコードを実行せず、単に解を知っているだけなのだ。Haskellの関数は解を計算する必要がある。有限のステップ数で解が得られるなら、何ステップかかっても問題はない。ところが、計算のなかには再帰を伴うものもあり、ずっと停止しないことがあり得る。Haskellから非停止関数
          (non-terminating function)
          を単に追放することはできない。なぜなら、停止関数と非停止関数の区別は決定できないからだ。これは停止性問題
          (halting problem)
          として有名だ。そのため計算機科学者たちは素晴らしいアイデアを考案した。それは捉え方によっては大きなハッキングとも言えるだろう。そのアイデアとは、<span id="bottom"
            class="keyword">ボトム</span> (bottom)
          と呼ばれる、記号<code>_|_</code>またはユニコードの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>⊥</mi>
              <annotation encoding="application/x-tex">\bot</annotation>
            </semantics>
          </math>で<a href="#fn2" class="footnote-ref" id="fnref2"
            role="doc-noteref"><sup>2</sup></a>表される特別な値を用いてすべての型を拡張する、というものだ。この「値」は非停止計算に対応する。したがって、次のように宣言される関数:</p>
        <div class="sourceCode" id="cb15">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre>
        </div>
        <p>は<code>True</code>か<code>False</code>か<code>_|_</code>を返し、最後の場合は決して停止しないことを意味する。</p>
        <p>
          興味深いことに、ひとたび型システムの一部としてボトムを受け入れたなら、すべての実行時エラーをボトムとして扱い、さらには関数からボトムを明示的に返せるようにするのが便利だ。後者は通常、<code>undefined</code>という式を使って行われる:
        </p>
        <div class="sourceCode" id="cb16">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre>
        </div>
        <p>この定義が型検査を通るのは、<code>undefined</code>が評価されるとボトムになるからだ。ボトムは<code>Bool</code>も含むすべての型のメンバーだ。さらに:</p>
        <div class="sourceCode" id="cb17">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre>
        </div>
        <p>のように (<code>x</code>なしで)
          書くことさえできる。ボトムが<code>Bool-&gt;Bool</code>型のメンバーでもあるためだ。</p>
        <p>ボトムを返す可能性のある関数は、取りうるすべての引数に対して有効な結果を返す全域関数
          (total function) ではなく、部分関数 (partial function) と呼ばれる。</p>
        <p>ボトムがあるため、Haskellの型と関数の圏は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>ではなく<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐇</mi>
                <mi>𝐚</mi>
                <mi>𝐬</mi>
                <mi>𝐤</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Hask}</annotation>
            </semantics>
          </math>と呼ばれる。理論的な観点から見ると、これは果てしない複雑さの原因となる。だから、この時点で一連の推論を肉切り包丁で捌いて終わらせよう。実用的な観点からは、停止しない関数とボトムを無視し、<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐇</mi>
                <mi>𝐚</mi>
                <mi>𝐬</mi>
                <mi>𝐤</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Hask}</annotation>
            </semantics>
          </math>を真正な<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>として扱うことは問題ない。</p>
        <aside id="footnotes" class="footnotes footnotes-end-of-section" role="doc-footnote">
          <hr />
          <ol start="2">
            <li id="fn2">
              <p>訳註: Up Tack (U+22A5) を指す。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p>
            </li>
          </ol>
        </aside>
        <h2 data-number="2.4" id="なぜ数学モデルが必要なのか"><span class="header-section-number">2.4</span>
          なぜ数学モデルが必要なのか？</h2>
        <p>
          プログラマーであるあなたは、プログラミング言語の構文と文法に精通している。言語のこれらの側面は、通常、言語仕様の冒頭で形式的な表記法で記述される。一方で、言語の意味、つまりセマンティクスを記述するのははるかに困難だ。より多くのページを必要とし、十分に形式化されていることはほとんどなく、完全であることもほとんどない。それゆえ、言語法律家たちの間では終わりのない議論が交わされ、言語標準の細かい解釈を目的とした書籍が家内工業的に出版されている。
        </p>
        <p>言語のセマンティクスを記述するための形式手法ツールは存在するが、複雑なため、ほとんどの場合は簡略化された学術言語で使われ、実用される巨大なプログラミング言語ではあまり使われない。そのようなツールのうち<span
            id="operational_semantics" class="keyword">操作的意味論</span>
          (operational semantics)
          と呼ばれるものは、プログラム実行の仕組みを記述する。それは形式化され理想化されたインタプリタを定義する。C++のような産業用言語の意味論は、通常、非形式的な操作上の推論を用いて説明され、「抽象機械」の観点から説明されることが多い。
        </p>
        <p>問題は、操作的意味論を使ってプログラムに関することを証明するのが非常に難しいことだ。プログラムの特性を表示するためには、基本的には理想化されたインタプリタを通して「実行」しなければならない。</p>
        <p>
          プログラマーが正確さを形式的に証明しないことは問題ではない。我々はいつも正しいプログラムを書いていると「思っている」。キーボードの前に座って、「さて、コードを数行打ち込んで、何が起こるか見てみよう」と言う人はいない。我々は、作成するコードが望ましい結果を生み出す特定のアクションを実行すると考えている。そうでない場合、たいていかなり驚くことになる。つまり、我々は自分が書いたプログラムについて理性を持っており、通常は頭の中でインタプリタを走らせることによってそれを行っている。すべての変数を追跡するのは非常に困難だ。コンピューターはプログラムを実行するのが得意だ――だが人間は不得意だ！
          もし得意だったら、コンピューターは必要ないだろう。</p>
        <p>しかし、別の選択肢もある。それは<span id="denotational_semantics" class="keyword">表示的意味論</span> (denotational semantics)
          と呼ばれ、数学に基づいている。表示的意味論では、すべてのプログラミング構成体に数学的解釈が与えられる。それを使えば、プログラムの特性を証明したいときは数学的定理を証明するだけでよい。定理を証明するのは難しいと思うかもしれないが、実際には、人類は数千年にわたって数学的手法を構築してきたので、利用できる知識が豊富に蓄積されている。また、プロの数学者が証明する定理と比べると、プログラミングで遭遇する問題は、自明ではないにせよ、通常は極めて単純なものだ。
        </p>
        <p>表示的意味論に従う言語であるHaskellで階乗関数の定義を考えてみよう:</p>
        <div class="sourceCode" id="cb18">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>fact n <span class="ot">=</span> <span class="fu">product</span> [<span class="dv">1</span><span class="op">..</span>n]</span></code></pre>
        </div>
        <p>
          式<code>[1..n]</code>は、<code>1</code>から<code>n</code>までの整数のリストだ。関数<code>product</code>は、リストのすべての要素を乗算する。これは数学のテキストから得られる階乗の定義と同じだ。これをCと比較してほしい。
        </p>
        <div class="sourceCode" id="cb19">
          <pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fact<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>        result <span class="op">*=</span> i<span class="op">;</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>もっと言う必要があるだろうか？</p>
        <p>確かに、不当な批判だったのは真っ先に認めよう！
          そもそも階乗関数には自明な数学的表記がある。鋭い読者なら「キーボードから文字を読み取ったり、ネットワークを介してパケットを送信したりするための数学的モデルは何か？」と尋ねるだろう。長きに渡って、それはかなり複雑な説明につながる面倒な質問だった。有用なプログラムを書くために不可欠な多くの重要なタスクには、表示的意味論は最適でないように思われたが、操作的意味論では容易に解決できた。突破口は圏論からもたらされた。エウジニオ・モッジ
          (Eugenio Moggi)
          によって、計算作用をモナドに写せることが発見された。これは表示的意味論に新たな生命を与え、純粋関数型プログラムをより使いやすくするだけでなく、従来のプログラミングに新たな光を当てる重要な観察となった。モナドについては後ほど、より圏論的なツールを開発するときに述べる。
        </p>
        <p>
          プログラミングの数学的モデルを持つ重要な利点の1つは、ソフトウェアの正しさを形式的に証明できることだ。消費者向けのソフトウェアを書く際、これはそれほど重要ではないように思えるだろうが、失敗の代償が法外なものになったり、人命が危険にさらされたりするようなプログラミングの領域もある。もっとも、医療システム用のWebアプリケーションを作成する場合であっても、Haskell標準ライブラリの関数やアルゴリズムが正しさを証明済みであるという考えの価値を認めることになるだろう。
        </p>
        <h2 data-number="2.5" id="純粋関数と非純粋関数"><span class="header-section-number">2.5</span> 純粋関数と非純粋関数</h2>
        <p>C++やその他の命令型言語で関数と呼ぶものは、数学者が関数と呼ぶものとは異なる。数学関数は値から値への写像にすぎない。</p>
        <p>
          数学関数はプログラミング言語で実装できる。そのような関数は、入力値が与えられると、出力値を計算する。数の2乗を生成する関数は、おそらく入力値をそれ自身で乗算する。これは呼び出されるたびに行われ、同じ入力で呼び出されるたびに同じ出力を生成することが保証されている。数の2乗は月の満ち欠けによって変化しない。
        </p>
        <p>また、数の2乗を計算することで犬においしい餌を出すという副作用があってはならない。それを行う「関数」は数学関数として簡単にモデル化できない。</p>
        <p>プログラミング言語では、同じ入力に対して常に同じ結果を生成し、副作用のない関数は<span id="pure_function" class="keyword">純粋関数</span> (pure function)
          と呼ばれる。Haskellのような純粋関数型言語では、すべての関数は純粋だ。そのため、これらの言語に表示的意味論を与え、圏論でモデル化することが容易になる。他の言語の場合と同様に、純粋なサブセットだけを使うように制約したり、副作用に関する理由を別にしたりすることは常に可能だ。モナドによって、純粋関数のみを使ってあらゆる種類の作用をモデル化する方法については、後ほど説明する。数学的関数だけという制約を課しても何も失われないのだ。
        </p>
        <h2 data-number="2.6" id="型の例"><span class="header-section-number">2.6</span> 型の例</h2>
        <p>型が集合であることを理解すれば、ややエキゾチックな型を考えられる。たとえば、空集合に対応するのはどんな型だろう？
          それは決してC++の<code>void</code>ではないが、その型はHaskellで<code>Void</code>と呼ばれている。値が存在しない型だ。<code>Void</code>を取る関数は、定義はできるが、呼び出せない。呼び出すには<code>Void</code>型の値を提供する必要があるが、それは存在しないからだ。この関数が返す内容に関しては、何ら制限はない。それは任意の型を返せる
          (ただし、呼び出せないため、返すことはない)。言い換えると、戻り値の型が多相な関数だ。Haskell使いたちはこう呼ぶ:</p>
        <div class="sourceCode" id="cb20">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">absurd ::</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <p>(<code>a</code>は任意の型を表せる型変数なのを覚えておいてほしい。)
          この名前は偶然ではない。Curry-Howard同型と呼ばれる論理の観点から、型と関数についてのより深い解釈が存在する。型<code>Void</code>は虚偽を表し、関数<code>absurd</code>の型は「虚偽からは何でも導ける」というラテン語の格言
          “ex falso sequitur quodlibet” に対応している。</p>
        <p>次は、単集合に対応する型だ。これが持てる値は1つしかない。その値は単に
          “is”
          だ。すぐにはわからないかもしれないが、これがC++の<code>void</code>だ。この型を引数に取る関数と、この型を返す関数を考えてみてほしい。<code>void</code>を取る関数は常に呼び出せる。それが純粋関数なら、常に同じ結果を返す。そのような関数の例を示そう:
        </p>
        <div class="sourceCode" id="cb21">
          <pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> f44<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">44</span><span class="op">;</span> <span class="op">}</span></span></code></pre>
        </div>
        <p>この関数は “nothing”
          を取ると思うかもしれないが、先ほど見たように、“nothing”
          を取る関数は決して呼び出されない。なぜなら、“nothing”
          を表す値がないからだ。この関数は何を取るのだろうか？
          概念的には、インスタンスが1つしか存在しないダミー値を取るため、明示的に言及する必要はない。しかしHaskellでは、この値を表す記号として、空の括弧のペア<code>()</code>がある。そのため、奇妙な偶然
          (これは偶然なのか？)
          によって、void関数の呼び出しはC++とHaskellで同じように見える。また、Haskellは簡潔さを好むので、同じシンボル<code>()</code>が型、コンストラクター、そして単集合に対応する唯一の値に使われる。この関数をHaskellで書くとこうなる:
        </p>
        <div class="sourceCode" id="cb22">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f44 ::</span> () <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>f44 () <span class="ot">=</span> <span class="dv">44</span></span></code></pre>
        </div>
        <p>最初の行は、<code>f44</code>が “unit”
          と発音される型<code>()</code>を型<code>Integer</code>に取り込むことを宣言している。2番目の行は<code>f44</code>を定義するためにunitの唯一のコンストラクター<code>()</code>に対してパターンマッチングを行い、44という番号を生成する。この関数を呼び出すにはunitの値<code>()</code>を指定する。
        </p>
        <div class="sourceCode" id="cb23">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>f44 ()</span></code></pre>
        </div>
        <p>unitのどの関数も、目的語の型から1つの要素を選択するのと等価であることに注意してほしい
          (ここでは<code>Integer</code>
          44を選択する)。実際、<code>f44</code>は番号44の別の表現と考えられる。これは、集合の要素を明示的に指定する代わりに、関数
          (矢)
          について説明する方法の例だ。unitから任意の型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>A</mi>
              <annotation encoding="application/x-tex">A</annotation>
            </semantics>
          </math>への関数は、その集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>A</mi>
              <annotation encoding="application/x-tex">A</annotation>
            </semantics>
          </math>の要素と1対1で対応している。</p>
        <p><code>void</code>型を返す関数や、Haskellでunit型を返す関数はどうだろうか？
          C++ではそのような関数が副作用を目的として使われるが、数学的な意味では実際には関数ではないのを我々は知っている。unitを返す純粋関数は何もせず、引数を破棄する。</p>
        <p>数学的には、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>A</mi>
              <annotation encoding="application/x-tex">A</annotation>
            </semantics>
          </math>から単集合への関数は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>A</mi>
              <annotation encoding="application/x-tex">A</annotation>
            </semantics>
          </math>のすべての要素をその単集合の単一の要素に写す。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>A</mi>
              <annotation encoding="application/x-tex">A</annotation>
            </semantics>
          </math>ごとに、そのような関数が1つだけ存在する。<code>Integer</code>に対するこの関数は次のとおりだ:</p>
        <div class="sourceCode" id="cb24">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fInt ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> ()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>fInt x <span class="ot">=</span> ()</span></code></pre>
        </div>
        <p>任意の整数を指定すると、unitが返される。簡潔さの精神で、Haskellでは、破棄する引数をワイルドカード・パターンであるアンダースコアで示せる。この方法なら名前を付ける必要はない。つまり上記は次のように書き直せる:
        </p>
        <div class="sourceCode" id="cb25">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fInt ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> ()</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>fInt _ <span class="ot">=</span> ()</span></code></pre>
        </div>
        <p>この関数の実装は、渡された値に依存しないだけでなく、引数の型にも依存しないことに注目してほしい。</p>
        <p>どの型に対しても同じ式で実装できる関数は、パラメトリック多相関数
          (parametrically polymorphic function)
          と呼ばれる。そのような関数の族はすべて、具体的な型の代わりに型パラメーターを使う1つの方程式によって実装できる。任意の型からunit型への多相関数を何と呼ぶべきだろう？
          もちろん<code>unit</code>と呼ぶ:</p>
        <div class="sourceCode" id="cb26">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unit ::</span> a <span class="ot">-&gt;</span> ()</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>unit _ <span class="ot">=</span> ()</span></code></pre>
        </div>
        <p>C++では、この関数を次のように記述する:</p>
        <div class="sourceCode" id="cb27">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> unit<span class="op">(</span>T<span class="op">)</span> <span class="op">{}</span></span></code></pre>
        </div>
        <p>
          型の類型における次のものは2要素集合だ。C++では<code>bool</code>と呼ばれ、Haskellでは予想どおり<code>Bool</code>と呼ばれる。違いは、C++の<code>bool</code>は組み込みの型であるのに対して、Haskellでは次のように定義できることだ:
        </p>
        <div class="sourceCode" id="cb28">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bool</span> <span class="ot">=</span> <span class="dt">True</span> <span class="op">|</span> <span class="dt">False</span></span></code></pre>
        </div>
        <p>(この定義の読み方は<code>Bool</code> is <code>True</code> or
          <code>False</code>だ。)
          原理的には、C++でもBoolean型を列挙型として定義できるはずだ:
        </p>
        <div class="sourceCode" id="cb29">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="dt">bool</span> <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">true</span><span class="op">,</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">false</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre>
        </div>
        <p>しかし、C++の<code>enum</code>は密かに整数だ。C++11の
          “<code>{enum class}</code>”
          を代わりに使うこともできたが、その場合は、<code>bool::true</code>や<code>bool::false</code>のように、クラス名で値を修飾する必要がある。言うまでもなく、それを使うすべてのファイルに適切なヘッダを含める必要がある。
        </p>
        <p><code>Bool</code>を取る純粋関数は、終域の型から2つの値を選択するだけだ。1つは<code>True</code>に対応し、もう1つは<code>False</code>に対応する。</p>
        <p><code>Bool</code>を返す関数は<span id="predicate" class="keyword">述語</span> (predicate)
          と呼ばれる。たとえば、Haskellライブラリ<code>Data.Char</code>は、<code>isAlpha</code>や<code>isDigit</code>のような述語でいっぱいだ。C++には<code>isalpha</code>や<code>isdigit</code>などを定義する同様のライブラリがあるが、これらはブール値ではなく<code>int</code>を返す。実際の述語は<code>std::ctype</code>で定義され、<code>ctype::is(alpha, c)</code>、<code>ctype::is(digit, c)</code>などの形式を持っている。
        </p>
        <h2 data-number="2.7" id="課題-1"><span class="header-section-number">2.7</span> 課題</h2>
        <ol type="1">
          <li>
            <p>任意の言語で高階関数 (または関数オブジェクト)
              <code>memoize</code>を定義せよ。この関数は純粋関数<code>f</code>を引数として受け取り、<code>f</code>とほぼ同じ動作をする関数を返す。ただし、もとの関数を引数ごとに1回だけ呼び出し、結果を内部に格納し、その後は同じ引数で呼び出されるたびに格納済みの結果を返す。メモ化
              (memoize)
              された関数ともとの関数は、パフォーマンスを見れば区別できる。たとえば、評価に時間のかかる関数のメモ化を試みること。最初に呼び出したときは結果を待つ必要があるが、同じ引数を使って次の呼び出しを行ったときには、すぐに結果を得られるだろう。
            </p>
          </li>
          <li>
            <p>乱数を生成するために通常使う標準ライブラリ関数をメモ化してみよ。うまくいくか？</p>
          </li>
          <li>
            <p>ほとんどの乱数発生器はシードで初期化できる。シードを受け取り、そのシードで乱数発生器を呼び出し、結果を返す関数を実装せよ。その関数をメモ化せよ。うまくいくか？</p>
          </li>
          <li>
            <p>以下のC++関数のうち、純粋なのはどれか？
              これらをメモ化してみて、何度も呼び出したときに何が起こるかを、メモ化した場合とそうでない場合について観察せよ。</p>
            <ol type="1">
              <li>
                <p>本文中で例示した階乗関数。</p>
              </li>
              <li>
                <div class="sourceCode" id="cb30">
                  <pre
                    class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>   <span class="bu">std::</span>getchar<span class="op">()</span></span></code></pre>
                </div>
              </li>
              <li>
                <div class="sourceCode" id="cb31">
                  <pre
                    class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">bool</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>     <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Hello!&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code></pre>
                </div>
              </li>
              <li>
                <div class="sourceCode" id="cb32">
                  <pre
                    class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>   <span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>   <span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>     <span class="at">static</span> <span class="dt">int</span> y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>     y <span class="op">+=</span> x<span class="op">;</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> y<span class="op">;</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code></pre>
                </div>
              </li>
            </ol>
          </li>
          <li>
            <p><code>Bool</code>を取り<code>Bool</code>を返す関数は何種類あるか？
              それらすべてを実装できるか？</p>
          </li>
          <li>
            <p><code>Void</code>型、<code>()</code> (unit)
              型、<code>Bool</code>型だけを対象とする圏の絵を描け。矢はこれらの型の間のすべての可能な関数に対応している。矢には関数名のラベルを付けよ。</p>
          </li>
        </ol>
        <h2 data-number="2.8" id="参考文献"><span class="header-section-number">2.8</span> 参考文献</h2>
        <ol type="1">
          <li>Nils Anders Danielsson, John Hughes, Patrik Jansson, Jeremy Gibbons,
            <a href="www.cs.ox.ac.uk/jeremy.gibbons/publications/fast+loose.pdf">Fast
              and Loose Reasoning is Morally Correct</a>.
            この論文は、ほとんどの文脈でボトムを無視することの正当性を説明している。
          </li>
        </ol>
        <h1 data-number="3" id="大きい圏から小さい圏まで"><span class="header-section-number">3</span> 大きい圏から小さい圏まで</h1>
        <p>様々な例を調べることで、圏の実際の用途を知ることができる。圏にはさまざまな形やサイズがあり、予期しない場所に現れることがよくある。ごくシンプルなものから始めよう。</p>
        <h2 data-number="3.1" id="対象の不在"><span class="header-section-number">3.1</span> 対象の不在</h2>
        <p>最も簡単な圏は、0個の対象、したがって0個の射を持つものだ。それ自体は非常に哀しい圏だが、他の圏の文脈、たとえば、すべての圏の圏
          (そう、1つ存在する)
          において重要になるだろう。空集合に意味があると思うなら、空の圏が無意味だとは思わないだろう？</p>
        <h2 data-number="3.2" id="シンプルなグラフ"><span class="header-section-number">3.2</span> シンプルなグラフ</h2>
        <p>対象を矢で接続するだけで圏を作成できる。任意の有向グラフから始めて、単に矢を追加するだけで圏になるのは想像できるだろう。最初に、各ノードに恒等射を追加する。次に、一方の終点が他方の始点と一致するような2つの矢
          (つまり、2つの<span id="composable" class="keyword">合成可能な</span>矢)
          に対して、新しい矢を追加して合成として機能させる。新しい矢を追加するたびに、(恒等射を除く)
          他の矢との合成も考慮する必要がある。通常は矢が無限に多くなるが、構わない。</p>
        <p>このプロセスを別の方法で見ると、グラフ内のすべてのノードに対する圏と、射として構成可能なグラフエッジのすべての<span id="chain"
            class="keyword">チェイン</span>を持つ対象を作成していることになる。(恒等射はチェインの長さが0の特殊な場合とも見なせる。)</p>
        <p>このような圏は、与えられたグラフによって生成される<span id="free_category" class="keyword">自由圏</span> (free category)
          と呼ばれる。これは自由構成の例であり、与えられた構成を、その規則
          (ここでは圏の規則)
          を満たすために最小限の数の項目で拡張して完成させるプロセスだ。今後さらに多くの例について見ていく。</p>
        <h2 data-number="3.3" id="順序"><span class="header-section-number">3.3</span> 順序</h2>
        <p>さて、全く別のものを見てみよう！ 射が対象間の等号付き大小関係
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mo>≤</mo>
              <annotation encoding="application/x-tex">\leqslant</annotation>
            </semantics>
          </math>)
          を表すような圏だ。これが本当に圏かどうか調べてみよう。恒等射はあるだろうか？
          すべての対象はそれ自身以下だろうか: 良し！ 合成はあるだろうか？
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant b</annotation>
            </semantics>
          </math>かつ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>b</mi>
                <mo>≤</mo>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">b \leqslant c</annotation>
            </semantics>
          </math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant c</annotation>
            </semantics>
          </math>:
          良し！ 合成は結合性を持つか？ 良し！ このような関係を持つ集合は<span id="preorder" class="keyword">前順序</span> (preorder)
          と呼ばれる。前順序は確かに圏だ。
        </p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant b</annotation>
            </semantics>
          </math>かつ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>b</mi>
                <mo>≤</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">b \leqslant a</annotation>
            </semantics>
          </math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>と等しくなければならないという追加条件を満たす、より強い関係も考えられる。これを<span id="partial_order" class="keyword">半順序</span> (partial
          order)
          と呼ぶ。</p>
        <p>最後に、任意の2つの対象が何らかの方法で互いに関係しているという条件も課せる。これにより、<span id="linear_order" class="keyword">線形順序</span> (linear
          order)
          あるいは<span id="total_order" class="keyword">全順序</span> (total
          order) が得られる。</p>
        <p>これらの順序付けられた集合を圏として特徴づけよう。前順序は、任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>に向かう射が最大1つ存在する圏だ。そのような圏は別名「やせた圏」
          (thin category) と呼ばれる。前順序はやせた圏だ。</p>
        <p>圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>における対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への射の集合は<span id="hom-set" class="keyword">hom集合</span>と呼ばれ、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          と書かれる
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐇</mi>
                    <mi>𝐨</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mi>𝐂</mi>
                </msub>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Hom}_{\mathbf{C}}(a, b)</annotation>
            </semantics>
          </math>
          と書かれることもある)。したがって、前順序のhom集合はどれも空集合か単集合になる。それはhom集合<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          を含む。これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>への射の集合であり、単集合であり、恒等射だけを含み、どの前順序においても存在する。ただし、前順序では循環が起こりうる。半順序では循環は禁止されている。</p>
        <p>ソートのためには、前順序・半順序・全順序を区別できることが非常に重要だ。クイックソート・バブルソート・マージソートなどのソートアルゴリズムは全順序に対してのみ正しく機能する。半順序にはトポロジカルソートが使える。
        </p>
        <h2 data-number="3.4" id="集合としてのモノイド"><span class="header-section-number">3.4</span> 集合としてのモノイド</h2>
        <p>
          モノイドは非常にシンプルにもかかわらず驚くほど強力な概念だ。それは基礎的な計算の背景にある概念であり、加算と乗算は両方ともモノイドを形成する。モノイドはプログラミングの世界では至るところにある。それは、文字列、リスト、畳み込み可能なデータ構造、並行プログラミングの先物、関数型リアクティブプログラミングのイベントなどとして現れる。
        </p>
        <p>伝統的に、モノイドは二項演算を持つ集合として定義される。この操作に必要なのは、結合性を持つことと、それに関して単位のように動作する特別な要素が1つあることだけだ。</p>
        <p>たとえば、0を含む自然数は加算についてモノイドを形成する。結合性は次のことを意味する:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>+</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>+</mo>
                <mi>c</mi>
                <mo>=</mo>
                <mi>a</mi>
                <mo>+</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>+</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">(a + b) + c = a + (b + c)</annotation>
            </semantics>
          </math></p>
        <p>(つまり、数を追加するときに括弧をスキップできる。)</p>
        <p>中立元は0だ。なぜなら:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>0</mn>
                <mo>+</mo>
                <mi>a</mi>
                <mo>=</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">0 + a = a</annotation>
            </semantics>
          </math></p>
        <p>かつ</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>+</mo>
                <mn>0</mn>
                <mo>=</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">a + 0 = a</annotation>
            </semantics>
          </math></p>
        <p>だからだ。第2の方程式は冗長だ。なぜなら、加算は可換
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>+</mo>
                <mi>b</mi>
                <mo>=</mo>
                <mi>b</mi>
                <mo>+</mo>
                <mi>a</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a+b=b+a)</annotation>
            </semantics>
          </math>
          だからだ。ただし、可換性はモノイドの定義の一部ではない。たとえば、文字列連結は可換ではないが、モノイドを形成する。ちなみに、文字列連結の中立元は空文字列であり、文字列を変更せずに文字列の両側に付加できる。
        </p>
        <p>Haskellでは、モノイドに対して型クラスを定義できる。その型は<code>mempty</code>と呼ばれる中立元と<code>mappend</code>と呼ばれる二項演算を持つ。</p>
        <div class="sourceCode" id="cb33">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="kw">where</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    mempty  ::</span> m</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    mappend ::</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m</span></code></pre>
        </div>
        <p>
          2つの引数を持つ関数<code>m -&gt; m -&gt; m</code>の型シグネチャは、最初は奇妙に見えるかもしれないが、カリー化について知った後には完全に理にかなったものに思えるようになるだろう。複数の型を持つシグネチャは、2つの基本的な方法で解釈できる。1つは複数の引数の関数として解釈し、右端の型を戻り値の矢印とする方法、もう1つは1つの引数
          (左端の引数)
          の関数として解釈し、関数を返す方法だ。後者の解釈は、<code>m -&gt; (m -&gt; m)</code>のように括弧
          (矢印が右結合であるため冗長)
          を追加することによって強調できる。この解釈については後で説明する。</p>
        <p>Haskellでは、<code>mempty</code>と<code>mappend</code>のモノイダル特性
          (すなわち、<code>mempty</code>は中立で、<code>mappend</code>は結合性を持つという事実)
          を表現する方法がないことに注意してほしい。それらを満たすことを確認するのは、プログラマーの責任だ。</p>
        <p>
          HaskellのクラスはC++クラスほど侵襲的ではない。新しい型を定義するときは、事前にクラスを指定する必要はない。先延ばしして、与えられた型をあるクラスのインスタンスとして後から宣言してよい。例として、<code>mempty</code>と<code>mappend</code>の実装を提供することで<code>String</code>をモノイドとして宣言しよう
          (実際、これは標準プレリュードで自動的に行われる):</p>
        <div class="sourceCode" id="cb34">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">String</span> <span class="kw">where</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span> <span class="ot">=</span> <span class="st">&quot;&quot;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mappend</span> <span class="ot">=</span> (<span class="op">++</span>)</span></code></pre>
        </div>
        <p>ここで、<code>String</code>は単なる文字のリストなので、リスト連結演算子<code>(++)</code>を再利用した。</p>
        <p>Haskellの構文に関する註:
          中置演算子は括弧で囲めば2つの引数を持つ関数に変換できる。与えられた2つの文字列の間に<code>++</code>を挿入すれば、それらを連結できる:</p>
        <div class="sourceCode" id="cb35">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;Hello &quot;</span> <span class="op">++</span> <span class="st">&quot;world!&quot;</span></span></code></pre>
        </div>
        <p>あるいは、括弧で括られた<code>(++)</code>に2つの引数として渡してもよい:</p>
        <div class="sourceCode" id="cb36">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">++</span>) <span class="st">&quot;Hello &quot;</span> <span class="st">&quot;world!&quot;</span></span></code></pre>
        </div>
        <p>関数への引数がコンマで区切られたり括弧で囲まれたりしていないことに注意してほしい。(これはおそらく、Haskellを学ぶときに慣れるのが一番難しい部分だろう。)</p>
        <p>Haskellでは関数の等価性を次のように表現できることは、強調しておく価値がある:</p>
        <div class="sourceCode" id="cb37">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mappend</span> <span class="ot">=</span> (<span class="op">++</span>)</span></code></pre>
        </div>
        <p>概念的には、これは関数によって生成される値の等価性を次のように表現するのとは異なる:</p>
        <div class="sourceCode" id="cb38">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mappend</span> s1 s2 <span class="ot">=</span> (<span class="op">++</span>) s1 s2</span></code></pre>
        </div>
        <p>前者は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐇</mi>
                <mi>𝐚</mi>
                <mi>𝐬</mi>
                <mi>𝐤</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Hask}</annotation>
            </semantics>
          </math>圏
          (または、終わりのない計算を指すボトムを無視するなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>圏)
          の射の等価性に変換される。このような方程式はより簡潔であるだけでなく、しばしば他の圏にも一般化できる。後者は<span id="extensional" class="keyword">外延的</span>同値性
          (extensional
          equivalence)
          と呼ばれ、どんな2つの入力文字列に対しても<code>mappend</code>と<code>(++)</code>の出力は同じであることを述べている。引数の値は<span id="point"
            class="keyword">点</span> (point) と呼ばれることがあるため
          (例:
          点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>における<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>の値)、これはpoint-wise
          equalityと呼ばれる。引数を指定しない関数の等価性は<span id="point-free" class="keyword">ポイントフリー</span> (point-free)
          と表現される。(ちなみに、ポイントフリーの式は関数合成を含むことが多く、これは点記号で表されるため、初心者は少し混乱するかもしれない。)</p>
        <p>C++でモノイドを宣言するのに最も近い方法は、C++20標準のコンセプト機能を使うことだ。</p>
        <div class="sourceCode" id="cb39">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>  T mempty <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  T mappend<span class="op">(</span>T<span class="op">,</span> T<span class="op">)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> M<span class="op">&gt;</span></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">concept</span> <span class="dt">bool</span> Monoid <span class="op">=</span> <span class="kw">requires</span> <span class="op">(</span>M m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> mempty<span class="op">&lt;</span>M<span class="op">&gt;</span> <span class="op">}</span> <span class="op">-&gt;</span> M<span class="op">;</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> mappend<span class="op">(</span>m<span class="op">,</span> m<span class="op">);</span> <span class="op">}</span> <span class="op">-&gt;</span> M<span class="op">;</span></span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">};</span></span></code></pre>
        </div>
        <p>最初の定義は、各特殊化で中立元を保持するための構造だ。</p>
        <p>キーワード<code>delete</code>は、デフォルト値が定義されていないことを意味する。これはケースバイケースで指定する必要がある。同様に、<code>mappend</code>にもデフォルトはない。
        </p>
        <p>
          <code>Monoid</code>というコンセプトは、与えられた型<code>M</code>に対して<code>mempty</code>と<code>mappend</code>の適切な定義が存在するかをテストする。
        </p>
        <p>このMonoidコンセプトのインスタンス化は、適切な特殊化とオーバーロードを提供することで実現できる:</p>
        <div class="sourceCode" id="cb40">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;&gt;</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string mempty<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;</span> <span class="op">=</span> <span class="op">{</span><span class="st">&quot;&quot;</span><span class="op">};</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string mappend<span class="op">(</span><span class="bu">std::</span>string s1<span class="op">,</span> <span class="bu">std::</span>string s2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s1 <span class="op">+</span> s2<span class="op">;</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <h2 data-number="3.5" id="圏としてのモノイド"><span class="header-section-number">3.5</span> 圏としてのモノイド</h2>
        <p>
          ここまでは集合の要素という観点でのモノイドの「おなじみの」定義だった。しかし、ご存知のように、圏論では集合とその要素から逃れようとし、代わりに対象と射について述べる。そこで、少し視点を変えて、二項演算子の適用先を、集合の周りを「移動」したり「シフト」したりするものと考えてみよう。
        </p>
        <p>たとえば、各自然数に5を加算する演算を考える。これは0を5、1を6
          、2を7のように写す。これは、一連の自然数で定義された関数だ。結構だ。関数と集合がある。一般に、任意の数nに対し<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>を加算する関数がある。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>の「加算器」だ。</p>
        <p>加算器はどのように合成すればよいだろう？
          5を加算する関数と7を加算する関数の合成は、12を加算する関数だ。これにより、加算器の合成を加算ルールと等価にできる。これまた結構だ。加算を関数合成に置き換えられる。</p>
        <p>ちょっと待った。それだけではない。中立元0の加算器もある。0を加算しても何も写されないので、これは自然数の集合における恒等関数だ。</p>
        <p>従来の加算の規則を与える代わりに、情報を失うことなく加算器を構成する規則を与えることもできる。加算器の合成は結合性を持つことに注目してほしい。これは、関数の合成が結合性を持ち、恒等関数に対応する0加算器があるからだ。
        </p>
        <p>
          鋭い読者なら、整数から加算器への写像が<code>mappend</code>の型シグネチャを<code>m -&gt; (m -&gt; m)</code>と解釈した結果であることに気付いただろう。これは<code>mappend</code>がモノイド集合の要素を、その集合に作用する関数に写すことを表している。
        </p>
        <p>
          さて、自然数を集合として扱っていることを忘れて、たくさんの射――加算器たちをひとかたまりにした、単一の対象だと考えてほしい。モノイドは対象が単一の圏だ。実際、monoidという名前は、ギリシャ語で単一を意味する<em>mono</em>に由来する。すべてのモノイドは、適切な合成規則に従う射の集合をもつ単一の対象の圏として記述できる。
        </p>
        <p><img src="images/monoid.jpg" style="width:35.0%" /></p>
        <p>文字列の連結は興味深いケースだ。なぜなら、右アペンダーと左アペンダー
          (あるいは<em>prependers</em>)
          を定義する選択肢があるからだ。2つのモデルの合成テーブルは、互いに鏡像反転している。「foo」に「bar」を後置するのと「bar」に「foo」を前置するのが同じなのは容易に納得できるだろう。</p>
        <p>すべての圏論的モノイド――対象が1つの圏――が二項演算付き集合
          (set-with-binary-operator)
          のモノイドを一意に定義するのか、という疑問を持つかもしれない。単一対象の圏からは常に集合を抽出できる。その集合は射の集合であり、この例では加算器だ。言い換えれば、圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐌</mi>
              <annotation encoding="application/x-tex">\mathbf{M}</annotation>
            </semantics>
          </math>内の単一対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>についてhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>m</mi>
                  <mo>,</mo>
                  <mi>m</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{M}(m, m)</annotation>
            </semantics>
          </math>
          が存在する。この集合における二項演算は簡単に定義できる。2つの集合要素のモノイダル積
          (monoidal product)
          とは、それらに対応する射を合成したものに対応する要素だ。つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>に対応する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>m</mi>
                  <mo>,</mo>
                  <mi>m</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{M}(m, m)</annotation>
            </semantics>
          </math>
          の2つの要素を指定すると、その積は合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∘</mo>
                <mi>g</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \circ g</annotation>
            </semantics>
          </math>に対応する。この合成は常に存在する。なぜなら、射の始域と終域が同じ対象だからだ。また、圏の規則より、結合性も持つ。恒等射はこの積の中立元だ。このように、圏論的モノイドからは常に集合論的モノイドを復元できる。どこからどう見てもそれらは同一だ。
        </p>
        <figure>
          <img src="images/monoidhomset.jpg" style="width:40.0%" alt="射あるいは集合内の点として見たモノイドhom集合" />
          <figcaption aria-hidden="true">射あるいは集合内の点として見たモノイドhom集合</figcaption>
        </figure>
        <p>
          数学者が補足すべき箇所は、射は必ずしも集合を形成しないということだけだ。圏の世界には集合よりも大きなものがある。任意の2つの物体間の射が集合を形成する圏は、局所的に小さい、と呼ばれる。約束どおり、私はそのような些細なことはほとんど無視するが、記録のために言及すべきだと考えた。
        </p>
        <p>hom集合の要素は、合成則に従う射としても、ある集合内の点としても見なせる。圏論における多くの興味深い現象はこの事実に根ざしている。ここで、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐌</mi>
              <annotation encoding="application/x-tex">\mathbf{M}</annotation>
            </semantics>
          </math>の射の合成は、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>m</mi>
                  <mo>,</mo>
                  <mi>m</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{M}(m, m)</annotation>
            </semantics>
          </math>
          のモノイダル積に変換される。</p>
        <h2 data-number="3.6" id="課題-2"><span class="header-section-number">3.6</span> 課題</h2>
        <ol type="1">
          <li>
            <p>以下から自由圏を生成せよ:</p>
            <ol type="1">
              <li>1つのノードを持ち、エッジのないグラフ</li>
              <li>1つのノードと1つの (有向) エッジを持つグラフ (ヒント:
                このエッジは自身と合成できる)</li>
              <li>2つのノードと、それらの間の矢を1つ持つグラフ</li>
              <li>1つのノードと、アルファベットa, b, c
                <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                  <semantics>
                    <mi>…</mi>
                    <annotation encoding="application/x-tex">\ldots</annotation>
                  </semantics>
                </math>
                zでマークされた26個の矢を持つグラフ
              </li>
            </ol>
          </li>
          <li>
            <p>以下はどんな順序だろうか？</p>
            <ol type="1">
              <li>包含関係:
                <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                  <semantics>
                    <mi>A</mi>
                    <annotation encoding="application/x-tex">A</annotation>
                  </semantics>
                </math>を持つ集合の集合は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                  <semantics>
                    <mi>A</mi>
                    <annotation encoding="application/x-tex">A</annotation>
                  </semantics>
                </math>のすべての要素が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                  <semantics>
                    <mi>B</mi>
                    <annotation encoding="application/x-tex">B</annotation>
                  </semantics>
                </math>の要素でもある場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                  <semantics>
                    <mi>B</mi>
                    <annotation encoding="application/x-tex">B</annotation>
                  </semantics>
                </math>に含まれる。
              </li>
              <li>次のサブタイプ関係を持つC++の型:
                <code>T1</code>が<code>T2</code>のサブタイプなのは、<code>T2</code>へのポインタを期待する関数に<code>T1</code>をコンパイルエラーを発生させずに渡せる場合だ。
              </li>
            </ol>
          </li>
          <li>
            <p><code>Bool</code>が2つの値<code>True</code>と<code>False</code>の集合であることを考えると、演算子<code>&amp;&amp;</code>
              (AND) と<code>||</code> (OR) にそれぞれ対応する2つの (集合論的)
              モノイドを形成することを示せ。</p>
          </li>
          <li>
            <p>AND演算子を伴う<code>Bool</code>モノイドを圏として表せ。射と合成の規則を列挙せよ。</p>
          </li>
          <li>
            <p>モジュロ3加算をモノイドの圏として表せ。</p>
          </li>
        </ol>
        <h1 data-number="4" id="kleisli-categories"><span class="header-section-number">4</span> Kleisli圏</h1>
        <h2 data-number="4.1" id="ログの合成"><span class="header-section-number">4.1</span> ログの合成</h2>
        <p>
          型と純粋関数を圏としてモデル化する方法を見てきた。また、圏論には副作用や非純粋関数をモデル化する方法があることにも触れた。その例として、実行内容をログに記録したりトレースしたりする関数を見てみよう。命令型言語では、次のように、何らかのグローバルな状態を変更することによって実装される場合が多い:
        </p>
        <div class="sourceCode" id="cb41">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>string logger<span class="op">;</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> negate<span class="op">(</span><span class="dt">bool</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>     logger <span class="op">+=</span> <span class="st">&quot;Not so! &quot;</span><span class="op">;</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> <span class="op">!</span>b<span class="op">;</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>これは純粋関数ではない。メモ化されたバージョンではログを生成できないからだ。この関数には<span id="side_effect" class="keyword">副作用</span>がある。</p>
        <p>現代のプログラミングでは、並行性の複雑さだけが理由だとしても、グローバルな可変状態をできる限り回避しようとする。それに、こんなコードをライブラリに加えたくはないだろう。</p>
        <p>幸い、この関数を純粋にすることは可能だ。ログを明示的に入出力するだけでよい。文字列引数を追加し、通常の出力と更新されたログを含む文字列をペアにすることで、これを実現しよう。</p>
        <div class="sourceCode" id="cb42">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>pair<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> string<span class="op">&gt;</span> negate<span class="op">(</span><span class="dt">bool</span> b<span class="op">,</span> string logger<span class="op">)</span> <span class="op">{</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> make_pair<span class="op">(!</span>b<span class="op">,</span> logger <span class="op">+</span> <span class="st">&quot;Not so! &quot;</span><span class="op">);</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>
          この関数は純粋で、副作用はなく、同じ引数で呼び出されるたびに同じペアを返し、必要に応じてメモ化できる。ただし、ログには累積的な性質があるので、特定の呼び出しにつながる可能性のあるすべての履歴をメモ化する必要があるだろう。次のような場合は、別々のメモエントリーになるだろう:
        </p>
        <div class="sourceCode" id="cb43">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>negate<span class="op">(</span><span class="kw">true</span><span class="op">,</span> <span class="st">&quot;It was the best of times. &quot;</span><span class="op">);</span></span></code></pre>
        </div>
        <p>と</p>
        <div class="sourceCode" id="cb44">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>negate<span class="op">(</span><span class="kw">true</span><span class="op">,</span> <span class="st">&quot;It was the worst of times. &quot;</span><span class="op">);</span></span></code></pre>
        </div>
        <p>などだ。</p>
        <p>
          これもライブラリ関数のインターフェースとしてはあまり適していない。戻り値の型が文字列を含むことについては、呼び出し元は無視してよいので、大きな負担ではない。一方で、入力として文字列を渡す必要があるのについては、不便な場合がある。
        </p>
        <p>同じことを簡単にやる方法はあるだろうか？
          関心を分離する方法はあるだろうか？
          ここでの単純な例では、関数<code>negate</code>の主な目的は、あるブール値を別のブール値に変換することだ。ログ生成は二次的なものだ。確かに、ログに記録されるメッセージは関数固有だが、それらのメッセージを1つの連続したログに集約する作業は別の関心事だ。文字列を生成する関数は必要だが、ログの生成とは分離したい。妥協案はこうだ:
        </p>
        <div class="sourceCode" id="cb45">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>pair<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> string<span class="op">&gt;</span> negate<span class="op">(</span><span class="dt">bool</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> make_pair<span class="op">(!</span>b<span class="op">,</span> <span class="st">&quot;Not so! &quot;</span><span class="op">);</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>ログを関数呼び出しの<em>間で</em>集約する、というアイデアだ。</p>
        <p>どうすればこうできるか確認するために、もう少し現実的な例に切り替えよう。小文字の文字列を大文字の文字列に変換する関数があるとする:</p>
        <div class="sourceCode" id="cb46">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>string toUpper<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    string result<span class="op">;</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">(*</span>toupperp<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> <span class="op">&amp;</span>toupper<span class="op">;</span> <span class="co">// toupper is overloaded</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    transform<span class="op">(</span>begin<span class="op">(</span>s<span class="op">),</span> end<span class="op">(</span>s<span class="op">),</span> back_inserter<span class="op">(</span>result<span class="op">),</span> toupperp<span class="op">);</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>さらに、文字列を空白区切りで分割して文字列のvectorにする別の関数があるとする。</p>
        <div class="sourceCode" id="cb47">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>string<span class="op">&gt;</span> toWords<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> words<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>実際の作業は補助関数<code>words</code>で行われる。</p>
        <div class="sourceCode" id="cb48">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>string<span class="op">&gt;</span> words<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>string<span class="op">&gt;</span> result<span class="op">{</span><span class="st">&quot;&quot;</span><span class="op">};</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> i <span class="op">=</span> begin<span class="op">(</span>s<span class="op">);</span> i <span class="op">!=</span> end<span class="op">(</span>s<span class="op">);</span> <span class="op">++</span>i<span class="op">)</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>isspace<span class="op">(*</span>i<span class="op">))</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span>push_back<span class="op">(</span><span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>            result<span class="op">.</span>back<span class="op">()</span> <span class="op">+=</span> <span class="op">*</span>i<span class="op">;</span></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>関数<code>toUpper</code>と<code>toWords</code>を修正して、通常の戻り値の上にメッセージ文字列を背負わせるようにしたい。</p>
        <p><img src="images/piggyback.jpg" style="width:30.0%" /></p>
        <p>これらの関数の戻り値を「装飾」(embellish)
          することにする。総称的な方法で、テンプレート<code>Writer</code>を定義しよう。このテンプレートは、最初のコンポーネントが任意の型<code>A</code>の値で、2番目のコンポーネントが文字列であるペアをカプセル化する:
        </p>
        <div class="sourceCode" id="cb49">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">&gt;</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> Writer <span class="op">=</span> pair<span class="op">&lt;</span>A<span class="op">,</span> string<span class="op">&gt;;</span></span></code></pre>
        </div>
        <p>装飾された関数は次のとおりだ:</p>
        <div class="sourceCode" id="cb50">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>Writer<span class="op">&lt;</span>string<span class="op">&gt;</span> toUpper<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    string result<span class="op">;</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">(*</span>toupperp<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> <span class="op">&amp;</span>toupper<span class="op">;</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    transform<span class="op">(</span>begin<span class="op">(</span>s<span class="op">),</span> end<span class="op">(</span>s<span class="op">),</span> back_inserter<span class="op">(</span>result<span class="op">),</span> toupperp<span class="op">);</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> make_pair<span class="op">(</span>result<span class="op">,</span> <span class="st">&quot;toUpper &quot;</span><span class="op">);</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>Writer<span class="op">&lt;</span>vector<span class="op">&lt;</span>string<span class="op">&gt;&gt;</span> toWords<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> make_pair<span class="op">(</span>words<span class="op">(</span>s<span class="op">),</span> <span class="st">&quot;toWords &quot;</span><span class="op">);</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>この2つの関数を、文字列を大文字にして単語に分割する別の装飾された関数に合成すると同時に、これらの動作のログを生成したい。その方法は次のとおりだ。</p>
        <div class="sourceCode" id="cb51">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>Writer<span class="op">&lt;</span>vector<span class="op">&lt;</span>string<span class="op">&gt;&gt;</span> process<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> p1 <span class="op">=</span> toUpper<span class="op">(</span>s<span class="op">);</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> p2 <span class="op">=</span> toWords<span class="op">(</span>p1<span class="op">.</span>first<span class="op">);</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> make_pair<span class="op">(</span>p2<span class="op">.</span>first<span class="op">,</span> p1<span class="op">.</span>second <span class="op">+</span> p2<span class="op">.</span>second<span class="op">);</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>目標は達成された。ログの集約はもはや個々の関数の関心事ではなくなった。それらは独自のメッセージを生成し、そのメッセージは外部でより大きなログに連結される。</p>
        <p>このスタイルで書かれたプログラム全体を想像してみてほしい。反復が多くエラーが発生しやすいコードという悪夢だ。しかし、我々はプログラマーだ。反復的なコードの扱い方は知っている。抽象化だ！
          しかし、ありきたりの抽象化ではだめだ――<span id="function_composition"
            class="keyword">関数合成</span>自体を抽象化する必要がある。しかし、合成は圏論の本質なので、さらにコードを書く前に、圏の観点から問題を分析してみよう。</p>
        <h2 data-number="4.2" id="writer圏"><span class="header-section-number">4.2</span> Writer圏</h2>
        <p>いくつかの追加機能を背負わせるために、関数群の戻り値の型を装飾するというアイデアは、非常に実りの多いものとなった。これからも多くの例が出てくるだろう。その出発点は、型と関数の正則圏
          (regular category)
          だ。対象は型のままにしておくが、射は装飾された関数になるように再定義する。</p>
        <p>
          たとえば、<code>int</code>から<code>bool</code>への関数<code>isEven</code>を装飾したいとする。それを装飾された関数で表される射に変換する。重要なのは、装飾された関数は次のようなペアを返すにも関わらず、この射は相変わらず対象<code>int</code>と<code>bool</code>の間の矢とみなされる、ということだ:
        </p>
        <div class="sourceCode" id="cb52">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>pair<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> string<span class="op">&gt;</span> isEven<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> make_pair<span class="op">(</span>n <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">,</span> <span class="st">&quot;isEven &quot;</span><span class="op">);</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>圏の規則によれば、この射は対象<code>bool</code>から何かに向かう別の射と合成できるはずだ。具体的には、先ほどの<code>negate</code>と合成できるはずだ:</p>
        <div class="sourceCode" id="cb53">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>pair<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> string<span class="op">&gt;</span> negate<span class="op">(</span><span class="dt">bool</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>     <span class="cf">return</span> make_pair<span class="op">(!</span>b<span class="op">,</span> <span class="st">&quot;Not so! &quot;</span><span class="op">);</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>明らかに、入力と出力の不一致のせいで、これら2つの射は通常の関数合成と同じようには合成できない。それらの合成はもっとこんな風になるはずだ:</p>
        <div class="sourceCode" id="cb54">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>pair<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> string<span class="op">&gt;</span> isOdd<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>    pair<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> string<span class="op">&gt;</span> p1 <span class="op">=</span> isEven<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    pair<span class="op">&lt;</span><span class="dt">bool</span><span class="op">,</span> string<span class="op">&gt;</span> p2 <span class="op">=</span> negate<span class="op">(</span>p1<span class="op">.</span>first<span class="op">);</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> make_pair<span class="op">(</span>p2<span class="op">.</span>first<span class="op">,</span> p1<span class="op">.</span>second <span class="op">+</span> p2<span class="op">.</span>second<span class="op">);</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>こうして、我々が構築している新しい圏における2つの射の合成のレシピができる:</p>
        <ol type="1">
          <li>
            <p>最初の射に対応する装飾された関数を実行する。</p>
          </li>
          <li>
            <p>その結果のペアから最初のコンポーネントを取り出し、2番目の射に対応する装飾された関数に渡す。</p>
          </li>
          <li>
            <p>最初の結果の2番目のコンポーネント (文字列)
              と2番目の結果の2番目のコンポーネント (文字列) を連結する。</p>
          </li>
          <li>
            <p>最終結果の最初のコンポーネントと連結された文字列を組み合わせた新しいペアを返す。</p>
          </li>
        </ol>
        <p>
          この合成をC++の高階関数として抽象化したい場合、圏の3つの対象に対応する3つの型でパラメーター化されたテンプレートを使わなければならない。ルールに従って構成可能な2つの装飾された関数を受け取り、3番目の装飾された関数を返す必要がある:
        </p>
        <div class="sourceCode" id="cb55">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">,</span> <span class="kw">class</span> C<span class="op">&gt;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>function<span class="op">&lt;</span>Writer<span class="op">&lt;</span>C<span class="op">&gt;(</span>A<span class="op">)&gt;</span> compose<span class="op">(</span>function<span class="op">&lt;</span>Writer<span class="op">&lt;</span>B<span class="op">&gt;(</span>A<span class="op">)&gt;</span> m1<span class="op">,</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>                               function<span class="op">&lt;</span>Writer<span class="op">&lt;</span>C<span class="op">&gt;(</span>B<span class="op">)&gt;</span> m2<span class="op">)</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">[</span>m1<span class="op">,</span> m2<span class="op">](</span>A x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> p1 <span class="op">=</span> m1<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> p2 <span class="op">=</span> m2<span class="op">(</span>p1<span class="op">.</span>first<span class="op">);</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> make_pair<span class="op">(</span>p2<span class="op">.</span>first<span class="op">,</span> p1<span class="op">.</span>second <span class="op">+</span> p2<span class="op">.</span>second<span class="op">);</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>ここで、前の例に戻り、この新しいテンプレートを使って<code>toUpper</code>と<code>toWords</code>の合成を実装できる:</p>
        <div class="sourceCode" id="cb56">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>Writer<span class="op">&lt;</span>vector<span class="op">&lt;</span>string<span class="op">&gt;&gt;</span> process<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> compose<span class="op">&lt;</span>string<span class="op">,</span> string<span class="op">,</span> vector<span class="op">&lt;</span>string<span class="op">&gt;&gt;(</span>toUpper<span class="op">,</span> toWords<span class="op">)(</span>s<span class="op">);</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p><code>compose</code>テンプレートへの型の受け渡しにはまだ多くのノイズがある。これは、戻り値型推論を持つ総称ラムダ関数をサポートするC++14準拠のコンパイラがあれば回避できる。(このコードはEric
          Nieblerによる。)</p>
        <div class="sourceCode" id="cb57">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="at">const</span> compose <span class="op">=</span> <span class="op">[](</span><span class="kw">auto</span> m1<span class="op">,</span> <span class="kw">auto</span> m2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">[</span>m1<span class="op">,</span> m2<span class="op">](</span><span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> p1 <span class="op">=</span> m1<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> p2 <span class="op">=</span> m2<span class="op">(</span>p1<span class="op">.</span>first<span class="op">);</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> make_pair<span class="op">(</span>p2<span class="op">.</span>first<span class="op">,</span> p1<span class="op">.</span>second <span class="op">+</span> p2<span class="op">.</span>second<span class="op">);</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre>
        </div>
        <p>この新しい定義では、<code>process</code>の実装は次のように簡略化される:</p>
        <div class="sourceCode" id="cb58">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>Writer<span class="op">&lt;</span>vector<span class="op">&lt;</span>string<span class="op">&gt;&gt;</span> process<span class="op">(</span>string s<span class="op">){</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> compose<span class="op">(</span>toUpper<span class="op">,</span> toWords<span class="op">)(</span>s<span class="op">);</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>しかし、まだ完成ではない。新しい圏で合成を定義したが、恒等射は何だろう？
          それらは通常の恒等関数ではない！
          それらは、型Aから型Aに戻る射でなければならず、つまり、それらは次の形式の装飾された関数であることを意味する:</p>
        <div class="sourceCode" id="cb59">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>Writer<span class="op">&lt;</span>A<span class="op">&gt;</span> identity<span class="op">(</span>A<span class="op">);</span></span></code></pre>
        </div>
        <p>それらは合成に関して単位元のように振る舞う必要がある。合成の定義を見ると、恒等射は引数を変更せずに渡し、ログには空文字列だけを与える必要があるのがわかる:</p>
        <div class="sourceCode" id="cb60">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">&gt;</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>Writer<span class="op">&lt;</span>A<span class="op">&gt;</span> identity<span class="op">(</span>A x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> make_pair<span class="op">(</span>x<span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">);</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>
          ここで定義した圏が本当に正当な圏であることは容易に納得できる。特に、ここでの合成が結合性を持つのは自明だ。各ペアの最初のコンポーネントで何が起こっているかを見ると、それは単なる通常の関数合成であり、結合性を持つ。2番目のコンポーネントは連結されており、連結も結合性を持つ。
        </p>
        <p>鋭い読者なら、この構成を文字列モノイドだけでなく、どんなモノイドにも容易に一般化できると気付くだろう。(<code>+</code>と<code>""</code>の代わりに)
          <code>mappend</code>を<code>compose</code>の中で、<code>mempty</code>を<code>identity</code>の中で使おう。ログ生成を文字列だけに限定する理由はない。優れたライブラリ作成者は、ライブラリを機能させられる最小限の制約を見抜けなくてはならない。ここで、ログ生成ライブラリの唯一の要件は、ログがモノイダル特性を持つことだ。
        </p>
        <h2 data-number="4.3" id="haskellにおけるwriter"><span class="header-section-number">4.3</span> HaskellにおけるWriter
        </h2>
        <p>Haskellでは同じことを少し簡潔にやれて、コンパイラからも多くの支援を受けられる。<code>Writer</code>型を定義することから始めよう:</p>
        <div class="sourceCode" id="cb61">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Writer</span> a <span class="ot">=</span> (a, <span class="dt">String</span>)</span></code></pre>
        </div>
        <p>ここでは単にC++の<code>typedef</code> (または<code>using</code>)
          に相当する型エイリアスを定義している。型<code>Writer</code>は型変数<code>a</code>によってパラメーター化され、<code>a</code>と<code>String</code>のペアと等価だ。ペアの構文は最小限だ。2つの項目を括弧で囲み、コンマで区切るだけだ。
        </p>
        <p>射は、任意の型から<code>Writer</code>型への関数だ:</p>
        <div class="sourceCode" id="cb62">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> <span class="dt">Writer</span> b</span></code></pre>
        </div>
        <p>合成を中置演算子として宣言する。この風変わりな演算子は「fish」と呼ばれることもある:</p>
        <div class="sourceCode" id="cb63">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;=&gt;) ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Writer</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> <span class="dt">Writer</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Writer</span> c)</span></code></pre>
        </div>
        <p>
          この関数は、それぞれ単独の関数である2つの引数を取り、1つの関数を返す。最初の引数は型<code>(a -&gt; Writer b)</code>、2番目の引数は<code>(b -&gt; Writer c)</code>、結果は<code>(a-&gt;Writer c)</code>となる。
        </p>
        <p>この中置演算子の定義は次のとおりだ。2つの引数<code>m1</code>と<code>m2</code>は、魚型シンボルの両側に現れる。</p>
        <div class="sourceCode" id="cb64">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>m1 <span class="op">&gt;=&gt;</span> m2 <span class="ot">=</span> \x <span class="ot">-&gt;</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (y, s1) <span class="ot">=</span> m1 x</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>        (z, s2) <span class="ot">=</span> m2 y</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> (z, s1 <span class="op">++</span> s2)</span></code></pre>
        </div>
        <p>結果は、1つの引数<code>x</code>を取るラムダ関数だ。ラムダはバックスラッシュで書かれる――ギリシャ文字の<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>λ</mi>
              <annotation encoding="application/x-tex">\lambda</annotation>
            </semantics>
          </math>を片脚にしたものと考えてほしい。</p>
        <p>
          <code>let</code>式では補助変数を宣言できる。ここでの<code>m1</code>の呼び出しの結果は、一対の変数<code>(y, s1)</code>にパターンマッチングされ、<code>m2</code>の呼び出しの結果は、最初のパターンからの引数<code>y</code>とともに、<code>(z, s2)</code>にマッチングされる。
        </p>
        <p>Haskellでは、C++のようにアクセサーを使うのではなく、ペアをパターンマッチするのが一般的だ。それ以外は、2つの実装は非常に直接的に対応している。</p>
        <p>
          <code>let</code>式全体の値は<code>in</code>節で指定される。ここでは、最初の要素が<code>z</code>で、2番目の要素が2つの文字列<code>s1++s2</code>の連結であるペアだ。
        </p>
        <p>この圏の恒等射も定義し、<code>return</code>と呼ぶことにする。そう呼ぶ理由は後で明らかになる。</p>
        <div class="sourceCode" id="cb65">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Writer</span> a</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> x <span class="ot">=</span> (x, <span class="st">&quot;&quot;</span>)</span></code></pre>
        </div>
        <p>完全を期すために、装飾された関数<code>upCase</code>と<code>toWords</code>のHaskell版を用意しよう:</p>
        <div class="sourceCode" id="cb66">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="ot">upCase ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> <span class="dt">String</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>upCase s <span class="ot">=</span> (<span class="fu">map</span> <span class="fu">toUpper</span> s, <span class="st">&quot;upCase &quot;</span>)</span></code></pre>
        </div>
        <div class="sourceCode" id="cb67">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toWords ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> [<span class="dt">String</span>]</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>toWords s <span class="ot">=</span> (<span class="fu">words</span> s, <span class="st">&quot;toWords &quot;</span>)</span></code></pre>
        </div>
        <p>
          関数<code>map</code>はC++の<code>transform</code>に対応する。これは文字関数<code>toUpper</code>を文字列<code>s</code>に適用する。ちなみに、補助関数<code>words</code>は標準Preludeライブラリで定義されている。
        </p>
        <p>最後に、2つの関数の合成は、fishオペレータの助けを借りて達成される:</p>
        <div class="sourceCode" id="cb68">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="ot">process ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> [<span class="dt">String</span>]</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>process <span class="ot">=</span> upCase <span class="op">&gt;=&gt;</span> toWords</span></code></pre>
        </div>
        <h2 data-number="4.4" id="kleisli圏"><span class="header-section-number">4.4</span> Kleisli圏</h2>
        <p>
          この圏は私がこの場で発明したのではないことに、もう気付いていると思う。これはいわゆるKleisli圏の一例で、モナドに基づいた圏だ。モナドについてはまだ議論する準備ができていないが、モナドで何ができるのかをあなたにお伝えしたかったのだ。我々の限定された目的に関しては、Kleisli圏は、対象として、背後にあるプログラム言語の型を持っている。型<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>A</mi>
              <annotation encoding="application/x-tex">A</annotation>
            </semantics>
          </math>から型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>B</mi>
              <annotation encoding="application/x-tex">B</annotation>
            </semantics>
          </math>への射は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>A</mi>
              <annotation encoding="application/x-tex">A</annotation>
            </semantics>
          </math>を取る関数であり、特定の装飾によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>B</mi>
              <annotation encoding="application/x-tex">B</annotation>
            </semantics>
          </math>から派生した型を返す。個々のKleisli圏は、そのような射を構成する個別の方法や、その合成に関する恒等射を定義している。(不正確な用語である「装飾」は、圏の自己関手という概念に対応していることが後で分かるだろう。)
        </p>
        <p>この章で圏の基礎として使ったモナドは<span id="writer_monad"
            class="keyword">writerモナド</span>と呼ばれ、関数の実行をログに記録したりトレースしたりするために使われる。また、純粋な計算に副作用を埋め込むための、より汎用的なメカニズムの例でもある。これまで見てきたように、プログラミング言語の型と関数は、
          (いつもどおりボトムは無視して)
          集合の圏でモデル化できる。ここでは、そのモデルをわずかに異なる圏に拡張した。すなわち、装飾された関数によって射が表現され、しかも関数の出力を別の関数の入力に渡すだけでは射を合成できない圏だ。さらに、もう1つ自由度がある。合成そのものだ。それはまさに、これまで副作用を使って実装されてきた命令型言語のプログラムに、簡潔な表示的意味を与えられるようにする自由度だとわかる。
        </p>
        <h2 data-number="4.5" id="課題-3"><span class="header-section-number">4.5</span> 課題</h2>
        <p>
          引数が取り得る値のうち一部だけに対して定義されている関数は、部分関数と呼ばれる。これは実際には数学的な意味での関数ではないので、標準的な圏の枠組みには合わない。しかし、装飾された型<code>optional</code>を返す関数でなら表せる:
        </p>
        <div class="sourceCode" id="cb69">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">&gt;</span> <span class="kw">class</span> optional <span class="op">{</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> _isValid<span class="op">;</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>    A    _value<span class="op">;</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a>    optional<span class="op">()</span>    <span class="op">:</span> _isValid<span class="op">(</span><span class="kw">false</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a>    optional<span class="op">(</span>A v<span class="op">)</span> <span class="op">:</span> _isValid<span class="op">(</span><span class="kw">true</span><span class="op">),</span> _value<span class="op">(</span>v<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> isValid<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> _isValid<span class="op">;</span> <span class="op">}</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a>    A value<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> _value<span class="op">;</span> <span class="op">}</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre>
        </div>
        <p>例として、装飾された関数<code>safe_root</code>の実装を示す:</p>
        <div class="sourceCode" id="cb70">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>optional<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> safe_root<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> optional<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;{</span>sqrt<span class="op">(</span>x<span class="op">)};</span></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="cf">return</span> optional<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;{};</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>課題は以下のとおりだ:</p>
        <ol type="1">
          <li>
            <p>部分関数のためのKleisli圏を構築せよ
              (合成と恒等射を定義せよ)。</p>
          </li>
          <li>
            <p>引数が0でない場合に有効な逆数を返す装飾された関数<code>safe_reciprocal</code>を実装せよ。</p>
          </li>
          <li>
            <p>
              関数<code>safe_root</code>と<code>safe_reciprocal</code>を合成して、可能なすべての場合に<code>sqrt(1/x)</code>を計算する<code>safe_root_reciprocal</code>を実装せよ。
            </p>
          </li>
        </ol>
        <h1 data-number="5" id="products-and-coproducts"><span class="header-section-number">5</span> 積と余積</h1>
        <h2 data-number="5.1" id="矢に従え"><span class="header-section-number">5.1</span> 矢に従え</h2>
        <p>古代ギリシアの劇作家のエウリーピデースは「人間は、喜んで交際している仲間たちと異なるところがない」<a href="#fn3" class="footnote-ref" id="fnref3"
            role="doc-noteref"><sup>3</sup></a>と言った。我々は人間関係によって定義される。これほど圏論に当てはまる言葉はない。圏の中の特定の対象を選び出すには、他の対象
          (およびそれ自身)
          との関係のパターンを記述するしかない。これらの関係は射によって定義される。</p>
        <p>圏論には<span id="universal_construction" class="keyword">普遍的構成</span> (universal construction)
          と呼ばれる構成がよく現れ、対象をその関係の観点から定義する。これを行う方法の1つとしては、対象と射から構成された特定の形のパターンを選び、圏に出現するすべてのパターンを探すことが挙げられる。そのパターンが十分に一般的であり、圏が大きい場合、該当するものがたくさん出てくるだろう。秘訣は、該当したものに対するある種の順位付けを確立し、最適と考えられるものを選択することだ。
        </p>
        <p>このプロセスは、ウェブ検索のやり方を思い起こさせる。クエリはパターンのようなものだ。非常に一般的なクエリなら、<em>再現率</em>
          (recall)
          が高く、すなわち該当するものの数が多い。関連性があるものもあれば、そうでないものもあるだろう。無関係なヒットを削除するには、クエリを絞り込む。これにより<em>精度</em>
          (precision)
          が向上する。最終的に、検索エンジンは検索結果を順位付けして、うまくいけば、あなたが興味のある結果がリストの一番上に表示される。</p>
        <aside id="footnotes" class="footnotes footnotes-end-of-section" role="doc-footnote">
          <hr />
          <ol start="3">
            <li id="fn3">
              <p>訳註: 『ポイニクス』812番の台詞に基づく。英訳の “Every
                man is like the company he is wont to keep.”
                が格言として広まったものと考えられる。この日本語訳は『ギリシア悲劇全集
                (12) エウリーピデース断片』(岩波書店、1993) に従った。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p>
            </li>
          </ol>
        </aside>
        <h2 data-number="5.2" id="始対象"><span class="header-section-number">5.2</span> 始対象</h2>
        <p>
          最も単純な形は単一の対象だ。明らかに、この形の実例は、特定の圏にある対象と同じ数だけ存在する。それでは候補が多すぎる。ある種の順位付けを確立し、この階層のトップにある対象を見つける必要がある。利用できる唯一の手段は射だ。射を矢として捉えるなら、矢の全体的な総フローが、圏の一方の端から他方の端へと存在しうる。これは、半順序など、順序付けられた圏に当てはまる。<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>へ向かう矢
          (射)
          が存在するなら、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>は対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>よりも「始め」だとして、対象の優先順位の概念を一般化できる。次に、<em>唯一の</em>始対象を、他のすべての対象に向かう矢を持つものとして定義する。明らかに、そのような対象が存在する保証はないのだが、大丈夫だ。より大きな問題は、そのような対象が多すぎる可能性があることだ。再現率は高いが、精度を欠いている。解決策は、順序付けられた圏からヒントを得ることだ。それらの圏では、任意の2つの対象の間に最大で1つの矢だけが存在できる。そのため、別の対象以下となる方法は1つしかない。これは始対象の次のような定義につながる:
        </p>
        <blockquote>
          <p><strong>始対象</strong> (the initial object)
            とは、圏内の任意の対象に対し、そこへ向かう射をちょうど1つだけ持つ対象だ。</p>
        </blockquote>
        <p><img src="images/initial.jpg" style="width:40.0%" /></p>
        <p>それでも、始対象が (存在するにしても)
          一意だとは保証されない。しかし、それは次善のものを保証する。<span id="up_to_isomorphism" class="keyword">同型を除いて</span>一意 (unique
          up to isomorphism)
          という性質だ。同型は圏論では非常に重要なので、すぐに説明する。差し当たっては、同型を除いて一意という性質が始対象の定義における「the」の使用を正当化することに同意しよう。</p>
        <p>以下にいくつかの例を示す。部分的に順序付けられた集合は、しばしば<span id="poset" class="keyword">ポセット</span> (poset)
          と呼ばれ、最小要素が始対象となる。始対象を持たないポセットもある。たとえば、正と負のすべての整数の集合のように、射について等号付き大小関係を持つものだ。</p>
        <p>集合と関数の圏では、始対象は空集合だ。空集合はHaskellの型<code>Void</code>に対応し
          (C++には対応する型は存在せず)、<code>Void</code>から他の型への一意な多相関数は<code>absurd</code>と呼ばれることを覚えてほしい。</p>
        <div class="sourceCode" id="cb71">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="ot">absurd ::</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <p><code>Void</code>を型の圏における始対象にしているのは、この射の族なのだ。</p>
        <h2 data-number="5.3" id="終対象"><span class="header-section-number">5.3</span> 終対象</h2>
        <p>引き続き単一対象パターンを扱うが、対象の順位付け方法を変更しよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>への射がある場合、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>は対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>よりも「終わりの側」と言える
          (方向が逆になっていることに注意してほしい)。探したいのは、圏のどの対象よりも終わりの側となる対象だ。再び、一意性を主張することになる:</p>
        <blockquote>
          <p><strong>終対象</strong>は、圏内のどの対象からも1つの射しか来ない対象だ。</p>
        </blockquote>
        <p><img src="images/final.jpg" style="width:40.0%" /></p>
        <p>
          繰り返すが、終対象は同型を除いて一意だ。これについてはすぐ後で説明する。まずは、いくつかの例を見てみよう。ポセットでは、終対象があれば、それが最大の対象だ。集合の圏では、終対象は単集合だ。単集合についてはすでに説明した。単集合は、C++では<code>void</code>型に対応し、Haskellではunit型<code>()</code>に対応する。これは1つの値しか持たない型で、C++では暗黙的に、Haskellでは明示的に<code>()</code>で表された。また、あらゆる型からunit型への唯一の純粋関数:
        </p>
        <div class="sourceCode" id="cb72">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unit ::</span> a <span class="ot">-&gt;</span> ()</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>unit _ <span class="ot">=</span> ()</span></code></pre>
        </div>
        <p>が、終対象のすべての条件を満たして存在することも確立した。</p>
        <p>この例では、一意性条件が決定的に重要であることに注意してほしい。なぜなら、すべての集合から入ってくる射を持つ他の集合
          (実際には、空集合を除くすべての集合)
          が存在するからだ。たとえば、すべての型に対して定義されたブール値関数
          (述語) がある:</p>
        <div class="sourceCode" id="cb73">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="ot">yes ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>yes _ <span class="ot">=</span> <span class="dt">True</span></span></code></pre>
        </div>
        <p>しかし、<code>Bool</code>は終対象ではない。すべての型に対して、少なくとももう1つの<code>Bool</code>値関数がある
          (<code>Void</code>に対してはどちらの関数も<code>absurd</code>と等しくなるので除く):</p>
        <div class="sourceCode" id="cb74">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="ot">no ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>no _ <span class="ot">=</span> <span class="dt">False</span></span></code></pre>
        </div>
        <p>一意性を主張することで、終対象の定義を1つの型だけに絞り込むのにちょうど良い精度が得られる。</p>
        <h2 data-number="5.4" id="双対性"><span class="header-section-number">5.4</span> 双対性</h2>
        <p>始対象と終対象の定義の対称性に注目せずにはいられないだろう。両者の唯一の違いは、射の方向だった。どの圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>に対しても、すべての矢を逆にするだけで<span id="opposite_category" class="keyword">反対圏</span> (opposite category)
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐂</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}</annotation>
            </semantics>
          </math>を定義できるとわかる。反対圏は、同時に圏を再定義する限り、合成のすべての要件を自動的に満たす。もとの射<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon a \to b</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>∷</mo>
                <mi>b</mi>
                <mo>→</mo>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">g \Colon b \to c</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>h</mi>
                <mo>=</mo>
                <mi>g</mi>
                <mo>∘</mo>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">h=g \circ f</annotation>
            </semantics>
          </math>によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>h</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">h \Colon a \to c</annotation>
            </semantics>
          </math>へと合成される場合、逆の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>f</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>∷</mo>
                <mi>b</mi>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">f^\mathit{op} \Colon b \to a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>g</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>∷</mo>
                <mi>c</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">g^\mathit{op} \Colon c \to b</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>h</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>=</mo>
                <msup>
                  <mi>f</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>∘</mo>
                <msup>
                  <mi>g</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">h^\mathit{op} = f^\mathit{op} \circ g^\mathit{op}</annotation>
            </semantics>
          </math>によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>h</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>∷</mo>
                <mi>c</mi>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">h^\mathit{op} \Colon c \to a</annotation>
            </semantics>
          </math>へと合成される。そして、恒等射を逆にすることは、(駄洒落に注意！)
          no-opだ。
        </p>
        <p>双対性は圏の非常に重要な特性だ。圏論を扱うすべての数学者の生産力を倍増させるからだ。思いつくすべての構成には反対圏があり、証明するすべての定理について無料で手に入る。反対圏の構成にはしばしば「余」(co)
          が前置され、積と余積、モナドとコモナド、錐と余錐、極限と余極限などがある。ただし、矢を2回反転させればもとの状態に戻るので、ココモナドはない。</p>
        <p>そして、終対象は反対圏の始対象だと言える。</p>
        <h2 data-number="5.5" id="同型"><span class="header-section-number">5.5</span> 同型</h2>
        <p>プログラマーである我々は、等価性を定義することが簡単な作業ではないことをよく知っている。2つのオブジェクトが等しいとはどういう意味だろう？
          メモリ内の同じ場所を占有する必要があるだろうか
          (ポインタの等価性)。あるいは、すべての要素の値が同じであれば十分だろうか？
          2つの複素数のうち、一方を実部と虚部で表し、もう一方を絶対値と角度で表すと、2つの複素数は等しいだろうか。数学者たちが等価性の意味を解明済みだろう、と思うかも知れないが、そうではない。数学者も、等価性に複数の競合する定義があるという、同じ問題を抱えている。命題的等価性、内包的等価性、外延的等価性、ホモトピー型理論の経路としての等価性がある。そして同型射のより弱い概念、さらには同値性のより弱い概念もある。
        </p>
        <p>
          直観としては、同型の対象は同じように見える――同じ形をしている。これは、1対1の写像において、ある対象の一部はすべて別の対象の一部にそれぞれ対応することを意味する。調べ得る限り、2つの物体はお互いの完全なコピーだ。数学的には、対象<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への写像があり、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>から対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>への写像があり、それらが互いに逆であることを意味する。圏論では、写像を射に置き換える。同型は可逆な射だ。つまり、互いに逆である射のペアだ。</p>
        <p>逆についての理解は合成と恒等射の観点に基づいている。射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>は、合成が恒等射の場合、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>の逆になる。これらの2つの射は、構成する方法が2つあるので、実際には2つの等式で表される:</p>
        <div class="sourceCode" id="cb75">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">.</span> g <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>g <span class="op">.</span> f <span class="ot">=</span> <span class="fu">id</span></span></code></pre>
        </div>
        <p>始 (終) 対象が同型を除いて一意だと言ったとき、2つの始 (終)
          対象は同型だということを意味していた。それは簡単に理解できる。2つの始対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{1}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>2</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{2}</annotation>
            </semantics>
          </math>があるとしよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{1}</annotation>
            </semantics>
          </math>が始対象であるため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{1}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>2</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{2}</annotation>
            </semantics>
          </math>への一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>が存在する。同様に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>2</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{2}</annotation>
            </semantics>
          </math>が始対象であるため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>2</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{2}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{1}</annotation>
            </semantics>
          </math>への一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>が存在する。これらの2つの射を合成すると何になるだろう？</p>
        <figure>
          <img src="images/uniqueness.jpg" style="width:40.0%" alt="この図中のすべての射は一意だ" />
          <figcaption aria-hidden="true">この図中のすべての射は一意だ</figcaption>
        </figure>
        <p>合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>∘</mo>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">g\circ f</annotation>
            </semantics>
          </math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{1}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{1}</annotation>
            </semantics>
          </math>への射でなければならない。しかし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{1}</annotation>
            </semantics>
          </math>は始対象なので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{1}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{1}</annotation>
            </semantics>
          </math>へ向かう射は1つだけだ。圏の中なので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{1}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{1}</annotation>
            </semantics>
          </math>への恒等射があるのは分かっている。候補は1つだけなので、それで間違いない。したがって、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>∘</mo>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">g\circ f</annotation>
            </semantics>
          </math>は恒等射と等しくなる。同様に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∘</mo>
                <mi>g</mi>
              </mrow>
              <annotation encoding="application/x-tex">f\circ g</annotation>
            </semantics>
          </math>は恒等射と等しくなければならない。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>2</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{2}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mn>2</mn>
              </msub>
              <annotation encoding="application/x-tex">i_{2}</annotation>
            </semantics>
          </math>に戻る射は1つしかないからだ。これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>が互いに逆でなければならないことを証明している。したがって、任意の2つの始対象は同型だ。</p>
        <p>この証明では、始対象からそれ自体への射の一意性を用いたことに注意してほしい。そうしなければ「同型を除いて」の部分は証明できない。しかし、なぜ<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>の一意性が必要なのだろうか。始対象は同型を除いて一意なだけでなく、<em>一意な</em>同型を除いて一意だからだ。原則として、2つの対象間には複数の同型が存在する可能性があるが、ここではそうではない。この「一意な同型を除いて一意という性質」は、すべての普遍的構成の重要な特性だ。
        </p>
        <h2 data-number="5.6" id="積"><span class="header-section-number">5.6</span> 積</h2>
        <p>次の普遍的構成は積 (product)
          に関するものだ。2つの集合のカルテシアン積が何なのかは知っている。ペアからなる集合だ。しかし、積の集合とそれを構成する集合を結びつけるパターンは何だろう？
          それがわかれば、他の圏にも一般化できるはずだ。</p>
        <p>我々が言えるのは、積から各構成要素への射影 (projection)
          という関数が2つある、ということだけだ。Haskellでは、これら2つの関数は<code>fst</code>と<code>snd</code>と呼ばれ、それぞれペアの最初と2番目の要素を選択する。</p>
        <div class="sourceCode" id="cb76">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fst</span><span class="ot"> ::</span> (a, b) <span class="ot">-&gt;</span> a</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fst</span> (x, y) <span class="ot">=</span> x</span></code></pre>
        </div>
        <div class="sourceCode" id="cb77">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="fu">snd</span><span class="ot"> ::</span> (a, b) <span class="ot">-&gt;</span> b</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="fu">snd</span> (x, y) <span class="ot">=</span> y</span></code></pre>
        </div>
        <p>ここで、関数は引数のパターンマッチングによって定義される。パターン<code>(x, y)</code>は任意のペアにマッチし、要素を変数<code>x</code>と<code>y</code>に抽出する。</p>
        <p>これらの定義は、ワイルドカードを使ってさらに単純化できる。</p>
        <div class="sourceCode" id="cb78">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fst</span> (x, _) <span class="ot">=</span> x</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="fu">snd</span> (_, y) <span class="ot">=</span> y</span></code></pre>
        </div>
        <p>C++では、次のようなテンプレート関数を使う。</p>
        <div class="sourceCode" id="cb79">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>A fst<span class="op">(</span>pair<span class="op">&lt;</span>A<span class="op">,</span> B<span class="op">&gt;</span> <span class="at">const</span> <span class="op">&amp;</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> p<span class="op">.</span>first<span class="op">;</span></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>この一見非常に限られた知識をもって、集合の圏における対象と射のパターンを定義してみよう。このパターンは、2つの集合
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>)
          からなる積の構成につながる。このパターンは、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>と2つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>で構成され、それぞれ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>に接続される。</p>
        <div class="sourceCode" id="cb80">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> c <span class="ot">-&gt;</span> a</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="ot">q ::</span> c <span class="ot">-&gt;</span> b</span></code></pre>
        </div>
        <p><img src="images/productpattern.jpg" style="width:30.0%" /></p>
        <p>このパターンに一致するすべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>が積の候補と見なされる。それは大量にあるかもしれない。</p>
        <p><img src="images/productcandidates.jpg" style="width:40.0%" /></p>
        <p>たとえば、構成要素として、2つのHaskellの型<code>Int</code>と<code>Bool</code>を選択し、それらの積の候補を挙げてみよう。</p>
        <p>1番目の候補は<code>Int</code>だ。<code>Int</code>は<code>Int</code>と<code>Bool</code>の積の候補と見なせるだろうか？
          そう、見なせる――その射影はこうなる:</p>
        <div class="sourceCode" id="cb81">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>p x <span class="ot">=</span> x</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="ot">q ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>q _ <span class="ot">=</span> <span class="dt">True</span></span></code></pre>
        </div>
        <p>これはかなり酷いが、基準を満たしている。</p>
        <p>2番目の候補は<code>(Int, Int, Bool)</code>だ。要素が3つのタプル、あるいはトリプルだ。これを正当な候補にする2つの射を以下に示す
          (ここではトリプルに対してパターンマッチングを使っている)。</p>
        <div class="sourceCode" id="cb82">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>p (x, _, _) <span class="ot">=</span> x</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="ot">q ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>q (_, _, b) <span class="ot">=</span> b</span></code></pre>
        </div>
        <p>1番目の候補は狭すぎ、積の<code>Int</code>次元だけをカバーしている。一方で、2番目の候補は広すぎ、<code>Int</code>次元が重複してしまっている。</p>
        <p>しかし、この普遍的構成の別の部分である順位付けについてはまだ調べていない。そこで、パターンの2つの例を比較できるようにしたい。つまり、対象の1つの候補<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>とその2つの射影<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>および<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>を、別の対象の候補<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>とその2つの射影<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">p&#39;</annotation>
            </semantics>
          </math>および<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>q</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">q&#39;</annotation>
            </semantics>
          </math>と比較したい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>がある場合に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>よりも「優れている」と言いたいのだが、それではあまりにも弱い。それに加えて、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>の射影が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>の射影よりも「優れている」、すなわち「より普遍的」であってほしい。つまり、射影<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">p&#39;</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>q</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">q&#39;</annotation>
            </semantics>
          </math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>を使って再構成できる。</p>
        <div class="sourceCode" id="cb83">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>p&#39; <span class="ot">=</span> p <span class="op">.</span> m</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>q&#39; <span class="ot">=</span> q <span class="op">.</span> m</span></code></pre>
        </div>
        <p><img src="images/productranking.jpg" style="width:40.0%" /></p>
        <p>別の観点でこれらの方程式を見ると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">p&#39;</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>q</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">q&#39;</annotation>
            </semantics>
          </math>を<em>分解</em>
          (factorize)
          している。これらの方程式が自然数について成り立ち、ドットが乗算であると仮定する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">p&#39;</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>q</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">q&#39;</annotation>
            </semantics>
          </math>で共通の係数だ。</p>
        <p>ある種の直観を築くために、2つの正準射影 (canonical projection)
          <code>fst</code>と<code>snd</code>を持つペア<code>(Int, Bool)</code>が、前に提示した2つの候補より本当に<em>優れている</em>ことを示そう。
        </p>
        <p><img src="images/not-a-product.jpg" style="width:40.0%" /></p>
        <p>1番目の候補に対する写像<code>m</code>は次のようになる:</p>
        <div class="sourceCode" id="cb84">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="ot">m ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>)</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>m x <span class="ot">=</span> (x, <span class="dt">True</span>)</span></code></pre>
        </div>
        <p>実際、2つの射影<code>p</code>と<code>q</code>は次のように再構成できる:</p>
        <div class="sourceCode" id="cb85">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>p x <span class="ot">=</span> <span class="fu">fst</span> (m x) <span class="ot">=</span> x</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>q x <span class="ot">=</span> <span class="fu">snd</span> (m x) <span class="ot">=</span> <span class="dt">True</span></span></code></pre>
        </div>
        <p>2番目の例の<code>m</code>も同様に一意に定まる:</p>
        <div class="sourceCode" id="cb86">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>m (x, _, b) <span class="ot">=</span> (x, b)</span></code></pre>
        </div>
        <p>
          <code>(Int, Bool)</code>が2つの候補のどちらよりも優れていることを示せた。その逆がなぜ真ではないのかを見てみよう。<code>p</code>と<code>q</code>から<code>fst</code>と<code>snd</code>を再構築するのに役立つ<code>m'</code>を見つけられるだろうか？
        </p>
        <div class="sourceCode" id="cb87">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fst</span> <span class="ot">=</span> p <span class="op">.</span> m&#39;</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="fu">snd</span> <span class="ot">=</span> q <span class="op">.</span> m&#39;</span></code></pre>
        </div>
        <p>
          1番目の例では、<code>q</code>は常に<code>True</code>を返す。しかし、第2要素が<code>False</code>であるペアが存在するのは分かっている。したがって、<code>q</code>からは<code>snd</code>を再構築できない。
        </p>
        <p>2番目の例は別物だ:
          <code>p</code>または<code>q</code>を経た後でも十分な情報が保持される。しかし、<code>fst</code>と<code>snd</code>を分解する方法が複数ある。<code>p</code>と<code>q</code>はどちらもトリプルの第2要素を無視するので、<code>m'</code>には何でも入れられる。たとえば、
        </p>
        <div class="sourceCode" id="cb88">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>m&#39; (x, b) <span class="ot">=</span> (x, x, b)</span></code></pre>
        </div>
        <p>あるいは</p>
        <div class="sourceCode" id="cb89">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>m&#39; (x, b) <span class="ot">=</span> (x, <span class="dv">42</span>, b)</span></code></pre>
        </div>
        <p>などを定義できる。</p>
        <p>
          以上すべてをまとめると、2つの射影<code>p</code>と<code>q</code>を持つ任意の型<code>c</code>について、それらの射影を分解する一意な<code>m</code>が<code>c</code>からカルテシアン積<code>(a, b)</code>へと存在する。実際には、<code>p</code>と<code>q</code>を組み合わせてペアにしているだけだ。
        </p>
        <div class="sourceCode" id="cb90">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="ot">m ::</span> c <span class="ot">-&gt;</span> (a, b)</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>m x <span class="ot">=</span> (p x, q x)</span></code></pre>
        </div>
        <p>これによってカルテシアン積<code>(a, b)</code>がベストマッチとなり、すなわち、この普遍的構成が集合の圏で機能することを意味する。これは任意の2つの集合の積を選ぶ。</p>
        <p>さて、集合のことは忘れて、同じ普遍的構成を使って任意の圏にある2つの対象の積を定義しよう。そのような積が必ず存在するわけではないが、存在する場合は、一意な同型を除いて一意だ。</p>
        <blockquote>
          <p>2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>a</mi>
                <annotation encoding="application/x-tex">a</annotation>
              </semantics>
            </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>b</mi>
                <annotation encoding="application/x-tex">b</annotation>
              </semantics>
            </math>の<strong>積</strong>は2つの射影を伴う対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>c</mi>
                <annotation encoding="application/x-tex">c</annotation>
              </semantics>
            </math>であり、別の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>c</mi>
                  <mi>′</mi>
                </mrow>
                <annotation encoding="application/x-tex">c&#39;</annotation>
              </semantics>
            </math>が伴う2つの射影が、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>c</mi>
                  <mi>′</mi>
                </mrow>
                <annotation encoding="application/x-tex">c&#39;</annotation>
              </semantics>
            </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>c</mi>
                <annotation encoding="application/x-tex">c</annotation>
              </semantics>
            </math>へと存在する一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>m</mi>
                <annotation encoding="application/x-tex">m</annotation>
              </semantics>
            </math>によって分解されるものだ。</p>
        </blockquote>
        <p>2つの候補から分解関数<code>m</code>を生成する (高階) 関数は、<span id="factorizer"
            class="keyword">factorizer</span>と呼ばれることもある。この例では、次の関数になる:</p>
        <div class="sourceCode" id="cb91">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorizer ::</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> (a, b))</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>factorizer p q <span class="ot">=</span> \x <span class="ot">-&gt;</span> (p x, q x)</span></code></pre>
        </div>
        <h2 data-number="5.7" id="余積"><span class="header-section-number">5.7</span> 余積</h2>
        <p>圏論のすべての構成と同じく、積にも双対があり、余積 (coproduct)
          と呼ばれる。積のパターンの矢を逆にすると、2つの<em>単射</em> (injection)
          <code>i</code>と<code>j</code>を伴う対象<em>c</em>になる。すなわち、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>への射だ。
        </p>
        <div class="sourceCode" id="cb92">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="ot">i ::</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="ot">j ::</span> b <span class="ot">-&gt;</span> c</span></code></pre>
        </div>
        <p><img src="images/coproductpattern.jpg" style="width:40.0%" /></p>
        <p>順位付けも逆転している:
          対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>は、もし<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>が単射を分解するなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>i</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">i&#39;</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>j</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">j&#39;</annotation>
            </semantics>
          </math>の単射を伴う対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>よりも「優れて」いる。</p>
        <div class="sourceCode" id="cb93">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>i&#39; <span class="ot">=</span> m <span class="op">.</span> i</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>j&#39; <span class="ot">=</span> m <span class="op">.</span> j</span></code></pre>
        </div>
        <p><img src="images/coproductranking.jpg" style="width:40.0%" /></p>
        <p>「最も優れた」対象は、他のすべてのパターンとつながる一意な射を持つもので、余積と呼ばれ、もし存在すれば、一意な同型を除いて一意だ。</p>
        <blockquote>
          <p>2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>a</mi>
                <annotation encoding="application/x-tex">a</annotation>
              </semantics>
            </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>b</mi>
                <annotation encoding="application/x-tex">b</annotation>
              </semantics>
            </math>の<strong>余積</strong>は2つの単射を伴う対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>c</mi>
                <annotation encoding="application/x-tex">c</annotation>
              </semantics>
            </math>であり、別の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>c</mi>
                  <mi>′</mi>
                </mrow>
                <annotation encoding="application/x-tex">c&#39;</annotation>
              </semantics>
            </math>が伴う2つの単射が、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>c</mi>
                <annotation encoding="application/x-tex">c</annotation>
              </semantics>
            </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>c</mi>
                  <mi>′</mi>
                </mrow>
                <annotation encoding="application/x-tex">c&#39;</annotation>
              </semantics>
            </math>へと存在する一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>m</mi>
                <annotation encoding="application/x-tex">m</annotation>
              </semantics>
            </math>によって分解されるものだ。</p>
        </blockquote>
        <p>集合の圏では、余積は2つの集合の<em>非交和</em> (disjoint union)
          だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の非交和の要素は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の要素か<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の要素のどちらかだ。2つの集合が重なる場合、非交和には共通部分のコピーが2つ含まれる。非交和の要素は起源を示す識別子でタグ付けされていると見なせる。</p>
        <p>
          プログラマーにとっては、型の観点から余積を理解する方が簡単だ。それは2つの型のタグ付き共用体だ。C++は共用体をサポートしているが、それらはタグ付けされていない。つまり、プログラム内では共用体のどのメンバーが有効であるかを何らかの方法で追跡しなければならないということだ。タグ付き共用体を作成するには、タグ――列挙型――を定義して共用体と結びつける必要がある。たとえば、<code>int</code>と<code>char const*</code>のタグ付き共用体は次のように実装できる。
        </p>
        <div class="sourceCode" id="cb94">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Contact <span class="op">{</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">enum</span> <span class="op">{</span> isPhone<span class="op">,</span> isEmail <span class="op">}</span> tag<span class="op">;</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">union</span> <span class="op">{</span> <span class="dt">int</span> phoneNum<span class="op">;</span> <span class="dt">char</span> <span class="at">const</span> <span class="op">*</span> emailAddr<span class="op">;</span> <span class="op">};</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre>
        </div>
        <p>この2つの単射は、コンストラクターとしても関数としても実装できる。たとえば、最初の単射を関数<code>PhoneNum</code>として実装すると次のようになる:</p>
        <div class="sourceCode" id="cb95">
          <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>Contact PhoneNum<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    Contact c<span class="op">;</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>    c<span class="op">.</span>tag <span class="op">=</span> isPhone<span class="op">;</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>    c<span class="op">.</span>phoneNum <span class="op">=</span> n<span class="op">;</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c<span class="op">;</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>これは<code>Contact</code>に整数を注入 (inject) する。</p>
        <p>タグ付き共用体は<span id="variant"
            class="keyword">variant</span>とも呼ばれ、boostライブラリに非常に汎用的な<code>boost::variant</code>という実装がある<a href="#fn4"
            class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>。</p>
        <p>Haskellでは、データコンストラクターをバーティカルバーで区切ることで、任意のデータ型をタグ付き共用体にまとめられる。<code>Contact</code>の例だと次のような宣言になる:</p>
        <div class="sourceCode" id="cb96">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Contact</span> <span class="ot">=</span> <span class="dt">PhoneNum</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">EmailAddr</span> <span class="dt">String</span></span></code></pre>
        </div>
        <p>ここで、<code>PhoneNum</code>と<code>EmailAddr</code>は、コンストラクター
          (単射) としても、パターンマッチングのタグとしても機能する
          (これについては後で詳しく説明する)。たとえば、電話番号を使って連絡先を作成する方法は次のとおりだ:</p>
        <div class="sourceCode" id="cb97">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="ot">helpdesk ::</span> <span class="dt">Contact</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>helpdesk <span class="ot">=</span> <span class="dt">PhoneNum</span> <span class="dv">2222222</span></span></code></pre>
        </div>
        <p>積の正規実装がプリミティブなペアとしてHaskellに組み込まれているのに対し、余積の正規実装は<code>Either</code>と呼ばれるデータ型であり、標準のPreludeで次のように定義されている:</p>
        <div class="sourceCode" id="cb98">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Either</span> a b <span class="ot">=</span> <span class="dt">Left</span> a <span class="op">|</span> <span class="dt">Right</span> b</span></code></pre>
        </div>
        <p>
          これは<code>a</code>と<code>b</code>の2つの型によってパラメーター化され、2つのコンストラクターを持つ。<code>Left</code>は型<code>a</code>の値をとり、<code>Right</code>は型<code>b</code>の値を取る。
        </p>
        <p>
          積についてfactorizerを定義したのと同様に、余積についても定義できる。型の候補<code>c</code>と2つの単射の候補<code>i</code>と<code>j</code>について、<code>Either</code>のfactorizerは次の分解関数を生成する:
        </p>
        <div class="sourceCode" id="cb99">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorizer ::</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Either</span> a b <span class="ot">-&gt;</span> c</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>factorizer i j (<span class="dt">Left</span> a)  <span class="ot">=</span> i a</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>factorizer i j (<span class="dt">Right</span> b) <span class="ot">=</span> j b</span></code></pre>
        </div>
        <aside id="footnotes" class="footnotes footnotes-end-of-section" role="doc-footnote">
          <hr />
          <ol start="4">
            <li id="fn4">
              <p>訳註: C++17以降では<a
                  href="https://cpprefjp.github.io/reference/variant/variant.html">std::variant</a>が利用できる。<a
                  href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p>
            </li>
          </ol>
        </aside>
        <h2 data-number="5.8" id="非対称性"><span class="header-section-number">5.8</span> 非対称性</h2>
        <p>
          これまでに2組の双対の定義を見てきた。終対象の定義は、始対象の定義から矢の方向を逆にすることで得られ、余積の定義は積の定義から得られる。しかし、集合の圏では、始対象と終対象は大きく異なり、余積と積は大きく異なる。後述するように、積は乗算のように振る舞い、終対象は1の役目を果たし、余積は和のように振る舞い、始対象は0の役目を果たす。特に、有限集合の場合、積のサイズは個々の集合のサイズの積であり、余積のサイズはサイズの合計だ。
        </p>
        <p>これは集合の圏が矢の反転に関して対称でないことを示している。</p>
        <p>空集合では、どの集合に対しても一意な射 (<code>absurd</code>関数)
          がある一方で、戻ってくる射はないことに注意してほしい。単集合では、どの集合からも一意な射が来るうえに、(空集合を除く)
          すべての集合へ向かう外向きの射<em>も</em>ある。これまで見てきたように、終対象から発するこれらの射は、他の集合の要素を選択するのに非常に重要な役目を果たしている
          (空集合には要素がないので、選択するものは何もない)。</p>
        <p>
          余積と異なるのは、単集合と積の関係だ。unit型<code>()</code>で表される単集合を、積パターンのもう1つの――非常に劣った――候補として使うことを考えてみてほしい。それを2つの射影<code>p</code>と<code>q</code>、すなわち単集合から各構成要素の集合への関数として実装してみよう。それらは具体的な要素をそれぞれの集合から選択する。積は普遍的なので、ここでの候補の単集合から積への(一意な)
          射<code>m</code>も存在する。この射は積の集合から要素を選択する。つまり、具体的なペアを選択する。さらに、次の2つの射影を分解する:</p>
        <div class="sourceCode" id="cb100">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> <span class="fu">fst</span> <span class="op">.</span> m</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>q <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> m</span></code></pre>
        </div>
        <p>単集合の唯一の要素である値<code>()</code>に作用させると、これら2つの式は次のようになる:</p>
        <div class="sourceCode" id="cb101">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>p () <span class="ot">=</span> <span class="fu">fst</span> (m ())</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>q () <span class="ot">=</span> <span class="fu">snd</span> (m ())</span></code></pre>
        </div>
        <p>
          <code>m ()</code>は<code>m</code>によって選択された積の要素なので、これらの式は、第1の集合から<code>p</code>によって選択された要素<code>p ()</code>が、<code>m</code>によって選択されたペアの第1要素であることを示す。同様に、<code>q ()</code>は第2要素に等しい。これは、積の要素は構成要素の集合からの要素のペアであるという理解と完全に一致している。
        </p>
        <p>
          余積にはそのような単純な解釈はない。単集合を余積での候補として要素を抽出しようと試みることもできるが、2つの射影がそこから出てくるのではなく、2つの単射がそこに入ることになる。それらはその起源について何も教えてくれないだろう
          (実際、入力パラメーターが無視されるのを見てきた)。また、余積から単集合への一意な射についても同様だろう。集合の圏は、始対象の向きで見たときと終対象から見たときとでは全く違って見える。</p>
        <p>これは集合の固有の特性ではなく、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>で射として使う関数の特性だ。関数は
          (一般に) 非対称だ。説明しよう。</p>
        <p>関数は、その始域のすべての要素に対して定義する必要がある
          (プログラミングでは、<span id="total" class="keyword">全</span>関数
          (total function)
          と呼ぶ)。しかし、終域全体を網羅する必要はない。すでにその極端な例をいくつか見てきた。単集合からの関数――終域内の1つの要素だけを選択する関数のことだ。(実際に、空集合からの関数は本当に極端だ。)
          始域のサイズが終域のサイズよりもずっと小さい場合、そのような関数はよく、始域を終域に埋め込むようなものと考えられる。たとえば、単集合からの関数は、その1つの要素を終域に埋め込むものだと考えられる。私はそれらを<span
            id="embedding" class="keyword">埋め込み</span> (embedding)
          関数と呼んでいるが、数学者は名前を反対に付けた方を好む。つまり、終域をきっちり満たす関数を<span id="surjective" class="keyword">全射</span> (surjective)
          または<span id="onto" class="keyword">上への</span> (onto) 関数と呼ぶ。</p>
        <p>非対称性のもう1つの原因は、関数が始域の多くの要素を終域の1つの要素に写せることだ。それらは自身を潰す
          (collapse)
          ことができる。極端な例としては、集合全体を単集合に写す関数が挙げられる。これまでに、まさにそれを行う多相<code>unit</code>関数を見てきた。合成すると、より酷く潰すことにしかならない。潰す関数2つの合成は、個々の関数よりもさらに潰すことになる。数学者は潰さない関数を<span
            id="injective" class="keyword">単射</span> (injective) または<span id="one-to-one" class="keyword">1対1</span>
          (one-to-one)
          という名前で呼ぶ。</p>
        <p>当然、埋め込みも潰しもしない関数もある。それらは<span id="bijections" class="keyword">双射</span> (bijection)
          と呼ばれ、可逆なので真に対称だ。集合の圏では、同型は双射と同じだ。</p>
        <h2 data-number="5.9" id="課題-4"><span class="header-section-number">5.9</span> 課題</h2>
        <ol type="1">
          <li>
            <p>終対象が一意な同型を除いて一意であることを示せ。</p>
          </li>
          <li>
            <p>ポセットの中の2つの対象の積は何か？ ヒント:
              普遍的構成を使う。</p>
          </li>
          <li>
            <p>ポセットの中の2つの対象の余積は何か？</p>
          </li>
          <li>
            <p>Haskellの<code>Either</code>に相当するものを、(Haskell以外の)
              好きな言語で総称型として実装せよ。</p>
          </li>
          <li>
            <p><code>Either</code>が、2つの単射を伴う<code>int</code>よりも「優れた」余積であることを示せ。</p>
            <div class="sourceCode" id="cb102">
              <pre
                class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> n<span class="op">;</span> <span class="op">}</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> j<span class="op">(</span><span class="dt">bool</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> b<span class="op">?</span> <span class="dv">0</span><span class="op">:</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span></code></pre>
            </div>
            <p>ヒント: 関数</p>
            <div class="sourceCode" id="cb103">
              <pre
                class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> m<span class="op">(</span>Either <span class="at">const</span> <span class="op">&amp;</span> e<span class="op">);</span></span></code></pre>
            </div>
            <p>を、<code>i</code>と<code>j</code>を分解するように定義する。</p>
          </li>
          <li>
            <p>
              前の問題の続き。<code>i</code>と<code>j</code>という2つの単射を持つ<code>int</code>が、<code>Either</code>よりも「優れている」ことはないと主張するにはどうすればよいか？
            </p>
          </li>
          <li>
            <p>さらに続き: 単射についてはどうか？</p>
            <div class="sourceCode" id="cb104">
              <pre
                class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> i<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> j<span class="op">(</span><span class="dt">bool</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> b<span class="op">?</span> <span class="dv">0</span><span class="op">:</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span></code></pre>
            </div>
          </li>
          <li>
            <p>
              <code>int</code>と<code>bool</code>の余積の候補として、<code>Either</code>への射を複数許容するという理由で<code>Either</code>より劣るものを挙げよ。
            </p>
          </li>
        </ol>
        <h2 data-number="5.10" id="参考文献-1"><span class="header-section-number">5.10</span> 参考文献</h2>
        <ol type="1">
          <li>The Catsters, <a href="https://www.youtube.com/watch?v=upCSDIO9pjc">Products and
              Coproducts</a> video.</li>
        </ol>
        <h1 data-number="6" id="シンプルな代数的データ型"><span class="header-section-number">6</span> シンプルな代数的データ型</h1>
        <p>
          型を組み合わせる2つの基本的な方法として、積と余積を使う方法を見てきた。日常のプログラミングにおける多くのデータ構造は、この2つのメカニズムだけを使って構築できると分かった。この事実は重要で実用的な結果をもたらす。データ構造の特性の多くは合成可能だ。たとえば、基本型の値が等価かどうか比較する方法を知っていて、それらの比較を積と余積の型に一般化する方法を知っていれば、自動的に複合型の等値演算子を導出できる。Haskellでは、複合型の大きな部分集合に対して、等価性、比較、文字列への変換、文字列からの変換などを自動的に導出できる。
        </p>
        <p>次に、直積型 (product type) と直和型 (sum type)
          がプログラミングに現れる様子を詳しく見てみよう。</p>
        <h2 data-number="6.1" id="直積型"><span class="header-section-number">6.1</span> 直積型</h2>
        <p>プログラム言語における2つの型の積の正統な実装はペアだ。Haskellではペアはプリミティブな型コンストラクターだ。C++では比較的複雑なテンプレートとして標準ライブラリで定義されている。</p>
        <p><img src="images/pair.jpg" style="width:35.0%" /></p>
        <p>
          ペアは厳密には可換ではない。ペア<code>(Int, Bool)</code>は、同じ情報を保持していても、ペア<code>(Bool, Int)</code>には置き換えられない。しかし、それらは同型を除いて可換だ。同型は<code>swap</code>関数
          (それ自体の逆関数) で与えらる:</p>
        <div class="sourceCode" id="cb105">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="ot">swap ::</span> (a, b) <span class="ot">-&gt;</span> (b, a)</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>swap (x, y) <span class="ot">=</span> (y, x)</span></code></pre>
        </div>
        <p>この2つのペアは、単に同じデータを格納するために異なるフォーマットを使っていると見なせる。ビッグエンディアンとリトルエンディアンのようなものだ。</p>
        <p>
          ペアの中にペアをネストすれば型をいくつでも積に結合できるが、もっと簡単な方法がある。ネストされたペアはタプルと等価なのだ。これは、ペアをネストする様々な方法が同型であるという事実からの帰結だ。3つの型<code>a</code>、<code>b</code>、<code>c</code>を順に積によって結合する場合、次の2つの方法がある:
        </p>
        <div class="sourceCode" id="cb106">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>((a, b), c)</span></code></pre>
        </div>
        <p>あるいは</p>
        <div class="sourceCode" id="cb107">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>(a, (b, c))</span></code></pre>
        </div>
        <p>これらは型が異なり、一方の型を期待する関数に他方の型を渡すことはできない。しかし、要素は1対1で対応している。そのため、相互に写す関数が存在し:</p>
        <div class="sourceCode" id="cb108">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> ((a, b), c) <span class="ot">-&gt;</span> (a, (b, c))</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>alpha ((x, y), z) <span class="ot">=</span> (x, (y, z))</span></code></pre>
        </div>
        <p>その逆関数も存在する:</p>
        <div class="sourceCode" id="cb109">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha_inv ::</span> (a, (b, c)) <span class="ot">-&gt;</span> ((a, b), c)</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>alpha_inv  (x, (y, z)) <span class="ot">=</span> ((x, y), z)</span></code></pre>
        </div>
        <p>したがって、これは同型だ。データは同じで、再パッケージ化するための方法が違うにすぎない。</p>
        <p>直積型の生成は、型における二項演算として解釈できる。この観点から見ると、上記の同型は、モノイドで見た結合則に非常によく似ている:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>*</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>*</mo>
                <mi>c</mi>
                <mo>=</mo>
                <mi>a</mi>
                <mo>*</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>*</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">(a * b) * c = a * (b * c)</annotation>
            </semantics>
          </math></p>
        <p>ただし、モノイドの場合は積を構成する2つの方法が等価であったのに対して、ここでは「同型を除いて」等価であるにすぎない。</p>
        <p>
          同型を認めて、厳密な等価性に固執しないならば、さらに進んで、1が乗算の単位であるのと同じようにunit型<code>()</code>が積の単位であるのを示せる。実際、ある型<code>a</code>の値と単位の組み合わせは、何の情報も追加しない。型:
        </p>
        <div class="sourceCode" id="cb110">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a>(a, ())</span></code></pre>
        </div>
        <p>は<code>a</code>と同型だ。その同型はこのようになる:</p>
        <div class="sourceCode" id="cb111">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rho ::</span> (a, ()) <span class="ot">-&gt;</span> a</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>rho (x, ()) <span class="ot">=</span> x</span></code></pre>
        </div>
        <div class="sourceCode" id="cb112">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rho_inv ::</span> a <span class="ot">-&gt;</span> (a, ())</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>rho_inv x <span class="ot">=</span> (x, ())</span></code></pre>
        </div>
        <p>これらの観察は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>
          (集合の圏) は<span id="monoidal_category" class="keyword">モノイダル圏</span> (monoidal category)
          である、と述べることによって形式化できる。それは、対象を
          (ここではカルテシアン積で)
          乗算できるという意味で、モノイドでもある圏だ。モノイダル圏についてさらに説明しよう。完全な定義は将来的に示す。</p>
        <p>
          Haskellには直積型を定義するもっと一般的な方法がある。特に、すぐ後で説明するとおり、直和型と組み合わされたときによく分かる。その定義には複数の引数を持つ名前付きコンストラクターを使う。たとえば、ペアは次のようにも定義できる:
        </p>
        <div class="sourceCode" id="cb113">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Pair</span> a b <span class="ot">=</span> <span class="dt">P</span> a b</span></code></pre>
        </div>
        <p>
          ここで、<code>Pair a b</code>は他の2つの型<code>a</code>と<code>b</code>によってパラメーター化された型の名前であり、<code>P</code>はデータコンストラクターの名前だ。ペアの型を定義するには<code>Pair</code>型コンストラクターに2つの型を渡す。適切な型の2つの値をコンストラクター<code>P</code>に渡すことで、ペアの値を構成する。たとえば、値<code>stmt</code>を<code>String</code>と<code>Bool</code>のペアとして定義したとする:
        </p>
        <div class="sourceCode" id="cb114">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stmt ::</span> <span class="dt">Pair</span> <span class="dt">String</span> <span class="dt">Bool</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>stmt <span class="ot">=</span> <span class="dt">P</span> <span class="st">&quot;This statements is&quot;</span> <span class="dt">False</span></span></code></pre>
        </div>
        <p>
          最初の行は型宣言だ。これは型コンストラクター<code>Pair</code>を使い、その<code>Pair</code>の総称定義の<code>a</code>と<code>b</code>を、それぞれ<code>String</code>と<code>Bool</code>で置き換えたものだ。2行目では、具体的な文字列と具体的なブール値をデータコンストラクター<code>P</code>に渡すことで、実際の値を定義している。型コンストラクターは型を構成するために使われ、データコンストラクターは値を構成するために使われる。
        </p>
        <p>Haskellでは型コンストラクターとデータコンストラクターの名前空間が分離されているため、次のように両方に同じ名前が使われていることがよくある:</p>
        <div class="sourceCode" id="cb115">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Pair</span> a b <span class="ot">=</span> <span class="dt">Pair</span> a b</span></code></pre>
        </div>
        <p>
          さらに目を細めれば、組み込みのペア型を、この種の宣言のバリエーションとして見ることもできる。この場合、<code>Pair</code>という名前は<code>(,)</code>という二項演算子で置き換えられる。実際、<code>(,)</code>を他の名前付きコンストラクターと同じように扱い、前置記法を使ってペアを作成できる:
        </p>
        <div class="sourceCode" id="cb116">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>stmt <span class="ot">=</span> (,) <span class="st">&quot;This statement is&quot;</span> <span class="dt">False</span></span></code></pre>
        </div>
        <p>同様に、<code>(,,)</code>を使ってトリプルを作成する、などもできる。</p>
        <p>総称ペアやタプルを使う代わりに、次のように特定の名前を付けた直積型を定義してもよい:</p>
        <div class="sourceCode" id="cb117">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stmt</span> <span class="ot">=</span> <span class="dt">Stmt</span> <span class="dt">String</span> <span class="dt">Bool</span></span></code></pre>
        </div>
        <p>
          これは単に<code>String</code>と<code>Bool</code>の積だが、独自の名前とコンストラクターが与えられている。このスタイルの宣言の利点は、内容は同じでも意味と機能が異なり、互いに置き換えられない型を多数定義できることだ。
        </p>
        <p>
          タプルや複数の引数を持つコンストラクターを使ってプログラミングすると、複雑で間違いが生じやすくなる。どのコンポーネントが何を表しているかを追うのが大変になるからだ。コンポーネントに名前を付ける方が望ましい場合がよくある。名前付きフィールドを持つ直積型は、Haskellでは<span
            id="record" class="keyword">record</span>、Cでは<code>struct</code>と呼ばれる。</p>
        <h2 data-number="6.2" id="レコード"><span class="header-section-number">6.2</span> レコード</h2>
        <p>簡単な例を見てみよう。化学元素を記述するために、2つの文字列
          (名前と元素記号) と整数 (原子番号)
          を組み合わせて1つのデータ構造にしたい。タプル<code>(String, String, Int)</code>を使えば、どのコンポーネントが何を表しているかを記憶できる。コンポーネントはパターンマッチングによって抽出しよう。たとえば、この関数は元素記号が名前の接頭辞かをチェックする
          (<strong>He</strong>は<strong>Helium</strong>の接頭辞だ)。</p>
        <div class="sourceCode" id="cb118">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="ot">startsWithSymbol ::</span> (<span class="dt">String</span>, <span class="dt">String</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>startsWithSymbol (name, symbol, _) <span class="ot">=</span> isPrefixOf symbol name</span></code></pre>
        </div>
        <p>このコードは間違いが生じやすく、読むのもメンテナンスするのも困難だ。レコードを定義する方がはるかに良い。</p>
        <div class="sourceCode" id="cb119">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Element</span> <span class="ot">=</span> <span class="dt">Element</span> {<span class="ot"> name         ::</span> <span class="dt">String</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>                       ,<span class="ot"> symbol       ::</span> <span class="dt">String</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>                       ,<span class="ot"> atomicNumber ::</span> <span class="dt">Int</span> }</span></code></pre>
        </div>
        <p>2つの表現は同型だ。そのことは、互いに逆になっている2つの変換関数からも分かる。</p>
        <div class="sourceCode" id="cb120">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tupleToElem ::</span> (<span class="dt">String</span>, <span class="dt">String</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Element</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>tupleToElem (n, s, a) <span class="ot">=</span> <span class="dt">Element</span> { name <span class="ot">=</span> n</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>                                , symbol <span class="ot">=</span> s</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>                                , atomicNumber <span class="ot">=</span> a }</span></code></pre>
        </div>
        <div class="sourceCode" id="cb121">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="ot">elemToTuple ::</span> <span class="dt">Element</span> <span class="ot">-&gt;</span> (<span class="dt">String</span>, <span class="dt">String</span>, <span class="dt">Int</span>)</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>elemToTuple e <span class="ot">=</span> (name e, symbol e, atomicNumber e)</span></code></pre>
        </div>
        <p>
          レコードのフィールド名は、それらのフィールドにアクセスするための関数としても機能することに注意してほしい。たとえば、<code>atomicNumber</code>は<code>e</code>から<code>atomicNumber</code>フィールドを取得する。つまり、<code>atomicNumber</code>は次のような型の関数として使われる:
        </p>
        <div class="sourceCode" id="cb122">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="ot">atomicNumber ::</span> <span class="dt">Element</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre>
        </div>
        <p>
          <g>Element</g>のレコード構文によって、関数<g>startsWithSymbol</g>はより読みやすくなる:
        </p>
        <div class="sourceCode" id="cb123">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="ot">startsWithSymbol ::</span> <span class="dt">Element</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>startsWithSymbol e <span class="ot">=</span> isPrefixOf (symbol e) (name e)</span></code></pre>
        </div>
        <p>Haskellのトリックを使って、関数<code>isPrefixOf</code>をバッククォーテーションで囲むことで中置演算子に変換すれば、まるで文のように読めるようにさえできる:</p>
        <div class="sourceCode" id="cb124">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a>startsWithSymbol e <span class="ot">=</span> symbol e <span class="ot">`isPrefixOf`</span> name e</span></code></pre>
        </div>
        <p>中置演算子は関数呼び出しよりも優先順位が低いため、この場合は括弧を省略できる。</p>
        <h2 data-number="6.3" id="直和型"><span class="header-section-number">6.3</span> 直和型</h2>
        <p>集合の圏の積が直積型を生み出すのと同じように、余積は直和型を生み出す。Haskellにおける直和型の標準的な実装は次のようなものだ:</p>
        <div class="sourceCode" id="cb125">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Either</span> a b <span class="ot">=</span> <span class="dt">Left</span> a <span class="op">|</span> <span class="dt">Right</span> b</span></code></pre>
        </div>
        <p>また、ペアと同様に、<code>Either</code>は (同型を除いて)
          可換であり、ネストでき、ネストの順序は (同型を除いて)
          無関係だ。したがって、たとえば、トリプルに相当する和:</p>
        <div class="sourceCode" id="cb126">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">OneOfThree</span> a b c <span class="ot">=</span> <span class="dt">Sinistral</span> a <span class="op">|</span> <span class="dt">Medial</span> b <span class="op">|</span> <span class="dt">Dextral</span> c</span></code></pre>
        </div>
        <p>などを定義できる。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>は余積に関する
          (対称な)
          モノイダル圏でもあることがわかる。二項演算の役割を演じるのは非交和であり、単位元の役割を演じるのは始対象だ。型に関しては、モノイダル演算子として<code>Either</code>があり、中立元として無人型
          (uninhabited type) である<code>Void</code>がある。
          <code>Either</code>は加算、<code>Void</code>は0と見なせる。実際、直和型に<code>Void</code>を足しても内容は変わらない。例として:
        </p>
        <div class="sourceCode" id="cb127">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Either</span> a <span class="dt">Void</span></span></code></pre>
        </div>
        <p>は<code>a</code>と同型だ。これは、この型の<code>Right</code>バージョンを構築する方法がないためだ。型<code>Void</code>に値は存在しない。
          <code>Either a Void</code>の唯一の要素は、<code>Left</code>コンストラクターを使って構築され、単純に型<code>a</code>の値をカプセル化する。したがって、象徴的に、<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>+</mo>
                <mn>0</mn>
                <mo>=</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">a + 0 = a</annotation>
            </semantics>
          </math>となる。
        </p>
        <p>直和型はHaskellではごく普通に使われるが、C++で同等のものであるunionやvariantは稀にしか使われない。その理由はいくつかある。</p>
        <p>まず、最も単純な直和型は単なる列挙であり、C++では<code>enum</code>を使って実装されている。Haskellの直和型:</p>
        <div class="sourceCode" id="cb128">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Color</span> <span class="ot">=</span> <span class="dt">Red</span> <span class="op">|</span> <span class="dt">Green</span> <span class="op">|</span> <span class="dt">Blue</span></span></code></pre>
        </div>
        <p>にC++で相当するものは:</p>
        <div class="sourceCode" id="cb129">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> <span class="op">{</span> Red<span class="op">,</span> Green<span class="op">,</span> Blue <span class="op">};</span></span></code></pre>
        </div>
        <p>だ。もっとシンプルな直和型:</p>
        <div class="sourceCode" id="cb130">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bool</span> <span class="ot">=</span> <span class="dt">True</span> <span class="op">|</span> <span class="dt">False</span></span></code></pre>
        </div>
        <p>は、C++ではプリミティブ<code>bool</code>だ。</p>
        <p>
          値の有無をエンコードする単純な直和型は、C++ではさまざまに実装されており、特殊なトリックや、空文字列・負値・ヌルポインタなどの「不可能な」値が使われる。この種のオプション性は、意図的なものなら、Haskellでは<code>Maybe</code>型を使って表現される:
        </p>
        <div class="sourceCode" id="cb131">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre>
        </div>
        <p><code>Maybe</code>型は2つの型の和だ。このことは2つのコンストラクターを個々の型に分けるとわかる。1つ目は次のようになる:</p>
        <div class="sourceCode" id="cb132">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NothingType</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre>
        </div>
        <p>これは<code>Nothing</code>という名前の1つの値を持つ列挙だ。言い換えると、これは単集合であり、unit型<code>()</code>と等価だ。2つ目の部分:</p>
        <div class="sourceCode" id="cb133">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">JustType</span> a <span class="ot">=</span> <span class="dt">Just</span> a</span></code></pre>
        </div>
        <p>は、型<code>a</code>を単にカプセル化したものだ。<code>Maybe</code>を次のように書いてもよかっただろう:</p>
        <div class="sourceCode" id="cb134">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Either</span> () a</span></code></pre>
        </div>
        <p>より複雑な直和型は、C++ではポインタを使って模擬することが多い。ポインタはヌルとなるか、あるいは特定の型の値を指し示す。たとえば、Haskellで
          (再帰的な) 直和型として定義できるリスト型:</p>
        <div class="sourceCode" id="cb135">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span></code></pre>
        </div>
        <p>をC++に変換するには、ヌルポインタのトリックを使って空のリストを実装する:</p>
        <div class="sourceCode" id="cb136">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">&gt;</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> List <span class="op">{</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">*</span> _head<span class="op">;</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a>    List<span class="op">()</span> <span class="op">:</span> _head<span class="op">(</span><span class="kw">nullptr</span><span class="op">)</span> <span class="op">{}</span>  <span class="co">// Nil</span></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>    List<span class="op">(</span>A a<span class="op">,</span> List<span class="op">&lt;</span>A<span class="op">&gt;</span> l<span class="op">)</span>        <span class="co">// Cons</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>      <span class="op">:</span> _head<span class="op">(</span><span class="kw">new</span> Node<span class="op">&lt;</span>A<span class="op">&gt;(</span>a<span class="op">,</span> l<span class="op">))</span></span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{}</span></span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre>
        </div>
        <p>Haskellでの2つのコンストラクター<code>Nil</code>と<code>Cons</code>が、よく似た引数
          (<code>Nil</code>は空、<code>Cons</code>は値1つとリスト1つ)
          でオーバーロードされた2つの<code>List</code>コンストラクターに変換されたことに注目してほしい。この<code>List</code>クラスには、直和型の2つのコンポーネントを区別するためのタグは必要ない。その代わりに<code>_head</code>に特別な<code>nullptr</code>値を使って<code>Nil</code>を表現する。
        </p>
        <p>
          もっとも、HaskellとC++の型の主な違いは、Haskellではデータ構造が不変であることだ。ある特定のコンストラクターを使ってオブジェクトを作成する場合、オブジェクトはどのコンストラクターが使われ、どの引数が渡されたかを永久に記憶する。したがって、<code>Just "energy"</code>として作成された<code>Maybe</code>オブジェクトが<code>Nothing</code>に変わることはない。同様に、空のリストは永久に空であり、3つの要素のリストは常に同じ3つの要素を持つことになる。
        </p>
        <p>この不変性こそが構成を可逆的にする。オブジェクトがあれば、いつでも構成で使われた部品に分解できる。この分解はパターンマッチングで行われ、コンストラクターをパターンとして再利用する。コンストラクター引数がある場合は、変数
          (またはその他のパターン) に置き換えられる。</p>
        <p>
          <code>List</code>データ型には2つのコンストラクターがあるため、任意の<code>List</code>の分解では、これらのコンストラクターに対応する2つのパターンを使う。1つは空の<code>Nil</code>リストに一致し、もう1つは<code>Cons</code>で構成されたリストに一致する。たとえば、複数の<code>List</code>に対する単純な関数の定義は次のとおりだ。
        </p>
        <div class="sourceCode" id="cb137">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="ot">maybeTail ::</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">List</span> a)</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>maybeTail <span class="dt">Nil</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>maybeTail (<span class="dt">Cons</span> _ t) <span class="ot">=</span> <span class="dt">Just</span> t</span></code></pre>
        </div>
        <p>
          <code>maybeTail</code>の定義の最初の部分は、<code>Nil</code>コンストラクターをパターンとして使い、<code>Nothing</code>を返す。2番目の部分では、<code>Cons</code>コンストラクターをパターンとして使う。コンストラクターの最初の引数には興味がないため、ワイルドカードで置き換える。<code>Cons</code>の2番目の引数は、変数<code>t</code>に束縛される
          (厳密に言えば、一度式に束縛されたら決して変化しないものの、変数と呼ぶことにする)。戻り値は<code>Just t</code>だ。こうして、<code>List</code>の作成方法に応じて、句の1つに一致するようになった。作成に<code>Cons</code>が使われるときは、渡した2つの引数が取得される
          (最初の引数は破棄される)。
        </p>
        <p>
          さらに複雑な直和型は、C++では多相クラス階層を使って実装されている。共通の祖先を持つ一連のクラスは、1つのバリアント型として理解でき、その中では仮想関数テーブルが隠しタグとして機能する。Haskellではコンストラクター上のパターンマッチングで特殊なコードを呼び出して行っていることを、C++では仮想関数テーブルのポインターに基づいて仮想関数呼び出しをディスパッチして実現している。
        </p>
        <p>
          C++で<code>union</code>が直和型として使われることはめったにない。含められるものに厳しい制限があるからだ。<code>std::string</code>でさえ、コピー・コンストラクターを持っているので、unionに入れられない。
        </p>
        <h2 data-number="6.4" id="型の代数"><span class="header-section-number">6.4</span> 型の代数</h2>
        <p>別々に用いても直積型と直和型でさまざまな有用なデータ構造を定義できるが、真の強みはこの2つを組み合わせることで得られる。合成の力が再び発揮される時がきた。</p>
        <p>
          これまでに分かったことをまとめておこう。型システムの下にある2つの可換モノイダル構造を見てきた。中立元として<code>Void</code>を持つ直和型と、中立元として<code>()</code>というunit型を持つ直積型だ。それらを加法や乗法に似たものだと見なそう。この比喩では、<code>Void</code>は0に対応し、<code>()</code>は1に対応する。
        </p>
        <p>この比喩をどこまで拡張できるか見てみよう。例として、0を掛けると0になるだろうか？
          言い換えれば、1つのコンポーネントが<code>Void</code>である直積型は、<code>Void</code>と同型だろうか？
          たとえば、<code>Int</code>と<code>Void</code>のペアを作成できるだろうか？</p>
        <p>
          ペアを作成するには2つの値が必要だ。整数なら簡単だが、型<code>Void</code>には値がない。したがって、すべての型<code>a</code>に対して、型<code>(a, Void)</code>は値を持たない無人型であり、つまり<code>Void</code>と等価になる。言い換えれば、<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>×</mo>
                <mn>0</mn>
                <mo>=</mo>
                <mn>0</mn>
              </mrow>
              <annotation encoding="application/x-tex">a \times 0 = 0</annotation>
            </semantics>
          </math>ということだ。</p>
        <p>加算と乗算をつなぐもう1つのものとして、分配律がある:</p>
        <div class="sourceCode" id="cb138">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">*</span> (b <span class="op">+</span> c) <span class="ot">=</span> a <span class="op">*</span> b <span class="op">+</span> a <span class="op">*</span> c</span></code></pre>
        </div>
        <p>これは直積型と直和型にも当てはまるだろうか？
          当てはまる――いつものように同型を除いて。左辺は次の型に相当する:</p>
        <div class="sourceCode" id="cb139">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a>(a, <span class="dt">Either</span> b c)</span></code></pre>
        </div>
        <p>また、右辺は次の型に相当する:</p>
        <div class="sourceCode" id="cb140">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Either</span> (a, b) (a, c)</span></code></pre>
        </div>
        <p>これらをある向きで変換する関数は次のとおりだ:</p>
        <div class="sourceCode" id="cb141">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prodToSum ::</span> (a, <span class="dt">Either</span> b c) <span class="ot">-&gt;</span> <span class="dt">Either</span> (a, b) (a, c)</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>prodToSum (x, e) <span class="ot">=</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Left</span>  y <span class="ot">-&gt;</span> <span class="dt">Left</span>  (x, y)</span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Right</span> z <span class="ot">-&gt;</span> <span class="dt">Right</span> (x, z)</span></code></pre>
        </div>
        <p>また、その逆向きだと次のとおりだ:</p>
        <div class="sourceCode" id="cb142">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sumToProd ::</span> <span class="dt">Either</span> (a, b) (a, c) <span class="ot">-&gt;</span> (a, <span class="dt">Either</span> b c)</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>sumToProd e <span class="ot">=</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Left</span>  (x, y) <span class="ot">-&gt;</span> (x, <span class="dt">Left</span>  y)</span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Right</span> (x, z) <span class="ot">-&gt;</span> (x, <span class="dt">Right</span> z)</span></code></pre>
        </div>
        <p>
          <code>case of</code>式は、パターンマッチング内部関数に使われる。各パターンの後には矢印と、パターンが一致したときに評価される式が続く。たとえば、次の値を指定して<code>prodToSum</code>を呼び出すとする。
        </p>
        <div class="sourceCode" id="cb143">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="ot">prod1 ::</span> (<span class="dt">Int</span>, <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Float</span>)</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>prod1 <span class="ot">=</span> (<span class="dv">2</span>, <span class="dt">Left</span> <span class="st">&quot;Hi!&quot;</span>)</span></code></pre>
        </div>
        <p>
          <code>case e of</code>内の<code>e</code>は<code>Left "Hi!"</code>と等しくなる。これはパターン<code>Left y</code>と一致し、<code>y</code>を<code>"Hi!"</code>に置き換える。<code>x</code>はすでに<code>2</code>と一致しているので、<code>case of</code>句の結果と関数全体は、期待どおり<code>Left (2, "Hi!")</code>となる。
        </p>
        <p>この2つの関数が互いに逆であることの証明は省くが、よく考えれば逆だと分かるはずだ。
          これらは、2つのデータ構造の内容を単純に再パックしているだけだ。データは同じで、フォーマットが異なるだけだ。</p>
        <p>数学者たちは、このような絡み合った2つのモノイドに<span id="semiring" class="keyword">半環</span> (semiring)
          という名前をつけている。これは完全な<span id="ring" class="keyword">環</span> (ring)
          ではない。型の減算は定義できないからだ。そのため、半環は「<em>n</em>
          (negative) がない環 (ring)」をかけて<span id="rig" class="keyword">リグ</span> (rig)
          と呼ばれることがある。しかし、そのことを除けば、リグを形成する自然数などに関する命題を型に関する命題に変換することで、多くのメリットが得られる。興味深い項目を含む変換表を以下に示す:</p>
        <table>
          <thead>
            <tr class="header">
              <th style="text-align: left;">Numbers</th>
              <th style="text-align: center;">Types</th>
            </tr>
          </thead>
          <tbody>
            <tr class="odd">
              <td style="text-align: left;">0</td>
              <td style="text-align: center;"><code>Void</code></td>
            </tr>
            <tr class="even">
              <td style="text-align: left;">1</td>
              <td style="text-align: center;"><code>()</code></td>
            </tr>
            <tr class="odd">
              <td style="text-align: left;">a + b</td>
              <td style="text-align: center;"><code>Either a b = Left a | Right b</code></td>
            </tr>
            <tr class="even">
              <td style="text-align: left;">a * b</td>
              <td style="text-align: center;"><code>(a, b)</code>または<code>Pair a b = Pair a b</code></td>
            </tr>
            <tr class="odd">
              <td style="text-align: left;">2 = 1 + 1</td>
              <td style="text-align: center;"><code>data Bool = True | False</code></td>
            </tr>
            <tr class="even">
              <td style="text-align: left;">1 + a</td>
              <td style="text-align: center;"><code>data Maybe = Nothing | Just a</code></td>
            </tr>
          </tbody>
        </table>
        <p>リスト型は、非常に興味深いことに、方程式の解として定義される。定義している型は、式の両辺に現れる:</p>
        <div class="sourceCode" id="cb144">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span></code></pre>
        </div>
        <p>通常の置換を行い、さらに<code>List a</code>を<code>x</code>に置き換えると、次の式が得られる:</p>
        <div class="sourceCode" id="cb145">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a <span class="op">*</span> x</span></code></pre>
        </div>
        <p>
          型の減算や除算はできないので、従来の代数的方法でこれを解くことはできない。しかし、置換の連続なら試せる。つまり、ひたすら右辺の<code>x</code>を<code>(1 + a*x)</code>に置き換えては分配律を使う。これによって次の一連の結果が得られる:
        </p>
        <div class="sourceCode" id="cb146">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a<span class="op">*</span>x</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a<span class="op">*</span>(<span class="dv">1</span> <span class="op">+</span> a<span class="op">*</span>x) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a <span class="op">+</span> a<span class="op">*</span>a<span class="op">*</span>x</span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a <span class="op">+</span> a<span class="op">*</span>a<span class="op">*</span>(<span class="dv">1</span> <span class="op">+</span> a<span class="op">*</span>x) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a <span class="op">+</span> a<span class="op">*</span>a <span class="op">+</span> a<span class="op">*</span>a<span class="op">*</span>a<span class="op">*</span>x</span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a <span class="op">+</span> a<span class="op">*</span>a <span class="op">+</span> a<span class="op">*</span>a<span class="op">*</span>a <span class="op">+</span> a<span class="op">*</span>a<span class="op">*</span>a<span class="op">*</span>a<span class="op">...</span></span></code></pre>
        </div>
        <p>最終的には積 (タプル)
          の和が無限に続くことになった。これは次のように解釈できる。リストは空集合<code>1</code>か、単集合<code>a</code>か、ペア<code>a*a</code>か、トリプル<code>a*a*a</code>か、などなど……。まさにそれがリストだ。一連の<code>a</code>だ！
        </p>
        <p>リストについては語るべきことがまだまだある。関手や不動点について学んだ後で、リストやその他の再帰的なデータ構造について再び説明する。</p>
        <p>記号変数を使って方程式を解く――これぞ代数だ！
          それゆえ、これらの型は代数的データ型と呼ばれる。</p>
        <p>
          最後に、型の代数の非常に重要な解釈について述べなければならない。<code>a</code>と<code>b</code>の2つの型の積には、型<code>a</code><em>および</em>型<code>b</code>の両方の値が含まれている必要があることに注意してほしい。これは、両方の型が居住
          (inhabit)
          である必要があることを意味する。一方、2つの型の和には、型<code>a</code>
          <em>または</em>型<code>b</code>のいずれかの値が含まれるので、どちらかが居住であれば十分だ。また、<em>論理積</em>
          (logical and) と<em>論理和</em> (logical or)
          も半環を形成し、型理論と対応付けられる:
        </p>
        <table>
          <thead>
            <tr class="header">
              <th style="text-align: left;">論理型</th>
              <th></th>
            </tr>
          </thead>
          <tbody>
            <tr class="odd">
              <td style="text-align: left;">false</td>
              <td><code>Void</code></td>
            </tr>
            <tr class="even">
              <td style="text-align: left;">true</td>
              <td><code>()</code></td>
            </tr>
            <tr class="odd">
              <td style="text-align: left;">a || b</td>
              <td><code>Either a b = Left a | Right b</code></td>
            </tr>
            <tr class="even">
              <td style="text-align: left;">a &amp;&amp; b</td>
              <td><code>(a, b)</code></td>
            </tr>
          </tbody>
        </table>
        <p>この比喩はさらに深く、論理と型理論を結ぶカリー・ハワード同型の基礎となっている。それについては関数型について説明するときに再び取り上げる。</p>
        <h2 data-number="6.5" id="課題-5"><span class="header-section-number">6.5</span> 課題</h2>
        <ol type="1">
          <li>
            <p><code>Maybe a</code>と<code>Either () a</code>の間の同型を示せ。</p>
          </li>
          <li>
            <p>円と長方形の直和型をHaskellで定義する。</p>
            <div class="sourceCode" id="cb147">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Shape</span> <span class="ot">=</span> <span class="dt">Circle</span> <span class="dt">Float</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>               <span class="op">|</span> <span class="dt">Rect</span> <span class="dt">Float</span> <span class="dt">Float</span></span></code></pre>
            </div>
            <p><code>Shape</code>に作用し面積を求める<code>area</code>のような関数を定義したい場合は、次の2つのコンストラクターでパターンマッチングを使う。</p>
            <div class="sourceCode" id="cb148">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="ot">area ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a>    area (<span class="dt">Circle</span> r) <span class="ot">=</span> <span class="fu">pi</span> <span class="op">*</span> r <span class="op">*</span> r</span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>    area (<span class="dt">Rect</span> d h) <span class="ot">=</span> d <span class="op">*</span> h</span></code></pre>
            </div>
            <p>
              C++またはJavaでインタフェースとして<code>Shape</code>を実装し、<code>Circle</code>と<code>Rect</code>という2つのクラスを作成せよ。<code>area</code>は仮想関数として実装せよ。
            </p>
          </li>
          <li>
            <p>先ほどの例を続ける。<code>Shape</code>の周の長さを求める新しい関数<code>circ</code>は簡単に追加できる。<code>Shape</code>の定義に触れる必要はない。</p>
            <div class="sourceCode" id="cb149">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="ot">circ ::</span> <span class="dt">Shape</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a>    circ (<span class="dt">Circle</span> r) <span class="ot">=</span> <span class="fl">2.0</span> <span class="op">*</span> <span class="fu">pi</span> <span class="op">*</span> r</span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a>    circ (<span class="dt">Rect</span> d h) <span class="ot">=</span> <span class="fl">2.0</span> <span class="op">*</span> (d <span class="op">+</span> h)</span></code></pre>
            </div>
            <p>C++またはJavaの実装に<code>circ</code>を追加せよ。もとのコードのどの部分に触れる必要があったか？</p>
          </li>
          <li>
            <p>
              さらに続ける。新しい図形として正方形<code>Square</code>を<code>Shape</code>に追加し、必要なすべてを更新する。HaskellならびにC++およびJavaでは、コードのどこに触れる必要があったか？
              (Haskellプログラマーでないとしても、変更箇所はごく自明なはずだ。）</p>
          </li>
          <li>
            <p>型について<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mrow>
                    <mi>a</mi>
                    <mo>+</mo>
                    <mi>a</mi>
                    <mo>=</mo>
                    <mn>2</mn>
                    <mo>×</mo>
                    <mi>a</mi>
                  </mrow>
                  <annotation encoding="application/x-tex">a + a = 2 \times a</annotation>
                </semantics>
              </math>が
              (同型を除いて)
              成り立つことを示せ。前掲の変換表によれば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mn>2</mn>
                  <annotation encoding="application/x-tex">2</annotation>
                </semantics>
              </math>は<code>Bool</code>に対応する。</p>
          </li>
        </ol>
        <h1 data-number="7" id="functors"><span class="header-section-number">7</span> 関手</h1>
        <p>壊れたレコードのように聞こえるかもしれないが、関手についてこう述べておきたい:
          関手は非常に単純だが強力な概念だ。圏論はこのような単純だが強力な概念であふれている。関手は圏の間の写像だ。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の2つの圏が与えられた場合、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の対象を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>内の対象に写す。これは対象についての関数だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の対象である場合は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の像を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F a</annotation>
            </semantics>
          </math>と
          (括弧なしで)
          書く。しかし、圏は単なる対象ではない――対象とそれらを接続する射から成る。関手は射も写す――射についての関数だ。ただし、射を行きあたりばったりに写すわけではない――接続を維持して写す。
          したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>が対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>に次のように接続する場合;</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon a \to b</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>の像<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">F f</annotation>
            </semantics>
          </math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の像を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の像に接続する:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>F</mi>
                <mi>a</mi>
                <mo>→</mo>
                <mi>F</mi>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">F f \Colon F a \to F b</annotation>
            </semantics>
          </math></p>
        <p>(これは数学的記法とHaskellの記法を組み合わせたものであり、ここでは理にかなっているだろう。対象や射に関数を適用するときは括弧を使わないことにする。)</p>
        <p><img src="images/functor.jpg" style="width:30.0%" /></p>
        <p>ご覧のとおり、関手は圏の構造を保存している。一方の圏で接続しているものは、もう一方の圏でも接続している。しかし、圏の構造にはそれ以上の何かがある:
          射の合成だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>の合成の場合:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>h</mi>
                <mo>=</mo>
                <mi>g</mi>
                <mo>∘</mo>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">h = g \circ f</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>の下の像を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>の像の合成にしたい:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>h</mi>
                <mo>=</mo>
                <mi>F</mi>
                <mi>g</mi>
                <mo>∘</mo>
                <mi>F</mi>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">F h = F g \circ F f</annotation>
            </semantics>
          </math></p>
        <p><img src="images/functorcompos.jpg" style="width:30.0%" /></p>
        <p>最終的に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内のすべての恒等射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>内の恒等射に写したい:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mi>a</mi>
                </msub>
                <mo>=</mo>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mrow>
                    <mi>F</mi>
                    <mi>a</mi>
                  </mrow>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">F %
                \mathbf{id}_{a}%
                = %
                \mathbf{id}_{F a}%
              </annotation>
            </semantics>
          </math></p>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">%
                \mathbf{id}_{a}%
              </annotation>
            </semantics>
          </math>は対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の恒等射であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mrow>
                  <mi>F</mi>
                  <mi>a</mi>
                </mrow>
              </msub>
              <annotation encoding="application/x-tex">%
                \mathbf{id}_{F a}%
              </annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F a</annotation>
            </semantics>
          </math>の恒等射だ。</p>
        <p><img src="images/functorid.jpg" style="width:30.0%" /></p>
        <p>
          これらの条件によって、関手は通常の関数よりもはるかに制約が厳しくなることに注意してほしい。関手は圏の構造を保存しなければならない。圏を、射のネットワークによって織りなされた対象の集まりと見なすなら、関手がこの織物に裂け目を入れることは許されない。対象を潰してまとめたり、複数の射を1つにくっつけたりすることはあるが、何かを引き裂くことは決してない。この引き裂きなしの拘束条件は、微積分学において知られる連続性条件に似ている。この意味では、関手は「連続的」である
          (もっとも、関手にはさらに制約が厳しい連続性の概念が存在する)。関数と同じように、関手にも潰すものと埋め込むものがある。埋め込みの傾向がより顕著なのは、始域圏が終域圏よりずっと小さいときだ。極端な場合、始域は、自明な単元圏
          (trivial singleton category) でありうる。すなわち、1つの対象と1つの射
          (恒等射)
          を持つ圏だ。単元圏から他の圏への関手は、単にその圏内の対象を選択するだけだ。これは、単集合からの射は終域内の要素を選択する、という特性と完全に類似している。最も潰す関手は、定関手<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>と呼ばれる。始域圏内のすべての対象を、終域圏内で選択された1つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>に写す。また、始域圏のすべての射を恒等射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">%
                \mathbf{id}_{c}%
              </annotation>
            </semantics>
          </math>に写す。まるでブラックホールのように働き、すべてを1つの特異点に圧縮する。この関手については、極限と余極限について議論するときに詳しく見よう。</p>
        <h2 data-number="7.1" id="プログラミングにおける関手"><span class="header-section-number">7.1</span> プログラミングにおける関手</h2>
        <p>現実に戻ってプログラミングについて話をしよう。我々には型と関数の圏がある。この圏をそれ自体に写す関手について話そう。そのような関手は自己関手
          (endofunctor) と呼ばれる。型の圏での自己関手とは何だろうか？
          まず、それは型を型に写す。そのような写像の例はすでに見たが、おそらくそれとは気付かなかったのだろう。いま述べているのは、ある型の定義が別の型によってパラメーター化されている場合についてだ。いくつか例を見てみよう。</p>
        <h3 data-number="7.1.1" id="maybe関手"><span class="header-section-number">7.1.1</span> Maybe関手</h3>
        <p><code>Maybe</code>は、型<code>a</code>から型<code>Maybe a</code>への写像として定義される:</p>
        <div class="sourceCode" id="cb150">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre>
        </div>
        <p>
          ここで重要な注意点がある。<code>Maybe</code>自体は型ではなく、<em>型コンストラクター</em>だ。型に変換するには、<code>Int</code>や<code>Bool</code>のような型引数を指定する必要がある。引数のない<code>Maybe</code>は、型の関数を表す。だが、<code>Maybe</code>は関手に変えられるだろうか？
          (これ以降、プログラミングの文脈で関手と言うとき、ほとんどの場合は自己関手を意味する。)
          関手は、対象 (ここでは型) の写像であるだけでなく、射 (ここでは関数)
          の写像でもある。<code>a</code>から<code>b</code>への任意の関数:</p>
        <div class="sourceCode" id="cb151">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> a <span class="ot">-&gt;</span> b</span></code></pre>
        </div>
        <p>
          について<code>Maybe a</code>から<code>Maybe b</code>への関数を生成したい。そのような関数を定義するには、<code>Maybe</code>の2つのコンストラクターに対応する2つの場合を考慮する必要がある。<code>Nothing</code>の場合は、単に<code>Nothing</code>を返すだけだ。引数が<code>Just</code>の場合は、関数<code>f</code>をその内容に適用すればよい。したがって、<code>Maybe</code>の下にある<code>f</code>の像は次の関数だ:
        </p>
        <div class="sourceCode" id="cb152">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f&#39; ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a>f&#39; <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>f&#39; (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre>
        </div>
        <p>(ところで、Haskellでは変数名でアポストロフィーを使えるため、今のような場合にとても便利だ。)
          Haskellでは、関手で射を写す部分は<code>fmap</code>と呼ばれる高階関数として実装されている。<code>Maybe</code>の場合、それは次のシグネチャを持つ:</p>
        <div class="sourceCode" id="cb153">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b)</span></code></pre>
        </div>
        <p><img src="images/functormaybe.jpg" style="width:35.0%" /></p>
        <p>
          <code>fmap</code>は関数を<em>リフト</em>するという言い方がよく使われる。リフトされた関数は<code>Maybe</code>値に対して作用する。いつものように、カリー化のため、このシグニチャは次の2つの方法で解釈できる。1つは、関数<code>(a -&gt; b)</code>を1つの引数と捉えて、関数<code>(Maybe a -&gt; Maybe b)</code>を返しているとする解釈だ。もうひとつは、2つの引数を取る関数が<code>Maybe b</code>を返しているとする解釈だ:
        </p>
        <div class="sourceCode" id="cb154">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span></code></pre>
        </div>
        <p>これまでの議論に基づいて、<code>Maybe</code>に<code>fmap</code>を実装する方法は次のとおりだ:</p>
        <div class="sourceCode" id="cb155">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> _ <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre>
        </div>
        <p>
          型コンストラクター<code>Maybe</code>が関数<code>fmap</code>を伴う関手を形成することを示すには、<code>fmap</code>が恒等射と合成を保存することを証明する必要がある。これらは「関手の規則」と呼ばれているが、単に圏の構造の保存を保証するだけのものだ。
        </p>
        <h3 data-number="7.1.2" id="等式推論"><span class="header-section-number">7.1.2</span> 等式推論</h3>
        <p>関手の規則を証明するために、Haskellでの一般的な証明テクニックである<span id="equational_reasoning" class="keyword">等式推論</span> (equational
          reasoning)
          を使う。これは、Haskellの関数が等価関数として定義されている、つまり左辺が右辺に等しい、という事実を利用している。左辺と右辺はいつでも入れ替えられる。ただし、名前の競合を避けるために変数名を変更する必要はあるかもしれない。これは、関数をインライン化するか、あるいは逆に式を関数にリファクタリングすることと考えてほしい。例として恒等関数を考えてみよう:
        </p>
        <div class="sourceCode" id="cb156">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre>
        </div>
        <p>たとえば、ある式の中に<code>id y</code>があるなら、<code>y</code>に置き換えられる
          (インライン化)。さらに、 (たとえば<code>id (y + 2)</code>のように)
          式に<code>id</code>が適用されているなら、<code>(y + 2)</code>のように式そのものに置き換えられる。そして、この置換は両方向に機能する。つまり、任意の式<code>e</code>を<code>id e</code>で置き換えられる
          (リファクタリング)。関数がパターンマッチングによって定義されている場合は、各サブ定義を独立して使える。たとえば、上記の<code>fmap</code>の定義では、<code>fmap f Nothing</code>を<code>Nothing</code>に置き換えることも、その逆を行うこともできる。これが実際にどのように機能するか見てみよう。恒等射の保存から始めよう:
        </p>
        <div class="sourceCode" id="cb157">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> <span class="fu">id</span> <span class="ot">=</span> <span class="fu">id</span></span></code></pre>
        </div>
        <p><code>Nothing</code>と<code>Just</code>の2つのケースを考慮する必要がある。1つ目のケースは次のようになる
          (Haskell疑似コードを使って左辺を右辺に変換している):</p>
        <div class="sourceCode" id="cb158">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> <span class="fu">id</span> <span class="dt">Nothing</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { definition <span class="kw">of</span> <span class="fu">fmap</span> }</span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { definition <span class="kw">of</span> <span class="fu">id</span> }</span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="dt">Nothing</span></span></code></pre>
        </div>
        <p>
          最後のステップで<code>id</code>の定義を逆向きに使ったことに注目してほしい。式<code>Nothing</code>を<code>id Nothing</code>に置き換えた。実際には、このような証明は、真ん中の同じ式に辿り着くまで「ロウソクを両端から燃やす」ことで成される。ここで真ん中に残るのは<code>Nothing</code>だ。2つ目のケースも簡単だ:
        </p>
        <div class="sourceCode" id="cb159">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> <span class="fu">id</span> (<span class="dt">Just</span> x)</span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { definition <span class="kw">of</span> <span class="fu">fmap</span> }</span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> (<span class="fu">id</span> x)</span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { definition <span class="kw">of</span> <span class="fu">id</span> }</span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> x</span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { definition <span class="kw">of</span> <span class="fu">id</span> }</span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> (<span class="dt">Just</span> x)</span></code></pre>
        </div>
        <p>では、<code>fmap</code>が合成を保存することを示そう:</p>
        <div class="sourceCode" id="cb160">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> (g <span class="op">.</span> f) <span class="ot">=</span> <span class="fu">fmap</span> g <span class="op">.</span> <span class="fu">fmap</span> f</span></code></pre>
        </div>
        <p>まずは<code>Nothing</code>のケース:</p>
        <div class="sourceCode" id="cb161">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> (g <span class="op">.</span> f) <span class="dt">Nothing</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { definition <span class="kw">of</span> <span class="fu">fmap</span> }</span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { definition <span class="kw">of</span> <span class="fu">fmap</span> }</span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> g <span class="dt">Nothing</span></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { definition <span class="kw">of</span> <span class="fu">fmap</span> }</span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> g (<span class="fu">fmap</span> f <span class="dt">Nothing</span>)</span></code></pre>
        </div>
        <p>次は<code>Just</code>のケース:</p>
        <div class="sourceCode" id="cb162">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> (g <span class="op">.</span> f) (<span class="dt">Just</span> x)</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { definition <span class="kw">of</span> <span class="fu">fmap</span> }</span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> ((g <span class="op">.</span> f) x)</span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { definition <span class="kw">of</span> composition }</span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> (g (f x))</span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { definition <span class="kw">of</span> <span class="fu">fmap</span> }</span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> g (<span class="dt">Just</span> (f x))</span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { definition <span class="kw">of</span> <span class="fu">fmap</span> }</span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> g (<span class="fu">fmap</span> f (<span class="dt">Just</span> x))</span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> { definition <span class="kw">of</span> composition }</span>
<span id="cb162-11"><a href="#cb162-11" aria-hidden="true" tabindex="-1"></a>  (<span class="fu">fmap</span> g <span class="op">.</span> <span class="fu">fmap</span> f) (<span class="dt">Just</span> x)</span></code></pre>
        </div>
        <p>等式推論はC++スタイルの副作用のある「関数」では使えないことは、強調しておく価値がある。次のコードを考えてみよう:</p>
        <div class="sourceCode" id="cb163">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> square<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">*</span> x<span class="op">;</span></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> counter<span class="op">()</span> <span class="op">{</span></span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">int</span> c <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c<span class="op">++;</span></span>
<span id="cb163-8"><a href="#cb163-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb163-9"><a href="#cb163-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-10"><a href="#cb163-10" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> y <span class="op">=</span> square<span class="op">(</span>counter<span class="op">());</span></span></code></pre>
        </div>
        <p>等式推論を使うと、<code>square</code>をインライン展開して次のようにできる:</p>
        <div class="sourceCode" id="cb164">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> y <span class="op">=</span> counter<span class="op">()</span> <span class="op">*</span> counter<span class="op">();</span></span></code></pre>
        </div>
        <p>明らかにこれは有効な変換ではなく、同じ結果は生成されない。それにもかかわらず、マクロとして<code>square</code>を実装すると、C++コンパイラは等式推論を使おうとし、悲惨な結果になる。</p>
        <h3 data-number="7.1.3" id="optional"><span class="header-section-number">7.1.3</span> Optional</h3>
        <p>
          関手は、Haskellでは簡単に表現できるが、総称プログラミングや高階関数をサポートする言語ならどれでも定義できる。C++版の<code>Maybe</code>、テンプレート型<code>optional</code>について考えてみよう。以下に実装の概略を示す
          (実際の実装ははるかに複雑で、C++に特有の、引数のさまざまな渡し方、コピーセマンティクス、リソース管理の問題を扱わなくてはならない)。</p>
        <div class="sourceCode" id="cb165">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> optional <span class="op">{</span></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> _isValid<span class="op">;</span> <span class="co">// the tag</span></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>    T    _v<span class="op">;</span></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true" tabindex="-1"></a>    optional<span class="op">()</span>    <span class="op">:</span> _isValid<span class="op">(</span><span class="kw">false</span><span class="op">)</span> <span class="op">{}</span>         <span class="co">// Nothing</span></span>
<span id="cb165-7"><a href="#cb165-7" aria-hidden="true" tabindex="-1"></a>    optional<span class="op">(</span>T x<span class="op">)</span> <span class="op">:</span> _isValid<span class="op">(</span><span class="kw">true</span><span class="op">)</span> <span class="op">,</span> _v<span class="op">(</span>x<span class="op">)</span> <span class="op">{}</span>  <span class="co">// Just</span></span>
<span id="cb165-8"><a href="#cb165-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> isValid<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> _isValid<span class="op">;</span> <span class="op">}</span></span>
<span id="cb165-9"><a href="#cb165-9" aria-hidden="true" tabindex="-1"></a>    T val<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> _v<span class="op">;</span> <span class="op">}</span></span>
<span id="cb165-10"><a href="#cb165-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre>
        </div>
        <p>このテンプレートは、関手の定義の一部である型の写像を提供する。これは任意の型<code>T</code>を新しい型<code>optional&lt;T&gt;</code>に写す。関数に対するアクションを定義しよう:
        </p>
        <div class="sourceCode" id="cb166">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>function<span class="op">&lt;</span>optional<span class="op">&lt;</span>B<span class="op">&gt;(</span>optional<span class="op">&lt;</span>A<span class="op">&gt;)&gt;</span></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>fmap<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;</span> f<span class="op">)</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">[</span>f<span class="op">](</span>optional<span class="op">&lt;</span>A<span class="op">&gt;</span> opt<span class="op">)</span> <span class="op">{</span></span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>opt<span class="op">.</span>isValid<span class="op">())</span></span>
<span id="cb166-7"><a href="#cb166-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> optional<span class="op">&lt;</span>B<span class="op">&gt;{};</span></span>
<span id="cb166-8"><a href="#cb166-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb166-9"><a href="#cb166-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> optional<span class="op">&lt;</span>B<span class="op">&gt;{</span> f<span class="op">(</span>opt<span class="op">.</span>val<span class="op">())</span> <span class="op">};</span></span>
<span id="cb166-10"><a href="#cb166-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb166-11"><a href="#cb166-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>これは高階関数で、引数として関数を受け取り、関数を返す。非カリー化版はこうなる:</p>
        <div class="sourceCode" id="cb167">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>optional<span class="op">&lt;</span>B<span class="op">&gt;</span> fmap<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;</span> f<span class="op">,</span> optional<span class="op">&lt;</span>A<span class="op">&gt;</span> opt<span class="op">)</span> <span class="op">{</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>opt<span class="op">.</span>isValid<span class="op">())</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> optional<span class="op">&lt;</span>B<span class="op">&gt;{};</span></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> optional<span class="op">&lt;</span>B<span class="op">&gt;{</span> f<span class="op">(</span>opt<span class="op">.</span>val<span class="op">())</span> <span class="op">};</span></span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>
          <code>fmap</code>を<code>optional</code>のテンプレートメソッドにするという選択肢もある。このように選択肢に迷うことになるため、C++で関手パターンを抽象化するのは難しい。関手は継承元となるインターフェースにすべきだろうか
          (残念ながら、テンプレート仮想関数は作れない)？
          フリーテンプレート関数は、カリー化版と非カリー化版のどちらにすべきだろうか？
          C++コンパイラは不足した型情報を正しく推論できるのか、それとも明示的に指定すべきだろうか？
          入力関数<code>f</code>が<code>int</code>から<code>bool</code>への関数である状況を考えてみよう。コンパイラに<code>g</code>の型が分かるだろうか:
        </p>
        <div class="sourceCode" id="cb168">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> g <span class="op">=</span> fmap<span class="op">(</span>f<span class="op">);</span></span></code></pre>
        </div>
        <p>特に将来、複数の関手が<code>fmap</code>をオーバーロードするようになった場合は？
          (近いうちにさらに多くの関手について見てみよう。)</p>
        <h3 data-number="7.1.4" id="型クラス"><span class="header-section-number">7.1.4</span> 型クラス</h3>
        <p>では、Haskellは関手の抽象化にどのように対処するのだろうか？
          それには型クラスの機構を使う。型クラスは、共通のインターフェースをサポートする一連の型を定義する。たとえば、等価性をサポートする対象についてのクラスは次のように定義される:</p>
        <div class="sourceCode" id="cb169">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre>
        </div>
        <p>
          この定義は、型<code>a</code>の引数を2つ取り<code>Bool</code>を返す演算子<code>(==)</code>がサポートされる場合、型<code>a</code>はクラス<code>Eq</code>であることを示している。特定の型が<code>Eq</code>であることをHaskellに伝えたい場合は、それをこのクラスの<span
            id="instance"
            class="keyword">インスタンス</span>として宣言し、<code>(==)</code>の実装を提供する必要がある。たとえば、2次元の点について<code>Point</code>
          (2つの<code>Float</code>の直積型) が定義されているとする:</p>
        <div class="sourceCode" id="cb170">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Point</span> <span class="ot">=</span> <span class="dt">Pt</span> <span class="dt">Float</span> <span class="dt">Float</span></span></code></pre>
        </div>
        <p>点の等価性は次のように定義できる:</p>
        <div class="sourceCode" id="cb171">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Point</span> <span class="kw">where</span></span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Pt</span> x y) <span class="op">==</span> (<span class="dt">Pt</span> x&#39; y&#39;) <span class="ot">=</span> x <span class="op">==</span> x&#39; <span class="op">&amp;&amp;</span> y <span class="op">==</span> y&#39;</span></code></pre>
        </div>
        <p>
          ここでは演算子<code>(==)</code>を定義し、2つのパターン<code>(Pt x y)</code>と<code>(Pt x'y Pt x y)</code>の中置記法として使った。関数の本体は、単一の等号の後に続く。<code>Point</code>が<code>Eq</code>のインスタンスとして宣言してあると、点同士を直接比較して等価性を調べられる。C++やJavaとは異なり、<code>Point</code>を定義するときに<code>Eq</code>クラス
          (またはインターフェース)
          を指定する必要はなく、クライアント・コード内で後から指定できることに注目してほしい。型クラスはまた、関数
          (および演算子)
          をオーバーロードするためのHaskellの唯一の機構でもある。これは、<code>fmap</code>を異なる関数に対してオーバーロードするために必要だ。ただし、1つ複雑な点がある。関手は型として定義されるのではなく、型の写像、つまり型コンストラクターとして定義される。必要な型クラスは、<code>Eq</code>の場合のような一連の型ではなく、一連の型コンストラクターだ。幸い、Haskellの型クラスは型だけでなく型コンストラクターでも動作する。以下に<code>Functor</code>クラスの定義を示す。
        </p>
        <div class="sourceCode" id="cb172">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre>
        </div>
        <p>
          これは、指定された型シグニチャを持つ関数<code>fmap</code>が存在する場合、<code>f</code>は<code>Functor</code>だと規定している。小文字の<code>f</code>は型変数であり、型変数<code>a</code>や<code>b</code>と似ている。しかし、コンパイラはそれが型ではなく型コンストラクターを表していることを、用法に基づいて推論できる。つまり、<code>f a</code>や<code>f b</code>のように他の型に作用しているのを見て推論できる。したがって、<code>Functor</code>のインスタンスを宣言するときは型コンストラクターを指定する必要がある。例として<code>Maybe</code>の場合を示す:
        </p>
        <div class="sourceCode" id="cb173">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> _ <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre>
        </div>
        <p>ちなみに、<code>Functor</code>クラスや、<code>Maybe</code>を含む多くの単純なデータ型のインスタンス定義は、標準のPreludeライブラリの一部となっている。</p>
        <h3 data-number="7.1.5" id="cでの関手"><span class="header-section-number">7.1.5</span> C++での関手</h3>
        <p>C++でも同じアプローチを試せるだろうか？
          型コンストラクターは、<code>optional</code>のようなテンプレート・クラスに対応しているので、同様に<code>fmap</code>を<span
            id="template_template_parameter" class="keyword">テンプレート・テンプレート引数</span> (template template
          parameter) でパラメーター化しよう。構文は次のとおりだ:</p>
        <div class="sourceCode" id="cb174">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">&gt;</span> F<span class="op">,</span> <span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a>F<span class="op">&lt;</span>B<span class="op">&gt;</span> fmap<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;,</span> F<span class="op">&lt;</span>A<span class="op">&gt;);</span></span></code></pre>
        </div>
        <p>このテンプレートをさまざまな関手に特殊化できるようにしたい。残念ながら、C++ではテンプレート関数の部分的な特殊化は禁止されている。そのため、次のような記述はできない:</p>
        <div class="sourceCode" id="cb175">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>optional<span class="op">&lt;</span>B<span class="op">&gt;</span> fmap<span class="op">&lt;</span>optional<span class="op">&gt;(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;</span> f<span class="op">,</span> optional<span class="op">&lt;</span>A<span class="op">&gt;</span> opt<span class="op">)</span></span></code></pre>
        </div>
        <p>代わりに関数のオーバーロードに頼る必要がある。これにより、もとのカリー化されていない<code>fmap</code>の定義に戻る:</p>
        <div class="sourceCode" id="cb176">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>optional<span class="op">&lt;</span>B<span class="op">&gt;</span> fmap<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;</span> f<span class="op">,</span> optional<span class="op">&lt;</span>A<span class="op">&gt;</span> opt<span class="op">)</span></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>opt<span class="op">.</span>isValid<span class="op">())</span></span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> optional<span class="op">&lt;</span>B<span class="op">&gt;{};</span></span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span></span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> optional<span class="op">&lt;</span>B<span class="op">&gt;{</span> f<span class="op">(</span>opt<span class="op">.</span>val<span class="op">())</span> <span class="op">};</span></span>
<span id="cb176-8"><a href="#cb176-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>この定義は機能するが、<code>fmap</code>の2番目の引数がオーバーロードを選択しているからにすぎない。より汎用的な<code>fmap</code>の定義を完全に無視している。</p>
        <h3 data-number="7.1.6" id="list関手"><span class="header-section-number">7.1.6</span> List関手</h3>
        <p>
          プログラミングにおける関手の役割についてある程度の直観を育むには、もっといろいろな例を見る必要がある。別の型によってパラメーター化される型は、いずれも関手の候補だ。総称コンテナも格納する要素の型によってパラメーター化されるので、ごく単純なコンテナであるリストを見てみよう:
        </p>
        <div class="sourceCode" id="cb177">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span></code></pre>
        </div>
        <p>
          型コンストラクター<code>List</code>がある。これは、任意の型<code>a</code>から型<code>List a</code>への写像だ。<code>List</code>が関手だと示すには、次のように関数のリフトを定義する必要がある。つまり、関数<code>a -&gt; b</code>について関数<code>List a -&gt; List b</code>を定義する。
        </p>
        <div class="sourceCode" id="cb178">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b)</span></code></pre>
        </div>
        <p>
          <code>List a</code>に作用する関数は、リストの2つのコンストラクターに対応する2つの場合を考慮する必要がある。<code>Nil</code>の場合は自明で、単に<code>Nil</code>を返す。空のリストでできることはあまりない。<code>Cons</code>の場合は、再帰を伴うため、ややトリッキーだ。そこで、少し前に戻って、何をしようとしているのか考えてみよう。<code>a</code>のリストと、<code>a</code>を<code>b</code>に変換する関数<code>f</code>があり、<code>b</code>のリストを生成したいと考えている。自明なのは、<code>f</code>を使ってリストの各要素を<code>a</code>から<code>b</code>に変換することだ。(空でない)
          リストが頭部と尾部の<code>Cons</code>として定義されている場合、実際にはどうやってそれを行うのだろうか。<code>f</code>を頭部に適用し、リフト
          (<code>fmap</code>)
          された<code>f</code>を尾部に適用する。これは再帰的な定義だ。リフトされた<code>f</code>をリフトされた<code>f</code>を用いて定義しているからだ。
        </p>
        <div class="sourceCode" id="cb179">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (<span class="dt">Cons</span> x t) <span class="ot">=</span> <span class="dt">Cons</span> (f x) (<span class="fu">fmap</span> f t)</span></code></pre>
        </div>
        <p>
          右辺では、<code>fmap f</code>が定義対象のリストよりも短いリストに適用されていることに注意してほしい。それは尾部に適用されている。再帰的に処理されるにつれてリストが短くなるため、最終的には空リスト、つまり<code>Nil</code>に到達することになる。しかし、先ほど決めたとおり、<code>fmap f</code>が<code>Nil</code>に作用すると<code>Nil</code>を返すため、再帰は停止する。最終的な結果を得るために、<code>Cons</code>コンストラクターを使って、新しい頭部<code>(f x)</code>と新しい尾部<code>(fmap f t)</code>を結合する。すべてをまとめると、list関手のインスタンス宣言はこうなる:
        </p>
        <div class="sourceCode" id="cb180">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">List</span> <span class="kw">where</span></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> _ <span class="dt">Nil</span> <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Cons</span> x t) <span class="ot">=</span> <span class="dt">Cons</span> (f x) (<span class="fu">fmap</span> f t)</span></code></pre>
        </div>
        <p>C++に慣れている場合は、最も汎用的なC++コンテナと見なせる<code>std::vector</code>の場合を考えてみてほしい。
          <code>fmap</code>の<code>std::vector</code>用の実装は<code>std::transform</code>の単純なカプセル化だ:
        </p>
        <div class="sourceCode" id="cb181">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>B<span class="op">&gt;</span> fmap<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;</span> f<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>A<span class="op">&gt;</span> v<span class="op">)</span></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>B<span class="op">&gt;</span> w<span class="op">;</span></span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>transform<span class="op">(</span> <span class="bu">std::</span>begin<span class="op">(</span>v<span class="op">)</span></span>
<span id="cb181-6"><a href="#cb181-6" aria-hidden="true" tabindex="-1"></a>                  <span class="op">,</span> <span class="bu">std::</span>end<span class="op">(</span>v<span class="op">)</span></span>
<span id="cb181-7"><a href="#cb181-7" aria-hidden="true" tabindex="-1"></a>                  <span class="op">,</span> <span class="bu">std::</span>back_inserter<span class="op">(</span>w<span class="op">)</span></span>
<span id="cb181-8"><a href="#cb181-8" aria-hidden="true" tabindex="-1"></a>                  <span class="op">,</span> f<span class="op">);</span></span>
<span id="cb181-9"><a href="#cb181-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> w<span class="op">;</span></span>
<span id="cb181-10"><a href="#cb181-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>これを使えば、たとえば次のように数字列の要素を自乗できる:</p>
        <div class="sourceCode" id="cb182">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span> <span class="op">};</span></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> w <span class="op">=</span> fmap<span class="op">([](</span><span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> i<span class="op">*</span>i<span class="op">;</span> <span class="op">},</span> v<span class="op">);</span></span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>copy<span class="op">(</span> <span class="bu">std::</span>begin<span class="op">(</span>w<span class="op">)</span></span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> <span class="bu">std::</span>end<span class="op">(</span>w<span class="op">)</span></span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a>         <span class="op">,</span> <span class="bu">std::</span>ostream_iterator<span class="op">(</span><span class="bu">std::</span>cout<span class="op">,</span> <span class="st">&quot;, &quot;</span><span class="op">));</span></span></code></pre>
        </div>
        <p>
          <code>std::transform</code>は<code>fmap</code>のより原始的な従兄弟だ。それに渡せるイテレータを実装しているため、ほとんどのC++コンテナは関手だと言える。残念ながら、関手の単純さは、イテレータや一時変数
          (上記の<code>fmap</code>の実装を参照)
          でいつも煩雑になるため失われてしまう。新しく提案されたC++のrangeライブラリによってrangeの関手的な性質がより顕著になったのは喜ばしい。
        </p>
        <h3 data-number="7.1.7" id="reader関手"><span class="header-section-number">7.1.7</span> Reader関手</h3>
        <p>
          さて、直観が育ってきただろう――たとえば、関手はある種のコンテナだ――では、一見したところ非常に異なる例をお見せしよう。型<code>a</code>からの、<code>a</code>を返す関数の型への写像を考えてみよう。関数型についてはあまり詳しく述べていない
          (完全に圏論的な扱いはこれからだ)
          が、プログラマならある程度理解している。Haskellでは、関数型はアロー型コンストラクター<code>(-&gt;)</code>を使って構築され、引数の型と結果の型の2つの型を取る。すでに中置記法<code>a -&gt; b</code>で見たことがあるが、括弧で括れば前置記法でも同様に使える:
        </p>
        <div class="sourceCode" id="cb183">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a>(<span class="ot">-&gt;</span>) a b</span></code></pre>
        </div>
        <p>通常の関数と同様に、複数の引数を持つ型関数も部分適用できる。したがって、矢印に対して型引数を1つだけ指定したなら、別の引数が必要になる。それが</p>
        <div class="sourceCode" id="cb184">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a>(<span class="ot">-&gt;</span>) a</span></code></pre>
        </div>
        <p>
          が型コンストラクターである理由だ。完全な型<code>a -&gt; b</code>を生成するには、もう1つの型<code>b</code>が必要だ。現状のままでは、<code>a</code>によってパラメーター化された一連の型コンストラクターの全体を定義している。これが関手でもあるかどうか見てみよう。2つの型パラメーターを扱うのは混乱を招くかもしれないので、名前を変更しておこう。前の型定義に従って、引数の型を<code>r</code>
          、結果の型を<code>a</code>と呼ぼう。したがって、この型コンストラクターは、任意の型<code>a</code>を取り、それを型<code>r -&gt; a</code>に写す。これが関手であることを示すために、関数<code>a -&gt; b</code>を、<code>r -&gt; a</code>を受け取って<code>r -&gt; b</code>を返す関数にリフトしよう。これらは、<code>a</code>と<code>b</code>のそれぞれに型コンストラクター<code>(-&gt;) r</code>を作用させて形成される型だ。このケースに適用される<code>fmap</code>の型シグニチャーは次のとおりだ:
        </p>
        <div class="sourceCode" id="cb185">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> b)</span></code></pre>
        </div>
        <p>次のようなパズルを解かなくてはならない:
          関数<code>f :: a -&gt; b</code>と関数<code>g :: r -&gt; a</code>が与えられるとき、関数<code>r -&gt; b</code>を作成せよ。2つの関数を合成する方法は1つしかなく、その結果はまさに必要なものだ。<code>fmap</code>の実装は次のようになる:
        </p>
        <div class="sourceCode" id="cb186">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> ((<span class="ot">-&gt;</span>) r) <span class="kw">where</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f g <span class="ot">=</span> f <span class="op">.</span> g</span></code></pre>
        </div>
        <p>うまくいった！
          簡潔な表記が好みなら、合成を前置記法で書き直せることに着目して、この定義をさらに短くできる:</p>
        <div class="sourceCode" id="cb187">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f g <span class="ot">=</span> (<span class="op">.</span>) f g</span></code></pre>
        </div>
        <p>引数を省略すると、2つの関数の直接の等価性が得られる:</p>
        <div class="sourceCode" id="cb188">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> <span class="ot">=</span> (<span class="op">.</span>)</span></code></pre>
        </div>
        <p>型コンストラクター
          <code>(-&gt;) r</code>と上記の<code>fmap</code>の実装の組み合わせは、Reader関手と呼ばれる。
        </p>
        <h2 data-number="7.2" id="コンテナとしての関手"><span class="header-section-number">7.2</span> コンテナとしての関手</h2>
        <p>
          汎用コンテナか、少なくともパラメーター化できる型を何らかの値として含むオブジェクトが定義されているプログラミング言語において、関手の例をいくつか見てきた。Reader関手は異端に思える。我々は関数をデータとは見なさないからだ。しかし、純粋関数はメモ化でき、関数の実行はテーブル参照に変えられるのを見てきた。テーブルはデータだ。逆に、Haskellは遅延評価を採用しているため、リストのような従来のコンテナは、実際には関数として実装されうる。たとえば、次のように簡潔に定義できる自然数の無限リストを考えてみよう。
        </p>
        <div class="sourceCode" id="cb189">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nats ::</span> [<span class="dt">Integer</span>]</span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a>nats <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span>]</span></code></pre>
        </div>
        <p>
          最初の行では、一対の角括弧はHaskellの組み込みリスト用の型コンストラクターだ。2行目では、リストリテラルを作成するために角括弧が使われている。明らかに、このような無限リストはメモリに格納できない。コンパイラはこれを、必要に応じて<code>Integer</code>を生成する関数として実装する。Haskellは実質的に、データとコードの区別を曖昧にしている。リストは関数と見なせて、関数は引数を結果に写すテーブルと見なせる。後者は、関数の領域が有限かつ大きすぎない場合なら現実的だ。しかし、<code>strlen</code>をテーブル参照として実装するのは現実的でない。なぜなら、無限に多くの異なる文字列が存在するからだ。プログラマーとして、我々は無限大は好きではないが、圏論では朝食に無限大を食べるのを学ぶことになる。すべての文字列の集合であっても、過去・現在・未来の宇宙のすべての可能な状態の集まりであっても、対処できる！
          したがって、関手対象 (自己関手によって生成された型の対象)
          は、パラメーター化される型の値を含むと考えたい。それらの値が物理的にそこに存在しない場合でもだ。関手の一例はC++の<code>std::future</code>で、ある時点で値を含みうるが、必ず含む保証はない。また、その値にアクセスしたいとき、別スレッドの実行終了を待つためにブロックされることがある。別の例としてはHaskellの<code>IO</code>オブジェクトがあり、ユーザ入力を含んだり、将来のバージョンの宇宙でモニタに「Hello
          World!」と表示されているのを含んだりできる。この解釈によれば、関手対象とは、パラメーター化された型の値を含みうるものだ。あるいは、これらの値を生成するためのレシピを含むこともできる。値にアクセスできるかは全く気にしない――それは完全にオプションであり、関手の守備範囲外だ。関心があるのは、これらの値を関手を使って操作できるかだけだ。値にアクセスできるなら、操作の結果を確認できるはずだ。アクセスできないなら、操作が正しく合成され、恒等関数による操作が何も変更しないことに注意するだけでよい。関手対象内の値へのアクセスをいかに気にしていないか示すため、引数<code>a</code>を完全に無視する型コンストラクターを例に挙げよう:
        </p>
        <div class="sourceCode" id="cb190">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Const</span> c a <span class="ot">=</span> <span class="dt">Const</span> c</span></code></pre>
        </div>
        <p>
          <code>Const</code>型コンストラクターは<code>c</code>と<code>a</code>の2つの型を取る。アローコンストラクターで行ったように、部分適用で関手を作成しよう。データコンストラクター
          (これも<code>Const</code>と呼ばれる)
          は型<code>c</code>の値を1つだけ取る。これは<code>a</code>には依存しない。この型コンストラクターの<code>fmap</code>の型は次のようになる:
        </p>
        <div class="sourceCode" id="cb191">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Const</span> c a <span class="ot">-&gt;</span> <span class="dt">Const</span> c b</span></code></pre>
        </div>
        <p>この関手は型引数を無視するので、<code>fmap</code>の実装は関数の引数を無視してよい――関数は扱うものがない。</p>
        <div class="sourceCode" id="cb192">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Const</span> c) <span class="kw">where</span></span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> _ (<span class="dt">Const</span> v) <span class="ot">=</span> <span class="dt">Const</span> v</span></code></pre>
        </div>
        <p>これはC++ではもう少し明確かもしれない
          (この言葉を口にするとは思わなかった！)。型引数はコンパイル時に決まるのに対し、値は実行時に決まり、より強い区別があるからだ。</p>
        <div class="sourceCode" id="cb193">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> C<span class="op">,</span> <span class="kw">class</span> A<span class="op">&gt;</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Const <span class="op">{</span></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>    Const<span class="op">(</span>C v<span class="op">)</span> <span class="op">:</span> _v<span class="op">(</span>v<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>    C _v<span class="op">;</span></span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre>
        </div>
        <p><code>fmap</code>のC++実装も関数の引数を無視し、<code>Const</code>引数の値を変更せずに本質的に再キャストする。</p>
        <div class="sourceCode" id="cb194">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> C<span class="op">,</span> <span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a>Const<span class="op">&lt;</span>C<span class="op">,</span> B<span class="op">&gt;</span> fmap<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;</span> f<span class="op">,</span> Const<span class="op">&lt;</span>C<span class="op">,</span> A<span class="op">&gt;</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Const<span class="op">&lt;</span>C<span class="op">,</span> B<span class="op">&gt;{</span>c<span class="op">.</span>_v<span class="op">};</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>その奇妙さにもかかわらず、<code>Const</code>関手は多くの構成で重要な役目を果たしている。圏論では、これは先に述べた<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>関手の特殊なケースであり、ブラックホールの自己関手版だ。今後もっと多く目にすることになるだろう。</p>
        <h2 data-number="7.3" id="関手の合成"><span class="header-section-number">7.3</span> 関手の合成</h2>
        <p>
          圏の間の関数が合成することは、集合の間の関数が合成するのと同様だと考えれば納得するのは難しくない。2つの関手の合成は、対象に作用するときは、それぞれの対象の写像の合成にすぎず、射に作用するときも同様だ。2つの関手を飛び越えたあと、恒等射は恒等射となり、射の合成は射の合成となる。これは大したことではない。特に、自己関手を合成するのは簡単だ。関数<code>maybeTail</code>を覚えているだろうか？
          ここではHaskellの組み込みのリスト実装を使って書き直そう:</p>
        <div class="sourceCode" id="cb195">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="ot">maybeTail ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [a]</span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a>maybeTail [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a>maybeTail (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Just</span> xs</span></code></pre>
        </div>
        <p>
          (<code>Nil</code>と呼んでいた空リストコンストラクターは、空の角括弧のペア<code>[]</code>に置き換えられる。<code>Cons</code>コンストラクターは、中置演算子<code>:</code>
          (コロン) に置き換えられる。)
          <code>maybeTail</code>の結果は、<code>Maybe</code>と<code>[]</code>という2つの関手の合成が<code>a</code>に作用するような型だ。これらの関数はそれぞれ独自のバージョンの<code>fmap</code>を備えているが、もし何らかの関数<code>f</code>を合成の内容、つまり<code>Maybe</code>リストに適用したい場合はどうなるだろう？
          2層の関手を突破しなければならない。<code>fmap</code>を使えば外側の<code>Maybe</code>は突破できる。しかし、<code>f</code>はリストでは動作しないので、<code>Maybe</code>内に<code>f</code>を単に送ることはできない。内部リストを操作するには、<code>(fmap f)</code>を送る必要がある。たとえば、整数の<code>Maybe</code>リストの要素を2乗するにはどうするか見てみよう:
        </p>
        <div class="sourceCode" id="cb196">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a>square x <span class="ot">=</span> x <span class="op">*</span> x</span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a><span class="ot">mis ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]</span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a>mis <span class="ot">=</span> <span class="dt">Just</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb196-5"><a href="#cb196-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-6"><a href="#cb196-6" aria-hidden="true" tabindex="-1"></a>mis2 <span class="ot">=</span> <span class="fu">fmap</span> (<span class="fu">fmap</span> square) mis</span></code></pre>
        </div>
        <p>
          コンパイラーは、型を分析した後、外側の<code>fmap</code>に対しては<code>Maybe</code>インスタンスからの実装を使い、内側のものに対してはlist関手の実装を使う必要があることを理解する。上記のコードを次のように書き換えられるのは、すぐには自明に思えないかもしれない:
        </p>
        <div class="sourceCode" id="cb197">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>mis2 <span class="ot">=</span> (<span class="fu">fmap</span> <span class="op">.</span> <span class="fu">fmap</span>) square mis</span></code></pre>
        </div>
        <p>だが、<code>fmap</code>は引数が1つだけの関数と見なせることを思い出してほしい:</p>
        <div class="sourceCode" id="cb198">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</span></code></pre>
        </div>
        <p>この例では、<code>(fmap . fmap)</code>内の2番目の<code>fmap</code>は引数として次のものを取る:</p>
        <div class="sourceCode" id="cb199">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="ot">square ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre>
        </div>
        <p>そして、次の型の関数を返す:</p>
        <div class="sourceCode" id="cb200">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a>[<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span></code></pre>
        </div>
        <p>最初の<code>fmap</code>がこの関数を受け取り、次の関数を返す:</p>
        <div class="sourceCode" id="cb201">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Maybe</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]</span></code></pre>
        </div>
        <p>
          最後に、この関数は<code>mis</code>に適用される。したがって、2つの関手を合成すると、対応する2つの<code>fmap</code>を合成した<code>fmap</code>を持つ関手になる。圏論に話を戻すと、関手の合成が結合性を持つのは、ごく自明だ
          (対象の写像が結合性を持ち、射の写像も結合性を持つ)。また、すべての圏には自明な恒等関手がある。それはすべての対象をそれ自身に写し、すべての射をそれ自身に写す。つまり、関手はある圏の射と全く同じ性質を持っている。しかし、それはどのような圏だろうか？
          対象が圏であり射が関手である圏でなければならない。すなわち、圏の圏だ。ところが、<em>すべての</em>圏の圏はそれ自体を含まなければならず、すべての集合の集合を不可能にしたのと同じ種類の矛盾にぶつかることになる。しかし、<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>と呼ばれる、すべての<em>小さい</em>圏の圏がある
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>自体は大きい圏なので、それ自体のメンバーにはなれない)。小さい圏で対象が形成するのは、集合よりも大きな何かではなく、集合だ。圏論では、数えられない無限集合であっても「小さい」とみなされることに注意してほしい。これらに言及しようと思ったのは、同じ構造が抽象化の多くのレベルで繰り返されているのを認識できることが、非常に驚くべきことだからだ。関手が圏を形成することについても後で説明する。
        </p>
        <h2 data-number="7.4" id="課題-6"><span class="header-section-number">7.4</span> 課題</h2>
        <ol type="1">
          <li>
            <p>次のように定義することで、<code>Maybe</code>型コンストラクターを関手に変換できるか？</p>
            <div class="sourceCode" id="cb202">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> _ _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre>
            </div>
            <p>これは両方の引数を無視する。(ヒント:
              関手の規則をチェックする。)</p>
          </li>
          <li>
            <p>Reader関手について関手の規則を証明せよ。ヒント:
              本当に単純だ。</p>
          </li>
          <li>
            <p>2番目に好きな言語でReader関手を実装せよ
              (1番目は当然、Haskellだ)。</p>
          </li>
          <li>
            <p>List関手について関手の規則を証明せよ。適用するリストの尾部について規則が真であると仮定する
              (言い換えると、<em>帰納法</em>を使う)。</p>
          </li>
        </ol>
        <h1 data-number="8" id="functoriality"><span class="header-section-number">8</span> 関手性</h1>
        <p>関手とは何かを学び、いくつかの例を見てきたのに続いて、小さい関手から大きい関手を作る方法を見てみよう。特に興味深いのは、どの型コンストラクター
          (圏内の対象間の写像に対応する) を関手 (射の間の写像を含む)
          に拡張できるのかという点だ。</p>
        <h2 data-number="8.1" id="双関手"><span class="header-section-number">8.1</span> 双関手</h2>
        <p>関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>
          (圏の圏) の射であるため、射 (特に関数)
          に関する直観の多くは関手にも当てはまる。たとえば、2つの引数を取る関数と同じように、2つの引数を取る関手、すなわち<span id="bifunctor" class="keyword">双関手</span>
          (bifunctor)
          が存在しうる。対象について、双関手は対象のすべてのペアを写す。1つは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から、もう1つは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>から、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐄</mi>
              <annotation encoding="application/x-tex">\mathbf{E}</annotation>
            </semantics>
          </math>の対象に写す。これは単に、圏の<span id="Cartesian_product" class="keyword">カルテシアン積</span> (Cartesian
          product)
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐃</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C} \times{} \mathbf{D}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐄</mi>
              <annotation encoding="application/x-tex">\mathbf{E}</annotation>
            </semantics>
          </math>への写像だと言っているだけであることに注意してほしい。
        </p>
        <p><img src="images/bifunctor.jpg" style="width:30.0%" /></p>
        <p>実に簡単だ。しかし、関手性によると、双関手は射も写さなければならない。ただし、今回は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の射のペアを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐄</mi>
              <annotation encoding="application/x-tex">\mathbf{E}</annotation>
            </semantics>
          </math>の射に写す必要がある。</p>
        <p>ここでも、射のペアは直積圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐃</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C} \times{} \mathbf{D}</annotation>
            </semantics>
          </math>内の1つの射に相当する。圏のカルテシアン積における射を、ある対象のペアから別の対象のペアへ進む射のペアと定義した。これらの射のペアは、自明な方法で合成できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>f</mi>
                  <mo>,</mo>
                  <mi>g</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>∘</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>f</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <mi>g</mi>
                  <mi>′</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>=</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>f</mi>
                  <mo>∘</mo>
                  <mi>f</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <mi>g</mi>
                  <mo>∘</mo>
                  <mi>g</mi>
                  <mi>′</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">(f, g) \circ (f&#39;, g&#39;) = (f \circ f&#39;, g \circ g&#39;)
              </annotation>
            </semantics>
          </math></p>
        <p>合成は結合的であり、恒等射として、恒等射の対
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mo>,</mo>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(\mathbf{id}, \mathbf{id})</annotation>
            </semantics>
          </math>
          を持つ。圏のカルテシアン積はまさに圏だ。
        </p>
        <p>
          しかし、さらに簡単に双関手について考えたいなら、両方の引数を取る関手だと見なせばよい。したがって、関手の規則――結合性と恒等射の保存――を関手から双関手へ翻訳するのではなく、引数ごとに別々にチェックすれば十分だろう。圏のペアから第3の圏への写像があり、それが関手的であることを各引数で別々に
          (たとえば、もう一方の引数を定数にするなどして)
          証明すれば、写像は自動的に双関手になる。<em>関手的</em>とは、正直な関手
          (honest functor) のように射に作用するという意味で用いている。</p>
        <p>
          Haskellで双関手を定義しよう。この場合、3つの圏はすべて同じであり、Haskellの型の圏だ。双関手は、2つの型引数を取る型コンストラクターだ。型クラス<code>Bifunctor</code>の定義をライブラリ<code>Control.Bifunctor</code>から採ると、次のとおりだ:
        </p>
        <div class="sourceCode" id="cb203">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Bifunctor</span> f <span class="kw">where</span></span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    bimap ::</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a b <span class="ot">-&gt;</span> f c d</span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>    bimap g h <span class="ot">=</span> first g <span class="op">.</span> second h</span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    first ::</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a b <span class="ot">-&gt;</span> f c b</span>
<span id="cb203-5"><a href="#cb203-5" aria-hidden="true" tabindex="-1"></a>    first g <span class="ot">=</span> bimap g <span class="fu">id</span></span>
<span id="cb203-6"><a href="#cb203-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    second ::</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a b <span class="ot">-&gt;</span> f a d</span>
<span id="cb203-7"><a href="#cb203-7" aria-hidden="true" tabindex="-1"></a>    second <span class="ot">=</span> bimap <span class="fu">id</span></span></code></pre>
        </div>
        <figure>
          <img src="images/bimap.jpg" style="width:30.0%" alt="bimap" />
          <figcaption aria-hidden="true">bimap</figcaption>
        </figure>
        <p>
          型変数<code>f</code>は双関手を表す。これは、どの型シグネチャにおいても常に2つの型引数に適用されているのがわかる。最初の型シグニチャは、2つの関数を同時に写す<code>bimap</code>を定義している。その結果はリフトされた関数<code>(f a b -&gt; f c d)</code>であり、双関手の型コンストラクターが生成する型に対して作用する。<code>bimap</code>には<code>first</code>と<code>second</code>の観点でのデフォルト実装があり、双関手を定義するにはそれぞれの引数に個別に関手性があれば十分なことを示している。
        </p>
        <p>
          他の2つの型シグニチャ、<code>first</code>と<code>second</code>は、2つの<code>fmap</code>であり、それぞれ最初と2番目の引数について<code>f</code>の関手性を示す。
        </p>
        <table>
          <tbody>
            <tr class="odd">
              <td style="text-align: left;"><img src="images/first.jpg" style="width:65.0%" alt="first" /></td>
              <td style="text-align: left;"><img src="images/second.jpg" style="width:60.0%" alt="second" /></td>
            </tr>
          </tbody>
        </table>
        <p>この型クラス定義では、両方のデフォルト実装を<code>bimap</code>として提供している。</p>
        <p>
          <code>Bifunctor</code>のインスタンスを宣言するときには、<code>bimap</code>を実装してデフォルトの<code>first</code>と<code>second</code>を受け入れるか、<code>first</code>と<code>second</code>の両方を実装してデフォルトの<code>bimap</code>を受け入れるか、どちらかを選択できる
          (もちろん、3つすべてを実装することもできるが、それらが相互に正しく関連付けられているのを確認するのはプログラマーの責任になる)。
        </p>
        <h2 data-number="8.2" id="積と余積の双関手"><span class="header-section-number">8.2</span> 積と余積の双関手</h2>
        <p>双関手の重要な例として、圏論的な積がある。それは<a
            href="#products-and-coproducts">普遍的構成</a>によって定義される2つの対象の積だ。対象の任意のペアに対して積が存在する場合、これらの対象から積への写像は双関手的だ。これは一般に真であり、Haskellに特によく当てはまる。以下に、ペアのコンストラクターについての<code>Bifunctor</code>インスタンスを示す。最も単純な直積型だ:
        </p>
        <div class="sourceCode" id="cb204">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Bifunctor</span> (,) <span class="kw">where</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a>    bimap f g (x, y) <span class="ot">=</span> (f x, g y)</span></code></pre>
        </div>
        <p>選択肢はあまりない:
          <code>bimap</code>は単に最初の関数をペアの最初のコンポーネントに適用し、2番目の関数を2番目のコンポーネントに適用するだけだ。次のような型を想定すれば、ほとんどコード自体が説明になっている:
        </p>
        <div class="sourceCode" id="cb205">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bimap ::</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> (a, b) <span class="ot">-&gt;</span> (c, d)</span></code></pre>
        </div>
        <p>ここでの双関手の働きは、たとえば次のような型の対を作ることだ:</p>
        <div class="sourceCode" id="cb206">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a>(,) a b <span class="ot">=</span> (a, b)</span></code></pre>
        </div>
        <p>
          双対性より、余積は、圏内の対象のすべてのペアに対して定義されているなら双関手でもある。Haskellでは、<code>Either</code>の型コンストラクターが<code>Bifunctor</code>のインスタンスであることが良い例だ:
        </p>
        <div class="sourceCode" id="cb207">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Bifunctor</span> <span class="dt">Either</span> <span class="kw">where</span></span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a>    bimap f _ (<span class="dt">Left</span> x)  <span class="ot">=</span> <span class="dt">Left</span> (f x)</span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>    bimap _ g (<span class="dt">Right</span> y) <span class="ot">=</span> <span class="dt">Right</span> (g y)</span></code></pre>
        </div>
        <p>これもコード自体が説明になっている。</p>
        <p>モノイダル圏について話したときのことを覚えているだろうか？
          モノイダル圏は、対象に作用する二項演算子と単位対象とを定義する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>はカルテシアン積に関して単集合を単位とするモノイダル圏である、と述べた。また、非交和に関しても空集合を単位とするモノイダル圏だ。述べていなかったのは、モノイダル圏の要件の1つは二項演算子が双関手であることだ、ということだ。これは非常に重要な要件だ。射によって定義される圏の構造とモノイダル積とを両立させたいからだ。我々は今、モノイダル圏の完全な定義に一歩近づいている
          (そこに到達する前に、まだ自然性について学ぶ必要がある)。</p>
        <h2 data-number="8.3" id="関手的代数的データ型"><span class="header-section-number">8.3</span> 関手的代数的データ型</h2>
        <p>これまで何例か見てきたパラメーター化されたデータ型に対して、<code>fmap</code>を定義でき、それらが関手であることがわかった。複雑なデータ型は単純なデータ型から構成される。特に、代数的データ型
          (ADT)
          は、和と積を使って作成される。先ほど、和と積が関手的であるのを見た。関手が合成するのも知っている。したがって、ADTの基本的な構成要素が関手的であると示せれば、パラメーター化されたADTも関手的だとわかる。</p>
        <p>では、パラメーター化された代数的データ型の構成要素は何だろうか？
          まず、<code>Maybe</code>における<code>Nothing</code>や、<code>List</code>における<code>Nil</code>のように、関手の型パラメーターに依存しない要素がある。それらは<code>Const</code>関手と等価だ。<code>Const</code>関手は型パラメーターを無視することを忘れないでほしい
          (実際には、興味があるのは<em>2番目</em>の型パラメーターであり、最初のパラメーターは一定に保たれる)。</p>
        <p>次に、<code>Maybe</code>における<code>Just</code>のように、単に型パラメーター自体をカプセル化する要素がある。これらは恒等関手と等価だ。以前、恒等関手について<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>の恒等射として言及したが、Haskellでの定義は説明しなかった。それをここに示す:</p>
        <div class="sourceCode" id="cb208">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Identity</span> a <span class="ot">=</span> <span class="dt">Identity</span> a</span></code></pre>
        </div>
        <div class="sourceCode" id="cb209">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Identity</span> <span class="kw">where</span></span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Identity</span> x) <span class="ot">=</span> <span class="dt">Identity</span> (f x)</span></code></pre>
        </div>
        <p><code>Identity</code>は、型<code>a</code>の (不変な)
          値を常に1つだけ格納する、最も単純なコンテナと見なせる。</p>
        <p>代数的データ構造の他のすべては、これら2つのプリミティブから積と和を使って構成される。</p>
        <p>この新しい知識に基づいて、<code>Maybe</code>型コンストラクターを改めて見てみよう。</p>
        <div class="sourceCode" id="cb210">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre>
        </div>
        <p>これは2つの型の和だ。和が関手的なのは知っている。1つ目の部分である<code>Nothing</code>は、<code>a</code>に作用する<code>Const ()</code>として表せる
          (<code>Const</code>の最初の型パラメーターはunitに設定されている――後で<code>Const</code>のさらに興味深い使い方を説明する)。2つ目の部分は、恒等関手の別名だ。<code>Maybe</code>は、同型を除いて、次のようにも定義できる:
        </p>
        <div class="sourceCode" id="cb211">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Either</span> (<span class="dt">Const</span> () a) (<span class="dt">Identity</span> a)</span></code></pre>
        </div>
        <p>
          したがって、<code>Maybe</code>は双関手<code>Either</code>を2つの関手<code>Const ()</code>と<code>Identity</code>に合成したものだ。(<code>Const</code>は実際には双関手だが、ここでは常に部分適用で使う。)
        </p>
        <p>
          関手の合成が関手であることはすでに見た。同じことが双関手にも当てはまるのは容易に納得できる。必要なのは、2つの関手を持つ双関手の合成が、射にどのように作用するかを理解することだけだ。2つの射が与えられた場合、片方の関手で片方の射を、もう1つの関手でもう1つの射をそれぞれリフトするだけでよい。次に、そのようにして得られるリフトされた射のペアを、双関手でリフトする。
        </p>
        <p>この合成はHaskellで表現できる。双関手<code>bf</code>
          (2つの型を引数に取る双関手コンストラクターである型変数)、2つの関手<code>fu</code>と<code>gu</code>
          (それぞれ1つの型変数を取る型コンストラクター)、および2つの通常の型<code>a</code>と<code>b</code>によってパラメーター化されるデータ型を定義しよう。<code>fu</code>を<code>a</code>に適用し、<code>gu</code>を<code>b</code>に適用し、それから<code>bf</code>を結果の2つの型に適用する:
        </p>
        <div class="sourceCode" id="cb212">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">BiComp</span> bf fu gu a b <span class="ot">=</span> <span class="dt">BiComp</span> (bf (fu a) (gu b))</span></code></pre>
        </div>
        <p>これが対象の合成であり、型の合成だ。Haskellで型コンストラクターを型に適用する方法が、関数を引数に適用するのと同じであることに注目してほしい。それらは同じ構文だ。</p>
        <p>
          少し迷ったなら、<code>BiComp</code>を、<code>Either</code>、<code>Const ()</code>、<code>Identity</code>、<code>a</code>、<code>b</code>の順に適用してみてほしい。<code>Maybe b</code>の必要最小限のバージョンを復元できるだろう
          (<code>a</code>は無視する)。</p>
        <p>
          新しいデータ型<code>BiComp</code>は、<code>a</code>および<code>b</code>内の双関手だが、<code>bf</code>自体が<code>Bifunctor</code>であり、<code>fu</code>および<code>gu</code>が<code>Functor</code>である場合に限る。コンパイラは、<code>bf</code>に対する<code>bimap</code>の定義と、<code>fu</code>と<code>gu</code>に対する<code>fmap</code>の定義とが存在することを認識している必要がある。Haskellでは、これはインスタンス宣言の前提条件として表現される。つまり、クラス制約のセットが二重矢印の前に書かれる:
        </p>
        <div class="sourceCode" id="cb213">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Bifunctor</span> bf, <span class="dt">Functor</span> fu, <span class="dt">Functor</span> gu) <span class="ot">=&gt;</span></span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Bifunctor</span> (<span class="dt">BiComp</span> bf fu gu) <span class="kw">where</span></span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a>    bimap f1 f2 (<span class="dt">BiComp</span> x) <span class="ot">=</span> <span class="dt">BiComp</span> ((bimap (<span class="fu">fmap</span> f1) (<span class="fu">fmap</span> f2)) x)</span></code></pre>
        </div>
        <p>
          <code>BiComp</code>に対する<code>bimap</code>の実装は、<code>bf</code>に対する<code>bimap</code>と、<code>fu</code>および<code>gu</code>に対する2つの<code>fmap</code>とで与えられる。コンパイラは、<code>BiComp</code>が使われるたびに、すべての型を自動的に推測し、適切なオーバーロード関数を選択する。
        </p>
        <p><code>bimap</code>の定義内の<code>x</code>の型は次のとおりだ:</p>
        <div class="sourceCode" id="cb214">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a>bf (fu a) (gu b)</span></code></pre>
        </div>
        <p>
          これはかなりの分量だ。外側の<code>bimap</code>は外側の<code>bf</code>の層を貫通しており、2つの<code>fmap</code>はそれぞれ<code>fu</code>と<code>gu</code>の下まで掘り下げている。<code>f1</code>と<code>f2</code>の型が次の場合:
        </p>
        <div class="sourceCode" id="cb215">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f1 ::</span> a <span class="ot">-&gt;</span> a&#39;</span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a><span class="ot">f2 ::</span> b <span class="ot">-&gt;</span> b&#39;</span></code></pre>
        </div>
        <p>最終結果の型は<code>bf (fu a') (gu b')</code>となる:</p>
        <div class="sourceCode" id="cb216">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bimap ::</span>(fu a <span class="ot">-&gt;</span> fu a&#39;) <span class="ot">-&gt;</span> (gu b <span class="ot">-&gt;</span> gu b&#39;)</span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> bf (fu a) (gu b) <span class="ot">-&gt;</span> bf (fu a&#39;) (gu b&#39;)</span></code></pre>
        </div>
        <p>ジグソーパズルが好きな人なら、この種の型操作で何時間も楽しめるだろう。</p>
        <p><code>Maybe</code>が関手だと証明する必要はなかったとわかった。この事実は、2つの関手的プリミティブの和という構築方法から導かれたものだ。</p>
        <p>鋭い読者ならこう尋ねるだろう:
          代数的データ型に対する<code>Functor</code>インスタンスをそれほど機械的に導出できるのなら、コンパイラによって自動化して実行できないのか？
          実際、可能であり、行われている。ただし、ソースファイルの先頭に次の行を含めることで、特定のHaskell拡張を有効にする必要がある:</p>
        <div class="sourceCode" id="cb217">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span></code></pre>
        </div>
        <p>そして、データ構造体に<code>derivating Functor</code>を追加する:</p>
        <div class="sourceCode" id="cb218">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre>
        </div>
        <p>すると、対応する<code>fmap</code>が自動的に実装される。</p>
        <p>代数的データ構造の正則性 (regularity)
          により、<g>関手</g>だけでなく、前に述べた<g>Eq</g>
          型クラスを含む、いくつかの型クラスのインスタンスを派生させられる。コンパイラーに独自の型クラスのインスタンスを派生させるように教えるという選択肢もあるが、それはもう少し高度だ。もっとも、基本的な構成要素に対する動作と和と積とを提供し、残りの部分はコンパイラーに計算させるという考え方は同じだ。
        </p>
        <h2 data-number="8.4" id="cでの関手-1"><span class="header-section-number">8.4</span> C++での関手</h2>
        <p>
          C++プログラマーなら、関手の実装に関しては、明らかに自分でやることになる。しかし、C++でもある種の代数的データ構造は見つかるはずだ。そのようなデータ構造を総称テンプレートにすれば、<code>fmap</code>を素早く実装できるだろう。
        </p>
        <p>データ木構造を見てみよう。Haskellでは再帰的な直和型として定義される:</p>
        <div class="sourceCode" id="cb219">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Leaf</span> a <span class="op">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre>
        </div>
        <p>
          前にも述べたように、C++で直和型を実装する方法の1つは、クラス階層を使うことだ。オブジェクト指向言語では、<code>fmap</code>を基本クラス<code>Functor</code>の仮想関数として実装し、それをすべてのサブクラスでオーバーライドするのが自然だ。残念ながらこれは不可能だ。なぜなら、<code>fmap</code>はテンプレートであり、それが作用する対象の型
          (<code>this</code>ポインタ)
          だけでなく、それに適用された関数の戻り型によってもパラメーター化されているからだ。C++では仮想関数はテンプレート化できない。<code>fmap</code>を総称フリー関数として実装し、パターンマッチングを<code>dynamic_cast</code>に置き換えよう。
        </p>
        <p>基本クラスは、動的キャストをサポートするために少なくとも1つの仮想関数を定義する必要があるため、デストラクターを仮想関数にする
          (いずれにしても良い考えだ):</p>
        <div class="sourceCode" id="cb220">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Tree <span class="op">{</span></span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>Tree<span class="op">()</span> <span class="op">{};</span></span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre>
        </div>
        <p><code>Leaf</code>は、<code>Identity</code>関手を偽装したものだ:</p>
        <div class="sourceCode" id="cb221">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Leaf <span class="op">:</span> <span class="kw">public</span> Tree<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a>    T _label<span class="op">;</span></span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true" tabindex="-1"></a>    Leaf<span class="op">(</span>T l<span class="op">)</span> <span class="op">:</span> _label<span class="op">(</span>l<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb221-5"><a href="#cb221-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre>
        </div>
        <p><code>Node</code>は直積型だ:</p>
        <div class="sourceCode" id="cb222">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Node <span class="op">:</span> <span class="kw">public</span> Tree<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a>    Tree<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span> _left<span class="op">;</span></span>
<span id="cb222-4"><a href="#cb222-4" aria-hidden="true" tabindex="-1"></a>    Tree<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span> _right<span class="op">;</span></span>
<span id="cb222-5"><a href="#cb222-5" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">(</span>Tree<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span> l<span class="op">,</span> Tree<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">*</span> r<span class="op">)</span> <span class="op">:</span> _left<span class="op">(</span>l<span class="op">),</span> _right<span class="op">(</span>r<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb222-6"><a href="#cb222-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre>
        </div>
        <p>
          <code>fmap</code>を実装するときには、<code>Tree</code>の型で動的ディスパッチを利用する。<code>Leaf</code>の場合は<code>Identity</code>版の<code>fmap</code>を適用し、<code>Node</code>の場合は2つの<code>Tree</code>関手で構成された双関手のように扱う。C++プログラマーとしては、これらの用語を使ってコードを分析することに慣れていないかもしれないが、圏的な考え方を実践するには適している。
        </p>
        <div class="sourceCode" id="cb223">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">,</span> <span class="kw">class</span> B<span class="op">&gt;</span></span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a>Tree<span class="op">&lt;</span>B<span class="op">&gt;</span> <span class="op">*</span> fmap<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span>B<span class="op">(</span>A<span class="op">)&gt;</span> f<span class="op">,</span> Tree<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">*</span> t<span class="op">)</span></span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true" tabindex="-1"></a>    Leaf<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">*</span> pl <span class="op">=</span> <span class="kw">dynamic_cast</span> <span class="op">&lt;</span>Leaf<span class="op">&lt;</span>A<span class="op">&gt;*&gt;(</span>t<span class="op">);</span></span>
<span id="cb223-5"><a href="#cb223-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pl<span class="op">)</span></span>
<span id="cb223-6"><a href="#cb223-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">new</span> Leaf<span class="op">&lt;</span>B<span class="op">&gt;(</span>f <span class="op">(</span>pl<span class="op">-&gt;</span>_label<span class="op">));</span></span>
<span id="cb223-7"><a href="#cb223-7" aria-hidden="true" tabindex="-1"></a>    Node<span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="op">*</span> pn <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>Node<span class="op">&lt;</span>A<span class="op">&gt;*&gt;(</span>t<span class="op">);</span></span>
<span id="cb223-8"><a href="#cb223-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pn<span class="op">)</span></span>
<span id="cb223-9"><a href="#cb223-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">new</span> Node<span class="op">&lt;</span>B<span class="op">&gt;(</span> fmap<span class="op">&lt;</span>A<span class="op">&gt;(</span>f<span class="op">,</span> pn<span class="op">-&gt;</span>_left<span class="op">)</span></span>
<span id="cb223-10"><a href="#cb223-10" aria-hidden="true" tabindex="-1"></a>                          <span class="op">,</span> fmap<span class="op">&lt;</span>A<span class="op">&gt;(</span>f<span class="op">,</span> pn<span class="op">-&gt;</span>_right<span class="op">));</span></span>
<span id="cb223-11"><a href="#cb223-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb223-12"><a href="#cb223-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>簡単のため、メモリとリソース管理の問題は無視することにしたが、本番コードではおそらくスマート・ポインター
          (uniqueかsharedかはポリシーによる) を使うことになるだろう。</p>
        <p><code>fmap</code>のHaskell実装と比較してほしい:</p>
        <div class="sourceCode" id="cb224">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Tree</span> <span class="kw">where</span></span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Leaf</span> a) <span class="ot">=</span> <span class="dt">Leaf</span> (f a)</span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Node</span> t t&#39;) <span class="ot">=</span> <span class="dt">Node</span> (<span class="fu">fmap</span> f t) (<span class="fu">fmap</span> f t&#39;)</span></code></pre>
        </div>
        <p>この実装は、コンパイラによって自動的に導出することもできる。</p>
        <h2 data-number="8.5" id="writer関手"><span class="header-section-number">8.5</span> Writer関手</h2>
        <p>前に<a
            href="#kleisli-categories">Kleisli圏</a>を説明したとき、戻ってくると約束した。Kleisli圏の射は、<code>Writer</code>データ構造体を返す「装飾された」関数として表現されていた。
        </p>
        <div class="sourceCode" id="cb225">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Writer</span> a <span class="ot">=</span> (a, <span class="dt">String</span>)</span></code></pre>
        </div>
        <p>
          すでに述べたように、装飾は自己関手と何らかの関係にある。そして実際、<code>Writer</code>の型コンストラクターは、<code>a</code>について関手的だ。単純な直積型なので、<code>fmap</code>を実装する必要すらない。
        </p>
        <p>しかし、Kleisli圏と関手の間には、どのような一般的な関係があるのだろうか？
          Kleisli圏は圏であり、合成と恒等射を定義する。合成はfishオペレータによって与えられるのを思い出してほしい:</p>
        <div class="sourceCode" id="cb226">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;=&gt;) ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Writer</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> <span class="dt">Writer</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Writer</span> c)</span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true" tabindex="-1"></a>m1 <span class="op">&gt;=&gt;</span> m2 <span class="ot">=</span> \x <span class="ot">-&gt;</span></span>
<span id="cb226-3"><a href="#cb226-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (y, s1) <span class="ot">=</span> m1 x</span>
<span id="cb226-4"><a href="#cb226-4" aria-hidden="true" tabindex="-1"></a>        (z, s2) <span class="ot">=</span> m2 y</span>
<span id="cb226-5"><a href="#cb226-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> (z, s1 <span class="op">++</span> s2)</span></code></pre>
        </div>
        <p>また、恒等射は<code>return</code>という関数によって計算される:</p>
        <div class="sourceCode" id="cb227">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Writer</span> a</span>
<span id="cb227-2"><a href="#cb227-2" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> x <span class="ot">=</span> (x, <span class="st">&quot;&quot;</span>)</span></code></pre>
        </div>
        <p>この2つの関数の型を十分に長く見れば
          (つまり、十分に<em>長く</em>見れば)、それらを組み合わせて、<code>fmap</code>として機能する適切な型シグネチャを持つ関数を作成する方法を見つけられる。それは次のようになる:</p>
        <div class="sourceCode" id="cb228">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f <span class="ot">=</span> <span class="fu">id</span> <span class="op">&gt;=&gt;</span> (\x <span class="ot">-&gt;</span> <span class="fu">return</span> (f x))</span></code></pre>
        </div>
        <p>
          この例では、fish演算子は2つの関数を組み合わせている。1つはおなじみの<code>id</code>であり、もう1つは、引数に<code>f</code>を適用した結果に<code>return</code>を適用するラムダ関数だ。理解するのが最も難しいのは<code>id</code>を使うところだろう。Fish演算子の引数となる関数は、「通常の」型を受け取って装飾された型を返す関数ではないのだろうか？
          実は、そんなことはない。<code>a -&gt; Writer b</code>の<code>a</code>が「普通の」型でなければならないとは誰も言っていない。これは型変数なので何でも良く、特に、<code>Writer b</code>のような装飾された型でも構わない。
        </p>
        <p>
          したがって、<code>id</code>は<code>Writer a</code>を受け取り、<code>Writer a</code>に変換する。Fish演算子は<code>a</code>の値を取り出し、<code>x</code>としてラムダに渡す。ここで、<code>f</code>はそれを<code>b</code>に変換し、<code>return</code>はそれを装飾して<code>Writer b</code>にする。これらすべてをまとめると、<code>Writer a</code>を受け取り、<code>Writer b</code>を返す関数が完成する。これは、<code>fmap</code>が生成するはずのものとまったく同じだ。
        </p>
        <p>
          注目してほしいのは、この引数が非常に汎用的であることだ。つまり、<code>Writer</code>は任意の型コンストラクターで置き換えられる。Fish演算子と<code>return</code>をサポートしていれば、<code>fmap</code>も定義できる。したがってKleisli圏での装飾は常に関手となる。(ただし、すべての関手がKleisli圏に由来するわけではない。)
        </p>
        <p>
          先ほど定義した<code>fmap</code>は、<code>derivating Functor</code>を使ってコンパイラによって導来された<code>fmap</code>と同じではないかと思うかもしれない。とても興味深いことに、そのとおりだ。そうなっているのは、Haskellが多相関数を実装する方法に由来する。それは<span
            id="parametric_polymorphism" class="keyword">パラメトリック多相</span>と呼ばれ、いわゆる<span id="theorem_for_free"
            class="keyword">theorems for
            free</span>の根源となっている。それらの定理の1つは、与えられた型コンストラクターに対して<code>fmap</code>の実装があって、それが恒等射を保存するなら、それは一意である、と述べている。
        </p>
        <h2 data-number="8.6" id="共変関手と反変関手"><span class="header-section-number">8.6</span> 共変関手と反変関手</h2>
        <p>Writer関手を振り返り終えたので、Reader関手に戻ろう。これは部分適用された関数-アロー型コンストラクターに基づく:</p>
        <div class="sourceCode" id="cb229">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a>(<span class="ot">-&gt;</span>) r</span></code></pre>
        </div>
        <p>これは型シノニムとして書き直せる:</p>
        <div class="sourceCode" id="cb230">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Reader</span> r a <span class="ot">=</span> r <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <p>これに対する<code>Functor</code>インスタンスは、これまで見てきたように、次のようになる:</p>
        <div class="sourceCode" id="cb231">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Reader</span> r) <span class="kw">where</span></span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f g <span class="ot">=</span> f <span class="op">.</span> g</span></code></pre>
        </div>
        <p>
          だが、ペアの型コンストラクターや<code>Either</code>型コンストラクターと同じく、この関数型コンストラクターは2つの型引数を取る。ペアや<code>Either</code>は両方の引数について関手的であり、すなわち双関手だった。この関数のコンストラクターも双関手だろうか？
        </p>
        <p>最初の引数で関手的にしてみよう。型シノニムから始めよう――<code>Reader</code>と似ているが、引数が反転している:</p>
        <div class="sourceCode" id="cb232">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Op</span> r a <span class="ot">=</span> a <span class="ot">-&gt;</span> r</span></code></pre>
        </div>
        <p>
          今回は、戻り値の型<code>r</code>を修正し、引数の型<code>a</code>を変更する。次のような型シグニチャを持つ<code>fmap</code>を実装するために、何らかの方法で型を一致させられるか見てみよう:
        </p>
        <div class="sourceCode" id="cb233">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> r)</span></code></pre>
        </div>
        <p>
          <code>a</code>を取りそれぞれ<code>b</code>と<code>r</code>を返す2つの関数だけでは、<code>b</code>を取り<code>r</code>を返す関数を作成する方法がまったくない。代わりに1つ目の関数を逆にして、<code>b</code>を受け取り<code>a</code>を返すようにできれば、状況は違ってくるだろう。任意の関数を逆にはできないが、反対圏に行くことはできる。
        </p>
        <p>簡単に要約すると、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>ごとに、双対圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐂</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}</annotation>
            </semantics>
          </math>が存在する。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と同じ対象を持つ圏だが、すべての矢印が逆になっている。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐂</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}</annotation>
            </semantics>
          </math>から他の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>への関手を考えてみよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∷</mo>
                <msup>
                  <mi>𝐂</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>→</mo>
                <mi>𝐃</mi>
              </mrow>
              <annotation encoding="application/x-tex">F \Colon \mathbf{C}^\mathit{op} \to \mathbf{D}</annotation>
            </semantics>
          </math></p>
        <p>このような関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐂</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}</annotation>
            </semantics>
          </math>の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>f</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">f^\mathit{op} \Colon a \to b</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <msup>
                  <mi>f</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>∷</mo>
                <mi>F</mi>
                <mi>a</mi>
                <mo>→</mo>
                <mi>F</mi>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">F f^\mathit{op} \Colon F a \to F b</annotation>
            </semantics>
          </math>に写す。しかし、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>f</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">f^\mathit{op}</annotation>
            </semantics>
          </math>は、もとの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>のある射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>b</mi>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon b \to a</annotation>
            </semantics>
          </math>と密かに対応している。反転に注意してほしい。</p>
        <p>さて、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>は正則関手
          (regular functor)
          だが、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>に基づいて定義できる別の写像があり、それは関手ではない。それを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>と呼ぼう。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>への写像だ。対象は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>と同じ方法で写されるが、射は逆に写される。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>b</mi>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon b \to a</annotation>
            </semantics>
          </math>を取り、それをまず反対の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>f</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">f^\mathit{op} \Colon a \to b</annotation>
            </semantics>
          </math>に写し、次に関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>を使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <msup>
                  <mi>f</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>∷</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">F f^\mathit{op} \Colon F\ a \to F\ b</annotation>
            </semantics>
          </math>を取得する。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F a</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">G a</annotation>
            </semantics>
          </math>と同じで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">F b</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">G b</annotation>
            </semantics>
          </math>と同じであることを考慮すると、この旅の全体は次のように記述できる:</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mi>f</mi>
                <mo>∷</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>→</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>G</mi>
                  <mi>a</mi>
                  <mo>→</mo>
                  <mi>G</mi>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">G f \Colon (b \to a) \to (G a \to G b)</annotation>
            </semantics>
          </math></p>
        <p>これは「ひねりのある関手」だ。このように射の方向を反転させる圏の写像は、<em>反変</em>
          (contravariant)
          関手と呼ばれる。反変関手は、反対圏からの正則関手にすぎないことに注意してほしい。その一方で、正則関手――これまでに学んだ関手――は<em>共変</em>
          (covariant) 関手と呼ばれる。</p>
        <figure>
          <img src="images/contravariant.jpg" style="width:30.0%" alt="反変" />
          <figcaption aria-hidden="true">反変</figcaption>
        </figure>
        <p>以下の型クラスは、Haskellにおける反変関手
          (実際には反変<em>自己</em>関手) を定義している:</p>
        <div class="sourceCode" id="cb234">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Contravariant</span> f <span class="kw">where</span></span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    contramap ::</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> f b)</span></code></pre>
        </div>
        <p>前述の型コンストラクター<code>Op</code>はこのインスタンスだ:</p>
        <div class="sourceCode" id="cb235">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> (<span class="dt">Op</span> r) <span class="kw">where</span></span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- (b -&gt; a) -&gt; Op r a -&gt; Op r b</span></span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a>    contramap f g <span class="ot">=</span> g <span class="op">.</span> f</span></code></pre>
        </div>
        <p>関数<code>f</code>が、<code>Op</code>の内容――関数<code>g</code>より<em>先</em>
          (つまり右側) に挿入されることに注意してほしい。</p>
        <p>
          <code>Op</code>に対する<code>contramap</code>の定義は、単に引数を反転した関数合成演算子であることに注意すれば、さらに簡潔にできるだろう。引数を反転するためには<code>flip</code>という特別な関数がある:
        </p>
        <div class="sourceCode" id="cb236">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a><span class="fu">flip</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c)</span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a><span class="fu">flip</span> f y x <span class="ot">=</span> f x y</span></code></pre>
        </div>
        <p>これにより、次の結果が得られる:</p>
        <div class="sourceCode" id="cb237">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a>contramap <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">.</span>)</span></code></pre>
        </div>
        <h2 data-number="8.7" id="プロ関手"><span class="header-section-number">8.7</span> プロ関手</h2>
        <p>これまで見てきたように、関手-アロー演算子は、最初の引数では反変、2番目の引数では共変だ。このような怪物に名前はあるのだろうか？
          終域圏が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>の場合、この怪物は<span id="profunctor" class="keyword">プロ関手</span> (profunctor)
          と呼ばれる。反変関手は反対圏の共変関手と等価なので、プロ関手は次のように定義される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>𝐂</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>×</mo>
                <mi>𝐃</mi>
                <mo>→</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}^\mathit{op} \times \mathbf{D} \to \mathbf{Set}
              </annotation>
            </semantics>
          </math></p>
        <p>
          Haskellの型は一次近似としては集合とみなせるので、引数が2つの型コンストラクター<code>p</code>に<code>Profunctor</code>という名前を適用する。1番目の引数は反-関手的で、2番目は関手的だ。<code>Data.Profunctor</code>ライブラリから適切な型クラスを引用しよう:
        </p>
        <div class="sourceCode" id="cb238">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Profunctor</span> p <span class="kw">where</span></span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  dimap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p b c <span class="ot">-&gt;</span> p a d</span>
<span id="cb238-3"><a href="#cb238-3" aria-hidden="true" tabindex="-1"></a>  dimap f g <span class="ot">=</span> lmap f <span class="op">.</span> rmap g</span>
<span id="cb238-4"><a href="#cb238-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  lmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p b c <span class="ot">-&gt;</span> p a c</span>
<span id="cb238-5"><a href="#cb238-5" aria-hidden="true" tabindex="-1"></a>  lmap f <span class="ot">=</span> dimap f <span class="fu">id</span></span>
<span id="cb238-6"><a href="#cb238-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  rmap ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p a c</span>
<span id="cb238-7"><a href="#cb238-7" aria-hidden="true" tabindex="-1"></a>  rmap <span class="ot">=</span> dimap <span class="fu">id</span></span></code></pre>
        </div>
        <p>
          これら3つの関数すべてにデフォルト実装がある。<code>Bifunctor</code>と同じように、<code>Profunctor</code>のインスタンスを宣言するとき、<code>dimap</code>を実装してデフォルトの<code>lmap</code>と<code>rmap</code>を受け入れるか、<code>lmap</code>と<code>rmap</code>の両方を実装してデフォルトの<code>dimap</code>を受け入れるか、どちらかを選択できる。
        </p>
        <figure>
          <img src="images/dimap.jpg" style="width:40.0%" alt="dimap" />
          <figcaption aria-hidden="true">dimap</figcaption>
        </figure>
        <p>ここで、関数-アロー演算子は<code>Profunctor</code>のインスタンスだと断定してよい:</p>
        <div class="sourceCode" id="cb239">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a>  dimap ab cd bc <span class="ot">=</span> cd <span class="op">.</span> bc <span class="op">.</span> ab</span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true" tabindex="-1"></a>  lmap <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">.</span>)</span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true" tabindex="-1"></a>  rmap <span class="ot">=</span> (<span class="op">.</span>)</span></code></pre>
        </div>
        <p>プロ関手の応用としてはHaskellのlensライブラリがある。エンドとコエンドについて述べるときに再び見ることになるだろう。</p>
        <h2 data-number="8.8" id="hom関手"><span class="header-section-number">8.8</span> Hom関手</h2>
        <p>上記の例は、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>のペアを取ってそれらの間の射の集合を割り当てる写像、すなわちhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          が関手であるという、より一般的な命題を反映している。それは直積圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>𝐂</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}\times{}\mathbf{C}</annotation>
            </semantics>
          </math>から集合の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への関手だ。</p>
        <p>射に対する作用を定義してみよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>𝐂</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}\times{}\mathbf{C}</annotation>
            </semantics>
          </math>の射は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>からの射のペアだ。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mi>′</mi>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon a&#39; \to a</annotation>
            </semantics>
          </math>
          <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>∷</mo>
                <mi>b</mi>
                <mo>→</mo>
                <mi>b</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">g \Colon b \to b&#39;</annotation>
            </semantics>
          </math>
        </p>
        <p>このペアのリフトは、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          から集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mi>′</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a&#39;, b&#39;)</annotation>
            </semantics>
          </math>
          への射 (関数)
          でなければならない。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          の任意の要素<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への射)
          を選択し、次を割り当てるだけでよい:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>∘</mo>
                <mi>h</mi>
                <mo>∘</mo>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">g \circ h \circ f</annotation>
            </semantics>
          </math></p>
        <p>これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mi>′</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a&#39;, b&#39;)</annotation>
            </semantics>
          </math>
          の要素だ。</p>
        <p>ご覧のとおり、hom関手はプロ関手の特殊なケースだ。</p>
        <h2 data-number="8.9" id="課題-7"><span class="header-section-number">8.9</span> 課題</h2>
        <ol type="1">
          <li>
            <p>データ型:</p>
            <div class="sourceCode" id="cb240">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Pair</span> a b <span class="ot">=</span> <span class="dt">Pair</span> a b</span></code></pre>
            </div>
            <p>が双関手であることを示せ。追加の課題として、<code>Bifunctor</code>を3つの方法すべてで実装し、それらの定義が、適用できる場合は常にデフォルトの実装と互換性があることを等式推論によって示せ。
            </p>
          </li>
          <li>
            <p><code>Maybe</code>の標準的な定義と次の脱糖との同型を示せ:</p>
            <div class="sourceCode" id="cb241">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Maybe&#39;</span> a <span class="ot">=</span> <span class="dt">Either</span> (<span class="dt">Const</span> () a) (<span class="dt">Identity</span> a)</span></code></pre>
            </div>
            <p>ヒント:
              2つの実装の間に2つの写像を定義する。追加の課題として、等式推論を使って、それらが互いに逆であることを示せ。</p>
          </li>
          <li>
            <p>
              別のデータ構造を試してみよう。私はこれを<code>PreList</code>と呼んでいる。<code>List</code>の前身だからだ。これは再帰を型パラメーター<code>b</code>で置き換える。
            </p>
            <div class="sourceCode" id="cb242">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">PreList</span> a b <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a b</span></code></pre>
            </div>
            <p><code>PreList</code>をそれ自体に再帰的に適用すれば、<code>List</code>の以前の定義を復元できる
              (どうなるかは、不動点について述べるときに説明する)。</p>
            <p><code>PreList</code>が<code>Bifunctor</code>のインスタンスであることを示せ。</p>
          </li>
          <li>
            <p>次のデータ型が<code>a</code>および<code>b</code>の双関手を定義していることを示せ:</p>
            <div class="sourceCode" id="cb243">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">K2</span> c a b <span class="ot">=</span> <span class="dt">K2</span> c</span></code></pre>
            </div>
            <div class="sourceCode" id="cb244">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Fst</span> a b <span class="ot">=</span> <span class="dt">Fst</span> a</span></code></pre>
            </div>
            <div class="sourceCode" id="cb245">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Snd</span> a b <span class="ot">=</span> <span class="dt">Snd</span> b</span></code></pre>
            </div>
            <p>追加の課題として、Conor McBrideの論文<a href="http://strictlypositive.org/CJ.pdf">Clowns to the Left of me,
                Jokers to the Right</a>と照らし合わせて解答を確認せよ。</p>
          </li>
          <li>
            <p>Haskell以外の言語で双関手を定義せよ。その言語で<code>bimap</code>を総称ペア用に実装せよ。</p>
          </li>
          <li>
            <p><code>std::map</code>は、2つのテンプレート引数<code>Key</code>と<code>T</code>について双関手またはプロ関手と見なすべきか？
              そう見なせるようにするには、このデータ型をどう再設計すればよいだろう？</p>
          </li>
        </ol>
        <h1 data-number="9" id="function-types"><span class="header-section-number">9</span> 関数型</h1>
        <p>ここまでは、関数型の意味について言い繕ってきた。関数型は他の型とは異なる。</p>
        <p><code>Integer</code>を例にとると、それは単なる整数の集合だ。<code>Bool</code>は2要素の集合だ。しかし、関数型<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \to b</annotation>
            </semantics>
          </math>はそれ以上のもので、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の間の射の集合だ。任意の圏における2つの対象間の射の集合はhom集合と呼ばれる。たまたま、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>圏では、すべてのhom集合はそれ自体が同じ圏の対象だ。なぜなら、それは結局は<em>集合</em>だからだ。</p>
        <figure>
          <img src="images/set-hom-set.jpg" style="width:35.0%" alt="Set圏のなかのhom集合は単なる集合だ。" />
          <figcaption aria-hidden="true">Set圏のなかのhom集合は単なる集合だ。</figcaption>
        </figure>
        <p>同じことは、hom集合が圏の外にあるような他の圏には当てはまらない。それらは<em>外部</em>
          (external) hom集合と呼ばれることもある。</p>
        <figure>
          <img src="images/hom-set.jpg" style="width:35.0%" alt="この圏Cのhom集合は外部集合だ。" />
          <figcaption aria-hidden="true">この圏Cのhom集合は外部集合だ。</figcaption>
        </figure>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>圏の自己参照的な性質によって、関数型は特殊なものになっている。しかし、少なくともいくつかの圏では、hom集合を表す対象を構築する方法がある。このような対象は<span id="internal"
            class="keyword">内部</span> (internal)
          hom集合と呼ばれる。</p>
        <h2 data-number="9.1" id="普遍的構成"><span class="header-section-number">9.1</span> 普遍的構成</h2>
        <p>関数の型が集合であることを一旦忘れて、ゼロから関数型を、より一般的には内部hom集合を構築してみよう。いつものように、ここでは<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>圏からヒントを得る。ただし、集合の性質に一切頼らないように気を付けて、他の圏でも構成が自動的に使えるようにする。</p>
        <p>関数型は、引数の型と結果の型の関係から、複合型と見なせる。対象間の関係を含む複合型の構築についてはすでに説明した。<a
            href="#products-and-coproducts">積と余積の型</a>を定義するのに普遍的構成を使った。同じトリックを使って関数型を定義できる。作成する関数型、引数の型、結果の型という3つの対象を含むパターンが必要になる。
        </p>
        <p>これら3つの型を結びつける自明なパターンは<span id="function_application" class="keyword">関数適用</span> (function
          application) あるいは<span id="evaluation" class="keyword">評価</span>
          (evaluation)
          と呼ばれる。関数型の候補が与えられたとして、それを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>と呼び、引数の型を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と呼ぶことにする。関数適用はこのペアを結果の型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>に写す
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>圏でない場合、これら3つの型はどれも他の対象と同様に単なる対象であることに注意)。3つの対象があり、そのうち
          (引数の型と結果の型を表す) 2つが決まった。</p>
        <p>関数適用も存在し、それは写像だ。どうすればこの写像をパターンに組み込めるだろう？
          対象の内部を見ることが許されている場合、関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>の要素)
          と引数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の要素)
          をペアにして、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mi>x</mi>
              </mrow>
              <annotation encoding="application/x-tex">f x</annotation>
            </semantics>
          </math>
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>へ適用したものであり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の要素)
          に写せる。</p>
        <figure>
          <img src="images/functionset.jpg" style="width:35.0%"
            alt="Setでは、関数の集合zから関数fを選び、集合 (型) aから引数xを選べる。その結果、集合 (型) bの中の要素f xが得られる。" />
          <figcaption aria-hidden="true">Setでは、関数の集合zから関数fを選び、集合
            (型) aから引数xを選べる。その結果、集合 (型) bの中の要素f
            xが得られる。</figcaption>
        </figure>
        <p>その一方で、個々のペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>f</mi>
                <mo>,</mo>
                <mi>x</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(f, x)</annotation>
            </semantics>
          </math>
          を扱うのではなく、関数型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>と引数の型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の<em>積</em>全体について述べることもできる。積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>z</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">z\times{}a</annotation>
            </semantics>
          </math>は対象であり、関数適用の射として、その対象から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への矢<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>を選択できる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>はすべてのペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>f</mi>
                <mo>,</mo>
                <mi>x</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(f, x)</annotation>
            </semantics>
          </math>
          を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mi>x</mi>
              </mrow>
              <annotation encoding="application/x-tex">f x</annotation>
            </semantics>
          </math>に写す関数になる。
        </p>
        <p>したがって、パターンはこうなる:
          2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の積が別の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>に射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>で接続されている。</p>
        <figure>
          <img src="images/functionpattern.jpg" style="width:40.0%" alt="普遍的構成の出発点である対象と射のパターン" />
          <figcaption aria-hidden="true">普遍的構成の出発点である対象と射のパターン</figcaption>
        </figure>
        <p>このパターンは、普遍的構成を使って関数型を特定するのに十分特化しているだろうか？
          すべての圏でそうだとは言えない。しかし、我々が関心を持っている圏ではそうだ。さらに別の疑問もある:
          積を先に定義せずに関数オブジェクトを定義できるだろうか？
          積が全く存在しない圏や、対象のすべてのペアに対しては存在しない圏もある。したがって、答えはノーだ。直積型がなければ関数型はない。これについては、後で冪乗について述べるときに再び説明する。</p>
        <p>普遍的構成をおさらいしよう。まず対象と射のパターンから始める。これは粗い検索であり、通常はヒットするものが多すぎる。特に、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>では、ほとんどすべてのものがすべてに接続されている。任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>を選んで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>との積を作れば、そこから<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への関数を作れる
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>が空集合の場合を除く)。</p>
        <p>その時に秘密兵器を使う:
          順位付けだ。これは通常、候補となる対象の間に一意な写像
          (構成を分解する写像)
          が存在することを条件として行われる。ここでは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>z</mi>
                <mo>×</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">z \times a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>を伴う<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>は、それ自身の関数適用<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">g&#39;</annotation>
            </semantics>
          </math>を伴う別の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>z</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">z&#39;</annotation>
            </semantics>
          </math>よりも<em>優れて</em>いるとして選別するが、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">g&#39;</annotation>
            </semantics>
          </math>の適用が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>の適用を通じて分解するような、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>z</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">z&#39;</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>への一意な写像<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>が存在する場合に限る。(ヒント:
          この文は図を見ながら読むこと。)</p>
        <figure>
          <img src="images/functionranking.jpg" style="width:40.0%" alt="関数オブジェクトの候補間の順位付けの確立" />
          <figcaption aria-hidden="true">関数オブジェクトの候補間の順位付けの確立</figcaption>
        </figure>
        <p>ここで厄介な部分がある。この特定の普遍的構成の説明を今まで延期した主な理由だ。射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>h</mi>
                <mo>∷</mo>
                <mi>z</mi>
                <mi>′</mi>
                <mo>→</mo>
                <mi>z</mi>
              </mrow>
              <annotation encoding="application/x-tex">h \Colon z&#39;\to z</annotation>
            </semantics>
          </math>が存在するとき、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>z</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">z&#39;</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>の両方を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と掛けた図式を閉じたい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>z</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">z&#39;</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>への写像<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>が存在するとき、本当に必要なのは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>z</mi>
                <mi>′</mi>
                <mo>×</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">z&#39;\times a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>z</mi>
                <mo>×</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">z\times a</annotation>
            </semantics>
          </math>への写像だ。そして今、<a href="#functoriality">積の関手性</a>についてすでに議論したので、そのやり方は分かっている。積自体が関手
          (正確には自己双関手)
          であるため、射のペアをリフトできる。すなわち、対象の積だけでなく、射の積も定義できる。</p>
        <p>積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>z</mi>
                <mi>′</mi>
                <mo>×</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">z&#39;×a</annotation>
            </semantics>
          </math>の2番目の要素には触れていないので、射のペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>h</mi>
                <mo>,</mo>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(h, \mathbf{id})</annotation>
            </semantics>
          </math>
          をリフトする。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐢</mi>
                <mi>𝐝</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{id}</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の恒等射だ。
        </p>
        <p>そして、ある関数適用<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>で別の関数適用<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">g&#39;</annotation>
            </semantics>
          </math>を分解するとこうなる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mi>′</mi>
                <mo>=</mo>
                <mi>g</mi>
                <mo>∘</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>h</mi>
                  <mo>×</mo>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">g&#39; = g \circ (h \times \mathbf{id})</annotation>
            </semantics>
          </math></p>
        <p>ここで鍵となるのは、射に対する積の作用だ。</p>
        <p>普遍的構成の第3部は、普遍的に最も優れた対象を選ぶことだ。その対象を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>⇒</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \Rightarrow b</annotation>
            </semantics>
          </math>と呼ぶことにしよう
          (Haskellの対象制約と混同しないための、1つの型クラスのシンボル名と考えてほしい。後で別の命名方法について議論する)。この対象は独自の関数適用を伴う。それは
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>⇒</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>×</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">(a \Rightarrow b) \times a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への射であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑒</mi>
                <mi>𝑣</mi>
                <mi>𝑎</mi>
                <mi>𝑙</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{eval}</annotation>
            </semantics>
          </math>と呼ばれる。対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>⇒</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \Rightarrow b</annotation>
            </semantics>
          </math>は、関数オブジェクトの他の候補すべてを、その関数適用の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑒</mi>
                <mi>𝑣</mi>
                <mi>𝑎</mi>
                <mi>𝑙</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{eval}</annotation>
            </semantics>
          </math>を通じて分解するようなかたちで一意に写せる場合、最も優れていると言える。我々の順位付けでは、この対象は他のどの対象よりも優れている。
        </p>
        <figure>
          <img src="images/universalfunctionobject.jpg" style="width:40.0%"
            alt="普遍的な関数オブジェクトの定義。これは上記と同じ図式だが、対象a \Rightarrow bは普遍だ。" />
          <figcaption aria-hidden="true">普遍的な関数オブジェクトの定義。これは上記と同じ図式だが、対象<math display="inline"
              xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>a</mi>
                  <mo>⇒</mo>
                  <mi>b</mi>
                </mrow>
                <annotation encoding="application/x-tex">a \Rightarrow b</annotation>
              </semantics>
            </math>は<em>普遍</em>だ。</figcaption>
        </figure>
        <p>形式的には:</p>
        <blockquote>
          <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>a</mi>
                <annotation encoding="application/x-tex">a</annotation>
              </semantics>
            </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>b</mi>
                <annotation encoding="application/x-tex">b</annotation>
              </semantics>
            </math>への<em>関数オブジェクト</em>は、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>a</mi>
                  <mo>⇒</mo>
                  <mi>b</mi>
                </mrow>
                <annotation encoding="application/x-tex">a \Rightarrow b</annotation>
              </semantics>
            </math>に射
            <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mrow>
                    <mi>𝑒</mi>
                    <mi>𝑣</mi>
                    <mi>𝑎</mi>
                    <mi>𝑙</mi>
                  </mrow>
                  <mo>∷</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>a</mi>
                      <mo>⇒</mo>
                      <mi>b</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                    <mo>×</mo>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>→</mo>
                  <mi>b</mi>
                </mrow>
                <annotation encoding="application/x-tex">\mathit{eval} \Colon ((a \Rightarrow b) \times a) \to b
                </annotation>
              </semantics>
            </math>
            を伴ったものであり、他の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>z</mi>
                <annotation encoding="application/x-tex">z</annotation>
              </semantics>
            </math>に射
            <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>g</mi>
                  <mo>∷</mo>
                  <mi>z</mi>
                  <mo>×</mo>
                  <mi>a</mi>
                  <mo>→</mo>
                  <mi>b</mi>
                </mrow>
                <annotation encoding="application/x-tex">g\Colon z \times a \to b</annotation>
              </semantics>
            </math>
          </p>
        </blockquote>
        <blockquote>
          <p>を伴ったものに対して、一意な射
            <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>h</mi>
                  <mo>∷</mo>
                  <mi>z</mi>
                  <mo>→</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>⇒</mo>
                    <mi>b</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                </mrow>
                <annotation encoding="application/x-tex">h \Colon z \to (a \Rightarrow b)</annotation>
              </semantics>
            </math>
            が存在して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>g</mi>
                <annotation encoding="application/x-tex">g</annotation>
              </semantics>
            </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>𝑒</mi>
                  <mi>𝑣</mi>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                </mrow>
                <annotation encoding="application/x-tex">\mathit{eval}</annotation>
              </semantics>
            </math>を通じて分解する:
            <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>g</mi>
                  <mo>=</mo>
                  <mrow>
                    <mi>𝑒</mi>
                    <mi>𝑣</mi>
                    <mi>𝑎</mi>
                    <mi>𝑙</mi>
                  </mrow>
                  <mo>∘</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>h</mi>
                    <mo>×</mo>
                    <mrow>
                      <mi>𝐢</mi>
                      <mi>𝐝</mi>
                    </mrow>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                </mrow>
                <annotation encoding="application/x-tex">g=\mathit{eval} \circ (h \times \mathbf{id})</annotation>
              </semantics>
            </math>
          </p>
        </blockquote>
        <p>当然、このような対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>⇒</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \Rightarrow b</annotation>
            </semantics>
          </math>が、ある圏内の対象の任意のペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>について存在する保証はない。しかし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>では常に存在する。さらに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>では、この対象はhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}(a, b)</annotation>
            </semantics>
          </math>
          と同型だ。</p>
        <p>そのため、Haskellでは、関数の型<code>a -&gt; b</code>を圏論的関数オブジェクト<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>⇒</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \Rightarrow b</annotation>
            </semantics>
          </math>として解釈する。</p>
        <h2 data-number="9.2" id="カリー化"><span class="header-section-number">9.2</span> カリー化</h2>
        <p>関数オブジェクトの全候補を見てみよう。ただし今回は、射の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>を2つの変数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の関数として考えてみよう。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>∷</mo>
                <mi>z</mi>
                <mo>×</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">g \Colon z \times a \to b</annotation>
            </semantics>
          </math></p>
        <p>積からの射であることと2変数関数であることは同じくらい近い。特に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>では<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>は値のペアを取る関数であり、そのペアの片方は集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>から、もう片方は集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>からの値だ。</p>
        <p>一方、普遍性 (universal property)
          は、このような<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>ごとに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>を関数オブジェクト<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>⇒</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \Rightarrow b</annotation>
            </semantics>
          </math>に写す一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>が存在することを示している:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>h</mi>
                <mo>∷</mo>
                <mi>z</mi>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>⇒</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">h \Colon z \to (a \Rightarrow b)</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>において、これは単に関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>が型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>の変数を1つ受け取って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への関数を返すことを意味する。これによって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>は高階関数になる。したがって、普遍的構成は、2変数関数と、関数を返す1変数関数との間に1対1の対応を確立する。この対応は<span id="currying"
            class="keyword">カリー化</span> (currying)
          と呼ばれ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>をカリー化した
          (curried) バージョンと呼ばれる。</p>
        <p>これは1対1の対応だ。任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>に対し一意な<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>が存在し、任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>に対して次の式を使って引数2つの関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>を常に再生成できるからだ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>=</mo>
                <mrow>
                  <mi>𝑒</mi>
                  <mi>𝑣</mi>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                </mrow>
                <mo>∘</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>h</mi>
                  <mo>×</mo>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">g = \mathit{eval} \circ (h \times \mathbf{id})</annotation>
            </semantics>
          </math></p>
        <p>関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>の<em>非カリー化</em>バージョンと呼べる。</p>
        <p>カリー化は本質的にHaskellの構文に組み込まれている。関数を返す関数:</p>
        <div class="sourceCode" id="cb246">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c)</span></code></pre>
        </div>
        <p>は2変数関数と見なされることが多い。括弧を外したシグネチャはそのように読まれる:</p>
        <div class="sourceCode" id="cb247">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</span></code></pre>
        </div>
        <p>この解釈は、複数の引数を取る関数を定義する方法ではっきり分かる。例として:</p>
        <div class="sourceCode" id="cb248">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a><span class="ot">catstr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a>catstr s s&#39; <span class="ot">=</span> s <span class="op">++</span> s&#39;</span></code></pre>
        </div>
        <p>と同じ関数を、関数を返す1引数関数、すなわちラムダとして記述できる:</p>
        <div class="sourceCode" id="cb249">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a>catstr&#39; s <span class="ot">=</span> \s&#39; <span class="ot">-&gt;</span> s <span class="op">++</span> s&#39;</span></code></pre>
        </div>
        <p>これら2つの定義は等価であり、どちらも1つの引数だけに部分適用でき、次のような1引数関数を生成する:</p>
        <div class="sourceCode" id="cb250">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a><span class="ot">greet ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a>greet <span class="ot">=</span> catstr “<span class="dt">Hello</span> “</span></code></pre>
        </div>
        <p>厳密に言えば、2変数関数はペア (直積型) を取る関数だ。</p>
        <div class="sourceCode" id="cb251">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a>(a, b) <span class="ot">-&gt;</span> c</span></code></pre>
        </div>
        <p>2つの表現の間の変換は自明であり、それを行う2つの (高階)
          関数は、もちろん、<code>curry</code>と<code>uncurry</code>と呼ばれる。</p>
        <div class="sourceCode" id="cb252">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a><span class="fu">curry</span><span class="ot"> ::</span> ((a, b)<span class="ot">-&gt;</span>c) <span class="ot">-&gt;</span> (a<span class="ot">-&gt;</span>b<span class="ot">-&gt;</span>c)</span>
<span id="cb252-2"><a href="#cb252-2" aria-hidden="true" tabindex="-1"></a><span class="fu">curry</span> f a b <span class="ot">=</span> f (a, b)</span></code></pre>
        </div>
        <p>および</p>
        <div class="sourceCode" id="cb253">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a><span class="fu">uncurry</span><span class="ot"> ::</span> (a<span class="ot">-&gt;</span>b<span class="ot">-&gt;</span>c) <span class="ot">-&gt;</span> ((a, b)<span class="ot">-&gt;</span>c)</span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a><span class="fu">uncurry</span> f (a, b) <span class="ot">=</span> f a b</span></code></pre>
        </div>
        <p><code>curry</code>は、関数オブジェクトの普遍的構成の<em>factorizer</em>であることに注目してほしい。これは、次の形式で書き直した場合に特に顕著だ:</p>
        <div class="sourceCode" id="cb254">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorizer ::</span> ((a, b)<span class="ot">-&gt;</span>c) <span class="ot">-&gt;</span> (a<span class="ot">-&gt;</span>(b<span class="ot">-&gt;</span>c))</span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a>factorizer g <span class="ot">=</span> \a <span class="ot">-&gt;</span> (\b <span class="ot">-&gt;</span> g (a, b))</span></code></pre>
        </div>
        <p>(備忘録: factorizerは候補から分解関数を生成する。)</p>
        <p>C++のような非関数型言語でもカリー化は可能だが、簡単ではない。C++の複数引数関数は、Haskellでのタプルを取る関数に対応すると見なせる
          (ただし、さらに混乱を招くことに、C++では明示的な<code>std::tuple</code>を取る関数、可変長引数関数、初期化子リストを取る関数も定義できる)。</p>
        <p>標準テンプレートライブラリの<code>std::bind</code>を使えばC++関数を部分適用できる。たとえば、文字列2つを取る関数があるとする:</p>
        <div class="sourceCode" id="cb255">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string catstr<span class="op">(</span><span class="bu">std::</span>string s1<span class="op">,</span> <span class="bu">std::</span>string s2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> s1 <span class="op">+</span> s2<span class="op">;</span></span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>文字列1つを取る関数は次のように定義できる:</p>
        <div class="sourceCode" id="cb256">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>placeholders<span class="op">;</span></span>
<span id="cb256-2"><a href="#cb256-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-3"><a href="#cb256-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> greet <span class="op">=</span> <span class="bu">std::</span>bind<span class="op">(</span>catstr<span class="op">,</span> <span class="st">&quot;Hello &quot;</span><span class="op">,</span> _1<span class="op">);</span></span>
<span id="cb256-4"><a href="#cb256-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> greet<span class="op">(</span><span class="st">&quot;Haskell Curry&quot;</span><span class="op">);</span></span></code></pre>
        </div>
        <p>ScalaはC++やJavaよりも関数型寄りの、中間的立場に立っている。定義したい関数が部分適用されると予想されるときは、複数引数のリストを使って定義する:</p>
        <div class="sourceCode" id="cb257">
          <pre
            class="sourceCode scala"><code class="sourceCode scala"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> <span class="fu">catstr</span><span class="op">(</span>s1<span class="op">:</span> <span class="ex">String</span><span class="op">)(</span>s2<span class="op">:</span> <span class="ex">String</span><span class="op">)</span> <span class="op">=</span> s1 <span class="op">+</span> s2</span></code></pre>
        </div>
        <p>当然、これにはある程度の先見の明や予測がライブラリの作者に求められる。</p>
        <h2 data-number="9.3" id="冪乗"><span class="header-section-number">9.3</span> 冪乗</h2>
        <p>数学の文献では、関数オブジェクト、すなわち2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の間の内部hom対象を<span id="exponential" class="keyword">冪乗</span> (exponential)
          と呼んで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>b</mi>
                <mi>a</mi>
              </msup>
              <annotation encoding="application/x-tex">b^{a}</annotation>
            </semantics>
          </math>と記すことが多い。引数の型が指数に含まれていることに注目してほしい。この記法は一見奇妙に思えるかもしれないが、関数と積の関係を考えると完全に理にかなっている。内部hom対象の普遍的構成で積を使わなければならないことはすでに見たが、つながりはそれよりも深い。
        </p>
        <p>
          これは、<code>Bool</code>、<code>Char</code>、あるいは<code>Int</code>や<code>Double</code>など、有限個の値を持つ型の間の関数を考えるときに最もよく見られる。そのような関数は、少なくとも原理的には、完全にメモ化したり、データ構造に変換してルックアップしたりできる。そしてこれが、射である関数と、対象である関数型との同値性の本質だ。
        </p>
        <p>たとえば、<code>Bool</code>を取る (純粋)
          関数は、<code>False</code>に対応する値と<code>True</code>に対応する値のペアによって完全に決まる。<code>Bool</code>から<code>Int</code>へのすべての可能な関数の集合は、<code>Int</code>のすべての組み合わせの集合だ。これは積<code>Int</code>
          ×
          <code>Int</code>と同じか、記法を少し創意工夫するなら、<code>Int</code><sup>2</sup>と同じだ。
        </p>
        <p>別の例として、256種類の値を含むC++の型<code>char</code>を見てみよう
          (Haskellの<code>Char</code>はユニコードを使っているのでもっと多い)。C++標準ライブラリの一部には、実装に通常はルックアップが使われる関数がいくつかある。<code>isupper</code>や<code>isspace</code>のような関数はテーブルを使って実装される。テーブルは256個のブール値のタプルと等価だ。タプルは直積型であるため、256個のブーリアンの積<code>bool × bool × bool × ... × bool</code>を扱っていることになる。積を繰り返したものが冪乗なのは知ってのとおりだ。<code>bool</code>を256
          (または<code>char</code>)
          回「掛ける」と、<code>bool</code>の<code>char</code>乗、つまり
          <code>bool</code><sup>char</sup>になる。
        </p>
        <p><code>bool</code>の256要素のタプルとして定義される型は何通りの値を取りうるだろう？
          ちょうど<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mn>2</mn>
                <mn>256</mn>
              </msup>
              <annotation encoding="application/x-tex">2^{256}</annotation>
            </semantics>
          </math>通りだ。これはまた、<code>char</code>から<code>bool</code>への関数の種類の数でもあり、各関数は一意な256要素のタプルに対応する。同様に、<code>bool</code>から<code>char</code>への関数の数は<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mn>256</mn>
                <mn>2</mn>
              </msup>
              <annotation encoding="application/x-tex">256^{2}</annotation>
            </semantics>
          </math>と計算できる。以下同様だ。このような場合には、関数型の冪乗記法が完全に理にかなっている。</p>
        <p>
          <code>int</code>や<code>double</code>を取る関数を完全にメモ化したいとは思わないだろう。しかし、関数とデータ型の間には、常に実用的だとは限らないにしても、同値性がある。型はリスト・文字列・木など無数に存在する。これらの型を取る関数をせっせとメモ化したら、無限のストレージが必要になるだろう。しかし、Haskellは遅延評価言語であるため、遅延評価された
          (無限の)
          データ構造と関数の境界は曖昧だ。この関数とデータの双対性は、Haskellの関数型と圏論の冪乗対象との区別を説明している。冪乗対象の方が<em>データ</em>という概念によく対応している。
        </p>
        <h2 data-number="9.4" id="カルテシアン閉圏"><span class="header-section-number">9.4</span> カルテシアン閉圏</h2>
        <p>型や関数のモデルとしては集合の圏を今後も使うが、圏にはより大きな族があって、同じ目的のモデルとして使えることは言及する価値がある。それらの圏は<span id="Cartesian_closed"
            class="keyword">カルテシアン閉</span> (Cartesian
          closed)
          と呼ばれ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>はそのような圏の一例だ。</p>
        <p>カルテシアン閉圏は、次のものを含まなければならない:</p>
        <ol type="1">
          <li>終対象</li>
          <li>任意の対象のペアの直積</li>
          <li>対象の任意のペアの冪乗</li>
        </ol>
        <p>冪乗を積の反復 (無限に繰り返される可能性がある)
          と見なすなら、カルテシアン閉圏は、任意のアリティの1つのサポートプロダクトと見なせる。特に、終対象は0個の物体の積、つまり対象の0乗と見なせる。</p>
        <p>コンピューター科学の観点から見てカルテシアン閉圏で興味深いのは、単純に型付けされたラムダ計算のモデルを提供しており、すべての型付けされたプログラミング言語の基礎を形成していることだ。</p>
        <p>終対象と積には、始対象と余積という双対がある。それら2つも含むカルテシアン閉圏で、余積に対し積を分配できるもの</p>
        <div class="sourceCode" id="cb258">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a>a × (b <span class="op">+</span> c) <span class="ot">=</span> a × b <span class="op">+</span> a × c</span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a>(b <span class="op">+</span> c) × a <span class="ot">=</span> b × a <span class="op">+</span> c × a</span></code></pre>
        </div>
        <p>は<span id="bicartesian_closed" class="keyword">双カルテシアン閉</span> (bicartesian closed)
          圏と呼ばれる。次の節では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>に代表される双カルテシアン閉圏の興味深い特性について説明する。</p>
        <h2 data-number="9.5" id="冪乗と代数的データ型"><span class="header-section-number">9.5</span> 冪乗と代数的データ型</h2>
        <p>
          関数型を冪乗として解釈すると、代数的データ型のスキームに非常によく適合する。高校で習う代数における数0と1、和、積、冪乗に関係する基本的な恒等式はどれも、双カルテシアン閉圏においてそれぞれ始対象と終対象、余積、積、冪乗を考えれば、ほとんど変わらないことがわかった。それらを証明する手段
          (随伴や米田の補題など)
          はまだ得ていないが、価値ある直観の源としてここに挙げておこう。</p>
        <h3 data-number="9.5.1" id="乗"><span class="header-section-number">9.5.1</span> 0乗</h3>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>a</mi>
                  <mn>0</mn>
                </msup>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">a^{0} = 1</annotation>
            </semantics>
          </math></p>
        <p>圏論の解釈では、0を始対象に、1を終対象に、等価性を同型に置き換える。冪乗は内部hom対象だ。ここに示した冪乗は、始対象から任意の対象<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>への射の集合を表している。始対象の定義によれば、そのような射は1つだけ存在するので、hom集合<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>0</mn>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(0, a)</annotation>
            </semantics>
          </math>
          は単集合となる。単集合は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内の終対象なので、この恒等式は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内で自明に成り立つ。つまり、どんな双カルテシアン閉圏でも成り立つということだ。</p>
        <p>
          Haskellでは、0を<code>Void</code>で、1を単位型<code>()</code>で、冪乗を関数型でそれぞれ置き換える。それは、<code>Void</code>から任意の型<code>a</code>への関数の集合が、単集合である単位型と等価だと主張する。言い換えると、関数<code>Void -&gt; a</code>は1つしかない。この関数は以前にも見たことがある:
          <code>absurd</code>と呼ばれる関数だ。
        </p>
        <p>2つの理由から、これは少しトリッキーだ。1つは、Haskellは実際には無人型
          (uninhabited type)
          を持たないことだ――すべての型には「終わりのない計算の結果」、つまりボトムが含まれている。第2の理由は、<code>absurd</code>のすべての実装は等価であるということだ。なぜなら、それらが何をしようと、誰も実行できないからだ。<code>absurd</code>に渡せる値はない。(そして、終わりのない計算を渡せたとしても、決して値は返らない！)
        </p>
        <h3 data-number="9.5.2" id="の冪乗"><span class="header-section-number">9.5.2</span> 1の冪乗</h3>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mn>1</mn>
                  <mi>a</mi>
                </msup>
                <mo>=</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">1^{a} = 1</annotation>
            </semantics>
          </math></p>
        <p>この恒等射は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>で解釈するとき、終対象の定義を「どの対象にも終対象への一意な射がある」と言い換える。一般に、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から終対象への内部hom対象は、終対象そのものと同型だ。</p>
        <p>
          Haskellでは、型<code>a</code>から単位型への関数は1つしかない。この関数は以前にも見たことがある。<code>unit</code>と呼ばれる関数だ。<code>()</code>に部分適用された<code>const</code>関数とも見なせる。
        </p>
        <h3 data-number="9.5.3" id="乗-1"><span class="header-section-number">9.5.3</span> 1乗</h3>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>a</mi>
                  <mn>1</mn>
                </msup>
                <mo>=</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">a^{1} = a</annotation>
            </semantics>
          </math></p>
        <p>これは、終対象からの射が対象<code>a</code>の「要素」を選ぶのに利用できるという観察を言い換えたものだ。このような射の集合は対象そのものと同型だ。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>とHaskellでは、集合<code>a</code>の要素と、それらの要素を選択する関数<code>() -&gt; a</code>との間に同型が成り立つ。</p>
        <h3 data-number="9.5.4" id="和による冪乗"><span class="header-section-number">9.5.4</span> 和による冪乗</h3>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>a</mi>
                  <mrow>
                    <mi>b</mi>
                    <mo>+</mo>
                    <mi>c</mi>
                  </mrow>
                </msup>
                <mo>=</mo>
                <msup>
                  <mi>a</mi>
                  <mi>b</mi>
                </msup>
                <mo>×</mo>
                <msup>
                  <mi>a</mi>
                  <mi>c</mi>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">a^{b+c} = a^{b} \times a^{c}</annotation>
            </semantics>
          </math></p>
        <p>
          これは、圏論では2つの対象の余積による冪乗が2つの冪乗の積と同型だと明確に示している。Haskellでは、この代数的恒等射には非常に実用的な解釈がある。これは、2つの型の直和型を取る関数が、個別の型を取る関数のペアと等価だと示している。直和型を取る関数を定義するときに使うケース分析そのものだ。<code>case</code>式で1つの関数定義を記述する代わりに、通常はそれを2つ
          (またはそれ以上)
          の関数に分割して、それぞれの型コンストラクターを別々に処理する。たとえば、直和型
          <code>(Either Int Double)</code> を取る関数を考える:
        </p>
        <div class="sourceCode" id="cb259">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre>
        </div>
        <p>これは、それぞれ<code>Int</code>と<code>Double</code>を取る2つの関数のペアとして定義できる。</p>
        <div class="sourceCode" id="cb260">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a>f (<span class="dt">Left</span> n)  <span class="ot">=</span> <span class="kw">if</span> n <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="st">&quot;Negative int&quot;</span> <span class="kw">else</span> <span class="st">&quot;Positive int&quot;</span></span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true" tabindex="-1"></a>f (<span class="dt">Right</span> x) <span class="ot">=</span> <span class="kw">if</span> x <span class="op">&lt;</span> <span class="fl">0.0</span> <span class="kw">then</span> <span class="st">&quot;Negative double&quot;</span> <span class="kw">else</span> <span class="st">&quot;Positive double&quot;</span></span></code></pre>
        </div>
        <p>ここで、<code>n</code>は<code>Int</code>で、<code>x</code>は<code>Double</code>だ。</p>
        <h3 data-number="9.5.5" id="冪乗の冪乗"><span class="header-section-number">9.5.5</span> 冪乗の冪乗</h3>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <msup>
                      <mi>a</mi>
                      <mi>b</mi>
                    </msup>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mi>c</mi>
                </msup>
                <mo>=</mo>
                <msup>
                  <mi>a</mi>
                  <mrow>
                    <mi>b</mi>
                    <mo>×</mo>
                    <mi>c</mi>
                  </mrow>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">(a^{b})^{c} = a^{b \times c}</annotation>
            </semantics>
          </math></p>
        <p>これは単にカリー化を純粋に冪乗対象の観点で表現したものだ。関数を返す関数は、積を引数に取る関数
          (2引数の関数) と等価だ。</p>
        <h3 data-number="9.5.6" id="積の冪乗"><span class="header-section-number">9.5.6</span> 積の冪乗</h3>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>×</mo>
                    <mi>b</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mi>c</mi>
                </msup>
                <mo>=</mo>
                <msup>
                  <mi>a</mi>
                  <mi>c</mi>
                </msup>
                <mo>×</mo>
                <msup>
                  <mi>b</mi>
                  <mi>c</mi>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">(a \times b)^{c} = a^{c} \times b^{c}</annotation>
            </semantics>
          </math></p>
        <p>Haskellでは、ペアを返す関数は、それぞれがペアの1つの要素を生成する関数のペアと等価だ。</p>
        <p>これらの高校数学の単純な代数的恒等式が、このように圏論にリフトされ、関数型プログラミングに実際に応用されているのは、実に驚くべきことだ。</p>
        <h2 data-number="9.6" id="カリーハワード同型"><span class="header-section-number">9.6</span> カリー・ハワード同型</h2>
        <p>論理と代数的データ型の対応についてはすでに述べた。<code>Void</code>型とunit型<code>()</code>は、偽と真に対応する。直積型と直和型は、論理積<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mo>∧</mo>
              <annotation encoding="application/x-tex">\wedge</annotation>
            </semantics>
          </math>
          (AND)
          と論理和<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mo>∨</mo>
              <annotation encoding="application/x-tex">\vee</annotation>
            </semantics>
          </math>
          (OR)
          に対応する。このスキームでは、先ほど定義した関数型が論理包含<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mo>⇒</mo>
              <annotation encoding="application/x-tex">\Rightarrow</annotation>
            </semantics>
          </math>に対応している。つまり、型<code>a -&gt; b</code>は「aならばb」と読める。</p>
        <p>カリー・ハワード同型によれば、すべての型は命題として解釈できる。命題とは、真または偽に定まる言明や判断だ。そのような命題は、型が居住
          (inhabited)
          ならば真とされ、そうでなければ偽とされる。特に、論理包含は対応する関数型が居住ならば真であり、その型の関数が存在することを意味する。したがって、関数の実装は定理の証明になる。プログラムを書くのは定理を証明するのと等価だ。いくつか例を見てみよう。
        </p>
        <p>関数オブジェクトの定義で導入した関数<code>eval</code>を取り上げよう。シグネチャは次のとおりだ:</p>
        <div class="sourceCode" id="cb261">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> ((a <span class="ot">-&gt;</span> b), a) <span class="ot">-&gt;</span> b</span></code></pre>
        </div>
        <p>これは関数とその引数のペアを取り、適切な型の結果を生成する。つまり、次の射をHaskellで実装したものだ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑒</mi>
                  <mi>𝑣</mi>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                </mrow>
                <mo>∷</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>⇒</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>×</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{eval} \Colon (a \Rightarrow b) \times a \to b
              </annotation>
            </semantics>
          </math></p>
        <p>この射は関数型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>⇒</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \Rightarrow b</annotation>
            </semantics>
          </math>
          (すなわち冪乗対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>b</mi>
                <mi>a</mi>
              </msup>
              <annotation encoding="application/x-tex">b^{a}</annotation>
            </semantics>
          </math>)
          を定義する。このシグネチャを、カリー・ハワード同型を使って論理の述語に変換しよう。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>⇒</mo>
                    <mi>b</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>∧</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>⇒</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">((a \Rightarrow b) \wedge a) \Rightarrow b</annotation>
            </semantics>
          </math></p>
        <p>この命題の読み方はこうだ:
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>が真であり、かつ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>が真ならば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>は必ず真である。これは完全に直観に適っていて、古代から<span id="modus_ponen" class="keyword">modus
            ponens</span>として知られていた。次の関数を実装することで、この定理を証明できる:
        </p>
        <div class="sourceCode" id="cb262">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> ((a <span class="ot">-&gt;</span> b), a) <span class="ot">-&gt;</span> b</span>
<span id="cb262-2"><a href="#cb262-2" aria-hidden="true" tabindex="-1"></a>eval (f, x) <span class="ot">=</span> f x</span></code></pre>
        </div>
        <p>
          <code>a</code>を取り<code>b</code>を返す関数<code>f</code>と、型<code>a</code>の具体的な値<code>x</code>とのペアがあれば、<code>f</code>を<code>x</code>に適用するだけで型<code>b</code>の具体的な値を得られる。この関数を実装することで、型<code>((a -&gt; b), a) -&gt; b</code>が居住であることを示した。modus
          ponensは我々の論理では真だ。
        </p>
        <p>では、あからさまに間違っている述語ではどうだろうか？ 例:
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>が真ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>は真でなければならない。
        </p>
        <div class="sourceCode" id="cb263">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a>a ⋁ b ⇒ a</span></code></pre>
        </div>
        <p>これは明らかに間違っている。なぜなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>が偽で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>が真の場合が反例となるからだ。</p>
        <p>この述語をCurry-Howard同型を使って関数シグネチャに写すと、次のようになる:</p>
        <div class="sourceCode" id="cb264">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Either</span> a b <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <p>
          いくらやってみても、この関数は実装できない――<code>Right</code>の値で呼び出された場合、型<code>a</code>の値は生成できない。(ここでは<em>純粋</em>関数について説明していることを思い出してほしい。)
        </p>
        <p>最終的に、<code>absurd</code>関数の意味にたどり着く:</p>
        <div class="sourceCode" id="cb265">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a><span class="ot">absurd ::</span> <span class="dt">Void</span> <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <p><code>Void</code>が偽に変換されることを考えると、次のようになる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑓</mi>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                  <mi>𝑠</mi>
                  <mi>𝑒</mi>
                </mrow>
                <mo>⇒</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{false} \Rightarrow a</annotation>
            </semantics>
          </math></p>
        <p>虚偽からは何でも導ける (<em>ex falso
            quodlibet</em>)。Haskellにおけるこの命題 (関数) の証明 (実装)
          として可能なものを以下に1つ示す。</p>
        <div class="sourceCode" id="cb266">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a>absurd (<span class="dt">Void</span> a) <span class="ot">=</span> absurd a</span></code></pre>
        </div>
        <p>ここで、<code>Void</code>は次のように定義される:</p>
        <div class="sourceCode" id="cb267">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Void</span> <span class="ot">=</span> <span class="dt">Void</span> <span class="dt">Void</span></span></code></pre>
        </div>
        <p>
          いつものように、型<code>Void</code>はトリッキーだ。この定義では、値を構築するには値を提供する必要があるため、値を構築できない。したがって、この関数<code>absurd</code>は決して呼び出せない。
        </p>
        <p>いずれも興味深い例だが、Curry-Howard同型に実用面はあるのだろうか？
          おそらく日々のプログラミングではないだろう。しかし、AgdaやCoqのようなプログラミング言語では、定理を証明するためにCurry-Howard同型が利用されている。</p>
        <p>
          コンピューターは数学者の仕事を助けているだけでなく、数学の基礎そのものに革命をもたらしている。この分野の注目の最新研究テーマはホモトピー型理論と呼ばれ、型理論の副産物だ。ブーリアン、整数、積と余積、関数型などでいっぱいだ。そして、疑念を払拭するかのように、理論はCoqとAgdaで定式化されている。コンピューターは世界にさまざまな形で革命を起こしている。
        </p>
        <h2 data-number="9.7" id="参考文献-2"><span class="header-section-number">9.7</span> 参考文献</h2>
        <ol type="1">
          <li>Ralph Hinze, Daniel W. H. James, <a href="http://www.cs.ox.ac.uk/ralf.hinze/publications/WGP10.pdf">Reason
              Isomorphically!</a>.
            この論文には、この章で述べた圏論におけるすべての高校数学の代数的恒等式の証明が含まれている。</li>
        </ol>
        <h1 data-number="10" id="natural-transformations"><span class="header-section-number">10</span> 自然変換</h1>
        <p>
          関手については圏と圏との間で構造を保存する写像としてすでに述べた。関手はある圏を別の圏に「埋め込む」。複数のものを1つに潰すことはできるが、接続が切断されることはない。1つの考え方は、ある圏を関手を使って別の圏の中にモデル化していると捉えることだ。始域圏は、終域圏の一部である構造物のモデル、あるいは青写真として機能する。
        </p>
        <p><img src="images/1_functors.jpg" style="width:40.0%" /></p>
        <p>
          ある圏を別の圏に埋め込む方法はいろいろある。それらは等価なこともあれば、大きく異なることもある。始域圏全体を1つの対象に潰すこともあれば、すべての対象を異なる対象に写し、すべての射を異なる射に写すこともある。同じ青写真を現実化する方法はいろいろある。自然変換は、それらの現実化方法を比較するのに役立つ。自然変換は関手の写像であり、その関手的性質を保存する特別な写像だ。
        </p>
        <p>圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の間に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>という2つの関数があるとする。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の1つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>だけに注目すると、それが2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">G\ a</annotation>
            </semantics>
          </math>に写されていると分かる。したがって、関手の写像では<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ a</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">G\ a</annotation>
            </semantics>
          </math>に写す必要がある。</p>
        <p><img src="images/2_natcomp.jpg" style="width:30.0%" /></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">G\ a</annotation>
            </semantics>
          </math>は同じ圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>内の対象であることに注意してほしい。同じ圏内の対象間の写像は、圏の特性に反するものであってはならない。対象同士の間に人為的な接続を作成したくはない。したがって、既存の接続、つまり射を使用するのは<em>自然</em>だ。自然変換は射の選択であり、対象<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>ごとに<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">G\ a</annotation>
            </semantics>
          </math>への射が1つ選択される。自然変換を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>と呼ぶ場合、この射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>における<span id="component" class="keyword">コンポーネント</span> (component)
          または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_a</annotation>
            </semantics>
          </math>と呼ばれる。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_a \Colon F\ a \to G\ a</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の対象であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_a</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の射であることに注意してほしい。</p>
        <p>ある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">G\ a</annotation>
            </semantics>
          </math>の間に射がない場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>の間に自然変換はない。</p>
        <p>もちろん、これは話の半分にすぎない。なぜなら、関手は対象を写すだけでなく、射も写すからだ。では自然変換はこれらの写像をどうするのだろうか？
          射の写像は固定されている――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>の間の自然変換では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ f</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">G\ f</annotation>
            </semantics>
          </math>に変換されなければならない。さらに、2つの関手による射の写像は、それに適合する自然変換を定義する際の選択肢を大幅に制限する。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の間に射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>があるとする。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>内の2つの射、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ f</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">G\ f</annotation>
            </semantics>
          </math>に写されている。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>F</mi>
                    <mi>f</mi>
                    <mo>∷</mo>
                    <mi>F</mi>
                    <mi>a</mi>
                    <mo>→</mo>
                    <mi>F</mi>
                    <mi>b</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>G</mi>
                    <mi>f</mi>
                    <mo>∷</mo>
                    <mi>G</mi>
                    <mi>a</mi>
                    <mo>→</mo>
                    <mi>G</mi>
                    <mi>b</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                F f \Colon F a \to F b \\
                G f \Colon G a \to G b
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>内で図式を完成させる2つの追加の射を提供する。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <msub>
                      <mi>α</mi>
                      <mi>a</mi>
                    </msub>
                    <mo>∷</mo>
                    <mi>F</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                    <mo>→</mo>
                    <mi>G</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <msub>
                      <mi>α</mi>
                      <mi>b</mi>
                    </msub>
                    <mo>∷</mo>
                    <mi>F</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>b</mi>
                    <mo>→</mo>
                    <mi>G</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>b</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                \alpha_a \Colon F\ a \to G\ a \\
                \alpha_b \Colon F\ b \to G\ b
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p><img src="images/3_naturality.jpg" style="width:40.0%" /></p>
        <p>今、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">G\ b</annotation>
            </semantics>
          </math>への移行には2つの方法がある。これらが等しいことを確認するには、任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>で成り立つ<span id="naturality_condition" class="keyword">自然条件</span> (naturality
          condition) を課す必要がある:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
                <mo>∘</mo>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
                <mo>=</mo>
                <msub>
                  <mi>α</mi>
                  <mi>b</mi>
                </msub>
                <mo>∘</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">G\ f \circ \alpha_a = \alpha_b \circ F\ f</annotation>
            </semantics>
          </math></p>
        <p>自然条件はかなり厳しい要件だ。たとえば、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ f</annotation>
            </semantics>
          </math>が可逆である場合、自然性は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_a</annotation>
            </semantics>
          </math>に基づいて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>b</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_b</annotation>
            </semantics>
          </math>を決定する。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>に沿って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_a</annotation>
            </semantics>
          </math>を<em>輸送</em>
          (transport) する:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>b</mi>
                </msub>
                <mo>=</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>G</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>f</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>∘</mo>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
                <mo>∘</mo>
                <msup>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>F</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>f</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mrow>
                    <mo>−</mo>
                    <mn>1</mn>
                  </mrow>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_b = (G\ f) \circ \alpha_a \circ (F\ f)^{-1}</annotation>
            </semantics>
          </math></p>
        <p><img src="images/4_transport.jpg" style="width:40.0%" /></p>
        <p>
          2つの対象間に2つ以上の可逆な射がある場合、これらの輸送はすべて一致する必要がある。ただし、一般には射は可逆ではない。しかし、2つの関手間に自然変換が存在するとは全く保証されていないことは理解できる。したがって、自然変換によって関連する関手が多いか少ないかは、それらが作用する圏の構造について多くのことを教えてくれるだろう。極限と米田の補題について話すときに、いくつかの例を見ることになる。
        </p>
        <p>自然変換をコンポーネントごとに見ると、対象を射に写していると言える。自然条件があるので、射を可換な正方図式に写しているとも言えるだろう――<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>のすべての射に対して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>内に可換な自然性の正方図式が1つ存在する。</p>
        <p><img src="images/naturality.jpg" style="width:40.0%" /></p>
        <p>自然変換のこの性質は、多くの圏の構造 (可換図式を含むことが多い)
          で非常に便利になる。関手を適切に選択すれば、これらの可換性条件の多くは自然条件に変換できる。その例は、極限・余極限・随伴に辿り着いたときに見ることになるだろう。</p>
        <p>最後に、自然変換を使って関手の同型を定義できる。2つの関手が自然に同型であると言うのは、全く同じだと言っているようなものだ。<span id="natural_isomorphism"
            class="keyword">自然同型</span> (natural
          isomorphism) は、コンポーネントがすべて同型 (可逆な同型)
          である自然変換として定義される。</p>
        <h2 data-number="10.1" id="多相関数"><span class="header-section-number">10.1</span> 多相関数</h2>
        <p>プログラミングにおける関手 (より具体的には自己関手)
          の役割についてもすでに述べた。それらは型を型に写す型コンストラクターに対応している。また、関数を関数に写し、その写像は高階関数<code>fmap</code>
          (あるいはC++では<code>transform</code>, <code>then</code>など)
          によって実装される。</p>
        <p>自然変換を構築するにはまず、ある対象から始める。ここでは型<code>a</code>から始める。ある関手<code>F</code>はそれを型<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ a</annotation>
            </semantics>
          </math>に写す。別の関手<code>G</code>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">G\ a</annotation>
            </semantics>
          </math>に写す。<code>a</code>における自然変換<code>alpha</code>のコンポーネントは、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">G\ a</annotation>
            </semantics>
          </math>への関数だ。疑似Haskellではこうなる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_a \Colon F\ a \to G\ a</annotation>
            </semantics>
          </math></p>
        <p>自然変換は、すべての型<code>a</code>に対して定義される多相関数だ:</p>
        <div class="sourceCode" id="cb268">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">F</span> a <span class="ot">-&gt;</span> <span class="dt">G</span> a</span></code></pre>
        </div>
        <p>Haskellでは<code>forall</code>はオプションだ
          (そして実際に言語拡張<code>ExplicitForAll</code>を有効にする必要がある)。通常は、次のように記述する:</p>
        <div class="sourceCode" id="cb269">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="dt">F</span> a <span class="ot">-&gt;</span> <span class="dt">G</span> a</span></code></pre>
        </div>
        <p>これは実際には<code>a</code>によってパラメーター化された一連の関数であることに注意してほしい。これもまた、Haskellの構文の簡潔さを示す一例だ。C++では同様の構文はもう少し冗長になる:</p>
        <div class="sourceCode" id="cb270">
          <pre
            class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> A<span class="op">&gt;</span> G<span class="op">&lt;</span>A<span class="op">&gt;</span> alpha<span class="op">(</span>F<span class="op">&lt;</span>A<span class="op">&gt;);</span></span></code></pre>
        </div>
        <p>Haskellの多相 (polymorphic) 関数とC++の総称 (generic)
          関数との間にはさらに大きな違いがあり、関数の実装や型チェックの方法はそれを反映している。Haskellでは、多相関数はすべての型に対して一様に定義されなければならない。1つの式があらゆる型にわたって機能する必要がある。これは<em>パラメトリック多相</em>
          (parametric polymorphism) と呼ばれる。</p>
        <p>一方、C++はデフォルトで<span id="ad_hoc_polymorphism" class="keyword">アドホック多相</span> (ad hoc polymorphism)
          をサポートしており、テンプレートはすべての型に対して明確に定義されている必要はない。ある型に対してテンプレートが機能するかどうかは、型パラメーターに具体的な型が代入されるインスタンス化時に決定される。型チェックが遅延されるため、残念ながら、理解し難いエラーメッセージにつながることがよくある。
        </p>
        <p>C++には、関数のオーバーロードとテンプレートの特殊化のための機構もあり、同じ関数で異なる型に対して異なる定義を行える。Haskellでは、この機能は型クラスと型ファミリーによって提供されている。</p>
        <p>Haskellのパラメトリック多相は予想外の結果をもたらす。次のような型の任意の多相関数:</p>
        <div class="sourceCode" id="cb271">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="dt">F</span> a <span class="ot">-&gt;</span> <span class="dt">G</span> a</span></code></pre>
        </div>
        <p>を関手<code>F</code>と<code>G</code>について考えると、それらは自動的に自然条件を満たす。圏論の表記法で表すとこうなる
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>は関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon a \to b</annotation>
            </semantics>
          </math>だ)。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
                <mo>∘</mo>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
                <mo>=</mo>
                <msub>
                  <mi>α</mi>
                  <mi>b</mi>
                </msub>
                <mo>∘</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">G\ f \circ \alpha_a = \alpha_b \circ F\ f</annotation>
            </semantics>
          </math></p>
        <p>
          Haskellでは、関手<code>f</code>の射<code>G</code>に対する作用は<code>fmap</code>を使って実装される。最初に疑似Haskellで、明示的な型アノテーションを付けて書こう:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mi>m</mi>
                <mi>a</mi>
                <msub>
                  <mi>p</mi>
                  <mi>G</mi>
                </msub>
                <mi>f</mi>
                <mi>.</mi>
                <mi>a</mi>
                <mi>l</mi>
                <mi>p</mi>
                <mi>h</mi>
                <msub>
                  <mi>a</mi>
                  <mi>a</mi>
                </msub>
                <mo>=</mo>
                <mi>a</mi>
                <mi>l</mi>
                <mi>p</mi>
                <mi>h</mi>
                <msub>
                  <mi>a</mi>
                  <mi>b</mi>
                </msub>
                <mi>.</mi>
                <mi>f</mi>
                <mi>m</mi>
                <mi>a</mi>
                <msub>
                  <mi>p</mi>
                  <mi>F</mi>
                </msub>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">fmap_G f . alpha_a = alpha_b . fmap_F f</annotation>
            </semantics>
          </math></p>
        <p>型推論によって、これらのアノテーションは不要になり、次の等式が成立する:</p>
        <div class="sourceCode" id="cb272">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f <span class="op">.</span> alpha <span class="ot">=</span> alpha <span class="op">.</span> <span class="fu">fmap</span> f</span></code></pre>
        </div>
        <p>これはまだ本物のHaskellではない――関数の等価性がコードで表現できない――が、これは恒等式であり、プログラマーが等式推論で、あるいはコンパイラが最適化を実装するのに使える。</p>
        <p>Haskellで自然条件が自動である理由は、“theorems for free”
          に関係している。Haskellで自然変換を定義するのに使われるパラメトリック多相は、実装に非常に強い制限を課す――すべての型に対して1つの式だ。これらの制限は、そのような関数に関する等式定理に変換される。関手を変換する関数の場合、free定理は自然条件だ。(free定理の詳細については、私のブログ<a
            href="https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/"
            title="Parametricity: Money for Nothing and Theormes for Free">Parametricity:
            Money for Nothing and Theormes for Free</a>を参照してほしい。)</p>
        <p>
          関手についてHaskellで考える1つの方法として先に述べたのは、一般化されたコンテナと見なす方法だった。この類推を続けると、自然変換は、あるコンテナの中身を別のコンテナに再パッケージするレシピと見なせる。要素自体に触れることはない:
          要素を変更したり、新しい要素を作成したりはしない。それら (の一部)
          を、時には複数回、新しいコンテナにコピーするだけだ。</p>
        <p>
          自然条件は、最初に<code>fmap</code>を適用して要素を変更してから後で再パッケージするのか、それとも最初に再パッケージしてから<code>fmap</code>を独自に実装して新しいコンテナ内の要素を変更するのか、は問題ではないという宣言になる。再パッケージ化と<code>fmap</code>の2つの作用は直交している。「一方は卵を動かし、もう一方は茹でる。」
        </p>
        <p>Haskellでの自然変換の例をいくつか見てみよう。1つ目はlist関手と<code>Maybe</code>関手の間の自然変換だ。これはリストの頭部を返すが、リストが空でない場合に限る:</p>
        <div class="sourceCode" id="cb273">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a><span class="ot">safeHead ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb273-2"><a href="#cb273-2" aria-hidden="true" tabindex="-1"></a>safeHead [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb273-3"><a href="#cb273-3" aria-hidden="true" tabindex="-1"></a>safeHead (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Just</span> x</span></code></pre>
        </div>
        <p>
          これは<code>a</code>について多相な関数だ。<code>a</code>がどんな型であっても制限なく機能するので、パラメトリック多相の一例といえる。したがって、これは2つの関手の間の自然変換だ。だが、納得するために、自然条件を証明してみよう。
        </p>
        <div class="sourceCode" id="cb274">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f <span class="op">.</span> safeHead <span class="ot">=</span> safeHead <span class="op">.</span> <span class="fu">fmap</span> f</span></code></pre>
        </div>
        <p>考慮すべきケースは2つある。1つは空リストだ:</p>
        <div class="sourceCode" id="cb275">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (safeHead []) <span class="ot">=</span> <span class="fu">fmap</span> f <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre>
        </div>
        <div class="sourceCode" id="cb276">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a>safeHead (<span class="fu">fmap</span> f []) <span class="ot">=</span> safeHead [] <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre>
        </div>
        <p>もう1つは空でないリストだ:</p>
        <div class="sourceCode" id="cb277">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (safeHead (x<span class="op">:</span>xs)) <span class="ot">=</span> <span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre>
        </div>
        <div class="sourceCode" id="cb278">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true" tabindex="-1"></a>safeHead (<span class="fu">fmap</span> f (x<span class="op">:</span>xs)) <span class="ot">=</span> safeHead (f x <span class="op">:</span> <span class="fu">fmap</span> f xs) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre>
        </div>
        <p>ここで、<code>fmap</code>の実装として以下の2つを利用した。リスト用:</p>
        <div class="sourceCode" id="cb279">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f [] <span class="ot">=</span> []</span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">:</span> <span class="fu">fmap</span> f xs</span></code></pre>
        </div>
        <p><code>Maybe</code>用:</p>
        <div class="sourceCode" id="cb280">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb280-2"><a href="#cb280-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre>
        </div>
        <p>
          興味深いのは、関手の1つが自明な<code>Const</code>関手であるケースだ。<code>Const</code>関手からの自然変換は戻り値の型について多相な関数のように見え、<code>Const</code>関手への自然変換は引数の型について多相な関数のように見える。
        </p>
        <p>たとえば、<code>length</code>はlist関手から<code>Const Int</code>関手への自然変換と見なせる。</p>
        <div class="sourceCode" id="cb281">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Const</span> <span class="dt">Int</span> a</span>
<span id="cb281-2"><a href="#cb281-2" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> [] <span class="ot">=</span> <span class="dt">Const</span> <span class="dv">0</span></span>
<span id="cb281-3"><a href="#cb281-3" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Const</span> (<span class="dv">1</span> <span class="op">+</span> unConst (<span class="fu">length</span> xs))</span></code></pre>
        </div>
        <p>ここで、<code>unConst</code>は<code>Const</code>コンストラクターを引き剥がすのに使われる:</p>
        <div class="sourceCode" id="cb282">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unConst ::</span> <span class="dt">Const</span> c a <span class="ot">-&gt;</span> c</span>
<span id="cb282-2"><a href="#cb282-2" aria-hidden="true" tabindex="-1"></a>unConst (<span class="dt">Const</span> x) <span class="ot">=</span> x</span></code></pre>
        </div>
        <p>当然、実用上は<code>length</code>は次のように定義される:</p>
        <div class="sourceCode" id="cb283">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre>
        </div>
        <p>これは実質的に、自然変換であるという事実を隠してしまう。</p>
        <p><code>Const</code>関手<em>から</em>のパラメトリック多相関数を見つけるのは少し難しい。無から値を生成する必要があるからだ。最善を尽くすと、次のようになる:</p>
        <div class="sourceCode" id="cb284">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a><span class="ot">scam ::</span> <span class="dt">Const</span> <span class="dt">Int</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb284-2"><a href="#cb284-2" aria-hidden="true" tabindex="-1"></a>scam (<span class="dt">Const</span> x) <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre>
        </div>
        <p>すでに見たもう1つの一般的な関手で、後ほど米田の補題で重要な役を果たすのは、<code>Reader</code>関手だ。定義を<code>newtype</code>に書き直そう:</p>
        <div class="sourceCode" id="cb285">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Reader</span> e a <span class="ot">=</span> <span class="dt">Reader</span> (e <span class="ot">-&gt;</span> a)</span></code></pre>
        </div>
        <p>これは2つの型によってパラメーター化されているが、(共変的に)
          関手的なのは2番目の型だけだ:</p>
        <div class="sourceCode" id="cb286">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Reader</span> e) <span class="kw">where</span></span>
<span id="cb286-2"><a href="#cb286-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Reader</span> g) <span class="ot">=</span> <span class="dt">Reader</span> (\x <span class="ot">-&gt;</span> f (g x))</span></code></pre>
        </div>
        <p>
          すべての型<code>e</code>について、<code>Reader e</code>から他の任意の関手<code>f</code>への自然変換の族を定義できる。この族のメンバーが常に<code>f e</code>の要素と1対1で対応している
          (<a href="#the-yoneda-lemma">米田の補題</a>) ことを後で説明する。</p>
        <p>
          たとえば、1つの要素<code>()</code>を持つ、ある意味で自明な単位型<code>()</code>について考えてみよう。関手<code>Reader ()</code>は、任意の型<code>a</code>を取り、それを関数型<code>() -&gt; a</code>に写す。これらは単に、集合<code>a</code>から1つの要素を選択するすべての関数だ。それらは<code>a</code>にある要素と同じ数だけある。ここで、この関手から<code>Maybe</code>関手への自然変換を考えてみよう。
        </p>
        <div class="sourceCode" id="cb287">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="dt">Reader</span> () a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span></code></pre>
        </div>
        <p>あるのは<code>dumb</code>と<code>obvious</code>の2つだけだ:</p>
        <div class="sourceCode" id="cb288">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a>dumb (<span class="dt">Reader</span> _) <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre>
        </div>
        <p>および</p>
        <div class="sourceCode" id="cb289">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true" tabindex="-1"></a>obvious (<span class="dt">Reader</span> g) <span class="ot">=</span> <span class="dt">Just</span> (g ())</span></code></pre>
        </div>
        <p>(<code>g</code>でできる唯一のことは、それをunit値<code>()</code>に適用することだ。)</p>
        <p>
          そして実際、米田の補題によって予言されるように、これらは<code>Maybe ()</code>型の2つの要素、<code>Nothing</code>と<code>Just ()</code>に対応している。米田の補題には後で戻ってこよう――ここではほんの少し垣間見ただけだ。
        </p>
        <h2 data-number="10.2" id="自然性を越えて"><span class="header-section-number">10.2</span> 自然性を越えて</h2>
        <p>2つの関手の間のパラメトリック多相関数
          (<code>Const</code>関手という特殊な例を含む)
          は、常に自然変換だ。標準的な代数的データ型はすべて関手なので、これらの型の間の多相関数はすべて自然変換だ。</p>
        <p>また、自由に使える関数型もあり、それらは戻り値の型について関手的だ。それらを使って
          (<code>Reader</code>関手のような)
          関手を構築し、高階関数である自然変換を定義できる。</p>
        <p>しかし、関数型は引数について共変ではない。それらは<span id="contravariant"
            class="keyword">反変</span>だ。当然、反変関手は反対圏からの共変関手と等価だ。2つの反変関手の間の多相関数は、反対圏からHaskellの型への関手を処理する点を除けば、圏論的には自然変換だ。
        </p>
        <p>反変関手の例を前に見たのを覚えているだろう:</p>
        <div class="sourceCode" id="cb290">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb290-1"><a href="#cb290-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Op</span> r a <span class="ot">=</span> <span class="dt">Op</span> (a <span class="ot">-&gt;</span> r)</span></code></pre>
        </div>
        <p>この関手は<code>a</code>について反変だ:</p>
        <div class="sourceCode" id="cb291">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> (<span class="dt">Op</span> r) <span class="kw">where</span></span>
<span id="cb291-2"><a href="#cb291-2" aria-hidden="true" tabindex="-1"></a>    contramap f (<span class="dt">Op</span> g) <span class="ot">=</span> <span class="dt">Op</span> (g <span class="op">.</span> f)</span></code></pre>
        </div>
        <p>たとえば、<code>Op Bool</code>から<code>Op String</code>への多相関数を書ける:</p>
        <div class="sourceCode" id="cb292">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a>predToStr (<span class="dt">Op</span> f) <span class="ot">=</span> <span class="dt">Op</span> (\x <span class="ot">-&gt;</span> <span class="kw">if</span> f x <span class="kw">then</span> <span class="st">&quot;T&quot;</span> <span class="kw">else</span> <span class="st">&quot;F&quot;</span>)</span></code></pre>
        </div>
        <p>ただし、2つの関手は共変ではないので、これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐇</mi>
                <mi>𝐚</mi>
                <mi>𝐬</mi>
                <mi>𝐤</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Hask}</annotation>
            </semantics>
          </math>の自然変換ではない。しかし、どちらも反変なので、「反対」の自然条件は満たしている:</p>
        <div class="sourceCode" id="cb293">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true" tabindex="-1"></a>contramap f <span class="op">.</span> predToStr <span class="ot">=</span> predToStr <span class="op">.</span> contramap f</span></code></pre>
        </div>
        <p><code>contramap</code>のシグネチャは次のとおりなので、関数<code>f</code>は<code>fmap</code>で使うのとは逆方向でなければならないことに注意してほしい:</p>
        <div class="sourceCode" id="cb294">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb294-1"><a href="#cb294-1" aria-hidden="true" tabindex="-1"></a><span class="ot">contramap ::</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Op</span> <span class="dt">Bool</span> a <span class="ot">-&gt;</span> <span class="dt">Op</span> <span class="dt">Bool</span> b)</span></code></pre>
        </div>
        <p>共変にしろ反変にしろ、関手ではない型コンストラクターは存在するのだろうか？
          次のような例が挙げられる:</p>
        <div class="sourceCode" id="cb295">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <p>同じ型<code>a</code>が負 (反変) と正 (共変)
          の両側で使われているので、これは関手ではない。この型には<code>fmap</code>や<code>contramap</code>を実装できない。したがって、次のシグネチャを持つ関数:</p>
        <div class="sourceCode" id="cb296">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true" tabindex="-1"></a>(a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> f a</span></code></pre>
        </div>
        <p>は自然変換にはなれない。ここで、<code>f</code>は任意の関手だ。興味深いことに、このような場合を扱う一般化された自然変換として、対角自然変換
          (dinatural transformation)
          と呼ばれるものがある。これについてはエンドについて議論するときに説明しよう。</p>
        <h2 data-number="10.3" id="関手圏"><span class="header-section-number">10.3</span> 関手圏</h2>
        <p>関手間の写像――自然変換――ができた今、関手が圏を形成するかどうかを問うのは自然なことだ。そして実際に形成する！
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の圏のペアごとに、関手の圏が1つある。この圏の対象は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>への関手であり、射はこれらの関手間の自然変換だ。
        </p>
        <p>2つの自然変換の合成を定義する必要があるが、それは非常に簡単だ。自然変換のコンポーネントは射であり、射を合成する方法は分かっている。</p>
        <p>実際に、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>への自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>を取ろう。対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>におけるそのコンポーネントはこのような射だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_a \Colon F\ a \to G\ a</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>を、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>H</mi>
              <annotation encoding="application/x-tex">H</annotation>
            </semantics>
          </math>への自然変換である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>β</mi>
              <annotation encoding="application/x-tex">\beta</annotation>
            </semantics>
          </math>と合成したい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>での<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>β</mi>
              <annotation encoding="application/x-tex">\beta</annotation>
            </semantics>
          </math>のコンポーネントは次の射だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>β</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mi>H</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\beta_a \Colon G\ a \to H\ a</annotation>
            </semantics>
          </math></p>
        <p>これらの射は合成可能であり、その合成は次のような別の射だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>β</mi>
                  <mi>a</mi>
                </msub>
                <mo>∘</mo>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mi>H</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\beta_a \circ \alpha_a \Colon F\ a \to H\ a</annotation>
            </semantics>
          </math></p>
        <p>この射を自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>β</mi>
                <mo>⋅</mo>
                <mi>α</mi>
              </mrow>
              <annotation encoding="application/x-tex">\beta \cdot \alpha</annotation>
            </semantics>
          </math>――自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>β</mi>
              <annotation encoding="application/x-tex">\beta</annotation>
            </semantics>
          </math>を自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>の後に合成したもの――のコンポーネントとして使う。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>β</mi>
                    <mo>⋅</mo>
                    <mi>α</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mi>a</mi>
                </msub>
                <mo>=</mo>
                <msub>
                  <mi>β</mi>
                  <mi>a</mi>
                </msub>
                <mo>⋅</mo>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">(\beta \cdot \alpha)_a = \beta_a \cdot \alpha_a</annotation>
            </semantics>
          </math></p>
        <p><img src="images/5_vertical.jpg" style="width:40.0%" /></p>
        <p>図式を (長く)
          見ていると、この合成の結果は本当に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>H</mi>
              <annotation encoding="application/x-tex">H</annotation>
            </semantics>
          </math>への自然変換だと確信できる。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>H</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
                <mo>∘</mo>
                <msub>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>β</mi>
                    <mo>⋅</mo>
                    <mi>α</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mi>a</mi>
                </msub>
                <mo>=</mo>
                <msub>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>β</mi>
                    <mo>⋅</mo>
                    <mi>α</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mi>b</mi>
                </msub>
                <mo>∘</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">H\ f \circ (\beta \cdot \alpha)_a = (\beta \cdot \alpha)_b \circ
                F\ f</annotation>
            </semantics>
          </math></p>
        <p><img src="images/6_verticalnaturality.jpg" style="width:35.0%" /></p>
        <p>自然変形の合成は結合的だ。なぜなら、それらの構成要素は正則 (regular)
          な射であり、合成に関して結合的だからだ。</p>
        <p>最後に、各関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>について恒等自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mn>1</mn>
                <mi>F</mi>
              </msub>
              <annotation encoding="application/x-tex">1_F</annotation>
            </semantics>
          </math>があり、そのコンポーネントは恒等射だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mrow>
                    <mi>F</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                  </mrow>
                </msub>
                <mo>∷</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{id}_{F\ a} \Colon F\ a \to F\ a</annotation>
            </semantics>
          </math></p>
        <p>以上より、確かに関手は圏を形成している。</p>
        <p>記法について述べておこう。ソーンダーズ・マックレーンにしたがって、私は先ほど述べたような自然変換の合成にドットを使う。問題は、自然変換を合成する方法が2つあることだ。こちらは垂直合成
          (vertical composition)
          と呼ばれている。なぜなら、通常は関数を上下に積んだ図式で説明されるからだ。垂直合成は関手圏を定義するうえで重要だ。水平合成についてもすぐに説明する。</p>
        <p><img src="images/6a_vertical.jpg" style="width:30.0%" /></p>
        <p>圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の間の関手圏は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐅</mi>
                <mi>𝐮</mi>
                <mi>𝐧</mi>
                <mrow>
                  <mo stretchy="true" form="prefix" mathvariant="bold">(</mo>
                  <mi>𝐂</mi>
                  <mo mathvariant="bold">,</mo>
                  <mi>𝐃</mi>
                  <mo stretchy="true" form="postfix" mathvariant="bold">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Fun(C, D)}</annotation>
            </semantics>
          </math>または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix" mathvariant="bold">[</mo>
                <mi>𝐂</mi>
                <mo mathvariant="bold">,</mo>
                <mi>𝐃</mi>
                <mo stretchy="true" form="postfix" mathvariant="bold">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{[C, D]}</annotation>
            </semantics>
          </math>、場合によっては<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐃</mi>
                <mi>𝐂</mi>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{D^C}</annotation>
            </semantics>
          </math>と書かれる。この最後の表記法は、関手圏自体が他の圏では関数オブジェクト
          (冪乗) と見なせることを示唆している。だが、本当にそうだろうか？</p>
        <p>これまでに構築してきた抽象化の階層を見てみよう。最初は対象と射の集まりとしての圏から始めた。圏自体
          (厳密に言えば、対象が集合を形成する<em>小さい</em>圏)
          は、それ自体がより高いレベルの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>における対象だ。その圏における射は関手だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>におけるhom集合は関手の集合だ。たとえば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
                <mrow>
                  <mo stretchy="true" form="prefix" mathvariant="bold">(</mo>
                  <mi>𝐂</mi>
                  <mo mathvariant="bold">,</mo>
                  <mi>𝐃</mi>
                  <mo stretchy="true" form="postfix" mathvariant="bold">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat(C, D)}</annotation>
            </semantics>
          </math>は、2つの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の間の関手の集合だ。</p>
        <p><img src="images/7_cathomset.jpg" style="width:30.0%" /></p>
        <p>関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix" mathvariant="bold">[</mo>
                <mi>𝐂</mi>
                <mo mathvariant="bold">,</mo>
                <mi>𝐃</mi>
                <mo stretchy="true" form="postfix" mathvariant="bold">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{[C, D]}</annotation>
            </semantics>
          </math>も、2つの圏の間の関手の集合だ
          (それと、射としての自然変換も加わる)。その対象は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
                <mrow>
                  <mo stretchy="true" form="prefix" mathvariant="bold">(</mo>
                  <mi>𝐂</mi>
                  <mo mathvariant="bold">,</mo>
                  <mi>𝐃</mi>
                  <mo stretchy="true" form="postfix" mathvariant="bold">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat(C, D)}</annotation>
            </semantics>
          </math>のメンバーと同じだ。さらに、関手圏は圏なので、それ自体が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>の対象でなければならない
          (2つの小さい圏の間の関手圏も、それ自体が小さい圏だ)。ある圏のhom集合と、同じ圏の対象の間の関係は知っている。この状況は、前の章で見た冪乗対象とまったく同じだ。後者を<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>で構築する方法を見てみよう。</p>
        <p>覚えているだろうが、冪乗を構成するには、まず積を定義する必要がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>では、これは比較的簡単であることがわかる。なぜなら、小さい圏は対象の<em>集合</em>であり、集合のカルテシアン積を定義する方法は知っているからだ。したがって、直積圏<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo mathvariant="bold">×</mo>
                <mi>𝐃</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C \times D}</annotation>
            </semantics>
          </math>内の対象は単なる対象のペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>c</mi>
                <mo>,</mo>
                <mi>d</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(c, d)</annotation>
            </semantics>
          </math>
          であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>からそれぞれ1つ取ったものだ。同様に、2つのそのようなペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>c</mi>
                <mo>,</mo>
                <mi>d</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(c, d)</annotation>
            </semantics>
          </math>
          と
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>c</mi>
                <mi>′</mi>
                <mo>,</mo>
                <mi>d</mi>
                <mi>′</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(c&#39;, d&#39;)</annotation>
            </semantics>
          </math>
          の間の射は、射のペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>f</mi>
                <mo>,</mo>
                <mi>g</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(f, g)</annotation>
            </semantics>
          </math>
          であり、ここで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>c</mi>
                <mo>→</mo>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon c \to c&#39;</annotation>
            </semantics>
          </math>および<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>∷</mo>
                <mi>d</mi>
                <mo>→</mo>
                <mi>d</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">g \Colon d \to d&#39;</annotation>
            </semantics>
          </math>だ。これらの射のペアはコンポーネントごとに合成でき、恒等ペアとしての単なる恒等射のペアも常に存在する。手短に言うと、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>は本格的なカルテシアン閉圏であり、そこにはあらゆる圏のペアに対する冪乗対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐃</mi>
                <mi>𝐂</mi>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{D^C}</annotation>
            </semantics>
          </math>が存在する。そして、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>の「対象」は圏を意味するので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐃</mi>
                <mi>𝐂</mi>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{D^C}</annotation>
            </semantics>
          </math>は圏であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の間の関手圏と同一視できる。
        </p>
        <h2 data-number="10.4" id="圏"><span class="header-section-number">10.4</span> 2-圏</h2>
        <p>もう心配ないので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>を詳しく見てみよう。定義より、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>内のすべてのHom集合は関手の集合だ。しかし、これまで見てきたように、2対象間の関手は単なる集合よりも豊かな構造を持っている。それらは圏を形成し、自然変換は射として作用する。関手は<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>では射と見なされるので、自然変換は射の間の射だ。</p>
        <p>より豊かなこの構造は、圏の一般化である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏の例であり、対象と射
          (この文脈では<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-射とも呼べる)
          の他に、射の間の射である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-射も存在する。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏と見なす場合、次のようになる:</p>
        <ul>
          <li>対象: (小さい) 圏</li>
          <li>1-射: 圏の間の関手</li>
          <li>2-射: 関手の間の自然変換。</li>
        </ul>
        <p><img src="images/8_cat-2-cat.jpg" style="width:30.0%" /></p>
        <p>2つの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の間のHom集合の代わりに、Hom圏――関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐃</mi>
                <mi>𝐂</mi>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{D^C}</annotation>
            </semantics>
          </math>がある。正則関手合成があり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐃</mi>
                <mi>𝐂</mi>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{D^C}</annotation>
            </semantics>
          </math>からの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐄</mi>
                <mi>𝐃</mi>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{E^D}</annotation>
            </semantics>
          </math>からの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>と合成して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐄</mi>
                <mi>𝐂</mi>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{E^C}</annotation>
            </semantics>
          </math>からの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mo>∘</mo>
                <mi>F</mi>
              </mrow>
              <annotation encoding="application/x-tex">G \circ F</annotation>
            </semantics>
          </math>を与える。しかし、それぞれのHom圏内での合成もある――関手間での自然変換（すなわち2つの射）の垂直合成だ。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏に2種類の合成があるので、それらはどのように相互作用するのか、という疑問が生じる。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>内の関手、つまり1-射を2つ選択しよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>F</mi>
                    <mo>∷</mo>
                    <mi>𝐂</mi>
                    <mo>→</mo>
                    <mi>𝐃</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>G</mi>
                    <mo>∷</mo>
                    <mi>𝐃</mi>
                    <mo>→</mo>
                    <mi>𝐄</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                F \Colon \mathbf{C} \to \mathbf{D} \\
                G \Colon \mathbf{D} \to \mathbf{E}
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>これらの合成は次のとおりだ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mo>∘</mo>
                <mi>F</mi>
                <mo>∷</mo>
                <mi>𝐂</mi>
                <mo>→</mo>
                <mi>𝐄</mi>
              </mrow>
              <annotation encoding="application/x-tex">G \circ F \Colon \mathbf{C} \to \mathbf{E}</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>β</mi>
              <annotation encoding="application/x-tex">\beta</annotation>
            </semantics>
          </math>という2つの自然変換があって、それぞれ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>に作用するとする:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>α</mi>
                    <mo>∷</mo>
                    <mi>F</mi>
                    <mo>→</mo>
                    <mi>F</mi>
                    <mi>′</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>β</mi>
                    <mo>∷</mo>
                    <mi>G</mi>
                    <mo>→</mo>
                    <mi>G</mi>
                    <mi>′</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                \alpha \Colon F \to F&#39; \\
                \beta \Colon G \to G&#39;
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p><img src="images/10_horizontal.jpg" style="width:40.0%" /></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>の終域と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>β</mi>
              <annotation encoding="application/x-tex">\beta</annotation>
            </semantics>
          </math>の始域が異なるため、このペアには垂直合成を適用できないことに注意してほしい。実際、これらは別々の関手圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐃</mi>
                <mi>𝐂</mi>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{D^C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐄</mi>
                <mi>𝐃</mi>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{E^D}</annotation>
            </semantics>
          </math>のメンバーだ。しかし、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">F&#39;</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">G&#39;</annotation>
            </semantics>
          </math>に合成を適用することはできる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">F&#39;</annotation>
            </semantics>
          </math>の終域も<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">G&#39;</annotation>
            </semantics>
          </math>の始域も圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>だからだ。関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mi>′</mi>
                <mo>∘</mo>
                <mi>F</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">G&#39; \circ F&#39;</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mo>∘</mo>
                <mi>F</mi>
              </mrow>
              <annotation encoding="application/x-tex">G \circ F</annotation>
            </semantics>
          </math>はどのような関係だろうか？</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>β</mi>
              <annotation encoding="application/x-tex">\beta</annotation>
            </semantics>
          </math>を自由に使えるので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mo>∘</mo>
                <mi>F</mi>
              </mrow>
              <annotation encoding="application/x-tex">G \circ F</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mo>∘</mo>
                <mi>F</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">G \circ F&#39;</annotation>
            </semantics>
          </math>への自然変換を定義できるだろうか？
          構成をスケッチしよう。</p>
        <p><img src="images/9_horizontal.jpg" style="width:50.0%" /></p>
        <p>いつものように、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から始める。その像は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>′</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F&#39;a</annotation>
            </semantics>
          </math>に分割される。また、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>のコンポーネントである射が2つの対象を接続している。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mi>F</mi>
                <mi>′</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_a \Colon F\ a \to F&#39;a</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐄</mi>
              <annotation encoding="application/x-tex">\mathbf{E}</annotation>
            </semantics>
          </math>に移行するとき、これら2つの対象はさらに4つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">G(F\ a)</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mi>′</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">G&#39;(F\ a)</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mi>′</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">G&#39;(F&#39;a)</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mi>′</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">G&#39;(F&#39;a)</annotation>
            </semantics>
          </math>
          に分割される。正方図式を形成する4つの射もある。これらの射のうちの2つは、自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>β</mi>
              <annotation encoding="application/x-tex">\beta</annotation>
            </semantics>
          </math>のコンポーネントだ。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <msub>
                      <mi>β</mi>
                      <mrow>
                        <mi>F</mi>
                        <mspace width="0.222em"></mspace>
                        <mi>a</mi>
                      </mrow>
                    </msub>
                    <mo>∷</mo>
                    <mi>G</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>F</mi>
                      <mspace width="0.222em"></mspace>
                      <mi>a</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                    <mo>→</mo>
                    <mi>G</mi>
                    <mi>′</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>F</mi>
                      <mspace width="0.222em"></mspace>
                      <mi>a</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <msub>
                      <mi>β</mi>
                      <mrow>
                        <mi>F</mi>
                        <mi>′</mi>
                        <mi>a</mi>
                      </mrow>
                    </msub>
                    <mo>∷</mo>
                    <mi>G</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>F</mi>
                      <mi>′</mi>
                      <mi>a</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                    <mo>→</mo>
                    <mi>G</mi>
                    <mi>′</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>F</mi>
                      <mi>′</mi>
                      <mi>a</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                \beta_{F\ a} \Colon G (F\ a) \to G&#39;(F\ a) \\
                \beta_{F&#39;a} \Colon G (F&#39;a) \to G&#39;(F&#39;a)
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>他の2つは、2つの関手による<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_a</annotation>
            </semantics>
          </math>の像だ
          (関手は射を写す)。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>G</mi>
                    <msub>
                      <mi>α</mi>
                      <mi>a</mi>
                    </msub>
                    <mo>∷</mo>
                    <mi>G</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>F</mi>
                      <mspace width="0.222em"></mspace>
                      <mi>a</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                    <mo>→</mo>
                    <mi>G</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>F</mi>
                      <mi>′</mi>
                      <mi>a</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>G</mi>
                    <mi>′</mi>
                    <msub>
                      <mi>α</mi>
                      <mi>a</mi>
                    </msub>
                    <mo>∷</mo>
                    <mi>G</mi>
                    <mi>′</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>F</mi>
                      <mspace width="0.222em"></mspace>
                      <mi>a</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                    <mo>→</mo>
                    <mi>G</mi>
                    <mi>′</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>F</mi>
                      <mi>′</mi>
                      <mi>a</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                G \alpha_a \Colon G (F\ a) \to G (F&#39;a) \\
                G&#39;\alpha_a \Colon G&#39;(F\ a) \to G&#39;(F&#39;a)
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>射がとてもたくさんある。目標は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">G(F\ a)</annotation>
            </semantics>
          </math>
          から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mi>′</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">G&#39;(F&#39;a)</annotation>
            </semantics>
          </math>
          への射を見つけることだ。これは2つの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mo>∘</mo>
                <mi>F</mi>
              </mrow>
              <annotation encoding="application/x-tex">G \circ F</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mo>∘</mo>
                <mi>F</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">G \circ F&#39;</annotation>
            </semantics>
          </math>を接続する自然変換のコンポーネントの候補だ。実際、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">G(F\ a)</annotation>
            </semantics>
          </math>
          から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mi>′</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">G&#39;(F&#39;a)</annotation>
            </semantics>
          </math>
          への道は1つではなく2つある。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mi>′</mi>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
                <mo>∘</mo>
                <msub>
                  <mi>β</mi>
                  <mrow>
                    <mi>F</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                  </mrow>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">G&#39;\alpha_a \circ \beta_{F\ a}</annotation>
            </semantics>
          </math>
          <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>β</mi>
                  <mrow>
                    <mi>F</mi>
                    <mi>′</mi>
                    <mi>a</mi>
                  </mrow>
                </msub>
                <mo>∘</mo>
                <mi>G</mi>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">\beta_{F&#39;a} \circ G \alpha_a</annotation>
            </semantics>
          </math>
        </p>
        <p>ありがたいことに、これらは等しい。なぜなら、我々が生成した正方図式は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>β</mi>
              <annotation encoding="application/x-tex">\beta</annotation>
            </semantics>
          </math>の自然性の正方図式だからだ。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mo>∘</mo>
                <mi>F</mi>
              </mrow>
              <annotation encoding="application/x-tex">G \circ F</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mo>∘</mo>
                <mi>F</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">G \circ F&#39;</annotation>
            </semantics>
          </math>への自然変換のコンポーネントが定義できた。この変換に対する自然性の証明は、十分に忍耐強い人にとっては、非常に簡単だ。</p>
        <p>この自然変換を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>β</mi>
              <annotation encoding="application/x-tex">\beta</annotation>
            </semantics>
          </math>の<span id="horizontal_composition" class="keyword">水平合成</span> (horizontal
          composition) と呼ぶ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>β</mi>
                <mo>∘</mo>
                <mi>α</mi>
                <mo>∷</mo>
                <mi>G</mi>
                <mo>∘</mo>
                <mi>F</mi>
                <mo>→</mo>
                <mi>G</mi>
                <mi>′</mi>
                <mo>∘</mo>
                <mi>F</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">\beta \circ \alpha \Colon G \circ F \to G&#39; \circ F&#39;
              </annotation>
            </semantics>
          </math></p>
        <p>ここでも私はマックレーンに従って、水平合成を表すのに小さな円を使うが、代わりにアスタリスクが使われることもある。</p>
        <p>圏論のルールをまとめると、合成に出会うたびに圏を探すべきだ、となる。自然変換には垂直合成があり、それは関手圏の一部だ。しかし、水平合成はどうだろうか？
          それはどの圏にあるのだろう？</p>
        <p>これを解明する方法は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>を横から見ることだ。自然変換を、関手の間の矢としてではなく、圏の間の矢として見てほしい。自然変換は、それが変換する関手で接続された2つの圏の間に位置する。つまり、それら2つの圏を結びつけるものと見なせる。
        </p>
        <p><img src="images/sideways.jpg" style="width:50.0%" /></p>
        <p>ここでは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>の2つの対象――圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>に焦点を当てる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>に接続する関手間をつなぐ自然変換の集合がある。それらの自然変換は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>への新しい矢だ。同じトークンによって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐄</mi>
              <annotation encoding="application/x-tex">\mathbf{E}</annotation>
            </semantics>
          </math>に接続する関手間をつなぐ自然変換が存在する。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐄</mi>
              <annotation encoding="application/x-tex">\mathbf{E}</annotation>
            </semantics>
          </math>へ向かう新しい矢として扱える。水平合成はこれらの矢の合成だ。</p>
        <p>また、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>への恒等射も存在する。これは恒等自然変換であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>上の恒等関手をそれ自体に写す。水平合成の恒等射は垂直合成の恒等射でもあるが、逆は成り立たないことに注意してほしい。</p>
        <p>最後に、2つの合成は交換則を満たす:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>β</mi>
                  <mi>′</mi>
                  <mo>⋅</mo>
                  <mi>α</mi>
                  <mi>′</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>∘</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>β</mi>
                  <mo>⋅</mo>
                  <mi>α</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>=</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>β</mi>
                  <mi>′</mi>
                  <mo>∘</mo>
                  <mi>β</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>⋅</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>α</mi>
                  <mi>′</mi>
                  <mo>∘</mo>
                  <mi>α</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">(\beta&#39; \cdot \alpha&#39;) \circ (\beta \cdot \alpha) =
                (\beta&#39; \circ \beta) \cdot (\alpha&#39; \circ \alpha)</annotation>
            </semantics>
          </math></p>
        <p>ここでソーンダーズ・マックレーンの言葉を引用しよう:「読者はこの事実を証明するのに必要となる証明の図式を書き下すと楽しいだろう。」</p>
        <p>あともう1つ、将来役に立つだろう表記法がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>のこの水平方向の新解釈では、対象から対象へ行く方法が2つある:
          関手を使う方法と自然変換を使う方法だ。しかし、関手の矢を特別な種類の自然変換、つまりその関手に作用する恒等自然変換として再解釈することはできる。したがって、このような記法をよく目にすることになるだろう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∘</mo>
                <mi>α</mi>
              </mrow>
              <annotation encoding="application/x-tex">F \circ \alpha</annotation>
            </semantics>
          </math></p>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐄</mi>
              <annotation encoding="application/x-tex">\mathbf{E}</annotation>
            </semantics>
          </math>への関手で、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>への2つの関手間の自然変換だ。関手と自然変換は合成できないので、これは恒等自然変換<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mn>1</mn>
                <mi>F</mi>
              </msub>
              <annotation encoding="application/x-tex">1_F</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>の後に水平合成したものと解釈される。</p>
        <p>同様に:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>α</mi>
                <mo>∘</mo>
                <mi>F</mi>
              </mrow>
              <annotation encoding="application/x-tex">\alpha \circ F</annotation>
            </semantics>
          </math></p>
        <p>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mn>1</mn>
                <mi>F</mi>
              </msub>
              <annotation encoding="application/x-tex">1_F</annotation>
            </semantics>
          </math>の後に水平合成したものだ。</p>
        <h2 data-number="10.5" id="おわりに"><span class="header-section-number">10.5</span> おわりに</h2>
        <p>これで本の第1部は終わりだ。我々は圏論の基本的な語彙を学んだ。対象・圏は名詞、射・関手・自然変換は動詞と見なせる。射は対象を接続し、関手は圏を接続し、自然変換は関手を接続する。</p>
        <p>また、ある抽象化レベルで作用として現れるものが、次のレベルでは対象になるのも見てきた。射の集合は関数オブジェクトになる。対象としては、それは別の射の始域や終域になり得る。これが高階関数の背景にある概念だ。</p>
        <p>
          関手は対象を対象に写すため、型コンストラクターやパラメトリック型として使える。関手は射も写すので、高階関数<code>fmap</code>だ。<code>Const</code>・積・余積などの単純な関手がいくつかあって、さまざまな代数的データ型の生成に使える。関数型も共変と反変の両方について関手的で、代数的データ型を拡張するのに使える。
        </p>
        <p>関手は関手圏での対象とも見なせる。そのようにして、それらは自然変換、すなわち射の始域および終域になる。自然変換は特別な多相関数だ。</p>
        <h2 data-number="10.6" id="課題-8"><span class="header-section-number">10.6</span> 課題</h2>
        <ol type="1">
          <li>
            <p><code>Maybe</code>関手からlist関手への自然変換を定義せよ。その自然条件を証明せよ。</p>
          </li>
          <li>
            <p><code>Reader ()</code>とlist関手の間に、少なくとも2つの異なる自然変換を定義せよ。<code>()</code>のリストは何種類あるか？</p>
          </li>
          <li>
            <p><code>Reader Bool</code>と<code>Maybe</code>を使って前の課題を続けよ。</p>
          </li>
          <li>
            <p>自然変換の水平合成が自然条件を満たしていることを示せ (ヒント:
              コンポーネントを使う)。これは図式を追ういい練習になる。</p>
          </li>
          <li>
            <p>交換則を証明するために必要な明確な図を描くのを楽しむ方法について、短いエッセイを書け。</p>
          </li>
          <li>
            <p>異なる<code>Op</code>関手間の変換の反対の自然条件について、テストケースをいくつか作成せよ。以下は1つの選択肢だ:</p>
            <div class="sourceCode" id="cb297">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a><span class="ot">op ::</span> <span class="dt">Op</span> <span class="dt">Bool</span> <span class="dt">Int</span></span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a>    op <span class="ot">=</span> <span class="dt">Op</span> (\x <span class="ot">-&gt;</span> x <span class="op">&gt;</span> <span class="dv">0</span>)</span></code></pre>
            </div>
            <p>と</p>
            <div class="sourceCode" id="cb298">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb298-1"><a href="#cb298-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb298-2"><a href="#cb298-2" aria-hidden="true" tabindex="-1"></a>    f x <span class="ot">=</span> <span class="fu">read</span> x</span></code></pre>
            </div>
          </li>
        </ol>
        <h1 data-number="11" id="圏論と宣言的プログラミング"><span class="header-section-number">11</span> 圏論と宣言的プログラミング</h1>
        <h2 data-number="11.1" id="第2部への導入"><span class="header-section-number">11.1</span> 第2部への導入</h2>
        <p>
          第1部では、圏論とプログラミングはどちらも合成可能性に関するものだと主張した。プログラミングでは、処理できる詳細レベルに達するまで問題を分解し続け、それぞれの部分問題を順番に解決し、解決策をボトムアップで再合成する。それには大きく2つの方法がある。コンピューターに何をすべきかを指示する方法と、どのようにすべきかを指示する方法だ。前者は宣言的と呼ばれ、後者は命令的と呼ばれる。
        </p>
        <p>これは最も基本的なレベルでも見られる。合成自体は宣言的に定義できる。たとえば、<code>h</code>は<code>g</code>を<code>f</code>の後に合成したものだ:</p>
        <div class="sourceCode" id="cb299">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true" tabindex="-1"></a>h <span class="ot">=</span> g <span class="op">.</span> f</span></code></pre>
        </div>
        <p>あるいは、命令的に定義するなら、まず<code>f</code>を呼び出し、その呼び出しの結果を記憶し、それからその結果を使って<code>g</code>を呼び出す:</p>
        <div class="sourceCode" id="cb300">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true" tabindex="-1"></a>h x <span class="ot">=</span> <span class="kw">let</span> y <span class="ot">=</span> f x</span>
<span id="cb300-2"><a href="#cb300-2" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span> g y</span></code></pre>
        </div>
        <p>
          プログラムの命令的バージョンは通常、時間軸で順序付けられた動作の連続として記述される。特に、<code>f</code>の実行が完了する前に<code>g</code>を呼び出すことはできない。少なくとも、概念としてはそうだ――遅延評価言語では、<em>call-by-need</em>で引数が渡されるため、実際の実行は異なる方法で進行する可能性がある。
        </p>
        <p>
          実際、コンパイラーの賢さによっては、宣言的コードと命令的コードの実行方法にほとんど違いがない場合もある。しかし、この2つの方法論は、問題解決へのアプローチ方法や実装コードの保守性とテスト可能性において、時には劇的に異なる。
        </p>
        <p>最大の疑問は、問題に直面したとき、解決のための選択肢として、宣言的アプローチと命令的アプローチの両方が常にあるか、ということだ。そして、宣言的な解決策があるなら、それは常にコンピューターコードに翻訳できるのだろうか？
          この問いへの答えは自明とは全く言えず、もしそれを見つけられたなら、宇宙の理解に革命が起こるだろう。</p>
        <p>
          詳しく説明させてほしい。物理学にも似たような双対性がある。それは、何か深い基本原理を指し示したり、我々の心の働きについて何かを教えてくれたりする。リチャード・P・ファインマンはこの双対性について、彼自身の量子電磁力学の研究におけるインスピレーションとして言及している。
        </p>
        <p>
          ほとんどの物理法則には2つの表現形式がある。一つは局所的、あるいは無限小的な考察を用いる。我々は、ごく近傍の系の状態を見て、次の瞬間にそれがどう変化するかを予測する。これは通常、微分方程式で表され、ある期間にわたって積分、つまり合計する必要がある。
        </p>
        <p>
          このアプローチが命令的思考に似ていることに注目してほしい。つまり、前のステップの結果に応じた一連の小さなステップに従って最終的な解に到達する。実際、物理系のコンピューターシミュレーションは、微分方程式を差分方程式に変換し、それらを反復することによって実装されるのが常道だ。小惑星ゲームでも宇宙船はこのようにしてアニメーション化される。各時間ステップにおいて、宇宙船の位置は速度に時間間隔を掛けて計算される小さな増分を加えることで変化する。また、速度は加速度に比例した小さな増分によって変化し、加速度は力を質量で割った値で与えられる。
        </p>
        <p><img src="images/asteroids.png" style="width:50.0%" /></p>
        <p>ニュートンの運動法則に対応する微分方程式の直接的な記述は次のとおりだ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>F</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>=</mo>
                    <mi>m</mi>
                    <mfrac>
                      <mrow>
                        <mi>d</mi>
                        <mi>v</mi>
                      </mrow>
                      <mrow>
                        <mi>d</mi>
                        <mi>t</mi>
                      </mrow>
                    </mfrac>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>v</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>=</mo>
                    <mfrac>
                      <mrow>
                        <mi>d</mi>
                        <mi>x</mi>
                      </mrow>
                      <mrow>
                        <mi>d</mi>
                        <mi>t</mi>
                      </mrow>
                    </mfrac>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                F &amp;= m \frac{dv}{dt} \\
                v &amp;= \frac{dx}{dt}
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>同様の方法は、より複雑な問題にも適用できる。たとえば、マクスウェル方程式を用いた電磁場の伝播や、量子色力学を用いた陽子内部のクォークやグルオンの挙動などだ。</p>
        <p>この局所的な考え方の最たるものは、デジタルコンピューターの使用によって空間と時間の離散化が促進されたのと相まって、宇宙全体の複雑さをセルオートマトンの系に縮約しようとするスティーブン・ウルフラム<a
            href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>の英雄的な試みの中に表れている。</p>
        <p>
          もう1つは大域的なアプローチだ。システムの初期状態と最終状態を見て、それらを結ぶ軌道を、特定の関数を最小化することで計算する。最も簡単な例はフェルマーの最小時間の原理だ。それは、光は伝搬時間が最小になる経路に沿って伝搬すると述べている。特に、反射も屈折もしない場合、点<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>A</mi>
              <annotation encoding="application/x-tex">A</annotation>
            </semantics>
          </math>から点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>B</mi>
              <annotation encoding="application/x-tex">B</annotation>
            </semantics>
          </math>への光は最短経路
          (直線) を通る。しかし、水やガラスのような (透明な)
          高密度の媒質では、光の伝播速度は遅くなる。したがって、始点を空気中に、終点を水中に選択すると、光は空中をより長く進んでから水中を近道する方が有利になる。最小時間の経路は光線を空気と水の境界で屈折させ、スネルの屈折の法則が導かれる。
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mfrac>
                  <mrow>
                    <mi>s</mi>
                    <mi>i</mi>
                    <mi>n</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <msub>
                        <mi>θ</mi>
                        <mn>1</mn>
                      </msub>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                  </mrow>
                  <mrow>
                    <mi>s</mi>
                    <mi>i</mi>
                    <mi>n</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <msub>
                        <mi>θ</mi>
                        <mn>2</mn>
                      </msub>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                  </mrow>
                </mfrac>
                <mo>=</mo>
                <mfrac>
                  <msub>
                    <mi>v</mi>
                    <mn>1</mn>
                  </msub>
                  <msub>
                    <mi>v</mi>
                    <mn>2</mn>
                  </msub>
                </mfrac>
              </mrow>
              <annotation encoding="application/x-tex">\frac{sin(\theta_1)}{sin(\theta_2)} = \frac{v_1}{v_2}
              </annotation>
            </semantics>
          </math></p>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>v</mi>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">v_1</annotation>
            </semantics>
          </math>は空気中の光速、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>v</mi>
                <mn>2</mn>
              </msub>
              <annotation encoding="application/x-tex">v_2</annotation>
            </semantics>
          </math>は水中の光速だ。</p>
        <p><img src="images/snell.jpg" style="width:30.0%" /></p>
        <p>古典力学はすべて最小作用の原理から導き出せる。作用は任意の経路に沿って、運動エネルギーとポテンシャルエネルギーの差であるラグランジアンを積分することで計算できる
          (註:
          和ではなく差だ――和は全エネルギーとなる)。大砲を撃って標的に命中させようとするとき、弾はまず重力によるポテンシャルエネルギーが高い場所へと上昇し、しばらくの間そこで作用への負の寄与を蓄積する。しかも放物線の頂点に向けて減速し、運動エネルギーを最小限に抑える。それから加速し、ポテンシャルエネルギーの低い領域を素早く通過する。
        </p>
        <p><img src="images/mortar.jpg" style="width:35.0%" /></p>
        <p>ファインマンの最大の功績は、最小作用の原理が量子力学に一般化できることを示したことだ。ここでも、問題は初期状態と最終状態に関して定式化されている。ファインマン経路積分を用いると、それらの状態間の遷移確率を計算できる。
        </p>
        <p><img src="images/feynman.jpg" style="width:35.0%" /></p>
        <p>
          重要なのは、物理法則を記述する方法には奇妙で説明のつかない双対性があるということだ。局所的な描像を採用し、物事が連続して小さな増分で起こると捉えてもよい。あるいは、大域的な描像を採用し、初期条件と最終条件を宣言し、途中のすべてはそれらにただ従うと捉えてもよい。
        </p>
        <p>
          大域的アプローチは、レイトレーシングを実装する場合など、プログラミングでも使える。眼の位置と光源の位置を宣言し、それらを光線が接続できる経路を見つければよい。実際には、各光線について飛行時間を明示的に最小化したりせず、スネルの法則と反射の幾何学を用いて同じ効果を得ている。
        </p>
        <p>
          局所的アプローチと大域的アプローチの大きな違いは、空間の扱いと、さらに重要なことに、時間の扱いだ。局所的なアプローチでは今・ここの即時的充足を受け入れるのに対し、大域的なアプローチは、あたかも未来があらかじめ決まっていたかのような長期的な静的な見方をとり、いわば永遠の宇宙の性質をただ分析する。
        </p>
        <p>ユーザインタラクションに対する関数型リアクティブプログラミング (FRP)
          アプローチほど、これが分かりやすく説明されているものはない。想定されるすべてのユーザアクションに対して個別のハンドラーを記述して、そのすべてが共有の可変状態にアクセスできるようにする代わりに、FRPでは外部イベントを無限リストとして扱って一連の変換を適用する。概念的には、将来のすべてのアクションのリストがそこにあり、プログラムへの入力データとして利用できる。プログラムの観点から見ると、<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>π</mi>
              <annotation encoding="application/x-tex">\pi</annotation>
            </semantics>
          </math>の数字のリスト、擬似乱数のリスト、コンピューターのハードウェアから得られるマウス位置のリストの間に違いはない。いずれの場合も、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>n</mi>
                <mtext mathvariant="normal">th</mtext>
              </msup>
              <annotation encoding="application/x-tex">n^\text{th}</annotation>
            </semantics>
          </math>項目を取得する場合は、最初の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>n</mi>
                <mo>−</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">n-1</annotation>
            </semantics>
          </math>項目を先に調べる必要がある。時間的イベントについて述べる場合、この特性を<em>因果律</em>
          (causality) と呼ぶ。</p>
        <p>それで、圏論と何の関係があるのだろうか？
          私の主張としては、圏論は大域的アプローチを奨励しており、それゆえ宣言型プログラミングを支持している。第一に、微積分とは異なり、距離・近傍・時間などの概念が組み込まれていない。あるのは抽象的な対象とそれらの間の抽象的な接続だけだ。一連のステップを通じて<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>A</mi>
              <annotation encoding="application/x-tex">A</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>B</mi>
              <annotation encoding="application/x-tex">B</annotation>
            </semantics>
          </math>に到達できるなら、一足飛びにそこに到達することもできる。さらに、圏論の主要なツールは普遍的構成であり、大域的アプローチの典型だ。実際に使われている例は、圏論的な積の定義などですでに見た。それは特性を指定することによって行われる――極めて宣言的なアプローチだ。これは2つの射影を伴う対象のうち最も良いものだ。つまり、ある特性を最適化するものだ。その特性とは、他の同様の対象の射影を分解する特性だ。
        </p>
        <p><img src="images/productranking.jpg" style="width:35.0%" /></p>
        <p>これをフェルマーの最短時間の原理、あるいは最小作用の原理と比較してほしい。</p>
        <p>
          逆に、カルテシアン積の従来の定義と対比させるとどうだろう。後者の方がはるかに命令的だ。積の要素を作るには、ある集合から1つの要素を選択し、別の集合から別の要素を選択する、という説明になる。これはペアを作るためのレシピだ。また、ペアを分解するためのレシピもある。
        </p>
        <p>Haskellなどの関数型言語を含め、ほとんどすべてのプログラム言語では、直積型・余積型・関数型は組み込まれており、普遍的構成で定義されるのではない。ただし、圏論的プログラム言語の作成も試みられている
          (たとえば<a href="http://web.sfc.keio.ac.jp/~hagino/thesis.pdf">萩野達也の博士論文</a>を参照)。</p>
        <p>
          直接使われるかどうかにかかわらず、圏論的な定義は既存のプログラミング構成を正当なものにするとともに、新しい構成を生み出す。最も重要なのは、宣言的レベルでコンピュータープログラムについて推論するためのメタ言語を圏論が提供することだ。また、コードとして表す前に問題の仕様について推論することも奨励する。
        </p>
        <aside id="footnotes" class="footnotes footnotes-end-of-section" role="doc-footnote">
          <hr />
          <ol start="5">
            <li id="fn5">
              <p>訳註:
                複雑系を専門とする数理物理学者で、数式処理ソフトMathematicaの作者としても有名。<a href="#fnref5" class="footnote-back"
                  role="doc-backlink">↩︎</a></p>
            </li>
          </ol>
        </aside>
        <h1 data-number="12" id="limits-and-colimits"><span class="header-section-number">12</span> 極限と余極限</h1>
        <p>圏論では、すべてがすべてに関係していて、すべてのものを様々な角度から見られるようだ。たとえば、<a href="#products-and-coproducts">積</a>の普遍的構成を考えてみよう。<a
            href="#functors">関手</a>と<a
            href="#natural-transformations">自然変換</a>について理解が深まったいま、それらを単純化し、できれば一般化できないだろうか。やってみよう。</p>
        <p><img src="images/productpattern.jpg" style="width:30.0%" /></p>
        <p>積の構成は、積を構築したい2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>を選択することから始まる。しかし、<em>対象を選択する</em>とは何を意味するのだろう？
          もっと圏論らしい言葉で言い換えられないだろうか？
          2つの対象は1つのパターンを形成する――ごく単純なパターンだ。このパターンは圏に抽象化できる。ごく単純な圏だが、それでも紛れもなく圏だ。これは、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>と呼ばれる圏だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>の2つの対象だけを含み、2つの必須の恒等射以外の射は含まない。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の2つの対象の選択は、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>を定義する動作と言い換えてよい。関手は対象を対象に写すため、その像はちょうど2つの対象になる
          (関手が対象を潰す場合は1つの対象になることもある)。また、関手は射も写す――ここでは単に恒等射を恒等射に写すだけだ。</p>
        <p>
          このアプローチの素晴らしいところは、圏論的な概念に基づいて構築されていることであり、「対象を選ぶ」といった不正確な、原始人の語彙からそのまま採ったような記述を避けていることだ。おまけに、一般化するのも簡単だ。パターンを定義するために<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>より複雑な圏を使ってはいけない理由はないからだ。</p>
        <p><img src="images/two.jpg" style="width:35.0%" /></p>
        <p>しかし、ここではこのまま進もう。積を定義する次のステップは、候補となる対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>の選択だ。ここでも、単元圏からの関手という観点で選択を言い換えられる。そして実際、Kan拡張を使っていたら、そうするのが正しい。しかし、まだKan拡張が用意できていないので、別のトリックを使おう。同じ圏<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>への定関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Δ</mi>
              <annotation encoding="application/x-tex">\Delta</annotation>
            </semantics>
          </math>だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>を選択するには<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>を使う。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>はすべての対象を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>に写し、すべての射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">%
                \mathbf{id}_{c}%
              </annotation>
            </semantics>
          </math>に写すことに注意してほしい。</p>
        <p><img src="images/twodelta.jpg" style="width:35.0%" /></p>
        <p>これで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>の2つの関手が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の間にできたので、これらの関手の間の自然変換について問うのは自然だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>の対象は2つだけなので、自然変換は2つのコンポーネントを持つ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>に写される。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>の間の自然変換のコンポーネントは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>への射だ。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>と呼べる。同様に、2番目のコンポーネントは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>で、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>による像だ。しかし、これらはもともとの積の定義で用いた2つの射影と全く同じだ。したがって、対象や射影の選択について議論する代わりに、ただ関手や自然変換の選択について議論すればよい。ここでの単純なケースでは、変換の自然条件が満たされるのは自明だ。なぜなら、<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>には射が
          (恒等射しか) 存在しないからだ。</p>
        <p><img src="images/productcone.jpg" style="width:35.0%" /></p>
        <p>この構成を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>以外の圏
          (たとえば、自明でない射を含む圏)
          に一般化すると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>の間の変換に自然条件が課される。このような変換を<em>錐</em>
          (cone)
          と呼ぶ。なぜなら、自然変換のコンポーネントによって側面が形成される錐・ピラミッドを考えると、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Δ</mi>
              <annotation encoding="application/x-tex">\Delta</annotation>
            </semantics>
          </math>の像がその頂点だからだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>の像は錐の底面を形成する。</p>
        <p>一般に、錐を構築するには、パターンを定義する圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>から始める。小さい、多くの場合は有限な圏だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>を選択し、それ
          (またはその像)
          を<em>図式</em>と呼ぶ。錐の頂点として、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>中の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>を選択する。それを使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>への定関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>を定義する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>までの自然変換が、求めていた錐となる。有限の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>に対しては、それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>と図式を接続するただの射の集まりで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>における<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>の像だ。</p>
        <p><img src="images/cone.jpg" style="width:35.0%" /></p>
        <p>自然性は、この図式のすべての三角形 (ピラミッドの側面)
          が可換であることを必要とする。実際に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>内の任意の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>を取ったとしよう。関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>は、それを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>D</mi>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">D f</annotation>
            </semantics>
          </math>に、すなわち、ある三角形の底辺となる射に写す。定関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>における恒等射に写す。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Δ</mi>
              <annotation encoding="application/x-tex">\Delta</annotation>
            </semantics>
          </math>は射の両端を1つの対象にまとめ、自然性の正方図式は可換な三角形になる。この三角形の2本の腕は自然変換のコンポーネントだ。</p>
        <p><img src="images/conenaturality.jpg" style="width:35.0%" /></p>
        <p>したがって、これは錐の1つだ。だが、関心があるのは<em>普遍錐</em>
          (universal cone)
          だ――積の定義のために普遍的な対象を選んだのと同じだ。</p>
        <p>それを目指す方法はいろいろある。たとえば、任意の関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>に基づいて<em>錐の圏</em>を定義できる。その圏における対象は錐だ。ただし、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>のすべての対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>が錐の頂点になるわけではない。なぜなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>の間に自然変換が存在しない可能性があるからだ。</p>
        <p>圏にするには、錐の間の射も定義しなければならない。それらは頂点間の射によって完全に決定される。しかし、どんな射でも良いわけではない。我々の積の構成では、候補となる対象
          (頂点)
          の間の射は射影の共通因子でなければならない、という条件を課したのを思い出してほしい。例を挙げよう:</p>
        <div class="sourceCode" id="cb301">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a>p&#39; <span class="ot">=</span> p <span class="op">.</span> m</span>
<span id="cb301-2"><a href="#cb301-2" aria-hidden="true" tabindex="-1"></a>q&#39; <span class="ot">=</span> q <span class="op">.</span> m</span></code></pre>
        </div>
        <p><img src="images/productranking.jpg" style="width:35.0%" /></p>
        <p>この条件は、一般には、一辺が分解射である三角形はすべて可換である、という条件に変換される。</p>
        <figure>
          <img src="images/conecommutativity.jpg" style="width:35.0%" alt="分解射hを持つ2つの錐を結ぶ可換な三角形 (ここでは、下側の錐は普遍的な三角形で、その頂点は%
\mathbf{Lim}{D}%
である)。" />
          <figcaption aria-hidden="true">分解射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>h</mi>
                <annotation encoding="application/x-tex">h</annotation>
              </semantics>
            </math>を持つ2つの錐を結ぶ可換な三角形
            (ここでは、下側の錐は普遍的な三角形で、その頂点は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mi>D</mi>
                </mrow>
                <annotation encoding="application/x-tex">%
                  \mathbf{Lim}{D}%
                </annotation>
              </semantics>
            </math>である)。</figcaption>
        </figure>
        <p>これらの分解射を錐の圏における射と見なそう。これらの射が実際に合成できることと、恒等射が分解射であることを確認するのは簡単だ。したがって、錐は圏を形成する。</p>
        <p>
          これで、普遍錐を錐の圏の<em>終対象</em>として定義できるようになった。終対象の定義では、任意の対象からその対象への一意な射があるとされている。ここでは、それは他の任意の錐の頂点から普遍錐の頂点への一意な分解射があることを意味する。この普遍錐を、図式<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐋</mi>
                  <mi>𝐢</mi>
                  <mi>𝐦</mi>
                </mrow>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">%
                \mathbf{Lim}{D}%
              </annotation>
            </semantics>
          </math>の<em>極限</em> (limit) と呼ぶ
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐋</mi>
                  <mi>𝐢</mi>
                  <mi>𝐦</mi>
                </mrow>
                <mrow></mrow>
              </mrow>
              <annotation encoding="application/x-tex">%
                \mathbf{Lim}{}%
              </annotation>
            </semantics>
          </math>記号の下に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>I</mi>
              <annotation encoding="application/x-tex">I</annotation>
            </semantics>
          </math>に向かう左矢印を記すことが多い)。この錐の頂点を単に極限
          (あるいは極限対象) と呼ぶこともよくある。</p>
        <p>直観的には、極限は図式全体の特性を単一の対象で具現化している。たとえば、2対象の図式の極限は、その2つの対象の積だ。積
          (および2つの射影)
          には、両方の対象に関する情報が含まれている。そして、普遍であるということは外来のゴミがないことを意味する。</p>
        <h2 data-number="12.1" id="自然同型としての極限"><span class="header-section-number">12.1</span> 自然同型としての極限</h2>
        <p>
          この極限の定義にはどこか不満が残る。どういうことかと言うと、使えなくはないが、任意の2つの錐を結ぶ三角形には依然としてこの可換性条件が課されている。それを何らかの自然条件に置き換えられれば、はるかにエレガントになるだろう。だが、どうやって？
        </p>
        <p>ここで扱っているのは、もはや1つの錐ではなく、錐の集まり (実際には圏)
          全体だ。極限が存在するなら
          (そして――明言しておくと――存在する保証はない)、それらの錐の1つは普遍錐だ。その他のすべての錐について、その頂点を普遍錐の頂点<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐋</mi>
                  <mi>𝐢</mi>
                  <mi>𝐦</mi>
                </mrow>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">%
                \mathbf{Lim}{D}%
              </annotation>
            </semantics>
          </math>に写す一意な分解射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>が存在する。(実際には「その他の」という言葉を省いても構わない。なぜなら、恒等射は普遍錐をそれ自身に写し、それ自身を分解するのは自明だからだ。)
          要点を繰り返そう:
          任意の錐について、特別な種類の一意な射が存在する。錐から特別な射への写像があり、それは1対1の写像だ。</p>
        <p>この特別な射は、hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c, %
                \mathbf{Lim}{D}%
                )</annotation>
            </semantics>
          </math>
          のメンバーだ。このhom集合の他のメンバーは、2つの錐の写像を分解しないという意味で、あまり幸運ではない。ここで必要なのは、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>ごとに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c, %
                \mathbf{Lim}{D}%
                )</annotation>
            </semantics>
          </math>
          から1つの射――特定の可換性条件を満たす射――を選択できるようにすることだ。まるで自然変換を定義しているかのように聞こえるだろうか？
          そのとおりだ！</p>
        <p>だが、この変換に関係する関手は何だろう？</p>
        <p>関手の1つは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>から集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c, %
                \mathbf{Lim}{D}%
                )</annotation>
            </semantics>
          </math>
          への写像だ。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への関手で、対象を集合に写す。実際は反変関手だ。射に関する作用を定義する方法は次のとおりだ。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>を例に取ろう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>c</mi>
                <mi>′</mi>
                <mo>→</mo>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon c&#39; \to c</annotation>
            </semantics>
          </math></p>
        <p>我々の関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>を集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c&#39;, %
                \mathbf{Lim}{D}%
                )</annotation>
            </semantics>
          </math>
          に写す。この関手の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>に対する作用を定義する
          (言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>をリフトする)
          には、対応する写像を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c, %
                \mathbf{Lim}{D}%
                )</annotation>
            </semantics>
          </math>
          と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c&#39;, %
                \mathbf{Lim}{D}%
                )</annotation>
            </semantics>
          </math>
          の間で定義する必要がある。そこで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c, %
                \mathbf{Lim}{D}%
                )</annotation>
            </semantics>
          </math>
          の要素<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>u</mi>
              <annotation encoding="application/x-tex">u</annotation>
            </semantics>
          </math>を1つ選択し、それを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c&#39;, %
                \mathbf{Lim}{D}%
                )</annotation>
            </semantics>
          </math>
          の要素に写せるか確認しよう。hom集合の要素は射なので、次のようになる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>u</mi>
                <mo>∷</mo>
                <mi>c</mi>
                <mo>→</mo>
                <mrow>
                  <mi>𝐋</mi>
                  <mi>𝐢</mi>
                  <mi>𝐦</mi>
                </mrow>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">u \Colon c \to %
                \mathbf{Lim}{D}%
              </annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>u</mi>
              <annotation encoding="application/x-tex">u</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>に前置合成すると、次のようになる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>u</mi>
                <mo>∘</mo>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>c</mi>
                <mi>′</mi>
                <mo>→</mo>
                <mrow>
                  <mi>𝐋</mi>
                  <mi>𝐢</mi>
                  <mi>𝐦</mi>
                </mrow>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">u \circ f \Colon c&#39; \to %
                \mathbf{Lim}{D}%
              </annotation>
            </semantics>
          </math></p>
        <p>そして、これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c&#39;, %
                \mathbf{Lim}{D}%
                )</annotation>
            </semantics>
          </math>
          の要素だ――つまり、実際に射の写像が見つかった:</p>
        <div class="sourceCode" id="cb302">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true" tabindex="-1"></a><span class="ot">contramap ::</span> (c&#39; <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> <span class="dt">Lim</span> <span class="dt">D</span>) <span class="ot">-&gt;</span> (c&#39; <span class="ot">-&gt;</span> <span class="dt">Lim</span> <span class="dt">D</span>)</span>
<span id="cb302-2"><a href="#cb302-2" aria-hidden="true" tabindex="-1"></a>contramap f u <span class="ot">=</span> u <span class="op">.</span> f</span></code></pre>
        </div>
        <p><em>反変</em>関手の特徴である、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>の順序の反転に注目してほしい。</p>
        <p><img src="images/homsetmapping.jpg" style="width:35.0%" /></p>
        <p>自然変換を定義するには、同じく<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への写像である別の関手が必要だ。しかし、今回は錐の集合を考えてみよう。錐は単なる自然変換なので、自然変換の集合<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑁</mi>
                  <mi>𝑎</mi>
                  <mi>𝑡</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>Δ</mi>
                    <mi>c</mi>
                  </msub>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Nat}(\Delta_c, D)</annotation>
            </semantics>
          </math>
          を見ていることになる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>からこの特定の自然変換の集合への写像は
          (反変) 関手だ。どうやってそれを示そう？
          ここでも、射の作用を定義してみよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>c</mi>
                <mi>′</mi>
                <mo>→</mo>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon c&#39; \to c</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>のリフトは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>へ向かう関手2つの間の自然変換の写像でなければならない。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑁</mi>
                  <mi>𝑎</mi>
                  <mi>𝑡</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>Δ</mi>
                    <mi>c</mi>
                  </msub>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mrow>
                  <mi>𝑁</mi>
                  <mi>𝑎</mi>
                  <mi>𝑡</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>Δ</mi>
                    <mrow>
                      <mi>c</mi>
                      <mi>′</mi>
                    </mrow>
                  </msub>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Nat}(\Delta_c, D) \to \mathit{Nat}(\Delta_{c&#39;}, D)
              </annotation>
            </semantics>
          </math></p>
        <p>自然変換をどのように写せば良いだろう？
          自然変換は射――そのコンポーネント――の選択であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>の要素ごとに射を1つ選択する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>内の対象)
          における、ある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑁</mi>
                  <mi>𝑎</mi>
                  <mi>𝑡</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>Δ</mi>
                    <mi>c</mi>
                  </msub>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Nat}(\Delta_c, D)</annotation>
            </semantics>
          </math>
          のメンバー) のコンポーネントは、次の射だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <msub>
                  <mi>Δ</mi>
                  <mi>c</mi>
                </msub>
                <mi>a</mi>
                <mo>→</mo>
                <mi>D</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_a \Colon \Delta_c a \to D a</annotation>
            </semantics>
          </math></p>
        <p>または、定関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Δ</mi>
              <annotation encoding="application/x-tex">\Delta</annotation>
            </semantics>
          </math>の定義を使うと、</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mi>c</mi>
                <mo>→</mo>
                <mi>D</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_a \Colon c \to D a</annotation>
            </semantics>
          </math></p>
        <p>となる。与えられた<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑁</mi>
                  <mi>𝑎</mi>
                  <mi>𝑡</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>Δ</mi>
                    <mrow>
                      <mi>c</mi>
                      <mi>′</mi>
                    </mrow>
                  </msub>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Nat}(\Delta_{c&#39;}, D)</annotation>
            </semantics>
          </math>
          のメンバーである<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>β</mi>
              <annotation encoding="application/x-tex">\beta</annotation>
            </semantics>
          </math>を構築する必要がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>におけるそのコンポーネントは次の射となる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>β</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mi>c</mi>
                <mi>′</mi>
                <mo>→</mo>
                <mi>D</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\beta_a \Colon c&#39; \to D a</annotation>
            </semantics>
          </math></p>
        <p>前者
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_a</annotation>
            </semantics>
          </math>)
          から後者
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>β</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\beta_a</annotation>
            </semantics>
          </math>)
          は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>に前置合成すれば簡単に得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>β</mi>
                  <mi>a</mi>
                </msub>
                <mo>=</mo>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
                <mo>∘</mo>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">\beta_a = \alpha_a \circ f</annotation>
            </semantics>
          </math></p>
        <p>これらのコンポーネントが実際に自然変換になることを示すのは比較的簡単だ。</p>
        <p><img src="images/natmapping.jpg" style="width:40.0%" /></p>
        <p>以上より、与えられた射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>について、2つの自然変換の間の写像をコンポーネントごとに構築できた。この写像は関手の<code>contramap</code>を定義する:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mo>→</mo>
                <mrow>
                  <mi>𝑁</mi>
                  <mi>𝑎</mi>
                  <mi>𝑡</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>Δ</mi>
                    <mi>c</mi>
                  </msub>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">c \to \mathit{Nat}(\Delta_c, D)</annotation>
            </semantics>
          </math></p>
        <p>先ほど示したのは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への2つの
          (反変)
          関手があるということだ。何の仮定もしなかった――これらの関手は常に存在する。</p>
        <p>ちなみに、これらの関手のうち第1のものは圏論で重要な役割を果たしている。米田の補題について話すときに再び見ることになるだろう。任意の圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への反変関手は「前層」(presheaf)
          と呼ばれる。ここでのものは<span id="representable_presheaf" class="keyword">表現可能前層</span> (representable presheaf)
          と呼ばれている。第2の関手も前層だ。</p>
        <p>2つの関手が出てきたので、その間の自然変換について述べられるようになった。そこで、これ以上何も言わず、結論を述べよう:
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>は極限<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐋</mi>
                  <mi>𝐢</mi>
                  <mi>𝐦</mi>
                </mrow>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">%
                \mathbf{Lim}{D}%
              </annotation>
            </semantics>
          </math>を持つ。ただし、先ほど定義した2つの関手間に自然同型がある場合に限る。
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≃</mo>
                <mrow>
                  <mi>𝑁</mi>
                  <mi>𝑎</mi>
                  <mi>𝑡</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>Δ</mi>
                    <mi>c</mi>
                  </msub>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c, %
                \mathbf{Lim}{D}%
                ) \simeq \mathit{Nat}(\Delta_c, D)</annotation>
            </semantics>
          </math></p>
        <p>自然同型とは何かを思い出してほしい。すべてのコンポーネントが同型、すなわち可逆な射である自然変換だ。</p>
        <p>この命題の証明をなぞるつもりはない。退屈とまでは言わないにしても、非常に単純な手順だからだ。自然変換を扱うときには、通常は、射であるコンポーネントに注目する。この場合、両方の関手の終域が<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>なので、自然同型のコンポーネントは関数になる。それらは高階関数だ。なぜなら、それらは、hom集合から自然変換の集合へと向かうからだ。再び、関数が引数に対して何を行うかを調べることで関数を分析できる。ここで、引数は射――<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c, %
                \mathbf{Lim}{D}%
                )</annotation>
            </semantics>
          </math>
          のメンバーで、結果は自然変換――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑁</mi>
                  <mi>𝑎</mi>
                  <mi>𝑡</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>Δ</mi>
                    <mi>c</mi>
                  </msub>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Nat}(\Delta_c, D)</annotation>
            </semantics>
          </math>
          のメンバー、または錐と呼ばれるものになる。この自然変換には独自のコンポーネントがあり、それは射だ。したがって、どこまでも射なので、それらを追跡できれば、先ほどの命題を証明できる。</p>
        <p>最も重要な結果は、この同型に対する自然条件がまさしく錐の写像についての可換性条件だということだ。</p>
        <p>今後のアトラクションの予告として、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑁</mi>
                  <mi>𝑎</mi>
                  <mi>𝑡</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>Δ</mi>
                    <mi>c</mi>
                  </msub>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Nat}(\Delta_c, D)</annotation>
            </semantics>
          </math>
          を関手圏におけるhom集合と見なせることに触れておきたい。つまり、ここでの自然同型は2つのhom集合を関連づけ、随伴と呼ばれるさらに一般的な関係を指し示している。</p>
        <h2 data-number="12.2" id="極限の例"><span class="header-section-number">12.2</span> 極限の例</h2>
        <p>すでに見たように、圏論的な積は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>と呼ばれる単純な圏が生成する図式の極限だ。</p>
        <p>極限のさらに単純な例として、終対象がある。初期衝動としては単元圏が終対象につながると考えがちだが、真実はさらに赤裸々だ。終対象は空圏
          (empty category)
          が生成する極限だ。空圏からの関手は対象を選択しないので、錐は頂点だけに収縮する。普遍錐はその唯一の頂点で、他の頂点からの一意な射を持つ。これが終対象の定義だときっと気付くだろう。</p>
        <p>次に興味深い極限は<em>イコライザ</em> (equalizer)
          と呼ばれる。これは2つの要素からなる圏によって生成された極限であり、要素間の2つの平行な射を伴う
          (そして、いつものように、それらは恒等射だ)。この圏は、2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>と、2つの射とで構成される<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の図式を選択する:</p>
        <div class="sourceCode" id="cb303">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb303-2"><a href="#cb303-2" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> a <span class="ot">-&gt;</span> b</span></code></pre>
        </div>
        <p>この図式の上に錐を構築するには、頂点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>と2つの射影を追加する必要がある:</p>
        <div class="sourceCode" id="cb304">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> c <span class="ot">-&gt;</span> a</span>
<span id="cb304-2"><a href="#cb304-2" aria-hidden="true" tabindex="-1"></a><span class="ot">q ::</span> c <span class="ot">-&gt;</span> b</span></code></pre>
        </div>
        <p><img src="images/equalizercone.jpg" style="width:35.0%" /></p>
        <p>可換でなければならない三角形が2つある:</p>
        <div class="sourceCode" id="cb305">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true" tabindex="-1"></a>q <span class="ot">=</span> f <span class="op">.</span> p</span>
<span id="cb305-2"><a href="#cb305-2" aria-hidden="true" tabindex="-1"></a>q <span class="ot">=</span> g <span class="op">.</span> p</span></code></pre>
        </div>
        <p>これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>がこれらの方程式の1つによって一意に決定されることを示している。たとえば<code>q = f . p</code>で、図から省略できる。残りの条件は1つだけだ:</p>
        <div class="sourceCode" id="cb306">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">.</span> p <span class="ot">=</span> g <span class="op">.</span> p</span></code></pre>
        </div>
        <p>つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>だけに注目すると、関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>の像は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の部分集合を選択している。この部分集合に限定したとき、関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>は等しくなる。</p>
        <p>たとえば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を座標<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>y</mi>
              <annotation encoding="application/x-tex">y</annotation>
            </semantics>
          </math>でパラメーター化された2次元平面とする。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>を実数の直線とし、次のようにする:</p>
        <div class="sourceCode" id="cb307">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a>f (x, y) <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> y <span class="op">+</span> x</span>
<span id="cb307-2"><a href="#cb307-2" aria-hidden="true" tabindex="-1"></a>g (x, y) <span class="ot">=</span> y <span class="op">-</span> x</span></code></pre>
        </div>
        <p>これら2つの関数のイコライザは、実数の集合
          (頂点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>)
          と次の関数だ:</p>
        <div class="sourceCode" id="cb308">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true" tabindex="-1"></a>p t <span class="ot">=</span> (t, (<span class="op">-</span><span class="dv">2</span>) <span class="op">*</span> t)</span></code></pre>
        </div>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>t</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(p~t)</annotation>
            </semantics>
          </math>
          は2次元平面内の直線を定義することに注意してほしい。この線上では2つの関数は等しい。</p>
        <p>当然、この等価性は他の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>と関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">p&#39;</annotation>
            </semantics>
          </math>でも満たしうる:</p>
        <div class="sourceCode" id="cb309">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb309-1"><a href="#cb309-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">.</span> p&#39; <span class="ot">=</span> g <span class="op">.</span> p&#39;</span></code></pre>
        </div>
        <p>ただし、それらはすべて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>を通じて一意に分解する。たとえば、単集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix" mathvariant="bold">(</mo>
                <mo stretchy="true" form="postfix" mathvariant="bold">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{()}</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>として受け取れば次の関数を使える:</p>
        <div class="sourceCode" id="cb310">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a>p&#39;() <span class="ot">=</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span></code></pre>
        </div>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>0</mn>
                  <mo>,</mo>
                  <mn>0</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>=</mo>
                <mi>g</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>0</mn>
                  <mo>,</mo>
                  <mn>0</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">f(0, 0) = g(0, 0)</annotation>
            </semantics>
          </math>
          だから、これは良い錐だ。しかし、普遍錐ではなく、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>によって一意に分解できる:</p>
        <div class="sourceCode" id="cb311">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true" tabindex="-1"></a>p&#39; <span class="ot">=</span> p <span class="op">.</span> h</span></code></pre>
        </div>
        <p>ただし</p>
        <div class="sourceCode" id="cb312">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true" tabindex="-1"></a>h () <span class="ot">=</span> <span class="dv">0</span></span></code></pre>
        </div>
        <p><img src="images/equilizerlimit.jpg" style="width:35.0%" /></p>
        <p>したがって、イコライザは型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mspace width="0.222em"></mspace>
                <mi>x</mi>
                <mo>=</mo>
                <mi>g</mi>
                <mspace width="0.222em"></mspace>
                <mi>x</mi>
              </mrow>
              <annotation encoding="application/x-tex">f~x = g~x</annotation>
            </semantics>
          </math>の方程式を解くのに使える。しかも、もっと汎用的だ。代数的な定義ではなく、対象や射の観点で定義されているからだ。</p>
        <p>方程式を解くという考え方をさらに一般化したものが、別の極限で具体化されている――引き戻し
          (pullback)
          だ。ここに、等価にしたい2つの射がまたあるが、今回はそれらの始域が異なる。まず<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>1</mn>
                <mo>→</mo>
                <mn>2</mn>
                <mo>←</mo>
                <mn>3</mn>
              </mrow>
              <annotation encoding="application/x-tex">1\rightarrow2\leftarrow3</annotation>
            </semantics>
          </math>という形の3対象の圏を作成する。この圏に対応する図式は、3つの対象
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>,
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>,
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>)
          と2つの射で構成されている:
        </p>
        <div class="sourceCode" id="cb313">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb313-2"><a href="#cb313-2" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> c <span class="ot">-&gt;</span> b</span></code></pre>
        </div>
        <p>この図式は<em>余スパン</em> (cospan) と呼ばれることが多い。</p>
        <p>この図式の上に構築された錐は、頂点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>d</mi>
              <annotation encoding="application/x-tex">d</annotation>
            </semantics>
          </math>と3つの射から構成されている:</p>
        <div class="sourceCode" id="cb314">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> d <span class="ot">-&gt;</span> a</span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true" tabindex="-1"></a><span class="ot">q ::</span> d <span class="ot">-&gt;</span> c</span>
<span id="cb314-3"><a href="#cb314-3" aria-hidden="true" tabindex="-1"></a><span class="ot">r ::</span> d <span class="ot">-&gt;</span> b</span></code></pre>
        </div>
        <p><img src="images/pullbackcone.jpg" style="width:35.0%" /></p>
        <p>可換性条件から、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>r</mi>
              <annotation encoding="application/x-tex">r</annotation>
            </semantics>
          </math>は他の射によって完全に決定されることがわかり、図から省略できる。したがって、次の条件のみが残る:</p>
        <div class="sourceCode" id="cb315">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">.</span> q <span class="ot">=</span> f <span class="op">.</span> p</span></code></pre>
        </div>
        <p>引き戻しは、この形の普遍錐だ。</p>
        <p><img src="images/pullbacklimit.jpg" style="width:35.0%" /></p>
        <p>もう一度、注目する範囲を集合だけに絞ると、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>d</mi>
              <annotation encoding="application/x-tex">d</annotation>
            </semantics>
          </math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>からの要素のペアで構成されていると見なせる。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>が最初のコンポーネントに作用したものは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>が2番目のコンポーネントに作用したものと等しい。これがまだ一般的すぎるなら、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>が定数関数である特別な場合を考えてみてほしい。たとえば、
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>が実数の集合だと仮定して)
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mspace width="0.222em"></mspace>
                <mi>_</mi>
                <mo>=</mo>
                <mn>1.23</mn>
              </mrow>
              <annotation encoding="application/x-tex">g~\_ = 1.23</annotation>
            </semantics>
          </math>とする。そうすれば、実際に方程式を解いていることになる:
        </p>
        <div class="sourceCode" id="cb316">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> <span class="fl">1.23</span></span></code></pre>
        </div>
        <p>この場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>として何を選択しても
          (空集合でない限り)
          関係ないので、単集合として構わない。たとえば、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>は3次元ベクトルの集合であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>はベクトル長だ。そうすれば、引き戻しはペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>v</mi>
                <mo>,</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(v, ())</annotation>
            </semantics>
          </math>
          の集合だ。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>v</mi>
              <annotation encoding="application/x-tex">v</annotation>
            </semantics>
          </math>は長さ1.23のベクトル
          (方程式<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msqrt>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <msup>
                      <mi>x</mi>
                      <mn>2</mn>
                    </msup>
                    <mo>+</mo>
                    <msup>
                      <mi>y</mi>
                      <mn>2</mn>
                    </msup>
                    <mo>+</mo>
                    <msup>
                      <mi>z</mi>
                      <mn>2</mn>
                    </msup>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                </msqrt>
                <mo>=</mo>
                <mn>1.23</mn>
              </mrow>
              <annotation encoding="application/x-tex">\sqrt{(x^{2}+y^{2}+z^{2})} = 1.23</annotation>
            </semantics>
          </math>の解)
          であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">()</annotation>
            </semantics>
          </math>
          は単集合のダミー要素だ。
        </p>
        <p>
          もっとも、引き戻しにはより一般的な用途があり、プログラミングで用いることもできる。たとえば、C++のクラスを圏と見なし、サブクラスとスーパークラスを結ぶ矢を射と見なそう。継承を推移的な特性と見なそう。つまり、<code>C</code>が<code>B</code>を継承し、<code>B</code>が<code>A</code>を継承しているなら、<code>C</code>は<code>A</code>を継承していると言える
          (要するに、<code>A</code>へのポインタを想定する箇所に<code>C</code>へのポインタを渡せる)。また、<code>C</code>は<code>C</code>から継承すると見なそう。つまり、すべてのクラスに恒等射がある。このようにすればサブクラス化はサブタイプ化と整合が取れる。C++は多重継承もサポートしているので、<code>A</code>を継承する2つのクラス<code>B</code>と<code>C</code>、および<code>B</code>と<code>C</code>とを多重継承する4番目のクラス<code>D</code>を含むダイヤモンド継承の図式を構築できる。通常、<code>D</code>は2つの<code>A</code>を取得する。ほとんどの場合、これは望ましくない。しかし、仮想継承を使えば<code>D</code>内の<code>A</code>を1つだけにできる。
        </p>
        <p><code>D</code>がこの図式の引き戻しになるとはどういうことだろう？
          それは、<code>B</code>と<code>C</code>を多重継承するすべてのクラス<code>E</code>が、<code>D</code>のサブクラスでもあることを意味する。これはC++では直接表現できない。C++は公称型
          (nominal subtyping) を採用しているからだ
          (C++コンパイラはこの種のクラス関係を推測しない――それには「ダック・タイピング」が必要となる)。しかし、サブタイプ関係の外に出て、代わりに<code>E</code>から<code>D</code>へのキャストが安全かどうか問うことはできる。このキャストが安全なのは、<code>D</code>が<code>B</code>と<code>C</code>の必要最小限の組み合わせで、追加データやメソッドのオーバーライドがない場合だ。そしてもちろん、<code>B</code>と<code>C</code>のメソッドに名前の衝突がある場合、引き戻しはない。
        </p>
        <p><img src="images/classes.jpg" style="width:25.0%" /></p>
        <p>さらに、型推論では引き戻しがより高度な使い方をされる。多くの場合、2つの表現の型を<em>単一化</em>
          (unify)
          する必要がある。たとえば、コンパイラが関数の型を推測しようとしているとする:</p>
        <div class="sourceCode" id="cb317">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true" tabindex="-1"></a>twice f x <span class="ot">=</span> f (f x)</span></code></pre>
        </div>
        <p>すべての変数と部分式に予備的な型を割り当てる。具体的には、以下を割り当てる:</p>
        <div class="sourceCode" id="cb318">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb318-1"><a href="#cb318-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f       ::</span> t0</span>
<span id="cb318-2"><a href="#cb318-2" aria-hidden="true" tabindex="-1"></a><span class="ot">x       ::</span> t1</span>
<span id="cb318-3"><a href="#cb318-3" aria-hidden="true" tabindex="-1"></a>f<span class="ot"> x     ::</span> t2</span>
<span id="cb318-4"><a href="#cb318-4" aria-hidden="true" tabindex="-1"></a>f (f x)<span class="ot"> ::</span> t3</span></code></pre>
        </div>
        <p>そこから次のことが推測される:</p>
        <div class="sourceCode" id="cb319">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true" tabindex="-1"></a><span class="ot">twice ::</span> t0 <span class="ot">-&gt;</span> t1 <span class="ot">-&gt;</span> t3</span></code></pre>
        </div>
        <p>また、関数の適用規則から生じる一連の制約も課される:</p>
        <div class="sourceCode" id="cb320">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb320-1"><a href="#cb320-1" aria-hidden="true" tabindex="-1"></a>t0 <span class="ot">=</span> t1 <span class="ot">-&gt;</span> t2 <span class="co">-- fがxに適用されるため。</span></span>
<span id="cb320-2"><a href="#cb320-2" aria-hidden="true" tabindex="-1"></a>t0 <span class="ot">=</span> t2 <span class="ot">-&gt;</span> t3 <span class="co">-- fが (f x) に適用されるため。</span></span></code></pre>
        </div>
        <p>これらの制約を単一化するためには、ある型 (または型変数)
          の集合を見つけて、その型で両方の式の未知の型に代入し、同じ型を生成させる必要がある。そのような置換の1つは次のとおりだ:</p>
        <div class="sourceCode" id="cb321">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb321-1"><a href="#cb321-1" aria-hidden="true" tabindex="-1"></a>t1 <span class="ot">=</span> t2 <span class="ot">=</span> t3 <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb321-2"><a href="#cb321-2" aria-hidden="true" tabindex="-1"></a><span class="ot">twice ::</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre>
        </div>
        <p>しかし、明らかに、これは最も一般的なものではない。最も一般的な置換を得るには引き戻しを用いる。詳細は本書の範囲外であるため説明しないが、次のような結果になることを確信できる:</p>
        <div class="sourceCode" id="cb322">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb322-1"><a href="#cb322-1" aria-hidden="true" tabindex="-1"></a><span class="ot">twice ::</span> (t <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> t</span></code></pre>
        </div>
        <p>ここで<code>t</code>は自由型変数 (free type variable) だ。</p>
        <h2 data-number="12.3" id="余極限"><span class="header-section-number">12.3</span> 余極限</h2>
        <p>圏論のすべての構造と同様に、極限には双対となる像が反対圏にある。錐内のすべての射の方向を反転させると、余錐
          (co-cone) が1つでき、それらのうち普遍なものが余極限 (colimit)
          と呼ばれる。反転が分解射にも影響することに注意してほしい。分解射は普遍な余錐から他の余錐へと向かうことになる。</p>
        <figure>
          <img src="images/colimit.jpg" style="width:35.0%" alt="2つの頂点を結ぶ分解射hを持つ余錐。" />
          <figcaption aria-hidden="true">2つの頂点を結ぶ分解射<code>h</code>を持つ余錐。</figcaption>
        </figure>
        <p>余極限の典型的な例は余積だ。これは、積の定義で使った<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>圏によって生成される図式に対応する。</p>
        <p><img src="images/coproductranking.jpg" style="width:35.0%" /></p>
        <p>積も余積も、別々の方法で対象のペアの本質を具現化している。</p>
        <p>終対象が極限だったように、始対象は空圏に基づく図式に対応する余極限だ。</p>
        <p>引き戻しの双対は<em>押し出し</em> (pushout)
          と呼ばれる。それは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>1</mn>
                <mo>←</mo>
                <mn>2</mn>
                <mo>→</mo>
                <mn>3</mn>
              </mrow>
              <annotation encoding="application/x-tex">1\leftarrow2\rightarrow3</annotation>
            </semantics>
          </math>によって生成されるスパン
          (span) と呼ばれる図式に基づく。</p>
        <h2 data-number="12.4" id="連続性"><span class="header-section-number">12.4</span> 連続性</h2>
        <p>すでに述べたように、関手は、既存の接続 (射)
          を決して壊さないという意味で、圏の連続的な写像の概念に近い。圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi mathvariant="bold">′</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C&#39;}</annotation>
            </semantics>
          </math>への<em>連続関手</em>
          (continuous functor)
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>の実際の定義には、関手が極限を保存するという要件が含まれている。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内のすべての図式<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>は、単に2つの関手を合成すれば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi mathvariant="bold">′</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C&#39;}</annotation>
            </semantics>
          </math>内の図式<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∘</mo>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\circ D</annotation>
            </semantics>
          </math>に写せる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>の連続性条件は、図式<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>が極限<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐋</mi>
                  <mi>𝐢</mi>
                  <mi>𝐦</mi>
                </mrow>
                <mrow></mrow>
                <mo>*</mo>
                <mi>D</mi>
                <mo>*</mo>
              </mrow>
              <annotation encoding="application/x-tex">%
                \mathbf{Lim}{}%
                *D*</annotation>
            </semantics>
          </math>を有するなら、図式<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∘</mo>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">F \circ D</annotation>
            </semantics>
          </math>も極限を有し、それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">F (%
                \mathbf{Lim}{D}%
                )</annotation>
            </semantics>
          </math> に等しいことを示している。
        </p>
        <p><img src="images/continuity.jpg" style="width:60.0%" /></p>
        <p>関手は射を射に、合成を合成に写すので、錐の像は常に錐であることに注意してほしい。可換な三角形は常に可換な三角形に写される
          (関手は合成を保存する)。分解射についても同じことが言える:
          分解射の像も分解射だ。したがって、すべての関手は<em>ほぼ</em>連続している。問題になる可能性があるのは、一意性条件だ。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi mathvariant="bold">′</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C&#39;}</annotation>
            </semantics>
          </math>の分解射は一意でないことがある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi mathvariant="bold">′</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C&#39;}</annotation>
            </semantics>
          </math>には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>にはなかった「より優れた錐」が他にあるかもしれない。</p>
        <p>Hom関手は連続関手の一例だ。Hom関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          が、最初の変数について反変であり、2番目の変数について共変であることを思い出してほしい。言い換えれば、次の関手だ:</p>
        <pre>
C<sup>op</sup> × C -> Set
</pre>
        <p>第2引数が固定されると、hom集合関手 (表現可能前層になる)
          は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の余極限を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>の極限に写す。第1引数が固定されると、極限を極限に写す。</p>
        <p>
          Haskellでのhom関手は、任意の2つの型から関数型への写像であるため、単なるパラメーター化された関数型だ。2番目のパラメーターを、たとえば<code>String</code>に固定すると、次の反変関手が得られる:
        </p>
        <div class="sourceCode" id="cb323">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb323-1"><a href="#cb323-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ToString</span> a <span class="ot">=</span> <span class="dt">ToString</span> (a <span class="ot">-&gt;</span> <span class="dt">String</span>)</span>
<span id="cb323-2"><a href="#cb323-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> <span class="dt">ToString</span> <span class="kw">where</span></span>
<span id="cb323-3"><a href="#cb323-3" aria-hidden="true" tabindex="-1"></a>    contramap f (<span class="dt">ToString</span> g) <span class="ot">=</span> <span class="dt">ToString</span> (g <span class="op">.</span> f)</span></code></pre>
        </div>
        <p>連続性は、<code>ToString</code>が余極限、たとえば余積<code>Either b c</code>に適用された場合に極限を生成することを意味する。この場合、2つの関数型の積は次のようになる:
        </p>
        <div class="sourceCode" id="cb324">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb324-1"><a href="#cb324-1" aria-hidden="true" tabindex="-1"></a><span class="dt">ToString</span> (<span class="dt">Either</span> b c) <span class="op">~</span> (b <span class="ot">-&gt;</span> <span class="dt">String</span>, c <span class="ot">-&gt;</span> <span class="dt">String</span>)</span></code></pre>
        </div>
        <p>実際、<code>Either b c</code>の関数はどれも、関数のペアによって提供される型2つを含む型宣言として実装される。</p>
        <p>同様に、hom集合の第1引数を固定すると、おなじみのreader関手が得られる。その連続性は、たとえば、積を返す関数すべてが関数の積と等価であることを意味する。具体的には:</p>
        <div class="sourceCode" id="cb325">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb325-1"><a href="#cb325-1" aria-hidden="true" tabindex="-1"></a>r <span class="ot">-&gt;</span> (a, b) <span class="op">~</span> (r <span class="ot">-&gt;</span> a, r <span class="ot">-&gt;</span> b)</span></code></pre>
        </div>
        <p>読者がどう思っているかは分かっている:
          これらを理解するのに圏論は必要ない。そのとおりだ！
          それでも、このような結果が、ビットやバイト、プロセッサーアーキテクチャ、コンパイラー技術、さらにはラムダ計算に頼ることなく、第一原理から得られるのは驚くべきことだと思う。</p>
        <p>「極限」と「連続性」という名前の由来が何なのか気になるなら、それらは微積分学において対応する概念を一般化したものだ。微積分学では、極限と連続性は開近傍に関連して定義される。開集合は、トポロジーを定義し、圏
          (ポセット) を形成する。</p>
        <h2 data-number="12.5" id="課題-9"><span class="header-section-number">12.5</span> 課題</h2>
        <ol type="1">
          <li>
            <p>C++クラスの圏における押し出しを説明するにはどうするか？</p>
          </li>
          <li>
            <p>恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mrow>
                    <mrow>
                      <mi>𝐈</mi>
                      <mi>𝐝</mi>
                    </mrow>
                    <mo>∷</mo>
                    <mi>𝐂</mi>
                    <mo>→</mo>
                    <mi>𝐂</mi>
                  </mrow>
                  <annotation encoding="application/x-tex">\mathbf{Id} \Colon \mathbf{C} \to \mathbf{C}</annotation>
                </semantics>
              </math>の極限が始対象であることを示せ。</p>
          </li>
          <li>
            <p>任意の集合の部分集合は圏を形成する。その圏の射は、1番目の集合が2番目の集合の部分集合である場合、それら2つの集合を接続する矢として定義される。そのような圏内の集合2つの引き戻しは何か？
              押し出しは何か？ 始対象と終対象は何か？</p>
          </li>
          <li>
            <p>コイコライザ (coequalizer) とは何か予想できるか？</p>
          </li>
          <li>
            <p>終対象が存在する圏では、終対象に向かう引き戻しが積であることを示せ。</p>
          </li>
          <li>
            <p>同様に、始対象が存在するなら、始対象からの押し出しが余積であることを示せ。</p>
          </li>
        </ol>
        <h1 data-number="13" id="free-monoids"><span class="header-section-number">13</span> 自由モノイド</h1>
        <p>
          モノイドは圏論においてもプログラミングにおいても重要な概念だ。圏は強い型付けの言語に相当し、モノイドは型なし言語に相当する。モノイドでは任意の2つの矢を合成できるからだ。それは型なし言語で任意の2つの関数を合成できることに当たる
          (当然、プログラムの実行時にランタイムエラーが発生する可能性はある)。</p>
        <p>
          これまでに見てきたように、モノイドは単一の対象を持つ圏として記述され、その圏ではすべての論理が射の合成の規則として表現されている。この圏論的モデルは、より伝統的で集合論的なモノイドの定義と完全に等価だ。そこでは集合の2つの要素を「乗算」することで第3の要素が得られる。この「乗算」の過程はさらに詳細に分析できる。すなわち、まず要素のペア1つを形成し、次にこのペアを既存の要素――それらの「積」と同一視する。
        </p>
        <p>乗算の2番目の部分、つまりペアと既存の要素との同一視を省くとどうなるだろうか？
          たとえば、任意の集合から始めて、すべての可能な要素のペアを形成し、それらを新しい要素と呼ぶ、といったことが可能だ。次に、これらの新しい要素をすべての可能な要素とペアにする。以下同様だ。これは連鎖反応だ――新しい要素を永久に追加し続けられる。その結果は、無限集合であり、<em>ほぼ</em>モノイドとなる。ただし、モノイドには単位元と結合則も必要だ。しかし、問題ない。特別な単位元を追加し、いくつかのペアを特定できる――単位元則と結合則をちょうど満たせる。
        </p>
        <p>簡単な例で、これがどのように機能するか見てみよう。2要素の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">{</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="false" form="postfix">}</mo>
              </mrow>
              <annotation encoding="application/x-tex">\{a, b\}</annotation>
            </semantics>
          </math>から始めよう。それらを自由モノイドの生成元
          (generator)
          と呼ぶことにする。まず、単位元として機能する特別な要素<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>e</mi>
              <annotation encoding="application/x-tex">e</annotation>
            </semantics>
          </math>を追加する。次に、要素のすべてのペアを追加し、それらを「積」と呼ぶ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の積はペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, b)</annotation>
            </semantics>
          </math>
          となる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の積はペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>b</mi>
                <mo>,</mo>
                <mi>a</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(b, a)</annotation>
            </semantics>
          </math>
          となり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の積は
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>a</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, a)</annotation>
            </semantics>
          </math>
          となり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の積は
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>b</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(b, b)</annotation>
            </semantics>
          </math>
          となる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>e</mi>
              <annotation encoding="application/x-tex">e</annotation>
            </semantics>
          </math>とのペアとして形成できる
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>e</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, e)</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>e</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(e, b)</annotation>
            </semantics>
          </math>
          などは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>などと同一視する。したがって、このラウンドでは
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>a</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, a)</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, b)</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>b</mi>
                <mo>,</mo>
                <mi>a</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(b, a)</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>b</mi>
                <mo>,</mo>
                <mi>a</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(b, a)</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>b</mi>
                <mo>,</mo>
                <mi>a</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(b, a)</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>b</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(b, b)</annotation>
            </semantics>
          </math>
          だけを追加して、最終的に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">{</mo>
                <mi>e</mi>
                <mo>,</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo>,</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>,</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>,</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>,</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo stretchy="false" form="postfix">}</mo>
              </mrow>
              <annotation encoding="application/x-tex">\{e, a, b, (a, a), (a, b), (b, a), (b, b)\}</annotation>
            </semantics>
          </math>という集合を作成する。
        </p>
        <p><img src="images/bunnies.jpg" style="width:80.0%" /></p>
        <p>次のラウンドでは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, (a, b))</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>,</mo>
                <mi>a</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">((a, b), a)</annotation>
            </semantics>
          </math>
          などの要素を追加していく。この時点で、結合性が保持されていることを確認する必要があるので、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, (b, a))</annotation>
            </semantics>
          </math>
          を
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>,</mo>
                <mi>a</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">((a, b), a)</annotation>
            </semantics>
          </math>
          などと同一視する。言い換えると、内側の括弧は必要ないということだ。
        </p>
        <p>このプロセスの最終的な結果が予想できるだろう:
          可能なすべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>のリストが作られる。事実、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>e</mi>
              <annotation encoding="application/x-tex">e</annotation>
            </semantics>
          </math>を空リストで表せば、「乗算」はリストの連結に他ならないことがわかる。</p>
        <p>この種の構成では、要素の可能なすべての組み合わせを生成し続け、同一視は最小限に――単位元則と結合則を維持するのにちょうど十分なだけに留める。これは自由構成と呼ばれる。これで、生成元<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">{</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="false" form="postfix">}</mo>
              </mrow>
              <annotation encoding="application/x-tex">\{a, b\}</annotation>
            </semantics>
          </math>の集合から<span id="free_monoid" class="keyword">自由モノイド</span> (free monoid)
          を構築したことになる。</p>
        <h2 data-number="13.1" id="haskellにおける自由モノイド"><span class="header-section-number">13.1</span>
          Haskellにおける自由モノイド</h2>
        <p>Haskellの2要素集合は型<code>Bool</code>と等価であり、この集合によって生成される自由モノイドは型<code>[Bool]</code>
          (<code>Bool</code>のリスト)
          と等価だ。(無限リストの問題は意図的に無視している。)</p>
        <p>Haskellのモノイドは型クラスによって定義されている:</p>
        <div class="sourceCode" id="cb326">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb326-1"><a href="#cb326-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="kw">where</span></span>
<span id="cb326-2"><a href="#cb326-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    mempty  ::</span> m</span>
<span id="cb326-3"><a href="#cb326-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    mappend ::</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m</span></code></pre>
        </div>
        <p>これが意味しているのは、すべての<code>Monoid</code>が<code>mempty</code>と呼ばれる中立元と、<code>mappend</code>と呼ばれる二項関数
          (乗算)
          を持たなければならないということだ。Haskellでは単位元則と結合則は表現できず、モノイドがインスタンス化されるたびにプログラマによって検証されなければならない。</p>
        <p>任意の型のリストがモノイドを形成するという事実は、次のインスタンス定義によって記述される:</p>
        <div class="sourceCode" id="cb327">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> [a] <span class="kw">where</span></span>
<span id="cb327-2"><a href="#cb327-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mempty</span>  <span class="ot">=</span> []</span>
<span id="cb327-3"><a href="#cb327-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mappend</span> <span class="ot">=</span> (<span class="op">++</span>)</span></code></pre>
        </div>
        <p>これは、空リスト<code>[]</code>が単位元であり、リスト連結<code>(++)</code>が二項演算であることを記述している。</p>
        <p>
          これまで見てきたように、型<code>a</code>のリストは、集合<code>a</code>を生成元とする自由モノイドに対応する。乗算を伴う自然数の集合は、多くの積が同一視されるので、自由モノイドではない。次の例と比較しよう:
        </p>
        <div class="sourceCode" id="cb328">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">*</span> <span class="dv">3</span> <span class="ot">=</span> <span class="dv">6</span></span>
<span id="cb328-2"><a href="#cb328-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>] <span class="op">++</span> [<span class="dv">3</span>] <span class="ot">=</span> [<span class="dv">2</span>, <span class="dv">3</span>] <span class="op">//</span> [<span class="dv">6</span>]と同一ではない</span></code></pre>
        </div>
        <p>これは簡単だが、問題は、圏論では対象の中を見るのが許されないのに、どうやってこの自由構成を実現できるのか、ということだ。我々の馬車馬を使おう:
          普遍的構成だ。</p>
        <p>2番目の興味深い疑問は、単位元則と結合則が必要とする最小数よりも多くの要素を同一視すれば、ある自由モノイドから任意のモノイドを得られるのか、ということだ。これが普遍的構成から直接導かれることをお見せしよう。</p>
        <h2 data-number="13.2" id="自由モノイドの普遍的構成"><span class="header-section-number">13.2</span> 自由モノイドの普遍的構成</h2>
        <p>
          普遍的構成についての経験を振り返れば、それは何かを構築するというより、特定のパターンに最もよく適合する対象を選択するものだと気付くだろう。したがって、普遍的構成を使って自由モノイドを「構築」したいなら、選択肢となる多数のモノイドの全体を考慮する必要がある。選択するにはモノイドの圏全体が必要だ。だが、モノイドは圏を形成するのだろうか？
        </p>
        <p>まず、単位元と乗算によって定義された追加構造を伴う集合としてモノイドを見てみよう。モノイダル構造を保存する関数を射として採用する。このような構造保存関数は<span id="homomorphism"
            class="keyword">準同型</span> (homomorphism)
          と呼ばれる。モノイド準同型は2つの要素の積を2つの要素の写像の積に写さなければならない:</p>
        <div class="sourceCode" id="cb329">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb329-1"><a href="#cb329-1" aria-hidden="true" tabindex="-1"></a>h (a <span class="op">*</span> b) <span class="ot">=</span> h a <span class="op">*</span> h b</span></code></pre>
        </div>
        <p>なおかつ単位元を単位元に写さなければならない。</p>
        <p>
          例として、整数のリストから整数への準同型を考えよう:<code>[2]</code>を2に写し、<code>[3]</code>を3に写すなら、<code>[2, 3]</code>を6に写す必要がある。なぜなら、連結:
        </p>
        <div class="sourceCode" id="cb330">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb330-1"><a href="#cb330-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>] <span class="op">++</span> [<span class="dv">3</span>] <span class="ot">=</span> [<span class="dv">2</span>, <span class="dv">3</span>]</span></code></pre>
        </div>
        <p>が次のような乗算になるからだ:</p>
        <div class="sourceCode" id="cb331">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb331-1"><a href="#cb331-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">*</span> <span class="dv">3</span> <span class="ot">=</span> <span class="dv">6</span></span></code></pre>
        </div>
        <p>ここで、個々のモノイドの内部構造については忘れて、対応する射をもつ対象としてのみ見よう。すると、モノイドの圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>が得られる。</p>
        <p>さて、内部構造を忘れる前に、重要な性質に注目しておこう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>のすべての対象が集合に写せるのは自明だ。それはただの要素の集合だ。この集合は<span id="underlying" class="keyword">基底</span>集合 (underlying
          set)
          と呼ばれる。実際、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>の対象を集合に写せるだけでなく、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>の射
          (準同型)
          も関数に写せる。これも自明なだけに見えるが、すぐに役立つようになるだろう。この<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への対象と射の写像は、実際には関手だ。この関手はモノイダル構造を「忘れている」。いったん通常の集合の中に入ると、もはや単位元を区別したり乗算を気にしたりすることはない。そのため、<span
            id="forgetful_functor" class="keyword">忘却関手</span> (forgetful
          functor) と呼ばれる。忘却関手は圏論ではよく出てくる。</p>
        <p>これで、2つの異なる観点から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>を見たことになる。それらは対象と射を伴う他のすべての圏と同じように扱える。この観点では、モノイドの内部構造は見えない。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>の中の特定の対象について言えるのは、それ自身や他の対象と射を通じて接続しているということだけだ。射の「乗法」の表――合成則――は、集合としてのモノイドという、もう一方の観点から導かれる。圏論に進んだことでこの観点を完全に失ったわけではない――まだ忘却関手を通じてアクセスできる。
        </p>
        <p>
          普遍的構成を適用するには、特別な性質を定義することにより、モノイドの圏を探索して自由モノイドの最良の候補を選べるようにする必要がある。しかし、自由モノイドはその生成元によって定義される。別の生成元を選べば、生成される自由モノイドは変わる
          (<code>Bool</code>のリストと<code>Int</code>のリストは違う)。我々の構成は、生成元の集合から始めなければならない。つまり、集合に戻ってきた！</p>
        <p>ここで忘却関手が登場する。それは我々のモノイドをレントゲン撮影するのに使える。これらの小塊のレントゲン写真から生成元を特定できる。その仕組みはこうだ:</p>
        <p>生成元の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>から始める。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内の集合だ。</p>
        <p>マッチさせるパターンは、モノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>の対象――と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内の関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>で構成されている。</p>
        <div class="sourceCode" id="cb332">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb332-1"><a href="#cb332-1" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> x <span class="ot">-&gt;</span> <span class="dt">U</span> m</span></code></pre>
        </div>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>U</mi>
              <annotation encoding="application/x-tex">U</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への忘却関手だ。これは奇妙な混成パターンだ――半分は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>で半分は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>だ。</p>
        <p>この考え方では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>のレントゲン写真内の生成元の集合を関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>が特定する。関数が集合内の点をきちんと特定できなくても問題ない
          (関数が点を潰してもよい)。普遍構成によってそのパターンの最も良い代表が選ばれて、すべて整理されるだろう。</p>
        <p><img src="images/monoid-pattern.jpg" style="width:40.0%" /></p>
        <p>候補間の順位付けも定義しなければならない。もう1つの候補があるとしよう。モノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>と、そのレントゲン写真内の生成元を特定する関数だ:</p>
        <div class="sourceCode" id="cb333">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb333-1"><a href="#cb333-1" aria-hidden="true" tabindex="-1"></a><span class="ot">q ::</span> x <span class="ot">-&gt;</span> <span class="dt">U</span> n</span></code></pre>
        </div>
        <p>次のようなモノイドの射 (構造保存準同型)
          がある場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>よりも優れていると言おう:</p>
        <div class="sourceCode" id="cb334">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb334-1"><a href="#cb334-1" aria-hidden="true" tabindex="-1"></a><span class="ot">h ::</span> m <span class="ot">-&gt;</span> n</span></code></pre>
        </div>
        <p>これの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>U</mi>
              <annotation encoding="application/x-tex">U</annotation>
            </semantics>
          </math>の下の像
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>U</mi>
              <annotation encoding="application/x-tex">U</annotation>
            </semantics>
          </math>は関手なので、射を関数に写す)
          は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>を通じて分解する:</p>
        <div class="sourceCode" id="cb335">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb335-1"><a href="#cb335-1" aria-hidden="true" tabindex="-1"></a>q <span class="ot">=</span> <span class="dt">U</span> h <span class="op">.</span> p</span></code></pre>
        </div>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>内の生成元を選択し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>内の「同じ」生成元を選択すると見なすなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>はこれらの生成元を2つのモノイドの間で写していると見なせる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>は、定義上、モノイダル構造を保存することを覚えておいてほしい。これは、1つのモノイドにおける2つの生成子の積が、2番目のモノイドにおいて対応する2つの生成子の積に写されることなどを意味する。</p>
        <figure>
          <img src="images/monoid-ranking.jpg" style="width:40.0%" alt="モノイドの順位付け" />
          <figcaption aria-hidden="true">モノイドの順位付け</figcaption>
        </figure>
        <p>この順位付けは、最も優れた候補、すなわち自由モノイドを見つけるために使われる。定義は次のとおりだ:</p>
        <blockquote>
          <p>(関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>p</mi>
                <annotation encoding="application/x-tex">p</annotation>
              </semantics>
            </math>を伴う)
            <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>m</mi>
                <annotation encoding="application/x-tex">m</annotation>
              </semantics>
            </math>と、前述の分解特性を満たす任意の他の
            (関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>q</mi>
                <annotation encoding="application/x-tex">q</annotation>
              </semantics>
            </math>を伴う)
            モノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>n</mi>
                <annotation encoding="application/x-tex">n</annotation>
              </semantics>
            </math>とについて、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>m</mi>
                <annotation encoding="application/x-tex">m</annotation>
              </semantics>
            </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>n</mi>
                <annotation encoding="application/x-tex">n</annotation>
              </semantics>
            </math>への<em>一意な</em>射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>h</mi>
                <annotation encoding="application/x-tex">h</annotation>
              </semantics>
            </math>が存在する場合に限って、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>m</mi>
                <annotation encoding="application/x-tex">m</annotation>
              </semantics>
            </math>を生成子<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>x</mi>
                <annotation encoding="application/x-tex">x</annotation>
              </semantics>
            </math>を伴う<strong>自由モノイド</strong>と呼ぶ。
          </p>
        </blockquote>
        <p>ちなみに、これは2番目の疑問に対する答えだ。関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>U</mi>
                <mi>h</mi>
              </mrow>
              <annotation encoding="application/x-tex">U h</annotation>
            </semantics>
          </math>には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>U</mi>
                <mi>m</mi>
              </mrow>
              <annotation encoding="application/x-tex">U m</annotation>
            </semantics>
          </math>の複数の要素を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>U</mi>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">U n</annotation>
            </semantics>
          </math>の1つの要素へ潰す力がある。ここで、潰すことは自由モノイドのいくつかの要素を同一視することに対応する。したがって、生成子<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>を伴うモノイドは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>に基づく自由モノイドから、いくつかの要素を同一視することによって得られる。自由モノイドとは、最小限だけしか同一視されていないモノイドのことだ。</p>
        <p>随伴について話すとき、自由モノイドに戻ってこよう。</p>
        <h2 data-number="13.3" id="課題-10"><span class="header-section-number">13.3</span> 課題</h2>
        <ol type="1">
          <li>
            <p>モノイドの準同型が単位元を保存する、という条件は
              (もともと私もそう思ったように)
              冗長だと思うかもしれない。結局のところ、すべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>a</mi>
                  <annotation encoding="application/x-tex">a</annotation>
                </semantics>
              </math>について次が成り立つのは分かっている:</p>
            <div class="sourceCode" id="cb336">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb336-1"><a href="#cb336-1" aria-hidden="true" tabindex="-1"></a>h a <span class="op">*</span> h e <span class="ot">=</span> h (a <span class="op">*</span> e) <span class="ot">=</span> h a</span></code></pre>
            </div>
            <p>したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mrow>
                    <mi>h</mi>
                    <mi>e</mi>
                  </mrow>
                  <annotation encoding="application/x-tex">h e</annotation>
                </semantics>
              </math>は右単位元のように働く
              (同様に、左単位元のようにも働く)。
              問題は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mrow>
                    <mi>h</mi>
                    <mi>a</mi>
                  </mrow>
                  <annotation encoding="application/x-tex">h a</annotation>
                </semantics>
              </math>は、すべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>a</mi>
                  <annotation encoding="application/x-tex">a</annotation>
                </semantics>
              </math>を考えると、終域モノイドの一部のモノイドしかカバーできないということだ。<math display="inline"
                xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>h</mi>
                  <annotation encoding="application/x-tex">h</annotation>
                </semantics>
              </math>の像の外部に「真の」単位元が存在する場合がある。モノイド間で乗算を保存する同型は自動的に単位元を保存しなければならないことを示せ。</p>
          </li>
          <li>
            <p>連結できる整数リストから乗算できる整数へのモノイド準同型について考える。空リスト<code>[]</code>の像は何か？
              すべての単要素リストは、それが含む整数に写されるとする。たとえば、<code>[3]</code>は3に写される。<code>[1, 2, 3, 4]</code>の像は何か？
              整数12に写されるリストはいくつあるか？
              2つのモノイド間に他の準同型はあるか？</p>
          </li>
          <li>
            <p>単集合によって生成される自由モノイドとは何か？
              それが何と同型なのか分かるか？</p>
          </li>
        </ol>
        <h1 data-number="14" id="representable-functors"><span class="header-section-number">14</span> 表現可能関手</h1>
        <p>
          そろそろ集合について少し話そう。数学者は集合論に対して愛憎相半ばする。集合論は数学にとってのアセンブリー言語だ――少なくともかつてはそうだった。圏論はある程度、集合論から距離を置こうとする。たとえば、すべての集合の集合は存在しないが、すべての集合の圏<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>なら存在する、というのはよく知られた事実だ。これは良い。一方で我々は、圏内の任意の2対象間の射は集合を形成する、と仮定した。そしてそれをhom集合と名付けさえした。公平のために言うと、圏論には射が集合を形成しないような分野もある。そこでは射は別の圏の対象となる。Hom集合の代わりにhom対象を使う圏は<span
            id="enriched" class="keyword">豊穣</span> (enriched)
          圏と呼ばれる。しかし、以下では古き良きhom集合を持つ圏に固執しよう。</p>
        <p>集合は、圏論での対象を飲み込める特徴のない塊、というのが最も近い。集合が含む要素については、言えることが少ししかない。有限集合なら要素を数えられる。基数
          (cardinal number)
          を使えば、ある意味で無限集合の要素を数えられる。たとえば、自然数の集合は実数の集合よりも小さいが、両者とも無限だ。ただし、驚くかも知れないが、有理数の集合は自然数の集合と同じ大きさだ。</p>
        <p>
          それ以外には、集合に関するすべての情報は、集合間の関数に――特に、同型と呼ばれる可逆関数に――エンコードできる。どこからどう見ても同型集合は同一だ。数学基礎論の研究者の逆鱗に触れる前に、等価性と同型には根本的に重要な区別があることを説明しておこう。これは数学の最新分野であるホモトピー型理論
          (Homotopy Type Theory, HoTT)
          の主要な関心事のひとつだ。ここでHoTTについて触れるのは、その純粋な数学理論が計算機科学にインスピレーションを得たものだからだ。主唱者の1人であるVladimir
          Voevodskyによる大きな発見は、定理証明系Coqを研究しているときに得られた。数学とプログラミングの相互作用は双方向なのだ。</p>
        <p>
          集合に関する重要な教訓は、異なる要素の集合を比較しても問題ないということだ。たとえば、ある自然変換の集合は何らかの射の集合と同型だと言える。集合はただの集合だからだ。この場合の同型とは、一方の集合からの自然変換すべてについて他方の集合からの一意な射が存在し、逆もまた成り立つことを意味する。それらは互いにペアにできる。リンゴとオレンジが異なる圏の対象なら比較できないが、リンゴの集合とオレンジの集合は比較できる。多くの場合、圏論の問題を集合論の問題に変換すれば、必要な洞察が得られ、有用な定理を証明することさえ可能になる。
        </p>
        <h2 data-number="14.1" id="hom関手-1"><span class="header-section-number">14.1</span> Hom関手</h2>
        <p>すべての圏には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への標準的な写像の族が用意されている。それらの写像は実際には関手であるため、圏の構造を保存している。そのような写像をひとつ生成しよう。</p>
        <p>ある対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内で固定し、別の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>も同様に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内で選択しよう。Hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation>
            </semantics>
          </math>
          は集合なので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>の対象だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を固定したまま<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>を変化させると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation>
            </semantics>
          </math>
          も<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内で変化する。それゆえ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への写像が存在する。</p>
        <p><img src="images/hom-set.jpg" style="width:45.0%" /></p>
        <p>hom集合を写像と見なしているということを2番目の引数で強調したい場合は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>
          と表記する。ここで、ダッシュは引数のプレースホルダとして機能する。</p>
        <p>この対象の写像は射の写像に容易に拡張できる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の任意の2対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>y</mi>
              <annotation encoding="application/x-tex">y</annotation>
            </semantics>
          </math>の間の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>を考えてみよう。先ほど定義した写像によって、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>は集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation>
            </semantics>
          </math>
          に写され、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>y</mi>
              <annotation encoding="application/x-tex">y</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>y</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, y)</annotation>
            </semantics>
          </math>
          に写される。この写像が関手なら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>は2つの集合間の関数に写されなければならない:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>y</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, x) \to \mathbf{C}(a, y)</annotation>
            </semantics>
          </math></p>
        <p>この関数をpoint-wiseに定義しよう。つまり、引数ごとに個別に定義する。引数として、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation>
            </semantics>
          </math>
          の任意の要素を1つ選択する必要がある。それを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>と呼ぼう。射は端と端が一致すれば合成可能だ。ここでも<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>の終域が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>の始域と一致しており、それらの合成:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∘</mo>
                <mi>h</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>y</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \circ h \Colon a \to y</annotation>
            </semantics>
          </math></p>
        <p>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>y</mi>
              <annotation encoding="application/x-tex">y</annotation>
            </semantics>
          </math>への射となる。したがって、これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>y</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, y)</annotation>
            </semantics>
          </math>
          のメンバーだ。</p>
        <figure>
          <img src="images/hom-functor.jpg" style="width:45.0%" alt="Hom関手" />
          <figcaption aria-hidden="true">Hom関手</figcaption>
        </figure>
        <p>先ほど、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation>
            </semantics>
          </math>
          から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>y</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, y)</annotation>
            </semantics>
          </math>
          への関数を見つけた。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>の像として使える。混乱の危険がないなら、このリフトされた関数を次のように記述しよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>f</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, f)</annotation>
            </semantics>
          </math></p>
        <p>また、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>に対するその作用を次のように記述しよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>f</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mi>h</mi>
                <mo>=</mo>
                <mi>f</mi>
                <mo>∘</mo>
                <mi>h</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, f) h = f \circ h</annotation>
            </semantics>
          </math></p>
        <p>この構成はどの圏でも機能するので、Haskellの型の圏でも機能するはずだ。Haskellでは、hom関手は<code>Reader</code>関手としてよく知られている:</p>
        <div class="sourceCode" id="cb337">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb337-1"><a href="#cb337-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Reader</span> a x <span class="ot">=</span> a <span class="ot">-&gt;</span> x</span></code></pre>
        </div>
        <div class="sourceCode" id="cb338">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb338-1"><a href="#cb338-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Reader</span> a) <span class="kw">where</span></span>
<span id="cb338-2"><a href="#cb338-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f h <span class="ot">=</span> f <span class="op">.</span> h</span></code></pre>
        </div>
        <p>Hom集合の始域を固定する代わりに終域を固定すると何が起こるかを考えてみよう。言い換えれば、写像<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mo>−</mo>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(-, a)</annotation>
            </semantics>
          </math>
          も関手なのかという疑問だ。そのとおり、関手だ。ただし、共変ではなく反変だ。なぜなら、射の端と端を同様にマッチングすると<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>による後置合成
          (postcomposition)
          となり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>
          の場合のような前置合成 (precomposition) ではないからだ。</p>
        <p>この反変関手はHaskellですでに見た。それは<code>Op</code>と呼ばれていた。</p>
        <div class="sourceCode" id="cb339">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb339-1"><a href="#cb339-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Op</span> a x <span class="ot">=</span> x <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <div class="sourceCode" id="cb340">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb340-1"><a href="#cb340-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Contravariant</span> (<span class="dt">Op</span> a) <span class="kw">where</span></span>
<span id="cb340-2"><a href="#cb340-2" aria-hidden="true" tabindex="-1"></a>    contramap f h <span class="ot">=</span> h <span class="op">.</span> f</span></code></pre>
        </div>
        <p>最後に、両方の対象を変化させると、プロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mo>−</mo>
                  <mo>,</mo>
                  <mo>=</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(-, =)</annotation>
            </semantics>
          </math>
          が得られる。これは最初の引数について反変で、2番目の引数について共変だ
          (2つの引数が独立して変化することを強調するため、2番目のプレースホルダとして二重ダッシュを使った)。このプロ関手については、関手性について話したときに見た:</p>
        <div class="sourceCode" id="cb341">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb341-1"><a href="#cb341-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Profunctor</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb341-2"><a href="#cb341-2" aria-hidden="true" tabindex="-1"></a>  dimap ab cd bc <span class="ot">=</span> cd <span class="op">.</span> bc <span class="op">.</span> ab</span>
<span id="cb341-3"><a href="#cb341-3" aria-hidden="true" tabindex="-1"></a>  lmap <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">.</span>)</span>
<span id="cb341-4"><a href="#cb341-4" aria-hidden="true" tabindex="-1"></a>  rmap <span class="ot">=</span> (<span class="op">.</span>)</span></code></pre>
        </div>
        <p>重要な教訓は、この観察がどの圏にも当てはまるということだ。すなわち、対象からhom集合への写像は関手的だ。反変は反対圏からの写像と等価なので、この事実は次のように簡潔に述べられる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>C</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mo>−</mo>
                  <mo>,</mo>
                  <mo>=</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>∷</mo>
                <msup>
                  <mi>𝐂</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>×</mo>
                <mi>𝐂</mi>
                <mo>→</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">C(-, =) \Colon \mathbf{C}^\mathit{op} \times \mathbf{C} \to
                \mathbf{Set}</annotation>
            </semantics>
          </math></p>
        <h2 data-number="14.2" id="表現可能関手"><span class="header-section-number">14.2</span> 表現可能関手</h2>
        <p>これまで見てきたように、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>で対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を選択するたびに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への関手が得られる。このように構造を保存する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への写像は、<span id="representation" class="keyword">表現</span> (representation)
          と呼ばれることが多い。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>での対象や射は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内の集合や関数として表現される。</p>
        <p>関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>
          自体を指して表現可能と呼ぶこともある。より一般的には、ある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の選択に対してhom関手と自然同型である関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>はすべて<span id="representable" class="keyword">表現可能</span> (representable)
          と呼ばれる。このような関手は必ず集合値関手
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>-valued
          functor)
          でなければならない。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>
          がそうだからだ。</p>
        <p>以前述べたように、同型集合は同一と見なされることが多い。より一般的には、圏の同型<em>対象</em>は同一と見なされる。ある対象は、他の対象
          (およびそれ自身) との射による関係以外の構造を持たないからだ。</p>
        <p>たとえば、まず集合でモデル化されたモノイドの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>について以前説明した。ただし、それらの集合のモノイダル構造を保存する関数のみを射として選ぶように気を付けた。したがって、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>内の2つの対象が同型である場合、すなわち、それらの間に可逆な射がある場合、それらはまったく同じ構造を持つ。それらが基づく集合と関数を見てみると、片方のモノイドの単位元はもう片方のモノイドの単位元に写され、2つの要素の積はそれらの写像の積に写されているのがわかる。
        </p>
        <p>同じ論法が関手にも適用できる。2つの圏の間の関手は圏を形成し、そこでは自然変換が射の役目を果たしている。したがって、2つの関手の間に可逆な自然変換があれば、それらは同型であり、同一と見なせる。</p>
        <p>この観点から、表現可能関手の定義を分析してみよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>が表現可能であるためには、次の条件を満たす必要がある:
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>に対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>があり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>への自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>が1つあり、逆方向に別の自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>β</mi>
              <annotation encoding="application/x-tex">\beta</annotation>
            </semantics>
          </math>があり、それらの合成が恒等自然変換であること。
        </p>
        <p>ある対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>における<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>のコンポーネントを見てみよう。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内の関数だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>x</mi>
                </msub>
                <mo>∷</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mi>F</mi>
                <mi>x</mi>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_x \Colon \mathbf{C}(a, x) \to F x</annotation>
            </semantics>
          </math></p>
        <p>この変換の自然条件は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>y</mi>
              <annotation encoding="application/x-tex">y</annotation>
            </semantics>
          </math>へのすべての射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>について、次の図式が可換であることを示している:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>f</mi>
                <mo>∘</mo>
                <msub>
                  <mi>α</mi>
                  <mi>x</mi>
                </msub>
                <mo>=</mo>
                <msub>
                  <mi>α</mi>
                  <mi>y</mi>
                </msub>
                <mo>∘</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>f</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">F f \circ \alpha_x = \alpha_y \circ \mathbf{C}(a, f)</annotation>
            </semantics>
          </math></p>
        <p>Haskellでは、自然変換を多相関数に置き換えればよい:</p>
        <div class="sourceCode" id="cb342">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb342-1"><a href="#cb342-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="kw">forall</span> x<span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> <span class="dt">F</span> x</span></code></pre>
        </div>
        <p>ここでオプションの量化子<code>forall</code>を使った。自然条件</p>
        <div class="sourceCode" id="cb343">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb343-1"><a href="#cb343-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f <span class="op">.</span> alpha <span class="ot">=</span> alpha <span class="op">.</span> <span class="fu">fmap</span> f</span></code></pre>
        </div>
        <p>はパラメトリック性 (前述のtheorems for freeの1つ)
          によって自動的に満たされる。これは、左辺の<code>fmap</code>が関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>によって定義され、右辺の<code>fmap</code>がreader関手によって定義されるという理解に基づく。readerでの<code>fmap</code>は単なる関数の前置合成なので、さらに明示的にできる。<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation>
            </semantics>
          </math>
          の要素である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>に作用することで、自然条件は次のように単純化される:</p>
        <div class="sourceCode" id="cb344">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb344-1"><a href="#cb344-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (alpha h) <span class="ot">=</span> alpha (f <span class="op">.</span> h)</span></code></pre>
        </div>
        <p>もう1つの変換<code>beta</code>は方向が逆だ:</p>
        <div class="sourceCode" id="cb345">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb345-1"><a href="#cb345-1" aria-hidden="true" tabindex="-1"></a><span class="ot">beta ::</span> <span class="kw">forall</span> x<span class="op">.</span> <span class="dt">F</span> x <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> x)</span></code></pre>
        </div>
        <p>これは自然条件を満たす必要があり、<code>alpha</code>の逆関数でなければならない:</p>
        <div class="sourceCode" id="cb346">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb346-1"><a href="#cb346-1" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">.</span> beta <span class="ot">=</span> <span class="fu">id</span> <span class="ot">=</span> beta <span class="op">.</span> alpha</span></code></pre>
        </div>
        <p>後で説明するとおり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F a</annotation>
            </semantics>
          </math>が空でないならば常に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>
          から任意の集合値関手への自然変換が存在する (米田の補題)
          が、必ずしも可逆ではない。</p>
        <p>Haskellでlist関手を用い、<code>Int</code>を<code>a</code>とした例を挙げよう。それを実現する自然変換はこうだ:</p>
        <div class="sourceCode" id="cb347">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb347-1"><a href="#cb347-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="kw">forall</span> x<span class="op">.</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> [x]</span>
<span id="cb347-2"><a href="#cb347-2" aria-hidden="true" tabindex="-1"></a>alpha h <span class="ot">=</span> <span class="fu">map</span> h [<span class="dv">12</span>]</span></code></pre>
        </div>
        <p>
          任意の数字として12を選び、それを使って単要素リストを作成した。次に、このリストに関数<code>h</code>を<code>fmap</code>し、<code>h</code>が返す型のリストを取得する。(実際には、そのような変換は整数のリストと同じくらいたくさんある。)
        </p>
        <p>自然条件は<code>map</code> (<code>fmap</code>のリスト版)
          の合成可能性と等価だ:</p>
        <div class="sourceCode" id="cb348">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb348-1"><a href="#cb348-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f (<span class="fu">map</span> h [<span class="dv">12</span>]) <span class="ot">=</span> <span class="fu">map</span> (f <span class="op">.</span> h) [<span class="dv">12</span>]</span></code></pre>
        </div>
        <p>しかし、逆変換を見つけるには、任意の型<code>x</code>のリストを元に<code>x</code>を返す関数を探さなくてはならない。</p>
        <div class="sourceCode" id="cb349">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb349-1"><a href="#cb349-1" aria-hidden="true" tabindex="-1"></a><span class="ot">beta ::</span> <span class="kw">forall</span> x<span class="op">.</span> [x] <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> x)</span></code></pre>
        </div>
        <p><code>head</code>か何かを使ってリストから<code>x</code>を取得しようと考えたかもしれないが、空のリストには使えない。ここで
          (<code>Int</code>の代わりとして)
          機能する型<code>a</code>の選択肢がないことに注目してほしい。すなわち、list関手は表現可能ではない。</p>
        <p>Haskellの (自己)
          関手がコンテナに少し似ていると言ったのを覚えているだろうか？
          同じように、表現可能関手は、関数呼び出しの結果をメモ化して保存するためのコンテナと見なせる
          (Haskellでのhom集合の要素は単なる関数だ)。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>
          内の対象を表現する型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>は、関数の表形式の値にアクセスするためのキー型と見なせる。ここでの変換<code>alpha</code>は<code>tabulate</code>と呼ばれ、その逆の<code>beta</code>は<code>index</code>と呼ばれる。以下は
          (少し単純化した) <code>Representable</code>のクラス定義だ:</p>
        <div class="sourceCode" id="cb350">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb350-1"><a href="#cb350-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Representable</span> f <span class="kw">where</span></span>
<span id="cb350-2"><a href="#cb350-2" aria-hidden="true" tabindex="-1"></a>   <span class="kw">type</span> <span class="dt">Rep</span><span class="ot"> f ::</span> <span class="op">*</span></span>
<span id="cb350-3"><a href="#cb350-3" aria-hidden="true" tabindex="-1"></a><span class="ot">   tabulate ::</span> (<span class="dt">Rep</span> f <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> f x</span>
<span id="cb350-4"><a href="#cb350-4" aria-hidden="true" tabindex="-1"></a><span class="ot">   index    ::</span> f x <span class="ot">-&gt;</span> <span class="dt">Rep</span> f <span class="ot">-&gt;</span> x</span></code></pre>
        </div>
        <p>ここで<code>Rep f</code>と呼ばれる型を表現する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>が<code>Representable</code>の定義の一部であることに注意してほしい。星印は<code>Rep f</code>が型である
          (型コンストラクターやその他のエキゾチックなカインドではない)
          ことを意味する。</p>
        <p>無限リストや空でないストリームは表現可能だ。</p>
        <div class="sourceCode" id="cb351">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb351-1"><a href="#cb351-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stream</span> x <span class="ot">=</span> <span class="dt">Cons</span> x (<span class="dt">Stream</span> x)</span></code></pre>
        </div>
        <p>それらは<code>Integer</code>を引数に取る関数の値をメモ化したものと見なせる。(厳密に言えば、非負整数を使うべきだが、コードを複雑にしたくなかった。)</p>
        <p>
          このような関数を<code>tabulate</code>化するためには、値の無限ストリームを作成する。もちろん、これが可能なのは、Haskellが遅延評価だからだ。つまり、値は必要になったとき評価される。メモ化された値にアクセスするには<code>index</code>を使う。
        </p>
        <div class="sourceCode" id="cb352">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb352-1"><a href="#cb352-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Representable</span> <span class="dt">Stream</span> <span class="kw">where</span></span>
<span id="cb352-2"><a href="#cb352-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Rep</span> <span class="dt">Stream</span> <span class="ot">=</span> <span class="dt">Integer</span></span>
<span id="cb352-3"><a href="#cb352-3" aria-hidden="true" tabindex="-1"></a>    tabulate f <span class="ot">=</span> <span class="dt">Cons</span> (f <span class="dv">0</span>) (tabulate (f <span class="op">.</span> (<span class="op">+</span><span class="dv">1</span>)))</span>
<span id="cb352-4"><a href="#cb352-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">index</span> (<span class="dt">Cons</span> b bs) n <span class="ot">=</span> <span class="kw">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="kw">then</span> b <span class="kw">else</span> <span class="fu">index</span> bs (n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre>
        </div>
        <p>任意の戻り値型を持つ一連の関数すべてをカバーするような単一のメモ化スキームを実装できるのは興味深い。</p>
        <p>反変関手の表現可能性も同様に定義される。ただし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mo>−</mo>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(-, a)</annotation>
            </semantics>
          </math>
          の2番目の引数を固定する。あるいは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐂</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への関手を考えるのでも等価だ。なぜなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>𝐂</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}(a, -)</annotation>
            </semantics>
          </math>
          は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mo>−</mo>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(-, a)</annotation>
            </semantics>
          </math>
          と同じだからだ。</p>
        <p>表現可能性には興味深い捻じれがある。カルテシアン閉圏では、hom集合を内部的には冪乗対象として扱えることに注意してほしい。hom集合<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a,x)</annotation>
            </semantics>
          </math>
          は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>x</mi>
                <mi>a</mi>
              </msup>
              <annotation encoding="application/x-tex">x^a</annotation>
            </semantics>
          </math>と等価で、表現可能関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>に対しては次のように書ける:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mo>−</mo>
                  <mi>a</mi>
                </msup>
                <mo>=</mo>
                <mi>F</mi>
              </mrow>
              <annotation encoding="application/x-tex">-^a = F</annotation>
            </semantics>
          </math></p>
        <p>試しに、両辺の対数をとってみよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>=</mo>
                <mrow>
                  <mi>𝐥</mi>
                  <mi>𝐨</mi>
                  <mi>𝐠</mi>
                </mrow>
                <mi>F</mi>
              </mrow>
              <annotation encoding="application/x-tex">a = \mathbf{log}F</annotation>
            </semantics>
          </math></p>
        <p>もちろん、これは純粋に形式的な変換だが、対数の性質を多少知っている人にとっては非常に便利だ。特に、直積型に基づく関手は直和型で表現でき、直和型の関手は一般に表現可能ではないことが知られている
          (例: list関手)。</p>
        <p>
          最後に、表現可能関手が同じものに対して2種類の実装を与えていることに注目してほしい――1つは関数、1つはデータ構造だ。それらの内容はまったく同じだ――同じキーを使えば同じ値が取得される。それが私が話していた「同一性」の感覚だ。2つの自然同型関手は、その内容に関する限り同一だ。一方、2つの表現は異なる方法で実装されることが多く、パフォーマンス特性が異なる可能性がある。メモ化はパフォーマンス改善策として使われ、実行時間の大幅な短縮につながる可能性がある。同じ基礎計算の異なる表現を生成できることは、実用上の価値が非常に高い。そのため、驚くべきことに、圏論はパフォーマンスをまったく考慮しないにも関わらず、実用上の価値を持つ別の実装を探求する十分な機会を与えてくれる。
        </p>
        <h2 data-number="14.3" id="課題-11"><span class="header-section-number">14.3</span> 課題</h2>
        <ol type="1">
          <li>
            <p>Hom関手が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>𝐂</mi>
                  <annotation encoding="application/x-tex">\mathbf{C}</annotation>
                </semantics>
              </math>内の恒等射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
                </semantics>
              </math>内の対応する恒等関数に写すことを示せ。</p>
          </li>
          <li>
            <p><code>Maybe</code>が表現可能でないことを示せ。</p>
          </li>
          <li>
            <p><code>Reader</code>関手は表現可能か？</p>
          </li>
          <li>
            <p><code>Stream</code>表現を使って、引数を自乗する関数をメモ化せよ。</p>
          </li>
          <li>
            <p><code>Stream</code>に対する<code>tabulate</code>と<code>index</code>が実際に互いに逆であることを示せ。(ヒント:
              数学的帰納法を使う。)</p>
          </li>
          <li>
            <p>次の関手:</p>
            <div class="sourceCode" id="cb353">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb353-1"><a href="#cb353-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Pair</span> a <span class="ot">=</span> <span class="dt">Pair</span> a a</span></code></pre>
            </div>
            <p>は表現可能だ。それを表現する型がわかるだろうか？
              <code>tabulate</code>と<code>index</code>を実装せよ。
            </p>
          </li>
        </ol>
        <h2 data-number="14.4" id="参考文献-3"><span class="header-section-number">14.4</span> 参考文献</h2>
        <ol type="1">
          <li><a href="https://www.youtube.com/watch?v=4QgjKUzyrhM">表現可能関手</a>についてのCatstersの動画</li>
        </ol>
        <h1 data-number="15" id="the-yoneda-lemma"><span class="header-section-number">15</span> 米田の補題</h1>
        <p>
          圏論における構造のほとんどは、より具体的な他の数学の分野での結果を一般化したものだ。積・余積・モノイド・冪乗などは、圏論よりずっと前から知られていた。それらは別の数学の分野で別の名前で知られていたかもしれない。集合論におけるカルテシアン積、順序集合論における交わり
          (meet)、論理学における論理積――これらはすべて圏論的な積という抽象概念に対応する具体例だ。</p>
        <p>この点で、米田の補題は、圏一般に関する包括的な命題として際立っており、数学の他の分野では全くと言ってよいほど前例がない。一番似ているのは群論におけるCayleyの定理
          (すべての群はある集合の置換群と同型) だという説もある。</p>
        <p>米田の補題は、任意の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>を前提とする。すでに前章で述べたように、集合値関手のいくつかは表現可能であり、hom関手と同型だ。米田の補題は、すべての集合値関手がhom関手から自然変換によって得られることを示し、そのようなすべての変換を明示的に列挙する。
        </p>
        <p>
          自然変換について話したとき、自然条件は非常に制約が厳しくなりうると述べた。ある対象について自然変換のコンポーネントを定義するとき、自然性が十分強いため、射を介して接続されている別の対象までそのコンポーネントを「輸送」することがある。始域圏と終域圏で対象間の矢が多いほど、自然変換のコンポーネントを輸送するための制約が厳しくなる。<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>はたまたま矢が豊富な圏だ。</p>
        <p>米田の補題では、hom関手と他の関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>との間の自然変換が、その単一コンポーネントの値を1点で指定するだけで
          (！)
          完全に決定されることが示される。自然変換の残りの部分は単に自然条件に従う。</p>
        <p>では、米田の補題に関わる2つの関手について、その間の自然条件を確認しよう。1番目の関手はhom関手だ。それは<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>を射の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation>
            </semantics>
          </math>
          に写す。ただし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の固定された対象とする。また、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>y</mi>
              <annotation encoding="application/x-tex">y</annotation>
            </semantics>
          </math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>をすべて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>f</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, f)</annotation>
            </semantics>
          </math>
          に写すこともすでに見た。</p>
        <p>2番目の関手は任意の集合値関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>だ。</p>
        <p>この2つの関手の間の自然変換を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>としよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内での操作なので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>x</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_x</annotation>
            </semantics>
          </math>や<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>y</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_y</annotation>
            </semantics>
          </math>などの自然変換のコンポーネントは集合間の正則関数にすぎない。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>x</mi>
                </msub>
                <mo>∷</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mi>F</mi>
                <mi>x</mi>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_x \Colon \mathbf{C}(a, x) \to F x</annotation>
            </semantics>
          </math>
          <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>y</mi>
                </msub>
                <mo>∷</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>y</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mi>F</mi>
                <mi>y</mi>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_y \Colon \mathbf{C}(a, y) \to F y</annotation>
            </semantics>
          </math>
        </p>
        <p><img src="images/yoneda1.png" style="width:40.0%" /></p>
        <p>そして、これらは単なる関数なので、特定の点での値を見られる。だが、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation>
            </semantics>
          </math>
          の点とは何だろうか？ 鍵となる観察はこうだ:
          集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation>
            </semantics>
          </math>
          内のすべての点は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>でもある。</p>
        <p>したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>についての自然性の正方図式:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>y</mi>
                </msub>
                <mo>∘</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>f</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>=</mo>
                <mi>F</mi>
                <mi>f</mi>
                <mo>∘</mo>
                <msub>
                  <mi>α</mi>
                  <mi>x</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_y \circ \mathbf{C}(a, f) = F f \circ \alpha_x</annotation>
            </semantics>
          </math></p>
        <p>は、point-wiseに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>に作用すると次のようになる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>y</mi>
                </msub>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>f</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mi>h</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>=</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>f</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>α</mi>
                    <mi>x</mi>
                  </msub>
                  <mi>h</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_y (\mathbf{C}(a, f) h) = (F f) (\alpha_x h)</annotation>
            </semantics>
          </math></p>
        <p>前の節でhom関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>
          の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>への作用を、次のような前置合成として定義したことを思い出しただろう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>f</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mi>h</mi>
                <mo>=</mo>
                <mi>f</mi>
                <mo>∘</mo>
                <mi>h</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, f) h = f \circ h</annotation>
            </semantics>
          </math></p>
        <p>これにより次が導かれる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>y</mi>
                </msub>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>f</mi>
                  <mo>∘</mo>
                  <mi>h</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>=</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>f</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>α</mi>
                    <mi>x</mi>
                  </msub>
                  <mi>h</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_y (f \circ h) = (F f) (\alpha_x h)</annotation>
            </semantics>
          </math></p>
        <p>この条件がどれほど強いかは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>x</mi>
                <mo>=</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">x = a</annotation>
            </semantics>
          </math>の場合に特化すれば分かる。</p>
        <p><img src="images/yoneda2.png" style="width:40.0%" /></p>
        <p>この場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>への射となる。そのような射が少なくとも1つ存在するのは分かっている。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>h</mi>
                <mo>=</mo>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mi>a</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">h = \mathbf{id}_a</annotation>
            </semantics>
          </math>だ。代入してみよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>y</mi>
                </msub>
                <mi>f</mi>
                <mo>=</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>f</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>α</mi>
                    <mi>a</mi>
                  </msub>
                  <msub>
                    <mrow>
                      <mi>𝐢</mi>
                      <mi>𝐝</mi>
                    </mrow>
                    <mi>a</mi>
                  </msub>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_y f = (F f) (\alpha_a \mathbf{id}_a)</annotation>
            </semantics>
          </math></p>
        <p>何が起きたか注目してほしい。左辺は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>y</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, y)</annotation>
            </semantics>
          </math>
          の任意の要素<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>y</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_y</annotation>
            </semantics>
          </math>を作用させている。そして、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\mathbf{id}_a</annotation>
            </semantics>
          </math>における<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_a</annotation>
            </semantics>
          </math>の単一値によって完全に決まる。そのような値は任意に選べて、自然変換を生成するだろう。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_a</annotation>
            </semantics>
          </math>の値は集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F a</annotation>
            </semantics>
          </math>内にあるため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F a</annotation>
            </semantics>
          </math>のどの点でも何らかの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>が定義される。</p>
        <p>逆に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>
          から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>への自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>が与えられた場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\mathbf{id}_a</annotation>
            </semantics>
          </math>において評価すれば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F a</annotation>
            </semantics>
          </math>の点を得られる。</p>
        <p>以上より、米田の補題が証明された:</p>
        <blockquote>
          <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                </mrow>
                <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
              </semantics>
            </math>
            から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>F</mi>
                <annotation encoding="application/x-tex">F</annotation>
              </semantics>
            </math>への自然変換と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>F</mi>
                  <mi>a</mi>
                </mrow>
                <annotation encoding="application/x-tex">F a</annotation>
              </semantics>
            </math>の要素との間には1対1の対応がある。</p>
        </blockquote>
        <p>言い換えれば、</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐍</mi>
                  <mi>𝐚</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Nat}(\mathbf{C}(a, -), F) \cong F a</annotation>
            </semantics>
          </math></p>
        <p>あるいは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">[</mo>
                <mi>𝐂</mi>
                <mo>,</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mo stretchy="true" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation>
            </semantics>
          </math>という表記で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>の間の関手圏を表すと、自然変換の集合はその圏のhom集合にすぎず、次のように書ける:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐂</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(a, -), F) \cong F a
              </annotation>
            </semantics>
          </math></p>
        <p>この対応が実際には自然同型であることについては後で説明する。</p>
        <p>さて、この結果について直観的に理解しておこう。最も驚くべきことは、自然変換全体の結晶化が、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\mathbf{id}_a</annotation>
            </semantics>
          </math>において割り当てた値というたった1粒の種から始まることだ。それはその1点から自然条件にしたがって広がっていく。それは<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の像を溢れさせる。そこで、まずは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>
          の下で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の像について考えてみたい。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>自体の像から始めよう。hom関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>
          の下では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>は集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          に写される。一方、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>の下では、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F a</annotation>
            </semantics>
          </math>に写される。自然変換のコンポーネント<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_a</annotation>
            </semantics>
          </math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F a</annotation>
            </semantics>
          </math>へのある関数だ。集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          の中の、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\mathbf{id}_a</annotation>
            </semantics>
          </math>に対応する1点だけに注目しよう。集合内の1点にすぎないという事実を強調するために、これを<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>と呼ぼう。コンポーネント<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_a</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F a</annotation>
            </semantics>
          </math>内のある点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>に写すはずだ。どんな<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>を選択しても一意な自然変換につながることを説明しよう。</p>
        <p><img src="images/yoneda3.png" style="width:30.0%" /></p>
        <p>1つ目の主張は、1点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>を選択すれば残りの関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_a</annotation>
            </semantics>
          </math>が一意に決まる、というものだ。実際に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>に対応する他の点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">p&#39;</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          内で選んでみよう。そしてここで米田の補題の魔法が起こる:
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>は集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          内の点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">p&#39;</annotation>
            </semantics>
          </math>と見なせる。同時に、それは集合間の<em>関数</em>を2つ選択する。実際、射<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>は、hom関手では関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>g</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, g)</annotation>
            </semantics>
          </math>
          に写され、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>では<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>g</mi>
              </mrow>
              <annotation encoding="application/x-tex">F g</annotation>
            </semantics>
          </math>に写される。
        </p>
        <p><img src="images/yoneda4.png" style="width:40.0%" /></p>
        <p>ここで、もとの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>に対する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>g</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, g)</annotation>
            </semantics>
          </math>
          の作用を考えてみよう。ただし、記憶のとおり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\mathbf{id}_a</annotation>
            </semantics>
          </math>に対応する。その作用は前置合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>∘</mo>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mi>a</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">g \circ \mathbf{id}_a</annotation>
            </semantics>
          </math>として定義される。すなわち、点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">p&#39;</annotation>
            </semantics>
          </math>に対応する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>と同じだ。したがって、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>に作用するときに<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">p&#39;</annotation>
            </semantics>
          </math>を生成する関数に、すなわち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>に写される。ぐるりと一周した！</p>
        <p>さて、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>g</mi>
              </mrow>
              <annotation encoding="application/x-tex">F g</annotation>
            </semantics>
          </math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>への作用を考えてみよう。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>q</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">q&#39;</annotation>
            </semantics>
          </math>で、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F a</annotation>
            </semantics>
          </math>内の点だ。自然性の正方図式を完成させるには、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">p&#39;</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_a</annotation>
            </semantics>
          </math>によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>q</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">q&#39;</annotation>
            </semantics>
          </math>に写される必要がある。任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">p&#39;</annotation>
            </semantics>
          </math>
          (任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>)
          を選択し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_a</annotation>
            </semantics>
          </math>の下でのその写像を導出した。したがって、関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_a</annotation>
            </semantics>
          </math>は完全に決定される。</p>
        <p>2番目の主張は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>に接続された<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>に対して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>x</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_x</annotation>
            </semantics>
          </math>が一意に決定される、というものだ。論法は同様だ。ただし、ここではさらに2つの集合<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation>
            </semantics>
          </math>
          と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>x</mi>
              </mrow>
              <annotation encoding="application/x-tex">F x</annotation>
            </semantics>
          </math>があり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>は、hom関手の下では次のように写される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>g</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>∷</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, g) \Colon \mathbf{C}(a, a) \to \mathbf{C}(a, x)
              </annotation>
            </semantics>
          </math></p>
        <p>そして、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>の下では次のようになる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>g</mi>
                <mo>∷</mo>
                <mi>F</mi>
                <mi>a</mi>
                <mo>→</mo>
                <mi>F</mi>
                <mi>x</mi>
              </mrow>
              <annotation encoding="application/x-tex">F g \Colon F a \to F x</annotation>
            </semantics>
          </math></p>
        <p>ここでも、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>に作用する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>g</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, g)</annotation>
            </semantics>
          </math>
          は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation>
            </semantics>
          </math>
          内の点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">p&#39;</annotation>
            </semantics>
          </math>に対応する前置合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>∘</mo>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mi>a</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">g \circ \mathbf{id}_a</annotation>
            </semantics>
          </math>によって与えられる。自然性により、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">p&#39;</annotation>
            </semantics>
          </math>に作用する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>x</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_x</annotation>
            </semantics>
          </math>の値は次のように決定される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>q</mi>
                <mi>′</mi>
                <mo>=</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>g</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mi>q</mi>
              </mrow>
              <annotation encoding="application/x-tex">q&#39; = (F g) q</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">p&#39;</annotation>
            </semantics>
          </math>は任意としていたため、関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mi>x</mi>
              </msub>
              <annotation encoding="application/x-tex">\alpha_x</annotation>
            </semantics>
          </math>全体がこのように決定される。</p>
        <p><img src="images/yoneda5.png" style="width:40.0%" /></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>に接続されていない対象が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>にある場合はどうなるだろう？
          それらすべてが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>
          の下で空集合に写される。空集合は集合の圏における始対象なのを思い出してほしい。これは、この集合から他の集合への一意な関数があることを意味する。その関数は<code>absurd</code>と呼ばれていた。したがって、ここでも、自然変換のコンポーネントには選択の余地がない:
          <code>absurd</code>しかあり得ない。
        </p>
        <p>
          米田の補題を理解する方法の1つは、集合値関手の間の自然変換は関数の族にすぎず、関数は一般には非可逆だと理解することだ。情報を潰す関数もあり、その場合は終域の一部しかカバーされない。非可逆でない唯一の関数は、可逆なもの、つまり同型だ。したがって、構造を保存する最良の集合値関手は表現可能関手だということになる。それらはhom関手か、あるいはhom関手と自然同型な関手のどちらかだ。その他の関手<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>はすべてhom関手を非可逆変換することで得られる。そのような変換は、情報を失わせるだけでなく、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内の関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>の像のごく一部しかカバーしない可能性がある。</p>
        <h2 data-number="15.1" id="haskellにおける米田の補題"><span class="header-section-number">15.1</span> Haskellにおける米田の補題
        </h2>
        <p>Haskellのhom関手には、すでにreader関手という名前で出会っている:</p>
        <div class="sourceCode" id="cb354">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb354-1"><a href="#cb354-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Reader</span> a x <span class="ot">=</span> a <span class="ot">-&gt;</span> x</span></code></pre>
        </div>
        <p>Readerは射 (ここでは関数) を前置合成で写す:</p>
        <div class="sourceCode" id="cb355">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb355-1"><a href="#cb355-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Reader</span> a) <span class="kw">where</span></span>
<span id="cb355-2"><a href="#cb355-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f h <span class="ot">=</span> f <span class="op">.</span> h</span></code></pre>
        </div>
        <p>米田の補題によれば、reader関手は他の任意の関手へ自然に写せる。</p>
        <p>自然変換は多相関数だ。したがって、関手<code>F</code>が与えられると、reader関手からの写像が得られる:</p>
        <div class="sourceCode" id="cb356">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb356-1"><a href="#cb356-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="kw">forall</span> x <span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> <span class="dt">F</span> x</span></code></pre>
        </div>
        <p>いつものように、<code>forall</code>はオプションだが、自然変換のパラメトリック多相を強調するために明示的に書くことにしている。</p>
        <p>米田の補題によれば、これらの自然変換は<code>F a</code>の要素と1対1の対応関係にある。</p>
        <div class="sourceCode" id="cb357">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb357-1"><a href="#cb357-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> x <span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> <span class="dt">F</span> x ≅ <span class="dt">F</span> a</span></code></pre>
        </div>
        <p>この恒等射の右辺は、通常はデータ構造と見なしているものだ。一般化されたコンテナとして関手を解釈したのを覚えているだろうか？
          <code>F a</code>は<code>a</code>のコンテナだ。しかし、左辺は関数を引数に取る多相関数だ。米田の補題によれば、2つの表現は等価だ――それらは同じ情報を含んでいる。
        </p>
        <p>別の言い方をしよう: 次のような型の多相関数:</p>
        <div class="sourceCode" id="cb358">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb358-1"><a href="#cb358-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> <span class="kw">forall</span> x <span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> <span class="dt">F</span> x</span></code></pre>
        </div>
        <p>
          を与えてくれれば、<code>a</code>のコンテナを作成してみせる。このトリックは米田の補題の証明で使ったものだ。この関数を<code>id</code>で呼び出すことで<code>F a</code>の要素を取得した:
        </p>
        <div class="sourceCode" id="cb359">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb359-1"><a href="#cb359-1" aria-hidden="true" tabindex="-1"></a>alpha<span class="ot"> id ::</span> <span class="dt">F</span> a</span></code></pre>
        </div>
        <p>逆もまた真だ。型<code>F a</code>の任意の値:</p>
        <div class="sourceCode" id="cb360">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb360-1"><a href="#cb360-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fa ::</span> <span class="dt">F</span> a</span></code></pre>
        </div>
        <p>について、多相関数:</p>
        <div class="sourceCode" id="cb361">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb361-1"><a href="#cb361-1" aria-hidden="true" tabindex="-1"></a>alpha h <span class="ot">=</span> <span class="fu">fmap</span> h fa</span></code></pre>
        </div>
        <p>を正しい型で定義できる。2つの表現の間は簡単に行き来できる。</p>
        <p>表現が複数ある利点は、一方が他方よりも合成しやすかったり、用途によっては効率的だったりすることだ。</p>
        <p>この原則の最も単純な例は、コンパイラの構成でよく使われるコード変換である、継続渡しスタイル
          (continuation passing style, CPS)
          だ。これは米田の補題を恒等関手へ最も単純に適用したものだ。<code>F</code>を恒等射に置き換えると、次のようになる:</p>
        <div class="sourceCode" id="cb362">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb362-1"><a href="#cb362-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> r <span class="op">.</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r ≅ a</span></code></pre>
        </div>
        <p>
          この式の解釈は、任意の型<code>a</code>は<code>a</code>の「ハンドラー」を取る関数によって置き換えられる、ということだ。ハンドラーは、<code>a</code>を受け入れ、残りの計算――継続を実行する関数だ。(型<code>r</code>は通常、ある種のステータスコードをカプセル化している。)
        </p>
        <p>このスタイルのプログラミングは、UI、非同期システム、並行プログラミングではごく一般的だ。CPSの欠点は、制御の反転を伴うことだ。コードは生産者と消費者
          (ハンドラー)
          に分割されていて、簡単には合成できない。Webプログラミングの経験がある人なら誰でも、ステートフルなハンドラーとやり取りするスパゲッティ・コードの悪夢をよく知っている。後で述べるように、関手とモナドを慎重に使うことでCPSの合成的な特性を復元できる。
        </p>
        <h2 data-number="15.2" id="余米田の補題"><span class="header-section-number">15.2</span> 余米田の補題</h2>
        <p>いつものように、矢の方向を逆にすればおまけの構成が得られる。米田の補題を反対圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐂</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}</annotation>
            </semantics>
          </math>に適用すれば反変関手の間の写像を得られる。</p>
        <p>同様に、hom関手の始対象の代わりに終対象を固定することで、余米田の補題を導出できる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への反変hom関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mo>−</mo>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(-, a)</annotation>
            </semantics>
          </math>
          を取ろう。反変版の米田の補題は、この関手から他の任意の反変関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>への自然変換と、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F a</annotation>
            </semantics>
          </math>の要素との間に1対1の対応を確立する:</p>
        <div class="sourceCode" id="cb363">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb363-1"><a href="#cb363-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Nat</span>(<span class="dt">C</span>(<span class="op">-</span>, a), <span class="dt">F</span>) ≅ <span class="dt">F</span> a</span></code></pre>
        </div>
        <p>Haskell版の余米田の補題は次のようになる:</p>
        <div class="sourceCode" id="cb364">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb364-1"><a href="#cb364-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> x <span class="op">.</span> (x <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">F</span> x ≅ <span class="dt">F</span> a</span></code></pre>
        </div>
        <p>一部の文献では反変版の方を米田の補題と呼んでいるので注意してほしい。</p>
        <h2 data-number="15.3" id="課題-12"><span class="header-section-number">15.3</span> 課題</h2>
        <ol type="1">
          <li>
            <p>米田の同型を成す2つのHaskellの関数<code>phi</code>と<code>psi</code>が互いに逆であることを示せ。</p>
            <div class="sourceCode" id="cb365">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb365-1"><a href="#cb365-1" aria-hidden="true" tabindex="-1"></a><span class="ot">phi ::</span> (<span class="kw">forall</span> x <span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> <span class="dt">F</span> x) <span class="ot">-&gt;</span> <span class="dt">F</span> a</span>
<span id="cb365-2"><a href="#cb365-2" aria-hidden="true" tabindex="-1"></a>phi alpha <span class="ot">=</span> alpha <span class="fu">id</span></span></code></pre>
            </div>
            <div class="sourceCode" id="cb366">
              <pre
                class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb366-1"><a href="#cb366-1" aria-hidden="true" tabindex="-1"></a><span class="ot">psi ::</span> <span class="dt">F</span> a <span class="ot">-&gt;</span> (<span class="kw">forall</span> x <span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> <span class="dt">F</span> x)</span>
<span id="cb366-2"><a href="#cb366-2" aria-hidden="true" tabindex="-1"></a>psi fa h <span class="ot">=</span> <span class="fu">fmap</span> h fa</span></code></pre>
            </div>
          </li>
          <li>
            <p>離散圏 (discrete category)
              は、対象はあるが恒等射以外の射はない圏だ。米田の補題はそのような圏の関手でどのように役立つだろうか？</p>
          </li>
          <li>
            <p>
              unit型のリスト<code>[()]</code>は長さ以外の情報を含まない。したがって、データ型としては、整数をエンコードしていると見なせる。空リストは0をエンコードし、単リスト<code>[()]</code>
              (型ではなく値)
              は1をエンコードし、以下同様だ。このデータ型の別の表現を、list関手に対する米田の補題を使って構成せよ。</p>
          </li>
        </ol>
        <h2 data-number="15.4" id="参考文献-4"><span class="header-section-number">15.4</span> 参考文献</h2>
        <ol type="1">
          <li><a href="https://www.youtube.com/watch?v=TLMxHB19khE">Catsters</a>の動画</li>
        </ol>
        <h1 data-number="16" id="yoneda-embedding"><span class="header-section-number">16</span> 米田埋め込み</h1>
        <p>以前見たとおり、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>で対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を固定すると、写像<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>
          は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への
          (共変) 関手となる。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>x</mi>
                <mo>→</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">x \to \mathbf{C}(a, x)</annotation>
            </semantics>
          </math></p>
        <p>(Hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>x</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, x)</annotation>
            </semantics>
          </math>
          は<em>集合</em>なので終域は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>だ。)
          この写像はhom関手と呼ばれる。射に対するその作用についてもすでに定義した。</p>
        <p>さて、この写像で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を変化させてみよう。Hom<em>関手</em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>
          を任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>に割り当てる新しい写像が得られる。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>→</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">a \to \mathbf{C}(a, -)</annotation>
            </semantics>
          </math></p>
        <p>これは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の対象から関手への写像だ。それらの関手は関手圏の<em>対象</em>だ
          (<a href="#natural-transformations">自然変換</a>の関手圏についての節を参照)。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への関手圏を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">[</mo>
                <mi>𝐂</mi>
                <mo>,</mo>
                <mi>S</mi>
                <mi>e</mi>
                <mi>t</mi>
                <mo stretchy="true" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, Set]</annotation>
            </semantics>
          </math>と表記しよう。また、Hom関手が<a href="#kleisli-categories">表現可能関手</a>の原型だということも思い出しただろう。</p>
        <p>2つの圏間の対象の写像を見るたびに、その写像が関手でもあるかどうかを知りたくなるのは自然なことだ。言い換えると、一方の圏の射をもう一方の圏の射へとリフトできるかどうかだ。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          の要素にすぎないが、関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">[</mo>
                <mi>𝐂</mi>
                <mo>,</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mo stretchy="true" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation>
            </semantics>
          </math>の射は自然変換だ。つまり、射から自然変換への写像を探していることになる。</p>
        <p>射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon a \to b</annotation>
            </semantics>
          </math>に対応する自然変換が見つかるかどうか調べよう。まず、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>が何に写されているか見てみよう。それらは2つの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, -)</annotation>
            </semantics>
          </math>
          と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(b, -)</annotation>
            </semantics>
          </math>
          に写されている。この2つの関手の間の自然変換が必要だ。</p>
        <p>そして、ここが秘訣だ。米田の補題を使う:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐂</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(a, -), F) \cong F a
              </annotation>
            </semantics>
          </math></p>
        <p>さらに総称<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>をhom関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(b, -)</annotation>
            </semantics>
          </math>
          で置き換える。すると、次の結果が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐂</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>b</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(a, -), \mathbf{C}(b, -))
                \cong \mathbf{C}(b, a)</annotation>
            </semantics>
          </math></p>
        <p><img src="images/yoneda-embedding.jpg" style="width:60.0%" /></p>
        <p>これはまさに探していた2つのhom関手の間の自然変換だが、少しひねりがある。つまり、自然変換と射――<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(b, a)</annotation>
            </semantics>
          </math>
          の要素――の間の写像の向きが「間違って」いる。でも大丈夫だ。それは単に関手が反変なのを意味する。</p>
        <p><img src="images/yoneda-embedding-2.jpg" style="width:65.0%" /></p>
        <p>実際、予想以上のものが得られた。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">[</mo>
                <mi>𝐂</mi>
                <mo>,</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mo stretchy="true" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation>
            </semantics>
          </math>への写像は反変関手というだけではない――それは<em>充満忠実</em>
          (fully faithful)
          関手だ。充実性と忠実性という特性は、関手がhom集合をどう写すかを述べている。</p>
        <p><em>忠実</em> (faithful)
          関手はhom集合上の<em>単射</em>であり、つまり、異なる射を異なる射に写す。言い換えれば、射を合体させない。</p>
        <p><em>充満</em> (full)
          関手はhom集合上の<em>全射</em>であり、つまり、1つのhom集合をもう1つのhom集合の<em>上に</em>写し、後者を完全にカバーする。</p>
        <p>充満忠実関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>はhom集合上の<span id="bijection" class="keyword">全単射</span> (bijection)
          であり、両方の集合のすべての要素が1対1で写される。始域圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>のすべてのペアに対して、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐃</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{D}(F a, F b)</annotation>
            </semantics>
          </math>
          の間に全単射がある。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>の終域圏
          (この場合は関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">[</mo>
                <mi>𝐂</mi>
                <mo>,</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mo stretchy="true" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation>
            </semantics>
          </math>)
          だ。ただし、これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>が<em>対象</em>について全単射であることを意味しないので注意してほしい。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>内の対象のうち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>の像内にないものが存在する可能性があり、それらの対象のhom集合については何も言えない。</p>
        <h2 data-number="16.1" id="埋め込み"><span class="header-section-number">16.1</span> 埋め込み</h2>
        <p>先ほど説明した (反変)
          関手、すなわち、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の対象を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">[</mo>
                <mi>𝐂</mi>
                <mo>,</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mo stretchy="true" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation>
            </semantics>
          </math>内の関手に写す関手:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>→</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">a \to \mathbf{C}(a, -)</annotation>
            </semantics>
          </math></p>
        <p>によって<span id="Yoneda_embedding" class="keyword">米田埋め込み</span> (Yoneda embedding)
          が定義される。それは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>
          (厳密に言うと反変なので圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐂</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{C}^\mathit{op}</annotation>
            </semantics>
          </math>)
          を関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">[</mo>
                <mi>𝐂</mi>
                <mo>,</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mo stretchy="true" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation>
            </semantics>
          </math>の内部に<em>埋め込む</em>。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の対象を関手に写すだけでなく、それらの間のすべての接続を忠実に保持する。</p>
        <p>これは非常に有用な結果だ。なぜなら、数学者は関手圏について、特に終域が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>である関手についてよく知っているからだ。任意の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>について、関手圏へ埋め込むことで多くの知見を得られる。</p>
        <p>当然だが米田埋め込みにも双対があり、余米田埋め込み (co-Yoneda
          embedding)
          とも呼ばれる。始めの時点で各hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mo>−</mo>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(-, a)</annotation>
            </semantics>
          </math>
          の (始対象ではなく)
          終対象を固定しても良かったことに着目しよう。そうすれば反変hom関手が得られただろう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への反変関手は、おなじみの前層だ
          (たとえば、<a href="#limits-and-colimits">極限と余極限</a>を参照)。余米田埋め込みは圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の前層圏への埋め込みを定義する。射に対する作用は次のように与えられる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐂</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mo>−</mo>
                    <mo>,</mo>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mo>−</mo>
                    <mo>,</mo>
                    <mi>b</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(-, a), \mathbf{C}(-, b))
                \cong \mathbf{C}(a, b)</annotation>
            </semantics>
          </math></p>
        <p>数学者は前層圏についても多くのことを知っているので、そこに任意の圏を埋め込めるのは大きな戦果だ。</p>
        <h2 data-number="16.2" id="haskellへの応用"><span class="header-section-number">16.2</span> Haskellへの応用</h2>
        <p>Haskellでの米田埋め込みは、一方ではreader関手の自然変換の間の同型として、他方では
          (逆向きの) 関数として表せる:</p>
        <div class="sourceCode" id="cb367">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb367-1"><a href="#cb367-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> x<span class="op">.</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> x) ≅ b <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <p>(Reader関手が<code>((-&gt;) a)</code>と等価であることを思い出してほしい。)</p>
        <p>この恒等射の左辺は多相関数であり、<code>a</code>から<code>x</code>への関数と型<code>b</code>の値が与えられれば、型<code>x</code>の値を生成できる
          (関数<code>b -&gt; x</code>を非カリー化することにより、括弧で囲むのを省略する)。これをすべての<code>x</code>に対して行える唯一の方法は、関数が<code>b</code>を<code>a</code>に変換する方法を知っている場合だ。関数<code>b -&gt; a</code>に密かにアクセスできる必要がある。
        </p>
        <p>そのようなコンバーター<code>btoa</code>があれば、左辺を定義できる。左辺は<code>fromY</code>と呼ばれ、次のようになる:</p>
        <div class="sourceCode" id="cb368">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb368-1"><a href="#cb368-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fromY ::</span> (a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> x</span>
<span id="cb368-2"><a href="#cb368-2" aria-hidden="true" tabindex="-1"></a>fromY f b <span class="ot">=</span> f (btoa b)</span></code></pre>
        </div>
        <p>逆に、関数<code>fromY</code>があれば、恒等射で<code>fromY</code>を呼び出すことでコンバーターを復元できる:</p>
        <div class="sourceCode" id="cb369">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb369-1"><a href="#cb369-1" aria-hidden="true" tabindex="-1"></a>fromY<span class="ot"> id ::</span> b <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <p>これは型<code>fromY</code>と<code>btoa</code>の関数間の全単射を確立する。</p>
        <p>この同型を別の観点で見ると、<code>b</code>から<code>a</code>への関数のCPS符号化とも見なせる。引数<code>a -&gt; x</code>は継続
          (ハンドラー)
          だ。結果は<code>b</code>から<code>x</code>への関数であり、型<code>b</code>の値で呼ばれたとき、エンコードされた関数を前置合成した継続を実行する。</p>
        <p>米田埋め込みはHaskellのデータ構造の代替表現についても説明する。特に、非常に便利な<a
            href="https://bartoszmilewski.com/2015/07/13/from-lenses-to-yoneda-embedding/">レンズの表現</a>を<code>Control.Lens</code>ライブラリで提供する。
        </p>
        <h2 data-number="16.3" id="前順序の例"><span class="header-section-number">16.3</span> 前順序の例</h2>
        <p>この節の例はRobert
          Harperによって提案された。前順序によって定義された圏に米田埋め込みを適用するものだ。前順序は要素間に順序関係がある集合だ。順序関係は伝統的に<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mo>≤</mo>
              <annotation encoding="application/x-tex">\leqslant</annotation>
            </semantics>
          </math>
          (以下)
          で記述される。前順序に「前」が付いているのは、関係が推移律と反射律を満たす必要があるだけで、必ずしも反対称律を満たす必要はないからだ
          (すなわち、循環してもよい)。</p>
        <p>前順序関係をもつ集合は圏を生成する。対象はその集合の要素だ。対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への射は、対象が比較できない場合や<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant b</annotation>
            </semantics>
          </math>が真でない場合には存在せず、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant b</annotation>
            </semantics>
          </math>の場合には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への向きに存在する。ある対象から別の対象への射が2つ以上存在することはない。したがって、このような圏のhom集合はすべて、空集合または単集合だ。このような圏は<em>やせた圏</em>
          (thin category) と呼ばれる。</p>
        <p>この構成が実際に圏であることは簡単に納得できる。まず、矢は合成可能だ。なぜなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant b</annotation>
            </semantics>
          </math>かつ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>b</mi>
                <mo>≤</mo>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">b \leqslant c</annotation>
            </semantics>
          </math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant c</annotation>
            </semantics>
          </math>だからだ。そして、合成は結合性を持つ。恒等射も存在する。なぜなら、(基礎となる関係から再帰的に)
          すべての要素がそれ自身 (以下) となるからだ。</p>
        <p>これで前順序圏に余米田埋め込みを適用できるようになった。特に、射に対する作用には興味がある:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐂</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mo>−</mo>
                    <mo>,</mo>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mo>−</mo>
                    <mo>,</mo>
                    <mi>b</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(-, a), \mathbf{C}(-, b))
                \cong \mathbf{C}(a, b)</annotation>
            </semantics>
          </math></p>
        <p>右辺のhom集合が空集合でないのは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant b</annotation>
            </semantics>
          </math>のときだけだ。その場合は単集合となる。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant b</annotation>
            </semantics>
          </math>の場合、左辺には自然変換が1つだけ存在する。それ以外の場合は自然変換はない。</p>
        <p>では、前順序のhom関手間の自然変換とは何だろうか？
          それは2つの集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mo>−</mo>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(-, a)</annotation>
            </semantics>
          </math>
          と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mo>−</mo>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(-, b)</annotation>
            </semantics>
          </math>
          の間の関数の族でなければならない。前順序集合では、2つの集合はそれぞれ空集合か単集合だ。どんな関数があり得るか見てみよう。</p>
        <p>空集合からそれ自身への関数
          (空集合に作用する恒等射)、空集合から単集合への<code>absurd</code>関数
          (定義すべき要素が空集合には1つもないので、何もしない)、そして単集合からそれ自身への関数
          (要素が1つの集合に作用する恒等射)
          がある。単集合から空集合への組み合わせだけは禁じられている
          (そのような関数が単集合の要素に作用したとして、どんな値を返せばよいだろう？)。</p>
        <p>したがって、この自然変換は決してhom単集合をhom空集合に接続しない。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>x</mi>
                <mo>≤</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">x \leqslant a</annotation>
            </semantics>
          </math>
          (hom単集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>x</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(x, a)</annotation>
            </semantics>
          </math>)
          ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>x</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(x, b)</annotation>
            </semantics>
          </math>
          は空集合ではない。空でない<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>x</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(x, b)</annotation>
            </semantics>
          </math>
          は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>以下であることを意味する。したがって、ここでの自然変換が存在するためには、すべての<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>x</mi>
                <mo>≤</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">x \leqslant a</annotation>
            </semantics>
          </math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>x</mi>
                <mo>≤</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">x \leqslant b</annotation>
            </semantics>
          </math>が成り立つ必要がある:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mtext mathvariant="normal">for all</mtext>
                <mi>x</mi>
                <mo>,</mo>
                <mi>x</mi>
                <mo>≤</mo>
                <mi>a</mi>
                <mo>⇒</mo>
                <mi>x</mi>
                <mo>≤</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">\text{for all} x, x \leqslant a \Rightarrow x \leqslant b
              </annotation>
            </semantics>
          </math></p>
        <p>一方、余米田の補題によると、この自然変換の存在は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          が空でないか<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant b</annotation>
            </semantics>
          </math>であることと等価だ。まとめると、次の結果が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>b</mi>
                <mrow>
                  <mspace width="0.333em"></mspace>
                  <mtext mathvariant="normal"> if and only if for all </mtext>
                  <mspace width="0.333em"></mspace>
                </mrow>
                <mi>x</mi>
                <mo>,</mo>
                <mi>x</mi>
                <mo>≤</mo>
                <mi>a</mi>
                <mo>⇒</mo>
                <mi>x</mi>
                <mo>≤</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant b \text{ if and only if for all } x, x \leqslant a
                \Rightarrow x \leqslant b</annotation>
            </semantics>
          </math></p>
        <p>この結果に直接到達することもできただろう。直観的には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant b</annotation>
            </semantics>
          </math>ならば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>未満のすべての要素も<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>未満である必要がある。逆に、右辺の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>に代入すると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant b</annotation>
            </semantics>
          </math>となる。しかし、米田埋め込みを通じてこの結果に到達する方がはるかに刺激的なのは認めなければならない。</p>
        <h2 data-number="16.4" id="自然性"><span class="header-section-number">16.4</span> 自然性</h2>
        <p>米田の補題は、自然変換の集合と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>の対象との間に同型射を設ける。自然変換は関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">[</mo>
                <mi>𝐂</mi>
                <mo>,</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mo stretchy="true" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]</annotation>
            </semantics>
          </math>内の射だ。任意の2つの関手間の自然変換の集合は、その圏におけるhom集合だ。米田の補題とは次の同型だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐂</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(a, -), F) \cong F a
              </annotation>
            </semantics>
          </math></p>
        <p>この同型は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>でも<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>でも自然だとわかる。言い換えれば、直積圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐂</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mo>×</mo>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}] \times \mathbf{C}</annotation>
            </semantics>
          </math>から取られたペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>F</mi>
                <mo>,</mo>
                <mi>a</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(F, a)</annotation>
            </semantics>
          </math>
          で自然だ。ここでは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>を関手圏の<em>対象</em>として扱っていることに注意してほしい。
        </p>
        <p>これが何を意味するのか少し考えてみよう。自然同型は2つの関手の間の反転可能な<em>自然変換</em>だ。そして実際、前述の同型の右辺は関手だ。それは<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐂</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mo>×</mo>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}]\times \mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への関手だ。ペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>F</mi>
                <mo>,</mo>
                <mi>a</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(F, a)</annotation>
            </semantics>
          </math>
          に対するその作用は集合だ――関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>を対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>において評価した結果だ。この関手は評価関手
          (evaluation functor) と呼ばれる。
        </p>
        <p>左辺も関手であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>F</mi>
                <mo>,</mo>
                <mi>a</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(F, a)</annotation>
            </semantics>
          </math>
          を自然変換の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐂</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(a, -), F)</annotation>
            </semantics>
          </math>
          に変換する。</p>
        <p>これらが本当に関手だと示すには、射に対する作用も定義しなければならない。しかし、ペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>F</mi>
                <mo>,</mo>
                <mi>a</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(F, a)</annotation>
            </semantics>
          </math>
          と
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>G</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(G, b)</annotation>
            </semantics>
          </math>
          の間の射とは何だろうか？ それは射のペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>Φ</mi>
                <mo>,</mo>
                <mi>f</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(\Phi, f)</annotation>
            </semantics>
          </math>
          だ。1番目は関手間の射――自然変換――であり、2番目は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の正則な射だ。
        </p>
        <p>評価関手はこのペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>Φ</mi>
                <mo>,</mo>
                <mi>f</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(\Phi, f)</annotation>
            </semantics>
          </math>
          を取り、2つの集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">G b</annotation>
            </semantics>
          </math>の間の関数に写す。このような関数は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>における<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Φ</mi>
              <annotation encoding="application/x-tex">\Phi</annotation>
            </semantics>
          </math>のコンポーネント
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F a</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">G a</annotation>
            </semantics>
          </math>に写す)
          と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>によってリフトされた射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>から、簡単に構築できる。
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>G</mi>
                  <mi>f</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>⋅</mo>
                <msub>
                  <mi>Φ</mi>
                  <mi>a</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">(G f) \cdot \Phi_a</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Φ</mi>
              <annotation encoding="application/x-tex">\Phi</annotation>
            </semantics>
          </math>の自然性により、これは次と同じであることに注意してほしい:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>Φ</mi>
                  <mi>b</mi>
                </msub>
                <mo>⋅</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>f</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\Phi_b \cdot (F f)</annotation>
            </semantics>
          </math></p>
        <p>同型射全体の自然性を証明するつもりはない――関手とは何かが掴めれば、ごく機械的に証明できる。それは同型が関手と自然変換から成り立っているという事実から導かれる。うまくいかないはずがない。</p>
        <h2 data-number="16.5" id="課題-13"><span class="header-section-number">16.5</span> 課題</h2>
        <ol type="1">
          <li>
            <p>余米田埋め込みをHaskellで表現せよ。</p>
          </li>
          <li>
            <p><code>fromY</code>と<code>btoa</code>の間に確立された全単射が同型射であることを示せ
              (2つの写像は互いに逆だ)。</p>
          </li>
          <li>
            <p>モノイドについて米田埋め込みを実現せよ。そのモノイドの単一の対象に対応する関手は何か？
              どのような自然変換がモノイド射に対応するか？</p>
          </li>
          <li>
            <p><em>共変</em>米田埋め込みの全順序への応用は何か？
              (この問いはGershom Bazermanによって提案された。)</p>
          </li>
          <li>
            <p>米田埋め込みを使えば、任意の関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mi>𝐂</mi>
                    <mo>,</mo>
                    <mi>𝐃</mi>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{D}]</annotation>
                </semantics>
              </math>を関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mrow>
                      <mo stretchy="true" form="prefix">[</mo>
                      <mi>𝐂</mi>
                      <mo>,</mo>
                      <mi>𝐃</mi>
                      <mo stretchy="true" form="postfix">]</mo>
                    </mrow>
                    <mo>,</mo>
                    <mrow>
                      <mi>𝐒</mi>
                      <mi>𝐞</mi>
                      <mi>𝐭</mi>
                    </mrow>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <annotation encoding="application/x-tex">[[\mathbf{C}, \mathbf{D}], \mathbf{Set}]</annotation>
                </semantics>
              </math>に埋め込める。それが射
              (この場合は自然変換) にどう作用するか説明せよ。</p>
          </li>
        </ol>
        <h1 data-number="17" id="射のすべて"><span class="header-section-number">17</span> 射のすべて</h1>
        <p>まだ圏論は射に関するものだと納得していないなら、私の仕事が不十分だったようだ。次の話題である随伴
          (adjunction)
          は、hom集合の同型射によって定義されるため、hom集合の構成単位についての直観を見直すのが理にかなっている。また、これまで見てきた多くの構成を復習しておくのも有意義だろう。それらは、随伴が提供するさらに汎用的な語彙によって詳しく記述できるからだ。
        </p>
        <h2 data-number="17.1" id="関手"><span class="header-section-number">17.1</span> 関手</h2>
        <p>
          まず始めに、本当に関手を射の写像だと考えるべきだ。これはHaskellで<code>fmap</code>を中心に展開される<code>Functor</code>型クラスの定義において強調されている考え方だ。当然、関手は対象――射の終点――も写す。そうでなければ、合成の保存について語れない。対象は射のどのペアが合成可能か教えてくれる。一方の射の終対象がもう一方の始対象と等しくなければ合成できない。したがって、射の合成を<span
            id="lifted" class="keyword">リフトされた</span>射の合成に写したい場合、それらの終点の写像は十分に決定される。</p>
        <h2 data-number="17.2" id="可換図式"><span class="header-section-number">17.2</span> 可換図式</h2>
        <p>射の多くの性質は可換図式によって表される。もし特定の射が他の射の合成として複数の方法で記述できるなら、可換図式があることになる。</p>
        <p>特に、可換図式はほぼすべての普遍的構成の基礎となっている
          (始対象と終対象という例外を除く)。このことはすでに、積、余積、その他さまざまな
          (余) 極限、冪乗対象、自由モノイドなどの定義で見てきた。</p>
        <p>積は普遍的構成の簡単な例だ。ある2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>について、その積となる普遍性を持つような、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>のペアを伴う対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>の存在を確認する。</p>
        <p><img src="images/productranking.jpg" style="width:30.0%" /></p>
        <p>
          積は極限の特別な場合でもある。極限は錐によって定義される。一般的な錐は可換図式から作成される。それらの図式の可換性は、関手の写像のための適切な自然条件で置き換えてよい。このようにして、可換性は自然変換という高水準言語に対するアセンブリ言語の役割に降格される。
        </p>
        <h2 data-number="17.3" id="自然変換"><span class="header-section-number">17.3</span> 自然変換</h2>
        <p>一般に、自然変換は射から可換正方図式への写像が必要なときに非常に便利だ。自然性の正方図式の対辺は、ある射<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>を2つの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>で写したものだ。他の辺は自然変換のコンポーネントだ
          (それらも射だ)。</p>
        <p><img src="images/3_naturality.jpg" style="width:35.0%" /></p>
        <p>自然性は、「隣接する」 (射でつながった)
          コンポーネントに移っても、圏や関手の構造に反しないことを意味する。まず自然変換のコンポーネントを使って対象間のギャップを埋めてから関手を使って隣の対象にジャンプするのでも、その逆でも関係ない。2つの方向は直交している。いうなれば、自然変換では左右に動けて、関手では上下や前後に動ける。関手の<em>像</em>は、対象となる圏でのシートとして視覚化できる。自然変換はFに対応するシートをGに対応する別のシートに写す。
        </p>
        <p><img src="images/sheets.png" style="width:35.0%" /></p>
        <p>この直交性のHaskellにおける例を見た。そこでは、関手の作用はコンテナの形状を変更せずに内容を変更し、自然変換は内容を変更せずに別のコンテナに再パッケージした。これらの操作の順序は関係ない。</p>
        <p>
          極限の定義の中で錐が自然変換に置き換えられるのを見た。自然性はすべての錐について側面が可換だと保証する。さらに、極限は錐の<em>間の</em>写像によって定義される。これらの写像は可換性条件も満たす必要がある。(たとえば、積の定義における三角形は可換である必要がある)。
        </p>
        <p>これらの条件も自然性によって代替できる。<em>普遍な</em>錐、すなわち極限は、(反変)
          hom関手間の自然変換として定義されていたのを覚えているだろう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∷</mo>
                <mi>c</mi>
                <mo>→</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mrow></mrow>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">F \Colon c \to \mathbf{C}(c, %
                \mathbf{Lim}{}%
                {D})</annotation>
            </semantics>
          </math></p>
        <p>また、(反変)
          関手は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の対象を、それ自体が自然変換である錐に写す:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mo>∷</mo>
                <mi>c</mi>
                <mo>→</mo>
                <mrow>
                  <mi>𝐍</mi>
                  <mi>𝐚</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>Δ</mi>
                    <mi>c</mi>
                  </msub>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">G \Colon c \to \mathbf{Nat}(\Delta_c, D)</annotation>
            </semantics>
          </math></p>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>は定関手、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>での図式を定義する関手だ。関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>は両方とも、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の射に対する作用が明確に定義されている。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>の間の特定の自然変換が<em>同型</em>なのは偶然だ。</p>
        <h2 data-number="17.4" id="自然同型"><span class="header-section-number">17.4</span> 自然同型</h2>
        <p>
          自然同型――すべてのコンポーネントが可逆な自然変換――は、圏論で「2つのものは同じである」と言うときの言い方だ。そのような変換のコンポーネントは対象間の同型射――逆が存在する射――でなければならない。関手の像をシートとして表す場合、自然同型はシート間の1対1の可逆な写像だ。
        </p>
        <h2 data-number="17.5" id="hom集合"><span class="header-section-number">17.5</span> Hom集合</h2>
        <p>それにしても、射とは何だろう？
          射は対象よりも構造が豊かだ。対象とは違って、射には2つの端がある。しかし、始対象と終対象を固定すると、それら2つの間の射は平凡な集合を
          (少なくとも局所的に小さい圏では)
          形成する。この集合の要素を区別するために<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>や<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>のような名前を付けることはできるが、実際のところ、違いは何なのだろう？</p>
        <p>あるhom集合の射の間の本質的な差異は、(隣接するhom集合 (abutting
          hom-sets) からの)
          他の射と合成する方法にある。ある射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>に
          (前置または後置)
          合成したものと<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>に合成したものが異なる場合、すなわち:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>h</mi>
                <mo>∘</mo>
                <mi>f</mi>
                <mo>≠</mo>
                <mi>h</mi>
                <mo>∘</mo>
                <mi>g</mi>
              </mrow>
              <annotation encoding="application/x-tex">h \circ f \neq h \circ g</annotation>
            </semantics>
          </math></p>
        <p>ならば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>の違いを直接「観察」できる。しかし、違いが直接観察できない場合でも、関手を使えばhom集合にズームインできる。関手<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>は2つの射を別々の射に写せる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>f</mi>
                <mo>≠</mo>
                <mi>F</mi>
                <mi>g</mi>
              </mrow>
              <annotation encoding="application/x-tex">F f \neq F g</annotation>
            </semantics>
          </math></p>
        <p>これらの射が属する圏はより豊かで、隣接するhom集合による分解能がより高い。たとえば:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>h</mi>
                <mi>′</mi>
                <mo>∘</mo>
                <mi>F</mi>
                <mi>f</mi>
                <mo>≠</mo>
                <mi>h</mi>
                <mi>′</mi>
                <mo>∘</mo>
                <mi>F</mi>
                <mi>g</mi>
              </mrow>
              <annotation encoding="application/x-tex">h&#39; \circ F f \neq h&#39; \circ F g</annotation>
            </semantics>
          </math></p>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>h</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">h&#39;</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>の像に含まれない。</p>
        <h2 data-number="17.6" id="hom集合同型"><span class="header-section-number">17.6</span> Hom集合同型</h2>
        <p>
          圏論では多くの構造がhom集合間の同型に依存している。しかし、hom集合はただの集合なので、それらの間の同型射から分かることはあまりない。有限集合については、同型射は要素数が同じだと示すだけだ。無限集合なら、濃度が同じでなければならない。しかし、hom集合の意味のある同型射はすべて、合成も考慮しなければならない。そして、合成には複数のhom集合が関わる。あらゆるhom集合にまたがる同型を定義する必要があり、合成と相互運用できるような何らかの互換性の条件を課す必要がある。そして、<span
            id="natural" class="keyword">自然</span>同型はその条件にぴったり合う。</p>
        <p>だが、hom集合の自然同型とは何だろう？
          自然性は、集合間ではなく、関手間の写像の特性だ。つまり、今はhom集合値関手の間の自然同型について話している。それらの関手は単なる集合値関手ではない。射に対するその作用は、適切なhom関手によって導かれる。射はhom関手によって、前置合成か後置合成のどちらかで
          (合成の変性に依存して) 正準的に写される。</p>
        <p>米田埋め込みはそのような同型の一例だ。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内のhom集合を関手圏内のhom集合に写す。そしてそれは自然だ。米田埋め込みの関手は、1つは<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>のhom関手で、もう1つは対象をhom集合間の自然変換の集合に写す。</p>
        <p>極限の定義もhom集合間の自然同型だ
          (ここでも2番目は関手圏内のhom集合だ):</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐢</mi>
                    <mi>𝐦</mi>
                  </mrow>
                  <mrow></mrow>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≃</mo>
                <mrow>
                  <mi>𝐍</mi>
                  <mi>𝐚</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>Δ</mi>
                    <mi>c</mi>
                  </msub>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c, %
                \mathbf{Lim}{}%
                {D}) \simeq \mathbf{Nat}(\Delta_c, D)</annotation>
            </semantics>
          </math></p>
        <p>冪乗対象や自由モノイドの構成も、hom集合間の自然同型として書き直せることが分かる。</p>
        <p>これは偶然の一致ではない――次に見るように、これらはhom集合の自然同型として定義される随伴の様々な例にすぎない。</p>
        <h2 data-number="17.7" id="hom集合の非対称性"><span class="header-section-number">17.7</span> Hom集合の非対称性</h2>
        <p>随伴を理解するのに役立つ観察結果はもう1つある。Hom集合は一般に対称ではない。Hom集合<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          は、hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(b, a)</annotation>
            </semantics>
          </math>
          と大きく異なることがよくある。この非対称性の究極の例は、半順序を圏とみなすことだ。半順序では、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>以下の場合に限り、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への射が存在する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>が異なる場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>へと逆方向に進む射は存在しない。Hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          が空集合でない (ここでは単集合を意味する)
          なら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>=</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a = b</annotation>
            </semantics>
          </math>でない限り、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(b, a)</annotation>
            </semantics>
          </math>
          は空でなければならない。この圏の矢の流れは一方向に決まっている。</p>
        <p>関係が反対称でなくてもよい前順序も、たまにある循環を除けば「ほとんど」方向付けられている。任意の圏を前順序の一般化と見なすのは便利だ。</p>
        <p>前順序はやせた圏だ――すべてのhom集合が単集合か空集合のどちらかだ。一般の圏は「厚い」(thick)
          前順序として可視化できる。</p>
        <h2 data-number="17.8" id="課題-14"><span class="header-section-number">17.8</span> 課題</h2>
        <ol type="1">
          <li>縮退 (degenerate)
            した自然条件の例を考え、適切な図を描け。たとえば、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>F</mi>
                <annotation encoding="application/x-tex">F</annotation>
              </semantics>
            </math>または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>G</mi>
                <annotation encoding="application/x-tex">G</annotation>
              </semantics>
            </math>のどちらかが対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>a</mi>
                <annotation encoding="application/x-tex">a</annotation>
              </semantics>
            </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>b</mi>
                <annotation encoding="application/x-tex">b</annotation>
              </semantics>
            </math>
            (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>f</mi>
                  <mo>∷</mo>
                  <mi>a</mi>
                  <mo>→</mo>
                  <mi>b</mi>
                </mrow>
                <annotation encoding="application/x-tex">f \Colon a \to b</annotation>
              </semantics>
            </math>の終わり)
            の両方を同じ対象に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>F</mi>
                  <mi>a</mi>
                  <mo>=</mo>
                  <mi>F</mi>
                  <mi>b</mi>
                </mrow>
                <annotation encoding="application/x-tex">F a = F b</annotation>
              </semantics>
            </math>または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>G</mi>
                  <mi>a</mi>
                  <mo>=</mo>
                  <mi>G</mi>
                  <mi>b</mi>
                </mrow>
                <annotation encoding="application/x-tex">G a = G b</annotation>
              </semantics>
            </math>のように写したらどうなるか？
            (この方法で錐または余錐が得られることに注目してほしい。)
            次に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>F</mi>
                  <mi>a</mi>
                  <mo>=</mo>
                  <mi>G</mi>
                  <mi>a</mi>
                </mrow>
                <annotation encoding="application/x-tex">F a = G a</annotation>
              </semantics>
            </math>または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>F</mi>
                  <mi>b</mi>
                  <mo>=</mo>
                  <mi>G</mi>
                  <mi>b</mi>
                </mrow>
                <annotation encoding="application/x-tex">F b = G b</annotation>
              </semantics>
            </math>のどちらかの場合について考えよ。最後に、自分自身へループする射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>f</mi>
                  <mo>∷</mo>
                  <mi>a</mi>
                  <mo>→</mo>
                  <mi>a</mi>
                </mrow>
                <annotation encoding="application/x-tex">f \Colon a \to a</annotation>
              </semantics>
            </math>から始めた場合はどうか？</li>
        </ol>
        <h1 data-number="18" id="adjunctions"><span class="header-section-number">18</span> 随伴</h1>
        <p>
          数学では、あるものが別のものに似ているという言い方はいろいろある。最も厳密なのは等価性だ。互いを区別する方法がなければ、2つのものは等しい。想像できるあらゆる状況において、一方を他方の代わりにできる。たとえば、可換図式について話すときはいつも射の<span
            id="equality" class="keyword">等価性</span> (equality)
          を使っていることに気が付いていただろうか？ それは、射が集合 (hom集合)
          を形成し、集合の要素は等価性を確認できるからだ。</p>
        <p>
          しかし、等価性は強すぎることが多い。実際には等価ではないのに、あらゆる意図と目的に照らして同じであるという例はたくさんある。たとえば、ペアの型<code>(Bool, Char)</code>は<code>(Char, Bool)</code>と厳密に等しいわけではないが、含んでいる情報が同じなのは分かっている。この概念を最もうまく捉えたものは、2つの型の間の<em>同型射</em>――反転可能な射だ。これは射なので、構造を保存する。そして同型
          (isomorphism) の “iso”
          は、もとの場所に帰り着く往復旅行の一部であることを意味する。どちら側から出発するかは関係ない。ペアにおいては、この同型射は<code>swap</code>と呼ばれる:</p>
        <div class="sourceCode" id="cb370">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb370-1"><a href="#cb370-1" aria-hidden="true" tabindex="-1"></a><span class="ot">swap ::</span> (a,b) <span class="ot">-&gt;</span> (b,a)</span>
<span id="cb370-2"><a href="#cb370-2" aria-hidden="true" tabindex="-1"></a>swap (a,b) <span class="ot">=</span> (b,a)</span></code></pre>
        </div>
        <p><code>swap</code>はそれ自身の逆だ。</p>
        <h2 data-number="18.1" id="随伴と単位余単位ペア"><span class="header-section-number">18.1</span> 随伴と単位/余単位ペア</h2>
        <p>圏が同型だと述べるときは、これを圏間の写像、すなわち関手によって表す。圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>への逆変換可能な関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>
          (“right”)
          が存在する場合に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>は同型だと言えるようにしたい。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>に戻る別の関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>
          (“left”)
          が存在し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>と合成することで恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>I</mi>
              <annotation encoding="application/x-tex">I</annotation>
            </semantics>
          </math>に等しくなる。合成は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">R \circ L</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \circ R</annotation>
            </semantics>
          </math>の2種類があるので、恒等関手も<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>内の2種類がある。</p>
        <p><img src="images/adj-1.jpg" style="width:50.0%" /></p>
        <p>しかし、ここがややこしいところだ:
          2つの関手が<em>等しい</em>とは何を意味するのだろうか？
          次の等価性は何を意味するだろう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
                <mo>=</mo>
                <msub>
                  <mi>I</mi>
                  <mi>𝐃</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">R \circ L = I_{\mathbf{D}}</annotation>
            </semantics>
          </math></p>
        <p>あるいは、次のものは:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
                <mo>=</mo>
                <msub>
                  <mi>I</mi>
                  <mi>𝐂</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">L \circ R = I_{\mathbf{C}}</annotation>
            </semantics>
          </math></p>
        <p>
          関手の等価性を対象の等価性として定義するのは合理的に思える。2つの関手が同じ対象に作用するなら、同じ対象が生成されるはずだ。しかし、一般に、対象の等価性の概念は任意の圏においては存在しない。それは単に定義の一部ではない。(この「等価性とはなにか」といううさぎの穴を深く掘り下げると、ホモトピー型理論に辿り着く。)
        </p>
        <p>関手は圏の圏における射<em>である</em>から、それらは等価性で比較可能なはずだ、と主張したくなるかもしれない。実際、対象が集合を形成するような小さい圏を扱う限り、集合の要素の等価性を使って対象を等価性比較できる。
        </p>
        <p>ただし、覚えておいてほしい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>は実際には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏のhom集合には追加の構造がある――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟏</mn>
              <annotation encoding="application/x-tex">\mathbf{1}</annotation>
            </semantics>
          </math>-射の間に作用する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-射がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟏</mn>
              <annotation encoding="application/x-tex">\mathbf{1}</annotation>
            </semantics>
          </math>-射は関手であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-射は自然変換だ。だから、関手について述べるときに自然同型を等価性の代わりと考えるのは、より自然なのだ
          (この駄洒落は避けようがない！)。</p>
        <p>したがって、圏の同型の代わりに<span id="equivalence" class="keyword">同値性</span> (equivalence)
          という、より一般的な概念を考えるのが理にかなっている。2つの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>が<em>同値</em>
          (equivalent)
          であるとは、それらの間を行き来する2つの関手があり、(どちらかの向きの)
          合成が恒等関手と<span id="naturally_isomorphic" class="keyword">自然同型</span> (naturally isomorphic)
          であることだ。言い換えると、合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">R \circ L</annotation>
            </semantics>
          </math>と恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>I</mi>
                <mi>𝐃</mi>
              </msub>
              <annotation encoding="application/x-tex">I_{\mathbf{D}}</annotation>
            </semantics>
          </math>の間には双方向の自然変換があり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \circ R</annotation>
            </semantics>
          </math>と恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>I</mi>
                <mi>𝐂</mi>
              </msub>
              <annotation encoding="application/x-tex">I_{\mathbf{C}}</annotation>
            </semantics>
          </math>の間にも別の双方向の自然変換がある。</p>
        <p>随伴は同値性よりもさらに弱い。なぜなら、2つの関手の合成が恒等関手と<span id="isomorphic" class="keyword">同型</span> (isomorphic)
          でなくてもよいからだ。その代わり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>I</mi>
                <mi>𝐃</mi>
              </msub>
              <annotation encoding="application/x-tex">I_{\mathbf{D}}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">R \circ L</annotation>
            </semantics>
          </math>への<span id="one_way2" class="keyword">一方向の</span>自然変換と、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \circ R</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>I</mi>
                <mi>𝐂</mi>
              </msub>
              <annotation encoding="application/x-tex">I_{\mathbf{C}}</annotation>
            </semantics>
          </math>への別の一方向の自然変換が存在する必要がある。これら2つの自然変換の表記を以下に示す:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>η</mi>
                    <mo>∷</mo>
                    <msub>
                      <mi>I</mi>
                      <mi>𝐃</mi>
                    </msub>
                    <mo>→</mo>
                    <mi>R</mi>
                    <mo>∘</mo>
                    <mi>L</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>ε</mi>
                    <mo>∷</mo>
                    <mi>L</mi>
                    <mo>∘</mo>
                    <mi>R</mi>
                    <mo>→</mo>
                    <msub>
                      <mi>I</mi>
                      <mi>𝐂</mi>
                    </msub>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                \eta \Colon I_{\mathbf{D}} \to R \circ L \\
                \varepsilon \Colon L \circ R \to I_{\mathbf{C}}
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>は随伴の単位
          (unit)
          と呼ばれ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>は余単位
          (counit) と呼ばれる。</p>
        <p>これら2つの定義の非対称性に注目してほしい。一般には、残りの2つの写像は存在しない:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>R</mi>
                    <mo>∘</mo>
                    <mi>L</mi>
                    <mo>→</mo>
                    <msub>
                      <mi>I</mi>
                      <mi>𝐃</mi>
                    </msub>
                    <mspace width="1.0em"></mspace>
                    <mspace width="1.0em"></mspace>
                    <mtext mathvariant="normal">必須ではない</mtext>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <msub>
                      <mi>I</mi>
                      <mi>𝐂</mi>
                    </msub>
                    <mo>→</mo>
                    <mi>L</mi>
                    <mo>∘</mo>
                    <mi>R</mi>
                    <mspace width="1.0em"></mspace>
                    <mspace width="1.0em"></mspace>
                    <mtext mathvariant="normal">必須ではない</mtext>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                R \circ L \to I_{\mathbf{D}} \quad\quad\text{必須ではない} \\
                I_{\mathbf{C}} \to L \circ R \quad\quad\text{必須ではない}
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>この非対称性のため、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>は関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>に対する[左随伴]{.keyword
          #left adjoint} (left adjoint)
          と呼ばれ、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>に対する右随伴
          (right adjoint)
          と呼ばれる。(当然、左と右に意味があるのは図を特定の向きに描いた場合だけだ)。</p>
        <p>随伴は次のように略記される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>⊣</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \dashv R</annotation>
            </semantics>
          </math></p>
        <p>随伴をよりよく理解するために、単位と余単位をさらに詳しく分析してみよう。</p>
        <p><img src="images/adj-unit.jpg" style="width:50.0%" /></p>
        <p>まずは単位から始めよう。これは自然変換なので、射の族だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>d</mi>
              <annotation encoding="application/x-tex">d</annotation>
            </semantics>
          </math>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>のコンポーネントは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>I</mi>
                <mi>d</mi>
              </mrow>
              <annotation encoding="application/x-tex">I d</annotation>
            </semantics>
          </math>
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>d</mi>
              <annotation encoding="application/x-tex">d</annotation>
            </semantics>
          </math>に等しい)
          と
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>R</mi>
                  <mo>∘</mo>
                  <mi>L</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mi>d</mi>
              </mrow>
              <annotation encoding="application/x-tex">(R \circ L) d</annotation>
            </semantics>
          </math>
          (図中の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>d</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">d&#39;</annotation>
            </semantics>
          </math>)
          の間の射となる:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>η</mi>
                  <mi>d</mi>
                </msub>
                <mo>∷</mo>
                <mi>d</mi>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>R</mi>
                  <mo>∘</mo>
                  <mi>L</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mi>d</mi>
              </mrow>
              <annotation encoding="application/x-tex">\eta_d \Colon d \to (R \circ L) d</annotation>
            </semantics>
          </math></p>
        <p>合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">R \circ L</annotation>
            </semantics>
          </math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の自己関手であることに注意してほしい。</p>
        <p>この等式は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>内の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>d</mi>
              <annotation encoding="application/x-tex">d</annotation>
            </semantics>
          </math>を始域として選択でき、往復旅行する関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">R \circ L</annotation>
            </semantics>
          </math>を使って終域<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>d</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">d&#39;</annotation>
            </semantics>
          </math>を選択できることを示している。そして、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>η</mi>
                <mi>d</mi>
              </msub>
              <annotation encoding="application/x-tex">\eta_d</annotation>
            </semantics>
          </math>という矢が終域に向けて放たれる。</p>
        <p><img src="images/adj-counit.jpg" style="width:50.0%" /></p>
        <p>同様に、余単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>のコンポーネントは次のように記述できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>ε</mi>
                  <mi>c</mi>
                </msub>
                <mo>∷</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>L</mi>
                  <mo>∘</mo>
                  <mi>R</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mi>c</mi>
                <mo>→</mo>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon_{c} \Colon (L \circ R) c \to c</annotation>
            </semantics>
          </math></p>
        <p>これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>を終域として選択でき、ラウンドトリップ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \circ R</annotation>
            </semantics>
          </math>を使って始域<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
                <mo>=</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>L</mi>
                  <mo>∘</mo>
                  <mi>R</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39; = (L \circ R) c</annotation>
            </semantics>
          </math>を選択できることを示している。そして、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>ε</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\varepsilon_{c}</annotation>
            </semantics>
          </math>という矢が始域から終域に向けて放たれる。</p>
        <p>単位と余単位について別の見方をすると、単位は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>に恒等関手を挿入できる場所ならどこでも合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">R \circ L</annotation>
            </semantics>
          </math>を<em>導入</em>
          (introduce)
          でき、余単位は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の恒等射で置き換えることで合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \circ R</annotation>
            </semantics>
          </math>を<em>除去</em>
          (eliminate)
          できる。これにより、導入した後で除去すれば何も変更されないことを保証するいくつかの「自明な」整合性条件が導かれる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>L</mi>
                    <mo>=</mo>
                    <mi>L</mi>
                    <mo>∘</mo>
                    <msub>
                      <mi>I</mi>
                      <mi>𝐃</mi>
                    </msub>
                    <mo>→</mo>
                    <mi>L</mi>
                    <mo>∘</mo>
                    <mi>R</mi>
                    <mo>∘</mo>
                    <mi>L</mi>
                    <mo>→</mo>
                    <msub>
                      <mi>I</mi>
                      <mi>𝐂</mi>
                    </msub>
                    <mo>∘</mo>
                    <mi>L</mi>
                    <mo>=</mo>
                    <mi>L</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>R</mi>
                    <mo>=</mo>
                    <msub>
                      <mi>I</mi>
                      <mi>𝐃</mi>
                    </msub>
                    <mo>∘</mo>
                    <mi>R</mi>
                    <mo>→</mo>
                    <mi>R</mi>
                    <mo>∘</mo>
                    <mi>L</mi>
                    <mo>∘</mo>
                    <mi>R</mi>
                    <mo>→</mo>
                    <mi>R</mi>
                    <mo>∘</mo>
                    <msub>
                      <mi>I</mi>
                      <mi>𝐂</mi>
                    </msub>
                    <mo>=</mo>
                    <mi>R</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                L = L \circ I_{\mathbf{D}} \to L \circ R \circ L \to I_{\mathbf{C}} \circ L = L \\
                R = I_{\mathbf{D}} \circ R \to R \circ L \circ R \to R \circ I_{\mathbf{C}} = R
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>これらは、次の図式を可換にするので、三角恒等式 (triangular identity)
          と呼ばれる:</p>
        <p><img src="images/triangles.png" /></p>
        <p><img src="images/triangles-2.png" /></p>
        <p>これらは関手圏の図式だ。つまり、矢は自然変換であり、それらの合成は自然変換の水平合成だ。コンポーネントで表すと、これらの恒等式は次のようになる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <msub>
                      <mi>ε</mi>
                      <mrow>
                        <mi>L</mi>
                        <mi>d</mi>
                      </mrow>
                    </msub>
                    <mo>∘</mo>
                    <mi>L</mi>
                    <msub>
                      <mi>η</mi>
                      <mi>d</mi>
                    </msub>
                    <mo>=</mo>
                    <mi>i</mi>
                    <msub>
                      <mi>d</mi>
                      <mrow>
                        <mi>L</mi>
                        <mi>d</mi>
                      </mrow>
                    </msub>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>R</mi>
                    <msub>
                      <mi>ε</mi>
                      <mi>c</mi>
                    </msub>
                    <mo>∘</mo>
                    <msub>
                      <mi>η</mi>
                      <mrow>
                        <mi>R</mi>
                        <mi>c</mi>
                      </mrow>
                    </msub>
                    <mo>=</mo>
                    <mi>i</mi>
                    <msub>
                      <mi>d</mi>
                      <mrow>
                        <mi>R</mi>
                        <mi>c</mi>
                      </mrow>
                    </msub>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                \varepsilon_{L d} \circ L \eta_d = id_{L d} \\
                R \varepsilon_{c} \circ \eta_{R c} = id_{R c}
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>Haskellでは単位と余単位を別の名前でよく見かける。単位は<code>return</code>
          (あるいは<code>Applicative</code>の定義では<code>pure</code>)
          として知られている:</p>
        <div class="sourceCode" id="cb371">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb371-1"><a href="#cb371-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span><span class="ot"> ::</span> d <span class="ot">-&gt;</span> m d</span></code></pre>
        </div>
        <p>また、余単位は<code>extract</code>として知られている:</p>
        <div class="sourceCode" id="cb372">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb372-1"><a href="#cb372-1" aria-hidden="true" tabindex="-1"></a><span class="ot">extract ::</span> w c <span class="ot">-&gt;</span> c</span></code></pre>
        </div>
        <p>ここで、<code>m</code>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">R \circ L</annotation>
            </semantics>
          </math>に対応する
          (自己)
          関手であり、<code>w</code>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \circ R</annotation>
            </semantics>
          </math>に対応する
          (自己)
          関手だ。後で述べるように、これらはそれぞれモナドとコモナドの定義の一部だ。</p>
        <p>自己関手をコンテナと見なすなら、単位 (すなわち<code>return</code>)
          は任意の型の値に対して既定の箱を生成する多相関数だ。余単位
          (すなわち<code>extract</code>) はその逆を行う:
          コンテナから単一の値を取得または生成する。</p>
        <p>後で述べるように、随伴関手の各ペアはモナドとコモナドを定義する。逆に、すべてのモナドやコモナドは随伴関手のペアに分解され得る――ただし、その分解は一意ではない。</p>
        <p>Haskellではモナドをよく使うが、それらを随伴関手のペアに分解することはめったにない。その主な理由は、それらの関手によって通常は<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐇</mi>
                <mi>𝐚</mi>
                <mi>𝐬</mi>
                <mi>𝐤</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Hask}</annotation>
            </semantics>
          </math>の外へ追い出されるからだ。</p>
        <p>しかし、Haskellでは<span id="endofunctor"
            class="keyword">自己関手</span>の随伴を定義できる。以下は<code>Data.Functor.Adjunction</code>から引用した定義の一部だ:</p>
        <div class="sourceCode" id="cb373">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb373-1"><a href="#cb373-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Functor</span> f, <span class="dt">Representable</span> u) <span class="ot">=&gt;</span></span>
<span id="cb373-2"><a href="#cb373-2" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Adjunction</span> f u <span class="op">|</span> f <span class="ot">-&gt;</span> u, u <span class="ot">-&gt;</span> f <span class="kw">where</span></span>
<span id="cb373-3"><a href="#cb373-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    unit ::</span> a <span class="ot">-&gt;</span> u (f a)</span>
<span id="cb373-4"><a href="#cb373-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    counit ::</span> f (u a) <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <p>
          この定義には説明が必要だ。まず、これは多パラメーター型クラスを記述している――2つのパラメーターは<code>f</code>と<code>u</code>だ。その2つの型コンストラクターの間に<code>Adjunction</code>という関係を確立している。
        </p>
        <p>バーティカルバーの後の追加条件は、関数の依存関係を指定している。たとえば、<code>f -&gt; u</code>は<code>f</code>によって<code>u</code>が決定されることを意味する
          (<code>f</code>と<code>u</code>の関係は関数で、ここでは型コンストラクターについての関数だ)。逆に、<code>u -&gt; f</code>は、<code>u</code>が分かれば<code>f</code>が一意に決まることを意味する。
        </p>
        <p>なぜHaskellでは右随伴<code>u</code>が<span id="representable2"
            class="keyword">表現可能</span>関手であるという条件を課せるのかについては、すぐ後で説明する。</p>
        <h2 data-number="18.2" id="随伴とhom集合"><span class="header-section-number">18.2</span> 随伴とhom集合</h2>
        <p>
          随伴の等価な定義として、hom集合の自然同型によるものがある。その定義はこれまで学んだ普遍的構成とうまく結びついている。ある一意な射がある構成を分解しているという話を聞いたら毎回、それはある集合からhom集合への写像だと見なすべきだ。それが「一意な射を選択する」ということの意味だ。
        </p>
        <p>さらに言うと、分解は自然変換によって記述されることが多い。分解には可換図式が関わる――ある射は2つの射
          (因子)
          の合成に等しい。自然変換は射を可換図式に写す。したがって、普遍的構成では、射から可換図式へ、そして一意な射へ向かう。最終的には、射から射への写像、あるいはあるhom集合から別の
          (通常は異なる圏の)
          hom集合への写像が得られる。もしこの写像が可逆で、すべてのhom集合に自然に拡張できるならば、随伴が存在する。</p>
        <p>
          普遍的構成と随伴の主な違いは、後者がすべてのhom集合に対して大域的に定義されていることだ。たとえば、普遍的構成を使えば選択した2つの対象の積を定義できる。これはその圏内の他の対象のペアに対して積が存在しない場合でも同様だ。すぐ後で説明するように、対象の<em>任意のペア</em>の積が圏に存在する場合は、随伴によって定義することもできる。
        </p>
        <p><img src="images/adj-homsets.jpg" style="width:50.0%" /></p>
        <p>これがhom集合を使った随伴の別の定義だ。前と同じように、2つの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∷</mo>
                <mi>𝐃</mi>
                <mo>→</mo>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \Colon \mathbf{D} \to \mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∷</mo>
                <mi>𝐂</mi>
                <mo>→</mo>
                <mi>𝐃</mi>
              </mrow>
              <annotation encoding="application/x-tex">R \Colon \mathbf{C} \to \mathbf{D}</annotation>
            </semantics>
          </math>がある。任意の2つの対象として<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>内の始対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>d</mi>
              <annotation encoding="application/x-tex">d</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の終対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>を選択しよう<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>を使えば始対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>d</mi>
              <annotation encoding="application/x-tex">d</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>に写せる。これで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mi>d</mi>
              </mrow>
              <annotation encoding="application/x-tex">L d</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>が得られた。これらはhom集合を定義する:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>L</mi>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(L d, c)</annotation>
            </semantics>
          </math></p>
        <p>同様に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>を使えば終対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>を写せる。これで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>内の2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>d</mi>
              <annotation encoding="application/x-tex">d</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">R c</annotation>
            </semantics>
          </math>が得られた。これらもhom集合を定義する:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐃</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mi>R</mi>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{D}(d, R c)</annotation>
            </semantics>
          </math></p>
        <p>次のようなhom集合の同型が存在する場合に限って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>に対する左随伴と呼ばれる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>L</mi>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>𝐃</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mi>R</mi>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(L d, c) \cong \mathbf{D}(d, R c)</annotation>
            </semantics>
          </math></p>
        <p>これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>d</mi>
              <annotation encoding="application/x-tex">d</annotation>
            </semantics>
          </math>でも<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>でも自然だ。</p>
        <p>自然性は、始対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>d</mi>
              <annotation encoding="application/x-tex">d</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>間でスムーズに変化させられ、終対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>間でスムーズに変化させられることを意味する。より正確には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への次の2つの
          (共変)
          関手間に自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>φ</mi>
              <annotation encoding="application/x-tex">\varphi</annotation>
            </semantics>
          </math>が存在する。対象に対するこれらの関手の作用は次のとおりだ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>c</mi>
                    <mo>→</mo>
                    <mi>𝐂</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>L</mi>
                      <mi>d</mi>
                      <mo>,</mo>
                      <mi>c</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>c</mi>
                    <mo>→</mo>
                    <mi>𝐃</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>d</mi>
                      <mo>,</mo>
                      <mi>R</mi>
                      <mi>c</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                c \to \mathbf{C}(L d, c) \\
                c \to \mathbf{D}(d, R c)
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>もう一方の自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ψ</mi>
              <annotation encoding="application/x-tex">\psi</annotation>
            </semantics>
          </math>は次の
          (反変) 関手間に作用する:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>d</mi>
                    <mo>→</mo>
                    <mi>𝐂</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>L</mi>
                      <mi>d</mi>
                      <mo>,</mo>
                      <mi>c</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>d</mi>
                    <mo>→</mo>
                    <mi>𝐃</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>d</mi>
                      <mo>,</mo>
                      <mi>R</mi>
                      <mi>c</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                d \to \mathbf{C}(L d, c) \\
                d \to \mathbf{D}(d, R c)
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>自然変換は両方とも可逆でなければならない。</p>
        <p>随伴の2つの定義が等しいことは簡単に示せる。例として、単位変換の導出を、hom集合の同型から始めてみよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>L</mi>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>𝐃</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mi>R</mi>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(L d, c) \cong \mathbf{D}(d, R c)</annotation>
            </semantics>
          </math></p>
        <p>この同型は任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>で成り立つので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mo>=</mo>
                <mi>L</mi>
                <mi>d</mi>
              </mrow>
              <annotation encoding="application/x-tex">c = L d</annotation>
            </semantics>
          </math>でも成り立つ必要がある:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>L</mi>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mi>L</mi>
                  <mi>d</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>𝐃</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>R</mi>
                    <mo>∘</mo>
                    <mi>L</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mi>d</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(L d, L d) \cong \mathbf{D}(d, (R \circ L) d)
              </annotation>
            </semantics>
          </math></p>
        <p>左辺は少なくとも1つの射、つまり恒等射を必ず含むのが分かっている。自然変換は、この射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐃</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>R</mi>
                    <mo>∘</mo>
                    <mi>L</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mi>d</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{D}(d, (R \circ L) d)</annotation>
            </semantics>
          </math>
          の要素に写す。すなわち、恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>I</mi>
              <annotation encoding="application/x-tex">I</annotation>
            </semantics>
          </math>を挿入すると、以下の圏内の射に写す:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐃</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>I</mi>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>R</mi>
                    <mo>∘</mo>
                    <mi>L</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mi>d</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{D}(I d, (R \circ L) d)</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>d</mi>
              <annotation encoding="application/x-tex">d</annotation>
            </semantics>
          </math>でパラメーター化された射の族が得られた。それらは関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>I</mi>
              <annotation encoding="application/x-tex">I</annotation>
            </semantics>
          </math>と関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">R \circ L</annotation>
            </semantics>
          </math>の間に自然変換を形成する
          (自然条件は容易に確認できる)。これはまさに単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>だ。</p>
        <p>逆に、単位と余単位の存在から始めれば、hom集合間の変換を定義できる。例として、hom集合<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>L</mi>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(L d, c)</annotation>
            </semantics>
          </math>
          内の任意の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>を選択しよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>に作用して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐃</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mi>R</mi>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{D}(d, R c)</annotation>
            </semantics>
          </math>
          内に射を生成する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>φ</mi>
              <annotation encoding="application/x-tex">\varphi</annotation>
            </semantics>
          </math>を定義したい。</p>
        <p>選択肢はあまりない。試せる方法のひとつは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>を使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>をリフトすることだ。これにより、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>L</mi>
                  <mi>d</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">R (L d)</annotation>
            </semantics>
          </math>
          から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">R c</annotation>
            </semantics>
          </math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">R f</annotation>
            </semantics>
          </math>――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐃</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>R</mi>
                    <mo>∘</mo>
                    <mi>L</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mi>R</mi>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{D}((R \circ L) d, R c)</annotation>
            </semantics>
          </math>
          の要素である射が生成される。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>φ</mi>
              <annotation encoding="application/x-tex">\varphi</annotation>
            </semantics>
          </math>のコンポーネントに必要なのは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>d</mi>
              <annotation encoding="application/x-tex">d</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">R c</annotation>
            </semantics>
          </math>への射だ。これは問題ではない。なぜなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>η</mi>
                <mi>d</mi>
              </msub>
              <annotation encoding="application/x-tex">\eta_d</annotation>
            </semantics>
          </math>のコンポーネントを使えば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>d</mi>
              <annotation encoding="application/x-tex">d</annotation>
            </semantics>
          </math>から
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>R</mi>
                  <mo>∘</mo>
                  <mi>L</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mi>d</mi>
              </mrow>
              <annotation encoding="application/x-tex">(R \circ L) d</annotation>
            </semantics>
          </math>を得られるからだ。すると、次の結果が得られる:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>φ</mi>
                  <mi>f</mi>
                </msub>
                <mo>=</mo>
                <mi>R</mi>
                <mi>f</mi>
                <mo>∘</mo>
                <msub>
                  <mi>η</mi>
                  <mi>d</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">\varphi_f = R f \circ \eta_d</annotation>
            </semantics>
          </math></p>
        <p>他の方向についても同様であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ψ</mi>
              <annotation encoding="application/x-tex">\psi</annotation>
            </semantics>
          </math>の導出も同様だ。</p>
        <p>Haskellでの<code>Adjunction</code>の定義に戻ると、自然変換<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>φ</mi>
              <annotation encoding="application/x-tex">\varphi</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ψ</mi>
              <annotation encoding="application/x-tex">\psi</annotation>
            </semantics>
          </math>はそれぞれ
          (<code>a</code>と<code>b</code>についての)
          多相関数<code>leftAdjunct</code>と<code>rightAdjunct</code>に置き換えられる。関手<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>は<code>f</code>と<code>u</code>と呼ばれる。</p>
        <div class="sourceCode" id="cb374">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb374-1"><a href="#cb374-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Functor</span> f, <span class="dt">Representable</span> u) <span class="ot">=&gt;</span></span>
<span id="cb374-2"><a href="#cb374-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Adjunction</span> f u <span class="op">|</span> f <span class="ot">-&gt;</span> u, u <span class="ot">-&gt;</span> f <span class="kw">where</span></span>
<span id="cb374-3"><a href="#cb374-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    leftAdjunct  ::</span> (f a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> u b)</span>
<span id="cb374-4"><a href="#cb374-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    rightAdjunct ::</span> (a <span class="ot">-&gt;</span> u b) <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> b)</span></code></pre>
        </div>
        <p>
          <code>unit</code>/<code>counit</code>の構成と<code>leftAdjunct</code>/<code>rightAdjunct</code>の構成の同値性は、次の対応によって示される:
        </p>
        <div class="sourceCode" id="cb375">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb375-1"><a href="#cb375-1" aria-hidden="true" tabindex="-1"></a>  unit           <span class="ot">=</span> leftAdjunct <span class="fu">id</span></span>
<span id="cb375-2"><a href="#cb375-2" aria-hidden="true" tabindex="-1"></a>  counit         <span class="ot">=</span> rightAdjunct <span class="fu">id</span></span>
<span id="cb375-3"><a href="#cb375-3" aria-hidden="true" tabindex="-1"></a>  leftAdjunct f  <span class="ot">=</span> <span class="fu">fmap</span> f <span class="op">.</span> unit</span>
<span id="cb375-4"><a href="#cb375-4" aria-hidden="true" tabindex="-1"></a>  rightAdjunct f <span class="ot">=</span> counit <span class="op">.</span> <span class="fu">fmap</span> f</span></code></pre>
        </div>
        <p>随伴について圏論での記述からHaskellのコードへの翻案をなぞるのは非常に有益だ。演習として大いに推奨したい。</p>
        <p>以上で、Haskellで右随伴が自動的に<a
            href="#representable-functors">表現可能関手</a>になる理由を説明する準備ができた。その理由は、第1近似としては、Haskellの型の圏を集合の圏として扱えるからだ。</p>
        <p>右圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>であるとき、右随伴<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への関手だ。そのような関手が表現可能なのは、hom関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mi>𝑟</mi>
                    <mi>𝑒</mi>
                    <mi>𝑝</mi>
                  </mrow>
                  <mo>,</mo>
                  <mi>_</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(\mathit{rep}, \_)</annotation>
            </semantics>
          </math>
          が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>に対して自然同型であるような関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑟</mi>
                <mi>𝑒</mi>
                <mi>𝑝</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{rep}</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内にある場合だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>へのある関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>に対して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>が右随伴である場合、そのような対象は常に存在する――それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>の下の単集合
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">()</annotation>
            </semantics>
          </math>
          の像だ:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑟</mi>
                  <mi>𝑒</mi>
                  <mi>𝑝</mi>
                </mrow>
                <mo>=</mo>
                <mi>L</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{rep} = L ()</annotation>
            </semantics>
          </math></p>
        <p>実際、随伴は次の2つのhom集合が自然同型だと教えてくれる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>L</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>R</mi>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(L (), c) \cong \mathbf{Set}((), R c)</annotation>
            </semantics>
          </math></p>
        <p>与えられた<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>について、右辺は単集合
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">()</annotation>
            </semantics>
          </math>
          から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">R c</annotation>
            </semantics>
          </math>への関数の集合だ。そのような関数が集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mspace width="0.222em"></mspace>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">R\ c</annotation>
            </semantics>
          </math>からそれぞれ1つの要素を選択することはすでに説明した。そのような関数の集合は、集合<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">R c</annotation>
            </semantics>
          </math>の同型だ。したがって、次が成り立つ:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>L</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(L (), -) \cong R</annotation>
            </semantics>
          </math></p>
        <p>これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>が実際に表現可能であることを示している。</p>
        <h2 data-number="18.3" id="随伴に基づく積"><span class="header-section-number">18.3</span> 随伴に基づく積</h2>
        <p>これまでに、普遍的構成を用いた概念をいくつか紹介した。これらの概念の多くは、大域的に定義されている場合、随伴を使って表現する方が簡単だ。最も単純な非自明の例は積だ。<a
            href="#products-and-coproducts">積の普遍的構成</a>の要点は、普遍的構成を通じて積に似た候補を分解できることだ。</p>
        <p>より正確には、2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の積は、2つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑓</mi>
                <mi>𝑠</mi>
                <mi>𝑡</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{fst}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑠</mi>
                <mi>𝑛</mi>
                <mi>𝑑</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{snd}</annotation>
            </semantics>
          </math>を伴う対象
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>×</mo>
                <mi>b</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a \times b)</annotation>
            </semantics>
          </math>
          (またはHaskell表記の<code>(a, b)</code>)
          であり、かつ2つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mo>∷</mo>
                <mi>c</mi>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">p \Colon c \to a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>q</mi>
                <mo>∷</mo>
                <mi>c</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">q \Colon c \to b</annotation>
            </semantics>
          </math>を伴う他の候補<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>に対して、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑓</mi>
                <mi>𝑠</mi>
                <mi>𝑡</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{fst}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑠</mi>
                <mi>𝑛</mi>
                <mi>𝑑</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{snd}</annotation>
            </semantics>
          </math>を通じて分解する一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mo>∷</mo>
                <mi>c</mi>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">m \Colon c \to (a, b)</annotation>
            </semantics>
          </math>
          が存在する。
        </p>
        <p><a href="#products-and-coproducts">すでに</a>見たように、Haskellでは、2つの射影からこの射を生成する<code>factorizer</code>を実装できる。</p>
        <div class="sourceCode" id="cb376">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb376-1"><a href="#cb376-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorizer ::</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> (a, b))</span>
<span id="cb376-2"><a href="#cb376-2" aria-hidden="true" tabindex="-1"></a>factorizer p q <span class="ot">=</span> \x <span class="ot">-&gt;</span> (p x, q x)</span></code></pre>
        </div>
        <p>分解条件が成立することは簡単に確認できる:</p>
        <div class="sourceCode" id="cb377">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb377-1"><a href="#cb377-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fst</span> <span class="op">.</span> factorizer p q <span class="ot">=</span> p</span>
<span id="cb377-2"><a href="#cb377-2" aria-hidden="true" tabindex="-1"></a><span class="fu">snd</span> <span class="op">.</span> factorizer p q <span class="ot">=</span> q</span></code></pre>
        </div>
        <p>射のペア<code>p</code>と<code>q</code>をとり、もう一つの射<code>m = factorizer p q</code>を生成する写像が存在する。</p>
        <p>これをどのように変換すれば、随伴を定義するために必要な2つのhom集合間の写像にできるだろう？
          秘訣は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐇</mi>
                <mi>𝐚</mi>
                <mi>𝐬</mi>
                <mi>𝐤</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Hask}</annotation>
            </semantics>
          </math>の外に出て、射のペアを直積圏内の単一の射として扱うことだ。</p>
        <p>直積圏とは何か思い出してほしい。2つの任意の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>を取り上げよう。直積圏内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐃</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{D}</annotation>
            </semantics>
          </math>は、1つは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から、もう1つは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>からの対象のペアだ。射は、1つは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から、もう1つは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>からの射のペアだ。</p>
        <p>ある圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>に積を定義するには、直積圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation>
            </semantics>
          </math>から始める必要がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の射のペアは、直積圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation>
            </semantics>
          </math>内の単一の射だ。</p>
        <p><img src="images/adj-productcat.jpg" style="width:50.0%" /></p>
        <p>積を定義するために直積圏を使うのは、最初は少し紛らわしいかもしれない。しかし、これらはまったく異なる積だ。普遍的構成は直積圏を定義するのに必要ない。必要なのは対象のペアと射のペアという概念だけだ。</p>
        <p>ただし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>からの対象のペアは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の対象では<em>ない</em>。それは別の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation>
            </semantics>
          </math>の対象だ。このペアは形式的に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">⟨</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="false" form="postfix">⟩</mo>
              </mrow>
              <annotation encoding="application/x-tex">\langle a, b \rangle</annotation>
            </semantics>
          </math>と書ける。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の対象だ。一方、普遍的構成は、<em>同じ</em>圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a\times{}b</annotation>
            </semantics>
          </math>
          (またはHaskellでは<code>(a, b)</code>)
          を定義するために必要だ。この対象は、普遍的構成によって指定された方法でペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">⟨</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="false" form="postfix">⟩</mo>
              </mrow>
              <annotation encoding="application/x-tex">\langle a, b \rangle</annotation>
            </semantics>
          </math>を表すことになっている。これは常に存在するわけではなく、たとえ一部の対象に対して存在していても、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の他の対象のペアに対しては存在しない場合もある。</p>
        <p>さて、<code>factorizer</code>をhom集合の写像として見てみよう。1番目のhom集合は直積圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation>
            </semantics>
          </math>内にあり、2番目は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内にある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation>
            </semantics>
          </math>内の一般的な射は、射のペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">⟨</mo>
                <mi>f</mi>
                <mo>,</mo>
                <mi>g</mi>
                <mo stretchy="false" form="postfix">⟩</mo>
              </mrow>
              <annotation encoding="application/x-tex">\langle f, g \rangle</annotation>
            </semantics>
          </math>となる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>f</mi>
                    <mo>∷</mo>
                    <mi>c</mi>
                    <mi>′</mi>
                    <mo>→</mo>
                    <mi>a</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>g</mi>
                    <mo>∷</mo>
                    <mi>c</mi>
                    <mi>″</mi>
                    <mo>→</mo>
                    <mi>b</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                f \Colon c&#39; \to a \\
                g \Colon c&#39;&#39; \to b
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>ここで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>″</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;&#39;</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>と異なる可能性がある。しかし、積を定義するために関心があるのは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation>
            </semantics>
          </math>内で同じ始対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>を共有する特別な射のペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>だ。それは構わない:
          随伴の定義では、左hom集合の始域は任意の対象ではない――左関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>が右圏内の対象に作用した結果だ。要求に合う関手を推測するのは簡単だ――それは<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation>
            </semantics>
          </math>への対角関手
          (diagonal functor)
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Δ</mi>
              <annotation encoding="application/x-tex">\Delta</annotation>
            </semantics>
          </math>で、対象への作用は次のようになる:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>Δ</mi>
                <mspace width="0.222em"></mspace>
                <mi>c</mi>
                <mo>=</mo>
                <mo stretchy="false" form="prefix">⟨</mo>
                <mi>c</mi>
                <mo>,</mo>
                <mi>c</mi>
                <mo stretchy="false" form="postfix">⟩</mo>
              </mrow>
              <annotation encoding="application/x-tex">\Delta\ c = \langle c, c \rangle</annotation>
            </semantics>
          </math></p>
        <p>したがって、ここでの随伴の左hom集合はこうなる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>𝐂</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>Δ</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mo stretchy="false" form="prefix">⟨</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="false" form="postfix">⟩</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">(\mathbf{C}\times{}\mathbf{C})(\Delta\ c, \langle a, b \rangle)
              </annotation>
            </semantics>
          </math></p>
        <p>これは直積圏のhom集合だ。その要素は、<code>factorizer</code>の引数として知っている射のペアだ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>→</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>→</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mi>…</mi>
                <mrow></mrow>
              </mrow>
              <annotation encoding="application/x-tex">(c \to a) \to (c \to b) \ldots{}</annotation>
            </semantics>
          </math></p>
        <p>右hom集合は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>にあり、始対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>から、ある関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation>
            </semantics>
          </math>内の終対象に作用した結果へと向かう。これこそがペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">⟨</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="false" form="postfix">⟩</mo>
              </mrow>
              <annotation encoding="application/x-tex">\langle a, b \rangle</annotation>
            </semantics>
          </math>を積対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a\times{}b</annotation>
            </semantics>
          </math>に写す関手だ。hom集合のこの要素は<code>factorizer</code>の<em>結果</em>として認識される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>…</mi>
                <mrow></mrow>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>→</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>b</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\ldots{} \to (c \to (a, b))</annotation>
            </semantics>
          </math></p>
        <p><img src="images/adj-product.jpg" style="width:50.0%" /></p>
        <p>
          まだ完全な随伴は得られていない。まず<code>factorizer</code>が反転可能である必要がある――hom集合の間に<em>同型射</em>を構築しているからだ。<code>factorizer</code>の逆は、ある対象<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>から積対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a\times{}b</annotation>
            </semantics>
          </math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>で始まる必要がある。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>は次のものの要素でなければならない:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c, a\times{}b)</annotation>
            </semantics>
          </math></p>
        <p>逆factorizerは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">⟨</mo>
                <mi>c</mi>
                <mo>,</mo>
                <mi>c</mi>
                <mo stretchy="false" form="postfix">⟩</mo>
              </mrow>
              <annotation encoding="application/x-tex">\langle c, c \rangle</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">⟨</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="false" form="postfix">⟩</mo>
              </mrow>
              <annotation encoding="application/x-tex">\langle a, b \rangle</annotation>
            </semantics>
          </math>へ向かう<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation>
            </semantics>
          </math>内の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">⟨</mo>
                <mi>p</mi>
                <mo>,</mo>
                <mi>q</mi>
                <mo stretchy="false" form="postfix">⟩</mo>
              </mrow>
              <annotation encoding="application/x-tex">\langle p, q \rangle</annotation>
            </semantics>
          </math>に写す。言い換えると、次のものの要素である射に写す:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>𝐂</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>Δ</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mo stretchy="false" form="prefix">⟨</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="false" form="postfix">⟩</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">(\mathbf{C}\times{}\mathbf{C})(\Delta\ c, \langle a, b \rangle)
              </annotation>
            </semantics>
          </math></p>
        <p>この写像が存在するならば、対角関手に対して右随伴が存在すると結論できる。この関手は積を定義する。</p>
        <p>Haskellでは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑓</mi>
                <mi>𝑠</mi>
                <mi>𝑡</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{fst}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑠</mi>
                <mi>𝑛</mi>
                <mi>𝑑</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{snd}</annotation>
            </semantics>
          </math>でそれぞれ合成することで、常に<code>factorizer</code>の逆を合成できる。</p>
        <div class="sourceCode" id="cb378">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb378-1"><a href="#cb378-1" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span> <span class="fu">fst</span> <span class="op">.</span> m</span>
<span id="cb378-2"><a href="#cb378-2" aria-hidden="true" tabindex="-1"></a>q <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> m</span></code></pre>
        </div>
        <p>積を定義する2つの方法の同値性の証明を完成するには、hom集合間の写像が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>で自然であることも示す必要がある。これは熱心な読者のための練習として残しておこう。</p>
        <p>ここまでで行ったことを要約しよう:
          圏論的な積は対角関手の[右随伴]{.keyword #right
          adjoint}として大域的に定義できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>𝐂</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>Δ</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mo stretchy="false" form="prefix">⟨</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="false" form="postfix">⟩</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">(\mathbf{C} \times{} \mathbf{C})(\Delta\ c, \langle a, b \rangle)
                \cong \mathbf{C}(c, a\times{}b)</annotation>
            </semantics>
          </math></p>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a\times{}b</annotation>
            </semantics>
          </math>は、ペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">⟨</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="false" form="postfix">⟩</mo>
              </mrow>
              <annotation encoding="application/x-tex">\langle a, b \rangle</annotation>
            </semantics>
          </math>に対する右随伴関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑃</mi>
                <mi>𝑟</mi>
                <mi>𝑜</mi>
                <mi>𝑑</mi>
                <mi>𝑢</mi>
                <mi>𝑐</mi>
                <mi>𝑡</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Product}</annotation>
            </semantics>
          </math>の作用の結果だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}\times{}\mathbf{C}</annotation>
            </semantics>
          </math>からの関手はすべて双関手であるため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑃</mi>
                <mi>𝑟</mi>
                <mi>𝑜</mi>
                <mi>𝑑</mi>
                <mi>𝑢</mi>
                <mi>𝑐</mi>
                <mi>𝑡</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Product}</annotation>
            </semantics>
          </math>は双関手であることに注意してほしい。Haskellでは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑃</mi>
                <mi>𝑟</mi>
                <mi>𝑜</mi>
                <mi>𝑑</mi>
                <mi>𝑢</mi>
                <mi>𝑐</mi>
                <mi>𝑡</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Product}</annotation>
            </semantics>
          </math>双関手は単に<code>(,)</code>と書かれる。次の例のように、2つの型にこれを適用すれば直積型を得られる:</p>
        <div class="sourceCode" id="cb379">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb379-1"><a href="#cb379-1" aria-hidden="true" tabindex="-1"></a>(,) <span class="dt">Int</span> <span class="dt">Bool</span> <span class="op">~</span> (<span class="dt">Int</span>, <span class="dt">Bool</span>)</span></code></pre>
        </div>
        <h2 data-number="18.4" id="随伴に基づく冪乗"><span class="header-section-number">18.4</span> 随伴に基づく冪乗</h2>
        <p>冪乗<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>b</mi>
                <mi>a</mi>
              </msup>
              <annotation encoding="application/x-tex">b^a</annotation>
            </semantics>
          </math>、すなわち関数オブジェクト<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>⇒</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \Rightarrow b</annotation>
            </semantics>
          </math>は、<a
            href="https://bartoszmilewski.com/2015/03/13/function-types/">普遍的構成</a>を使って定義できる。この構成は、対象のすべてのペアに対して存在するなら、随伴と見なせる。繰り返すが、秘訣は言明に集中することだ:
        </p>
        <blockquote>
          <p>他の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>z</mi>
                <annotation encoding="application/x-tex">z</annotation>
              </semantics>
            </math>のうち、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>g</mi>
                  <mo>∷</mo>
                  <mi>z</mi>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>a</mi>
                  <mo>→</mo>
                  <mi>b</mi>
                </mrow>
                <annotation encoding="application/x-tex">g \Colon z\times{}a \to b</annotation>
              </semantics>
            </math>を伴うものについて、一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>h</mi>
                  <mo>∷</mo>
                  <mi>z</mi>
                  <mo>→</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>⇒</mo>
                    <mi>b</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                </mrow>
                <annotation encoding="application/x-tex">h \Colon z \to (a \Rightarrow b)</annotation>
              </semantics>
            </math>
            が存在する。</p>
        </blockquote>
        <p>この言明によりhom集合間の写像が確立される。</p>
        <p>この例では、同じ圏内の対象を扱っているので、随伴関手は2つとも自己関手だ。左
          (自己)
          関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>は、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>に作用すると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>z</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">z\times{}a</annotation>
            </semantics>
          </math>を生成する。ある固定された<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>について積を求めるのに相当する関手だ。</p>
        <p>右 (自己)
          関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>に作用すると、関数オブジェクト<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>⇒</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \Rightarrow b</annotation>
            </semantics>
          </math>
          (すなわち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>b</mi>
                <mi>a</mi>
              </msup>
              <annotation encoding="application/x-tex">b^a</annotation>
            </semantics>
          </math>)
          を生成する。ここでも、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>は固定されている。この2つの関手間の随伴は、よく次のように記述される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo>−</mo>
                <mo>×</mo>
                <mrow></mrow>
                <mi>a</mi>
                <mo>⊣</mo>
                <msup>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mi>a</mi>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">-\times{}a \dashv (-)^a</annotation>
            </semantics>
          </math></p>
        <p>この随伴の基礎となるhom集合の写像を極力理解しやすくするには、普遍的構成で用いた図式を描き直せばよい。</p>
        <p><img src="images/adj-expo.jpg" style="width:40.0%" /></p>
        <p>射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑒</mi>
                <mi>𝑣</mi>
                <mi>𝑎</mi>
                <mi>𝑙</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{eval}</annotation>
            </semantics>
          </math>はこの随伴の余単位に他ならないことに注目してほしい:
          <!-- \footnote{See ch.9 on \hyperref[function-types]{universal
construction}.} -->
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>⇒</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>×</mo>
                <mrow></mrow>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">(a \Rightarrow b)\times{}a \to b</annotation>
            </semantics>
          </math></p>
        <p>ここで:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>⇒</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>×</mo>
                <mrow></mrow>
                <mi>a</mi>
                <mo>=</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>L</mi>
                  <mo>∘</mo>
                  <mi>R</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">(a \Rightarrow b)\times{}a = (L \circ R) b</annotation>
            </semantics>
          </math></p>
        <p>前に述べたとおり、普遍的構成は同型を除いて一意な対象を定義する。それが積を
          “the” product、冪乗を “the”
          exponentialと書く理由だ。この特性は随伴にも及ぶ。つまり、ある関手に随伴があるなら、その随伴は同型を除いて一意だ。</p>
        <h2 data-number="18.5" id="課題-15"><span class="header-section-number">18.5</span> 課題</h2>
        <ol type="1">
          <li>次の2つの (反変)
            関手間の変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>ψ</mi>
                <annotation encoding="application/x-tex">\psi</annotation>
              </semantics>
            </math>について、自然性の正方図式を導出せよ:
            <math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mtable>
                  <mtr>
                    <mtd columnalign="center" style="text-align: center">
                      <mi>a</mi>
                      <mo>→</mo>
                      <mi>𝐂</mi>
                      <mrow>
                        <mo stretchy="true" form="prefix">(</mo>
                        <mi>L</mi>
                        <mi>a</mi>
                        <mo>,</mo>
                        <mi>b</mi>
                        <mo stretchy="true" form="postfix">)</mo>
                      </mrow>
                    </mtd>
                  </mtr>
                  <mtr>
                    <mtd columnalign="center" style="text-align: center">
                      <mi>a</mi>
                      <mo>→</mo>
                      <mi>𝐃</mi>
                      <mrow>
                        <mo stretchy="true" form="prefix">(</mo>
                        <mi>a</mi>
                        <mo>,</mo>
                        <mi>R</mi>
                        <mi>b</mi>
                        <mo stretchy="true" form="postfix">)</mo>
                      </mrow>
                    </mtd>
                  </mtr>
                </mtable>
                <annotation encoding="application/x-tex">
                  \begin{gathered}
                  a \to \mathbf{C}(L a, b) \\
                  a \to \mathbf{D}(a, R b)
                  \end{gathered}
                </annotation>
              </semantics>
            </math>
          </li>
          <li>随伴の第2の定義におけるhom集合同型から始めて、余単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>ε</mi>
                <annotation encoding="application/x-tex">\varepsilon</annotation>
              </semantics>
            </math>を導出せよ。</li>
          <li>随伴の2つの定義について、同値性の証明を完成せよ。</li>
          <li>余積が随伴によって定義できることを示せ。余積のfactorizerの定義から始めよ。</li>
          <li>余積が対角関手の左随伴であることを示せ。</li>
          <li>積と関数オブジェクトの間の随伴をHaskellで定義せよ。</li>
        </ol>
        <h1 data-number="19" id="自由忘却随伴"><span class="header-section-number">19</span> 自由/忘却随伴</h1>
        <h2 data-number="19.1" id="随伴に基づく自由モノイド"><span class="header-section-number">19.1</span> 随伴に基づく自由モノイド</h2>
        <p>自由構造は随伴の強力な応用例だ。<span id="free_functor" class="keyword">自由関手</span>は<span id="forgetful_functor2"
            class="keyword">忘却関手</span>への左随伴として定義される。忘却関手は構造を忘れた関手で、通常は非常に単純だ。たとえば、多くの興味深い圏は集合の上に構築されている。しかし、それらの集合を抽象化した圏論的対象は内部構造をもたず、要素をもたない。それでも、これらの対象はある意味で集合の記憶を保っていることがよくある。つまり、ある圏<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への写像――関手――が存在する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内のある対象に対応する集合は、その対象の<span id="underlying_set" class="keyword">台集合</span> (underlying set)
          と呼ばれる。</p>
        <p>モノイドは、台集合――要素の集合――を持つ対象だ。モノイドの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>から集合の圏へは忘却関手<code>U</code>が存在し、モノイドをその台集合に写す。それはさらにモノイド射
          (準同型) を集合間の関数に写す。</p>
        <p>私は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>が分裂した性格を持っていると見なすのが好きだ。一方では、それは乗算と単位元を持つたくさんの集合だ。もう一方では、それは特徴のない対象を持つ圏であり、その唯一の構造は対象間の射にエンコードされている。乗算と単位を保存するすべての集合関数は、<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>に射を呼び起こす。</p>
        <p>注意事項:</p>
        <ul>
          <li>同じ集合に写されるモノイドは多数存在する可能性があり、</li>
          <li>モノイド射は、それらの台集合の間に存在する関数よりも少ない
            (または、多くても同数だ)。</li>
        </ul>
        <p>忘却関手<code>U</code>の左随伴である関手<code>F</code>は、生成元集合から自由モノイドを構築する自由関手だ。随伴は、前に議論した<a
            href="#free-monoids">自由モノイドの普遍的構成</a>に従う。</p>
        <figure>
          <img src="images/forgetful.jpg" style="width:60.0%"
            alt="モノイドm_1とm_2は同じ台集合を持つ。m_2とm_3の台集合の間の関数は、その間の射よりも多い。" />
          <figcaption aria-hidden="true">モノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <msub>
                  <mi>m</mi>
                  <mn>1</mn>
                </msub>
                <annotation encoding="application/x-tex">m_1</annotation>
              </semantics>
            </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <msub>
                  <mi>m</mi>
                  <mn>2</mn>
                </msub>
                <annotation encoding="application/x-tex">m_2</annotation>
              </semantics>
            </math>は同じ台集合を持つ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <msub>
                  <mi>m</mi>
                  <mn>2</mn>
                </msub>
                <annotation encoding="application/x-tex">m_2</annotation>
              </semantics>
            </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <msub>
                  <mi>m</mi>
                  <mn>3</mn>
                </msub>
                <annotation encoding="application/x-tex">m_3</annotation>
              </semantics>
            </math>の台集合の間の関数は、その間の射よりも多い。</figcaption>
        </figure>
        <p>Hom集合を使って、この随伴を次のように書ける:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐧</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>x</mi>
                  <mo>,</mo>
                  <mi>m</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>x</mi>
                  <mo>,</mo>
                  <mi>U</mi>
                  <mi>m</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}(F x, m) \cong \mathbf{Set}(x, U m)</annotation>
            </semantics>
          </math></p>
        <p>この
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>についての自然)
          同型によって以下のことが分かる:</p>
        <ul>
          <li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>x</mi>
                <annotation encoding="application/x-tex">x</annotation>
              </semantics>
            </math>によって生成された自由モノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>F</mi>
                  <mi>x</mi>
                </mrow>
                <annotation encoding="application/x-tex">F x</annotation>
              </semantics>
            </math>と任意のモノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>m</mi>
                <annotation encoding="application/x-tex">m</annotation>
              </semantics>
            </math>との間のモノイド準同型に対し、生成元<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>x</mi>
                <annotation encoding="application/x-tex">x</annotation>
              </semantics>
            </math>の集合を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>m</mi>
                <annotation encoding="application/x-tex">m</annotation>
              </semantics>
            </math>の台集合に埋め込む一意な関数が存在する。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>x</mi>
                    <mo>,</mo>
                    <mi>U</mi>
                    <mi>m</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                </mrow>
                <annotation encoding="application/x-tex">\mathbf{Set}(x, U m)</annotation>
              </semantics>
            </math>
            内の関数だ。</li>
          <li>ある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>m</mi>
                <annotation encoding="application/x-tex">m</annotation>
              </semantics>
            </math>の台集合に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>x</mi>
                <annotation encoding="application/x-tex">x</annotation>
              </semantics>
            </math>を埋め込むすべての関数に対し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>x</mi>
                <annotation encoding="application/x-tex">x</annotation>
              </semantics>
            </math>によって生成された自由モノイドとモノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>m</mi>
                <annotation encoding="application/x-tex">m</annotation>
              </semantics>
            </math>の間に一意なモノイド射が存在する。(これは普遍的構成で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>h</mi>
                <annotation encoding="application/x-tex">h</annotation>
              </semantics>
            </math>と呼んでいた射だ。)</li>
        </ul>
        <p><img src="images/freemonadjunction.jpg" style="width:80.0%" /></p>
        <p>直観では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>x</mi>
              </mrow>
              <annotation encoding="application/x-tex">F x</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>に基づいて構築できる「最大の」モノイドだ。もしモノイドの内部を見られたら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐧</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>x</mi>
                  <mo>,</mo>
                  <mi>m</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}(F x, m)</annotation>
            </semantics>
          </math>
          に属するすべての射がこの自由モノイドを他のモノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>に<em>埋め込む</em>ことがわかるだろう。それは、おそらくいくつかの要素を同一視することで行われる。具体的には、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>x</mi>
              </mrow>
              <annotation encoding="application/x-tex">F x</annotation>
            </semantics>
          </math>の生成元
          (例えば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>の要素)
          を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>に埋め込む。この随伴は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>x</mi>
                  <mo>,</mo>
                  <mi>U</mi>
                  <mi>m</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}(x, U m)</annotation>
            </semantics>
          </math>
          からの関数で与えられる右辺の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>の埋め込みが、左辺のモノイドの埋め込みを一意に決定し、またその逆も成り立つことを示している。</p>
        <p>Haskellでは、リストのデータ構造は自由モノイドだ
          (ただし、注意点がいくつかある: <a href="http://comonad.com/reader/2015/free-monoids-in-haskell/">Dan
            Doelのブログ記事</a>を参照)。リスト型<code>[a]</code>は自由モノイドであり、型<code>a</code>は生成元の集合を表す。たとえば、型<code>[Char]</code>には、単位元――空リスト<code>[]</code>――と、<code>['a']</code>、<code>['b']</code>のような単要素リスト――自由モノイドの生成元が含まれている。残りは「積」を適用して生成される。ここでは、2つのリストの積は単に片方をもう片方に連結するだけだ。連結は結合的で単位的
          (unital) だ
          (つまり、中立元が存在する――ここでは空リストだ)。<code>Char</code>によって生成される自由モノイドは、<code>Char</code>からなるすべての文字列の集合に他ならない。これはHaskellでは<code>String</code>と呼ばれる:
        </p>
        <div class="sourceCode" id="cb380">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb380-1"><a href="#cb380-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">String</span> <span class="ot">=</span> [<span class="dt">Char</span>]</span></code></pre>
        </div>
        <p>(<code>type</code>は型シノニムを定義する――既存の型に別の名前を付ける。)</p>
        <p>
          もう1つの興味深い例として、単一の生成元から作られた自由モノイドが挙げられる。これはunitのリスト<code>[()]</code>の型だ。その要素は<code>[]</code>、<code>[()]</code>、<code>[(), ()]</code>などだ。そのようなリストはすべて、1つの自然数――長さで記述できる。それ以外にunitのリストにエンコードされた情報はない。このようなリスト2つを連結すると、長さが構成要素の長さの合計である新しいリストが生成される。型<code>[()]</code>が、(0を含む)
          自然数の加算モノイドと同型であることは容易に理解できる。以下の2つの関数は互いに逆であり、この同型を表している:</p>
        <div class="sourceCode" id="cb381">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb381-1"><a href="#cb381-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toNat ::</span> [()] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb381-2"><a href="#cb381-2" aria-hidden="true" tabindex="-1"></a>toNat <span class="ot">=</span> <span class="fu">length</span></span>
<span id="cb381-3"><a href="#cb381-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb381-4"><a href="#cb381-4" aria-hidden="true" tabindex="-1"></a><span class="ot">toLst ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [()]</span>
<span id="cb381-5"><a href="#cb381-5" aria-hidden="true" tabindex="-1"></a>toLst n <span class="ot">=</span> <span class="fu">replicate</span> n ()</span></code></pre>
        </div>
        <p>
          簡単のため<code>Natural</code>型ではなく<code>Int</code>型を使ったが、考え方は同じだ。関数<code>replicate</code>は、与えられた値――ここでは単位――で埋められた長さ<code>n</code>のリストを作成する。
        </p>
        <h2 data-number="19.2" id="いくつかの直観"><span class="header-section-number">19.2</span> いくつかの直観</h2>
        <p>以下では、身振り手振りの議論をいくつか挙げる。この種の議論は厳密ではないが、直観を形成するのに役立つ。</p>
        <p>
          自由/忘却随伴についての直観を得るには、関手や関数が本質的に情報を損失することを心に留めておくのがよい。関数は複数の対象や射を潰すことがあり、関数は集合の複数の要素をまとめることがある。また、像が終域の一部しかカバーしていないこともある。
        </p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内の「平均的な」hom集合は関数の全スペクトルを含み、最も損失の少ないもの
          (たとえば、単射、または、おそらく同型) に始まり、始域全体を単一要素
          (もしあれば) に潰す定数関数で終わる。</p>
        <p>私はよく、任意の圏における射も損失があると見なす。これは単なるメンタルモデルだが、特に随伴について考えるときには有用だ――典型的には、圏の1つが<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>である随伴の場合だ。</p>
        <p>形式的には、反転可能な射 (同型射)
          または反転不可能な射についてのみ語れる。損失があると見なせるのは後者だ。また、単射関数
          (潰さない関数) と全射関数 (終域全体をカバーする関数)
          という概念を一般化した、モノ (mono-) 射とエピ (epi-)
          射という概念もある。ただし、モノとエピの両方でありながら非可逆な射も存在可能だ。</p>
        <p>自由<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mo>⊣</mo>
              <annotation encoding="application/x-tex">\dashv</annotation>
            </semantics>
          </math>忘却随伴では、左側に制約の多い圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>があり、右側に制約の少ない圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の射が「より少ない」のは、何らかの追加構造を保存しなければならないからだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>の場合は乗算と単位を保存しなければならない。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の射はそれほど多くの構造を保存しなくてよいので、「より多くの」射がある。</p>
        <p>忘却関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>U</mi>
              <annotation encoding="application/x-tex">U</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>に適用するとき、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>の「内部構造」を暴いていると見なせる。実際、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>なら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>U</mi>
              <annotation encoding="application/x-tex">U</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>の内部構造――台集合――を<em>定義</em>していると見なせる。(任意の圏では、対象の内部については他の対象との接続を通じてしか述べられないが、ここでは単に身振り手振りで議論しているだけだ。)</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>U</mi>
              <annotation encoding="application/x-tex">U</annotation>
            </semantics>
          </math>を使って2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>を写す場合、一般に、hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c&#39;, c)</annotation>
            </semantics>
          </math>
          の写像は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐃</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>U</mi>
                  <mi>c</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <mi>U</mi>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{D}(U c&#39;, U c)</annotation>
            </semantics>
          </math>
          の部分集合のみをカバーすると予想される。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(c&#39;, c)</annotation>
            </semantics>
          </math>
          内の射が追加構造を保存しなければならないのに対して、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐃</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>U</mi>
                  <mi>c</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <mi>U</mi>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{D}(U c&#39;, U c)</annotation>
            </semantics>
          </math>
          の射はそうではないからだ。</p>
        <p><img src="images/forgettingmorphisms.jpg" style="width:45.0%" /></p>
        <p>しかし、随伴は特定のhom集合の<span id="isomorphism" class="keyword">同型</span>として定義されるので、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>は非常に慎重に選択しなければならない。随伴では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>c</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">c&#39;</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内のどこから選択してもよいわけではなく、自由関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>の
          (より小さいと推察される) 像から選択される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>𝐃</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>d</mi>
                  <mo>,</mo>
                  <mi>U</mi>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(F d, c) \cong \mathbf{D}(d, U c)</annotation>
            </semantics>
          </math></p>
        <p>したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>の像は任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>に向かう多くの射を持つ対象で構成されていなければならない。実際、構造を保存する<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>d</mi>
              </mrow>
              <annotation encoding="application/x-tex">F d</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>への射は、構造を保存しない<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>d</mi>
              <annotation encoding="application/x-tex">d</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>U</mi>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">U c</annotation>
            </semantics>
          </math>への射と同数存在する必要がある。これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>の像が本質的に構造のない対象で構成されている必要がある
          (射が保存すべき構造がない)
          ことを意味する。そのような「構造のない」対象は自由対象 (free object)
          と呼ばれる。</p>
        <p><img src="images/freeimage.jpg" style="width:45.0%" /></p>
        <p>モノイドの例では、自由モノイドは単位元則と結合則によって生成される構造以外には何の構造も持たない。それ以外では、すべての乗算はまったく新しい要素を生成する。</p>
        <p>自由モノイドでは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>2</mn>
                <mo>*</mo>
                <mn>3</mn>
              </mrow>
              <annotation encoding="application/x-tex">2 * 3</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>6</mn>
              <annotation encoding="application/x-tex">6</annotation>
            </semantics>
          </math>ではない――新しい要素<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <mn>2</mn>
                <mo>,</mo>
                <mn>3</mn>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}2, 3{]}</annotation>
            </semantics>
          </math>だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <mn>2</mn>
                <mo>,</mo>
                <mn>3</mn>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}2, 3{]}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>6</mn>
              <annotation encoding="application/x-tex">6</annotation>
            </semantics>
          </math>は同一視されないので、この自由モノイドから他の任意のモノイド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>への射は、それらを別々に写すことが許される。ただし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <mn>2</mn>
                <mo>,</mo>
                <mn>3</mn>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}2, 3{]}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>6</mn>
              <annotation encoding="application/x-tex">6</annotation>
            </semantics>
          </math>
          (それらの積)
          の両方を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>の同じ要素に写しても構わない。また、加算モノイドで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <mn>2</mn>
                <mo>,</mo>
                <mn>3</mn>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}2, 3{]}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>5</mn>
              <annotation encoding="application/x-tex">5</annotation>
            </semantics>
          </math>
          (それらの和)
          を同一視することなども同様だ。同一視が異なれば、得られるモノイドも異なる。</p>
        <p>これは別の興味深い直観を導く:
          自由モノイドは、モノイダル演算を実行する代わりに、渡された引数を累積
          (accumulate)
          する。例えば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>3</mn>
              <annotation encoding="application/x-tex">3</annotation>
            </semantics>
          </math>を掛ける代わりに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>3</mn>
              <annotation encoding="application/x-tex">3</annotation>
            </semantics>
          </math>をリストに記憶する。この手法の利点は、どんなモノイダル操作を使うか指定する必要がないことだ。引数を累積し続けて、最後だけその結果に演算子を適用すればよい。そしてその最後の時点で、どんな演算子を適用するか選択できる。数値を加算したり、乗算したり、モジュロ2加算したりできる。つまり、自由モノイドは式の作成と評価を分離する。この考え方は代数について話すときにもう一度見ることになる。
        </p>
        <p>この直観は他のもっと複雑な自由構造にも一般化できる。たとえば、評価する前に式木
          (expression tree)
          全体を累積できる。このアプローチの利点は、そのような木を変換して、評価を高速にしたり、メモリ消費を減らしたりできることだ。これはたとえば、行列計算の実装に使われる。先行評価
          (eager evaluation)
          で行列計算を行うと、中間結果を保存するための一時的な配列が大量に割り当てられてしまうからだ。</p>
        <h2 data-number="19.3" id="課題-16"><span class="header-section-number">19.3</span> 課題</h2>
        <ol type="1">
          <li>単集合から構築された自由モノイドを、その生成元と見なす。その自由モノイドから任意のモノイド<math display="inline"
              xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>m</mi>
                <annotation encoding="application/x-tex">m</annotation>
              </semantics>
            </math>への射と、その単集合から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>m</mi>
                <annotation encoding="application/x-tex">m</annotation>
              </semantics>
            </math>の台集合への関数との間に1対1の対応があることを示せ。</li>
        </ol>
        <h1 data-number="20" id="モナド-プログラマーの定義"><span class="header-section-number">20</span> モナド: プログラマーの定義</h1>
        <p>
          プログラマーたちは、モナドにまつわる神話を発展させてきた。これはプログラミングにおける極めて抽象的で難しい概念の1つだと考えられている。「わかっている」人とそうでない人がいる。多くの人にとって、モナドの概念を理解した瞬間はまるで神秘的な体験だ。モナドは非常に多様な構成の本質を抽象化しているので、日常生活でうまく比喩できるものがない。そして我々は暗闇の中で手探りするようになった。まるで盲人たちが象の端の様々な部分に触れて、「ロープだ」、「木の幹だ」、「ブリトーだ！」と勝ち誇って叫ぶように。
        </p>
        <p>はっきり言っておこう。モナドを取り巻く神秘主義はすべて誤解に基づいている。モナドはとてもシンプルな概念だ。混乱を引き起こしているのは、モナドの応用先の多様さだ。</p>
        <p>この記事のための調査の一環として、私はダクトテープ (別名ダックテープ)
          とその応用先について調べた。それを使ってできることのほんの一例を紹介しよう:</p>
        <ul>
          <li>ダクトをシーリングする</li>
          <li>アポロ13号に搭載された二酸化炭素除去装置を修理する</li>
          <li>いぼを治療する</li>
          <li>アップルのiPhone 4の通話切断問題を修正する</li>
          <li>プロムで着るドレスを作る</li>
          <li>吊り橋を建設する</li>
        </ul>
        <p>ダクトテープが何か知らずに、このリストに基づいて理解しようとしているのを想像してほしい。幸運を祈る！</p>
        <p>そういうわけで、「モナドは……のようなものだ」という常套句のコレクションにもう1つ追加しようと思う:
          モナドはダクトテープのようなものだ。応用は幅広く多様だが、原理はごく単純だ:
          モナドは物同士をくっつける。より正確には、物同士を合成する。</p>
        <p>
          このことは、多くのプログラマー、特に命令型言語をバックグラウンドに持つプログラマーがモナドを理解するのに困難が伴う理由の一部を説明している。問題は、プログラミングを関数合成の観点から考えるのに慣れていないことだ。これは理解できる。関数から関数へ値を直接渡さずに、中間値に名前を付けるのはよくあることだ。グルーコードの短い断片を、ヘルパー関数に抽象化せず、インライン化することもよくある。以下は、ベクトルの長さを求める関数をC言語で命令型スタイルで実装したものだ:
        </p>
        <div class="sourceCode" id="cb382">
          <pre
            class="sourceCode c"><code class="sourceCode c"><span id="cb382-1"><a href="#cb382-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> vlen<span class="op">(</span><span class="dt">double</span> <span class="op">*</span>v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb382-2"><a href="#cb382-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> d <span class="op">=</span> <span class="fl">0.0</span><span class="op">;</span></span>
<span id="cb382-3"><a href="#cb382-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb382-4"><a href="#cb382-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>n <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> n <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> <span class="op">++</span>n<span class="op">)</span></span>
<span id="cb382-5"><a href="#cb382-5" aria-hidden="true" tabindex="-1"></a>        d <span class="op">+=</span> v<span class="op">[</span>n<span class="op">]*</span> v<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb382-6"><a href="#cb382-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> sqrt<span class="op">(</span>d<span class="op">);</span></span>
<span id="cb382-7"><a href="#cb382-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
        </div>
        <p>これを、明示的な関数合成を用いた (様式化された)
          Haskell版と比較してほしい:</p>
        <div class="sourceCode" id="cb383">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb383-1"><a href="#cb383-1" aria-hidden="true" tabindex="-1"></a>vlen <span class="ot">=</span> <span class="fu">sqrt</span> <span class="op">.</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">fmap</span>  (<span class="fu">flip</span> (<span class="op">^</span>) <span class="dv">2</span>)</span></code></pre>
        </div>
        <p>(ここでは、より謎めかせるために、指数演算子<code>(^)</code>の2番目の引数を<code>2</code>に設定して部分適用した。)</p>
        <p>
          Haskellのポイントフリー・スタイルが常に優れていると主張しているのではなく、プログラミングで行うことのすべての基礎に関数合成があると主張しているだけだ。そして実質的には関数を合成しているにもかかわらず、Haskellでは多大な労力を費やして<code>do</code>記法と呼ばれる命令型構文をモナディック合成のために提供している。その使い方については後で説明する。まずは、なぜモナディック合成が必要なのか説明しよう。
        </p>
        <h2 data-number="20.1" id="kleisli圏-1"><span class="header-section-number">20.1</span> Kleisli圏</h2>
        <p>以前、通常の関数を装飾することで<a
            href="#writer-monad">Writerモナド</a>に到達した。装飾を行うために、典型的には、戻り値を文字列とペアにした。あるいはもっと一般的には、モノイドの要素とペアにした。今ではそのような装飾が関手だと気付ける:
        </p>
        <div class="sourceCode" id="cb384">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb384-1"><a href="#cb384-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Writer</span> w a <span class="ot">=</span> <span class="dt">Writer</span> (a, w)</span>
<span id="cb384-2"><a href="#cb384-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb384-3"><a href="#cb384-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Writer</span> w) <span class="kw">where</span></span>
<span id="cb384-4"><a href="#cb384-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Writer</span> (a, w)) <span class="ot">=</span> <span class="dt">Writer</span> (f a, w)</span></code></pre>
        </div>
        <p>その後、以下の形式の装飾された関数を合成する方法、すなわちKleisli矢
          (Kleisli arrow) を発見した。</p>
        <div class="sourceCode" id="cb385">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb385-1"><a href="#cb385-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> <span class="dt">Writer</span> w b</span></code></pre>
        </div>
        <p>ログの累積は合成の内部で実装した。</p>
        <p>これでKleisli圏をより一般的に定義する準備ができた。まずは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>から始める。対応するKleisli圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐊</mi>
              <annotation encoding="application/x-tex">\mathbf{K}</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と同じ対象を持つが、射は異なる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐊</mi>
              <annotation encoding="application/x-tex">\mathbf{K}</annotation>
            </semantics>
          </math>内の2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の間の射は次のように実装される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>→</mo>
                <mi>m</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \to m\ b</annotation>
            </semantics>
          </math></p>
        <p>これはもとの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の射だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐊</mi>
              <annotation encoding="application/x-tex">\mathbf{K}</annotation>
            </semantics>
          </math>内のKleisli矢は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の間の射として扱い、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">m\ b</annotation>
            </semantics>
          </math>の間の射としては扱わないことを覚えておくのが重要だ。</p>
        <p>この例では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>は<code>Writer w</code>に特化されており、ある決まったモノイド<code>w</code>に対応している。</p>
        <p>Kleisli矢は、それに適した合成を定義できるときだけ圏を形成する。すべての対象に対して恒等射を持ち結合的な合成がある場合、関手<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>は<span id="monad" class="keyword">モナド</span> (monad)
          と呼ばれ、その結果形成される圏はKleisli圏と呼ばれる。</p>
        <p>
          Haskellでは、Kleisli合成はfish演算子<code>&gt;=&gt;</code>を用いて定義され、その恒等射は<code>return</code>と呼ばれる多相関数だ。Kleisli合成を使ったモナドの定義は次のとおりだ:
        </p>
        <div class="sourceCode" id="cb386">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb386-1"><a href="#cb386-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb386-2"><a href="#cb386-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;=&gt;) ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m c)</span>
<span id="cb386-3"><a href="#cb386-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a</span></code></pre>
        </div>
        <p>
          モナドを定義する方法には同等のものがいくつもあり、これがHaskellエコシステムでの主要な方法ではないことを覚えておいてほしい。この方法の概念の簡潔さと得られる直観は気に入っているが、プログラミングの際に便利な定義は他にもある。それらについて少し話そう。
        </p>
        <p>この定式化ではモナド則を非常に簡単に表現できる。Haskellではモナド則を強制できないが、等式推論には使える。それらは単にKleisli圏の標準的な合成則だ:</p>
        <div class="sourceCode" id="cb387">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb387-1"><a href="#cb387-1" aria-hidden="true" tabindex="-1"></a>(f <span class="op">&gt;=&gt;</span> g) <span class="op">&gt;=&gt;</span> h <span class="ot">=</span> f <span class="op">&gt;=&gt;</span> (g <span class="op">&gt;=&gt;</span> h) <span class="co">-- 結合性</span></span>
<span id="cb387-2"><a href="#cb387-2" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> <span class="op">&gt;=&gt;</span> f <span class="ot">=</span> f                  <span class="co">-- 左単位元</span></span>
<span id="cb387-3"><a href="#cb387-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;=&gt;</span> <span class="fu">return</span> <span class="ot">=</span> f                  <span class="co">-- 右単位元</span></span></code></pre>
        </div>
        <p>
          この種の定義はモナドが本当は何なのかも表している。つまり、モナドは装飾された関数を合成する方法なのだ。副作用や状態は関係ない。関係あるのは合成だ。後で見るように、装飾された関数はさまざまな作用や状態を表現するために使われることがあるが、モナドはそのためのものではない。モナドは粘着力のあるダクトテープで、装飾された関数の一端を別の装飾された関数の一端につなぐ。
        </p>
        <p><code>Writer</code>の例に戻ろう: ログ生成関数
          (<code>Writer</code>関手でのKleisli矢)
          は圏を形成する。なぜなら、<code>Writer</code>はモナドだからだ。</p>
        <div class="sourceCode" id="cb388">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb388-1"><a href="#cb388-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Writer</span> w) <span class="kw">where</span></span>
<span id="cb388-2"><a href="#cb388-2" aria-hidden="true" tabindex="-1"></a>    f <span class="op">&gt;=&gt;</span> g <span class="ot">=</span> \a <span class="ot">-&gt;</span></span>
<span id="cb388-3"><a href="#cb388-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> <span class="dt">Writer</span> (b, s)  <span class="ot">=</span> f a</span>
<span id="cb388-4"><a href="#cb388-4" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Writer</span> (c, s&#39;) <span class="ot">=</span> g b</span>
<span id="cb388-5"><a href="#cb388-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span> <span class="dt">Writer</span> (c, s <span class="ot">`mappend`</span> s&#39;)</span>
<span id="cb388-6"><a href="#cb388-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Writer</span> (a, <span class="fu">mempty</span>)</span></code></pre>
        </div>
        <p><code>Writer w</code>のモナド則は、<code>w</code>のモノイド則が満たされている限り満たされる
          (これらもHaskellでは強制できない)。</p>
        <p><code>Writer</code>モナド用に便利なKleisli矢が定義されており、<code>tell</code>と呼ばれる。その唯一の目的は引数をログに追加することだ:</p>
        <div class="sourceCode" id="cb389">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb389-1"><a href="#cb389-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tell ::</span> w <span class="ot">-&gt;</span> <span class="dt">Writer</span> w ()</span>
<span id="cb389-2"><a href="#cb389-2" aria-hidden="true" tabindex="-1"></a>tell s <span class="ot">=</span> <span class="dt">Writer</span> ((), s)</span></code></pre>
        </div>
        <p>これは後で他のモナディック関数の構成要素として使うことになる。</p>
        <h2 data-number="20.2" id="fishの解剖"><span class="header-section-number">20.2</span> Fishの解剖</h2>
        <p>
          さまざまなモナドに対してfish演算子を実装するとすぐ、コードに重複がたくさんあり、簡単に括り出せることに気付くだろう。まず、2つの関数のKleisli合成は1つの関数を返す必要があるので、その実装も型<code>a</code>の引数を1つ取るラムダから始められる:
        </p>
        <div class="sourceCode" id="cb390">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb390-1"><a href="#cb390-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;=&gt;) ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m c)</span>
<span id="cb390-2"><a href="#cb390-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;=&gt;</span> g <span class="ot">=</span> \a <span class="ot">-&gt;</span> <span class="op">...</span></span></code></pre>
        </div>
        <p>この引数は<code>f</code>に渡す以外のことはできない:</p>
        <div class="sourceCode" id="cb391">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb391-1"><a href="#cb391-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;=&gt;</span> g <span class="ot">=</span> \a <span class="ot">-&gt;</span> <span class="kw">let</span> mb <span class="ot">=</span> f a</span>
<span id="cb391-2"><a href="#cb391-2" aria-hidden="true" tabindex="-1"></a>                <span class="kw">in</span> <span class="op">...</span></span></code></pre>
        </div>
        <p>
          この時点で、型<code>m c</code>の結果を生成し、型<code>m b</code>の対象と関数<code>g :: b -&gt; m c</code>を自由に使える必要がある。それを行う関数を定義しよう。この関数は<em>bind</em>と呼ばれ、通常は中置演算子の形式で記される:
        </p>
        <div class="sourceCode" id="cb392">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb392-1"><a href="#cb392-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span></code></pre>
        </div>
        <p>モナドごとに、fish演算子の代わりにbindを定義できる。実際、標準的なHaskellのモナドの定義ではbindが使われている:</p>
        <div class="sourceCode" id="cb393">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb393-1"><a href="#cb393-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb393-2"><a href="#cb393-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb393-3"><a href="#cb393-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a</span></code></pre>
        </div>
        <p>以下に<code>Writer</code>モナドのバインドの定義を示す:</p>
        <div class="sourceCode" id="cb394">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb394-1"><a href="#cb394-1" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Writer</span> (a, w)) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="kw">let</span> <span class="dt">Writer</span> (b, w&#39;) <span class="ot">=</span> f a</span>
<span id="cb394-2"><a href="#cb394-2" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">in</span>  <span class="dt">Writer</span> (b, w <span class="ot">`mappend`</span> w&#39;)</span></code></pre>
        </div>
        <p>これは確かにfish演算子の定義より短い。</p>
        <p>
          <code>m</code>が関手であるという事実を利用すればbindをさらに詳しく分析できる。<code>fmap</code>を使えば<code>m a</code>の内容に関数<code>a -&gt; m b</code>を適用できる。それによって<code>a</code>は<code>m b</code>に変換される。したがって、適用結果は型<code>m (m b)</code>となる。これは必要な結果の型<code>m b</code>そのものではない。しかし、近付いてはいる。<code>m</code>の2重適用を潰す、つまりフラット化する関数さえあればよい。そのような関数は<code>join</code>と呼ばれる。
        </p>
        <div class="sourceCode" id="cb395">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb395-1"><a href="#cb395-1" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> m (m a) <span class="ot">-&gt;</span> m a</span></code></pre>
        </div>
        <p><code>join</code>を使ってbindを次のように書き直せる:</p>
        <div class="sourceCode" id="cb396">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb396-1"><a href="#cb396-1" aria-hidden="true" tabindex="-1"></a>ma <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> join (<span class="fu">fmap</span> f ma)</span></code></pre>
        </div>
        <p>これはモナドの定義の3番目の選択肢につながる:</p>
        <div class="sourceCode" id="cb397">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb397-1"><a href="#cb397-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb397-2"><a href="#cb397-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    join ::</span> m (m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb397-3"><a href="#cb397-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a</span></code></pre>
        </div>
        <p>
          ここでは<code>m</code>が<code>Functor</code>であることを明示的に要求した。これまでの2つのモナドの定義ではその必要はなかった。型コンストラクター<code>m</code>は、fish演算子とbind演算子のどちらかをサポートするなら自動的に関手になるからだ。たとえば、<code>fmap</code>はbindと<code>return</code>で定義できる:
        </p>
        <div class="sourceCode" id="cb398">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb398-1"><a href="#cb398-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f ma <span class="ot">=</span> ma <span class="op">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> <span class="fu">return</span> (f a)</span></code></pre>
        </div>
        <p>完全を期すため、<code>Writer</code>モナドの<code>join</code>を以下に示す:</p>
        <div class="sourceCode" id="cb399">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb399-1"><a href="#cb399-1" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> <span class="dt">Writer</span> w (<span class="dt">Writer</span> w a) <span class="ot">-&gt;</span> <span class="dt">Writer</span> w a</span>
<span id="cb399-2"><a href="#cb399-2" aria-hidden="true" tabindex="-1"></a>join (<span class="dt">Writer</span> ((<span class="dt">Writer</span> (a, w&#39;)), w)) <span class="ot">=</span> <span class="dt">Writer</span> (a, w <span class="ot">`mappend`</span> w&#39;)</span></code></pre>
        </div>
        <h2 data-number="20.3" id="do記法"><span class="header-section-number">20.3</span> <code>do</code>記法</h2>
        <p>
          モナドを使ってコードを書く方法の1つは、Kleisli矢を使うこと――fishオペレータで合成することだ。このプログラミング手法はポイントフリー・スタイルを一般化したものだ。ポイントフリーのコードはコンパクトで、実にエレガントなことが多い。しかし、一般的には、理解するのが難しく暗号すれすれだ。だから、ほとんどのプログラマーは関数の引数や中間値に名前を付ける方を好む。
        </p>
        <p>
          それはつまり、モナドを扱う場合にはfish演算子よりもbind演算子を優先するのを意味する。Bindはモナディックな値を取ってモナディックな値を返す。プログラマーはそれらの値に名前を付けても構わない。しかし、これは改善とは言えない。本当は、あたかも通常の値を扱っているかのようなふりがしたい。値をカプセル化するモナディックなコンテナが欲しいのではない。命令型コードのように、グローバルなログの更新などの副作用のほとんどが視界から隠れていてほしい。そしてそれこそHaskellが<code>do</code>記法でエミュレートするものだ。
        </p>
        <p>ここで疑問に思うだろう。一体なぜモナドを使うのか？
          副作用を見えなくしたいなら、命令型言語に留まればいいのではないか？
          その答えは、モナドなら副作用をはるかにうまくコントロールできる、というものだ。たとえば、<code>Writer</code>モナドのログは関数から関数へ渡され、グローバルに公開されることはない。ログを改竄したりデータ競合を引き起したりする可能性はない。また、モナディックなコードはプログラムの他の部分から明確に区分され隔離される。
        </p>
        <p><code>do</code>記法はモナディック合成のための単なる糖衣構文だ。表面上は命令型コードによく似ているが、bindとラムダ式のシーケンスに直接変換できる。</p>
        <p>一例として、前に<code>Writer</code>モナドでのKleisli矢の合成を説明するために使った例を取り上げる。現在の定義を使うと、それは次のように書き直せる:</p>
        <div class="sourceCode" id="cb400">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb400-1"><a href="#cb400-1" aria-hidden="true" tabindex="-1"></a><span class="ot">process ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> <span class="dt">String</span> [<span class="dt">String</span>]</span>
<span id="cb400-2"><a href="#cb400-2" aria-hidden="true" tabindex="-1"></a>process <span class="ot">=</span> upCase <span class="op">&gt;=&gt;</span> toWords</span></code></pre>
        </div>
        <p>この関数は、動作ログを生成しつつ、入力文字列内のすべての文字を大文字に変換して単語に分割する。</p>
        <p><code>do</code>記法では次のようになるだろう:</p>
        <div class="sourceCode" id="cb401">
          <pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb401-1"><a href="#cb401-1" aria-hidden="true" tabindex="-1"></a>process s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb401-2"><a href="#cb401-2" aria-hidden="true" tabindex="-1"></a>    upStr <span class="ot">&lt;-</span> upCase s</span>
<span id="cb401-3"><a href="#cb401-3" aria-hidden="true" tabindex="-1"></a>    toWords upStr</span></code></pre>
        </div>
        <p>ここで、<code>upStr</code>は単なる<code>String</code>だが、<code>upCase</code>は<code>Writer</code>を生成するはずだ:</p>
        <div class="sourceCode" id="cb402">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb402-1"><a href="#cb402-1" aria-hidden="true" tabindex="-1"></a><span class="ot">upCase ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Writer</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb402-2"><a href="#cb402-2" aria-hidden="true" tabindex="-1"></a>upCase s <span class="ot">=</span> <span class="dt">Writer</span> (<span class="fu">map</span> <span class="fu">toUpper</span> s, <span class="st">&quot;upCase &quot;</span>)</span></code></pre>
        </div>
        <p>これは<code>do</code>ブロックがコンパイラによって次のように脱糖されるためだ:</p>
        <div class="sourceCode" id="cb403">
          <pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb403-1"><a href="#cb403-1" aria-hidden="true" tabindex="-1"></a>process s <span class="ot">=</span></span>
<span id="cb403-2"><a href="#cb403-2" aria-hidden="true" tabindex="-1"></a>    upCase s <span class="op">&gt;&gt;=</span> \upStr <span class="ot">-&gt;</span></span>
<span id="cb403-3"><a href="#cb403-3" aria-hidden="true" tabindex="-1"></a>        toWords upStr</span></code></pre>
        </div>
        <p>
          <code>upCase</code>のモナディックな結果は<code>String</code>を引数とするラムダに束縛されている。その引数の名前は<code>do</code>ブロックに書かれていたものと同じだ。次の行:
        </p>
        <div class="sourceCode" id="cb404">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb404-1"><a href="#cb404-1" aria-hidden="true" tabindex="-1"></a>upStr <span class="ot">&lt;-</span> upCase s</span></code></pre>
        </div>
        <p>は、<code>upStr</code>が<em>得る</em>のは<code>upCase s</code>の結果だ、と読める。</p>
        <p>
          <code>toWords</code>をインライン化すると、擬似的な命令型スタイルはさらに顕著になる。2つの関数呼び出しに置き換えよう。まず<code>tell</code>を呼び出して、文字列<code>"toWords"</code>をログに記録する。続いて<code>return</code>を呼び出して、文字列<code>upStr</code>を<code>words</code>によって分割した結果を返す。<code>words</code>は文字列を扱う通常の関数であることに注意してほしい。
        </p>
        <div class="sourceCode" id="cb405">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb405-1"><a href="#cb405-1" aria-hidden="true" tabindex="-1"></a>process s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb405-2"><a href="#cb405-2" aria-hidden="true" tabindex="-1"></a>    upStr <span class="ot">&lt;-</span> upCase s</span>
<span id="cb405-3"><a href="#cb405-3" aria-hidden="true" tabindex="-1"></a>    tell <span class="st">&quot;toWords &quot;</span></span>
<span id="cb405-4"><a href="#cb405-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="fu">words</span> upStr)</span></code></pre>
        </div>
        <p>ここで、doブロックの各行を脱糖すると、ネストされた新たなbindが導入される:</p>
        <div class="sourceCode" id="cb406">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb406-1"><a href="#cb406-1" aria-hidden="true" tabindex="-1"></a>process s <span class="ot">=</span></span>
<span id="cb406-2"><a href="#cb406-2" aria-hidden="true" tabindex="-1"></a>    upCase s <span class="op">&gt;&gt;=</span> \upStr <span class="ot">-&gt;</span></span>
<span id="cb406-3"><a href="#cb406-3" aria-hidden="true" tabindex="-1"></a>      tell <span class="st">&quot;toWords &quot;</span> <span class="op">&gt;&gt;=</span> \() <span class="ot">-&gt;</span></span>
<span id="cb406-4"><a href="#cb406-4" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> (<span class="fu">words</span> upStr)</span></code></pre>
        </div>
        <p><code>tell</code>はunit値を生成するので、後続のラムダに渡す必要はないことに注意してほしい。モナディックな結果の内容を無視するのはよくあることだ
          (ただし、その作用――ここではログへの寄与――は無視しない)。そのため、そのような場合にbindを置き換える特別な演算子がある:</p>
        <div class="sourceCode" id="cb407">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb407-1"><a href="#cb407-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;) ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b</span>
<span id="cb407-2"><a href="#cb407-2" aria-hidden="true" tabindex="-1"></a>m <span class="op">&gt;&gt;</span> k <span class="ot">=</span> m <span class="op">&gt;&gt;=</span> (\_ <span class="ot">-&gt;</span> k)</span></code></pre>
        </div>
        <p>実際に脱糖されたコードは次のようになる:</p>
        <div class="sourceCode" id="cb408">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb408-1"><a href="#cb408-1" aria-hidden="true" tabindex="-1"></a>process s <span class="ot">=</span></span>
<span id="cb408-2"><a href="#cb408-2" aria-hidden="true" tabindex="-1"></a>    upCase s <span class="op">&gt;&gt;=</span> \upStr <span class="ot">-&gt;</span></span>
<span id="cb408-3"><a href="#cb408-3" aria-hidden="true" tabindex="-1"></a>      tell <span class="st">&quot;toWords &quot;</span> <span class="op">&gt;&gt;</span></span>
<span id="cb408-4"><a href="#cb408-4" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> (<span class="fu">words</span> upStr)</span></code></pre>
        </div>
        <p>一般に、<code>do</code>ブロックは行 (またはサブブロック)
          で構成され、左矢印によって新しい名前を導入してコードの残りの部分で使えるようにするか、あるいは純粋に副作用を目的として実行される。Bind演算子はコード行間で暗黙的に使われる。ちなみに、Haskellでは<code>do</code>ブロックの書式を波括弧とセミコロンで置き換えられる。これが、モナドはセミコロンをオーバーロードする方法だ、と表現される理由になっている。
        </p>
        <p>
          <code>do</code>記法を脱糖する際にラムダとbind演算子がネストされると、<code>do</code>ブロックの残りを各行の結果に基づいて実行するのに影響を与えることに注目してほしい。この特性を使えば、例外をシミュレートするなど、複雑な制御構造を導入できる。
        </p>
        <p>興味深いことに、<code>do</code>記法と同等のものが命令型言語、特にC++に応用されている。つまり、再開可能な関数、すなわちコルーチンだ。C++の<a
            href="https://bartoszmilewski.com/2014/02/26/c17-i-see-a-monad-in-your-future/">futureがモナドを形成する</a>ことは秘密ではない。これは継続モナドの一例だ。継続モナドについてはすぐ後で議論する。継続の問題点は、合成するのが非常に難しいことだ。Haskellでは<code>do</code>という表記法を使うことで、「こっちのハンドラーがそっちのハンドラーを呼ぶ」というスパゲッティを、逐次コードに非常によく似たものに変換している。再開可能な関数によって、同じ変換がC++でも可能になる。また、同じメカニズムを適用すれば、<a
            href="https://bartoszmilewski.com/2014/04/21/getting-lazy-with-c/">ネストされたループのスパゲッティ</a>をリスト内包表記または「ジェネレーター」に変えられる。これは本質的にリストモナドの<code>do</code>記法だ。モナドによる統一的な抽象化がなければ、これらの個々の問題は通常、言語にカスタム拡張を提供して対処されることになる。Haskellでは、すべてライブラリを通じて対処される。
        </p>
        <h1 data-number="21" id="モナドと作用"><span class="header-section-number">21</span> モナドと作用</h1>
        <p>
          モナドが何のためにあるのかは理解できた。モナドは装飾された関数を合成できる。本当に興味深い疑問は、なぜ装飾された関数が関数プログラミングにおいてそんなに重要なのかということだ。すでに見た例として、<code>Writer</code>モナドでは、装飾によって複数の関数呼び出しにわたってログを作成し累積できた。通常は非純粋関数
          (impure function) を使って
          (たとえば、何らかのグローバルな状態にアクセスし変更することで)
          解決するような問題を、純粋関数を使って解決した。</p>
        <h2 data-number="21.1" id="問題"><span class="header-section-number">21.1</span> 問題</h2>
        <p>よく似た問題を集めた短いリストを、<a
            href="https://core.ac.uk/download/pdf/21173011.pdf">エウジニオ・モッジの独創的な論文</a>から転載して以下に示した。どれも伝統的には関数の純粋さを放棄することで解決される:
        </p>
        <ul>
          <li>部分性: 停止しない可能性のある計算</li>
          <li>非決定性: 何種類もの結果を返す可能性のある計算</li>
          <li>副作用: 状態にアクセス・変更する計算
            <ul>
              <li>読み取り専用の状態、あるいは環境</li>
              <li>書き込み専用の状態、あるいはログ</li>
              <li>読み取り・書き込みの状態</li>
            </ul>
          </li>
          <li>例外: 失敗する可能性のある部分関数</li>
          <li>継続: プログラムの状態を保存でき、要求に応じて復元できること</li>
          <li>インタラクティブな入力</li>
          <li>インタラクティブな出力</li>
        </ul>
        <p>本当に驚くべきことに、これらすべての問題はひとつの巧妙なトリックで解決できる。装飾された関数にするというトリックだ。もちろん、装飾は各ケースで全く違うものになる。</p>
        <p>
          装飾がモナディックだという条件は、この段階では必要ないことを認識しておかなくてはならない。合成――1つの装飾された関数をより小さな装飾された関数に分解できること――を主張するとき、初めてモナドが必要になる。また、それぞれの装飾が違うため、モナディック合成の実装方法もやはり違うものになるが、全体的なパターンは同じだ。非常に単純な、恒等射を伴った結合的な合成というパターンだ。
        </p>
        <p>次節では、Haskellでの例について詳しく説明する。圏論に戻りたい人や、Haskellによるモナドの実装にすでに慣れている人は、遠慮なく斜め読みしたり飛ばしたりして構わない。</p>
        <h2 data-number="21.2" id="解決策"><span class="header-section-number">21.2</span> 解決策</h2>
        <p>
          まず、<code>Writer</code>モナドの使用方法を分析してみよう。まず、あるタスクを実行する純粋関数から始めた。引数を与えると、ある決まった出力が生成される。この関数を、もとの出力を文字列とペアにすることで装飾する別の関数に置き換えた。これがログ生成の問題に対する解決策だった。
        </p>
        <p>それで終わりにできなかったのは、一般に、モノリシックな解決策は扱いたくないからだ。1つのログ生成関数をより小さなログ生成関数に分解できる必要があった。こうした小さな関数の合成こそがモナドという概念への道標となった。
        </p>
        <p>本当に驚くべきことは、関数の戻り値の型を装飾するという同一のパターンが、通常は純粋性を放棄する必要がある多種多様な問題に対して機能することだ。リストを見て、それぞれの問題に適用される装飾を順番に突き止めよう。</p>
        <h3 data-number="21.2.1" id="部分性"><span class="header-section-number">21.2.1</span> 部分性</h3>
        <p>停止しない可能性のあるすべての関数について、戻り値の型を「リフトされた」型に変更する。その型はもとの型のすべての値および特別な「ボトム」値<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>⊥</mi>
              <annotation encoding="application/x-tex">\bot</annotation>
            </semantics>
          </math>を含む。たとえば、<code>Bool</code>型は集合としては<code>True</code>と<code>False</code>の2つの要素を含む。リフトされた<code>Bool</code>は3つの要素を含む。リフトされた<code>Bool</code>を返す関数は、<code>True</code>または<code>False</code>を生成するか、永久に実行し続ける。
        </p>
        <p>面白いのは、Haskellのような遅延評価言語では、終わりのない関数が実際に値を返すことがあり、その値が次の関数に渡されうるということだ。この特別な値はボトムと呼ばれる。この値が
          (たとえば、パターンマッチングに使うため、あるいは出力として生成したため)
          明示的に必要とされているのでない限り、プログラムの実行を遅らせることなくこの値を渡せる。すべてのHaskellの関数は潜在的に非停止であり得るため、Haskellのすべての型はリフトされることが想定されている。これが、単純な<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>ではなく、Haskellの
          (リフトされた)
          型と関数の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐇</mi>
                <mi>𝐚</mi>
                <mi>𝐬</mi>
                <mi>𝐤</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Hask}</annotation>
            </semantics>
          </math>について頻繁に議論する理由だ。もっとも、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐇</mi>
                <mi>𝐚</mi>
                <mi>𝐬</mi>
                <mi>𝐤</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Hask}</annotation>
            </semantics>
          </math>が本物の圏かどうかは議論がある
          (<a href="http://math.andrej.com/2016/08/06/hask-is-not-a-category/">Andrej
            Bauerによる記事</a>を参照)。</p>
        <h3 data-number="21.2.2" id="非決定性"><span class="header-section-number">21.2.2</span> 非決定性</h3>
        <p>
          関数が多くの異なる結果を返すことがあるなら、一度にすべての結果を返す方がよいだろう。意味論的には、非決定論的関数は結果のリストを返す関数と等価だ。これはガベージコレクションのある遅延評価言語では実に理に適っている。たとえば、必要な値が1つだけの場合はリストの頭部だけを取得すればよく、尾部が評価されることはない。ランダムな値が必要な場合は乱数ジェネレーターを使ってリストのn番目の要素を選択する。遅延評価では結果の無限リストを返すことさえ可能になる。
        </p>
        <p>
          リストモナド――Haskellでの非決定論的計算の実装――では<code>join</code>は<code>concat</code>として実装されている。<code>join</code>の役割はコンテナのコンテナをフラット化することなのを思い出してほしい――<code>concat</code>はリストのリストを連結して1つのリストにする。また、<code>return</code>は単要素リストを作成する:
        </p>
        <div class="sourceCode" id="cb409">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb409-1"><a href="#cb409-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span></span>
<span id="cb409-2"><a href="#cb409-2" aria-hidden="true" tabindex="-1"></a>    join <span class="ot">=</span> <span class="fu">concat</span></span>
<span id="cb409-3"><a href="#cb409-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> x <span class="ot">=</span> [x]</span></code></pre>
        </div>
        <p>リストモナドのbind演算子は、<code>fmap</code>の後に<code>join</code>が続くという一般式で与えられ、ここでは次のようになる:</p>
        <div class="sourceCode" id="cb410">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb410-1"><a href="#cb410-1" aria-hidden="true" tabindex="-1"></a>as <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="fu">concat</span> (<span class="fu">fmap</span> k as)</span></code></pre>
        </div>
        <p>
          ここで、関数<code>k</code>はそれ自体がリストを生成する関数で、リスト<code>as</code>のすべての要素に適用される。結果はリストのリストとなり、<code>concat</code>を使ってフラット化される。
        </p>
        <p>プログラマーの観点では、リストの操作は比較的簡単であり、たとえば、非決定論的関数をループ内で呼び出したり、イテレーターを返す関数を実装したりする方が難しい
          (ただし、<a
            href="http://ericniebler.com/2014/04/27/range-comprehensions/">近年のC++</a>では、遅延評価するrangeを返すのはHaskellでリストを返すのとほぼ等価だ)。
        </p>
        <p>
          非決定性が創造的に使われる好例はゲームプログラミングだ。たとえば、コンピューターが人間を相手にチェスをするとき、相手の次の動きは予測できない。しかし、すべての可能な移動のリストを生成して1つずつ分析できる。同様に、非決定論的な構文解析器は、与えられた式に対して可能なすべての構文解析のリストを生成できる。
        </p>
        <p>
          リストを返す関数は非決定論的だと解釈してもよいものの、リストモナドの応用範囲はもっと広い。リストを生成する計算をつなぎ合わせることは、命令型プログラミングで使われる反復構文――ループ――を関数型プログラミングで完全に代替する手段だからだ。単一のループは、多くの場合<code>fmap</code>を使って書き直せる。fmapはループの本体をリストの各要素に適用する。リストモナドで<code>do</code>記法を使えば、複雑な多重ループを置き換えられる。
        </p>
        <p>私のお気に入りの例は、ピタゴラス数 (Pythagorean triple)
          ――直角三角形の辺を形成できる3つの正の整数の組――を生成するプログラムだ。</p>
        <div class="sourceCode" id="cb411">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb411-1"><a href="#cb411-1" aria-hidden="true" tabindex="-1"></a>triples <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb411-2"><a href="#cb411-2" aria-hidden="true" tabindex="-1"></a>    z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>]</span>
<span id="cb411-3"><a href="#cb411-3" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>z]</span>
<span id="cb411-4"><a href="#cb411-4" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">&lt;-</span> [x<span class="op">..</span>z]</span>
<span id="cb411-5"><a href="#cb411-5" aria-hidden="true" tabindex="-1"></a>    guard (x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">^</span><span class="dv">2</span> <span class="op">==</span> z<span class="op">^</span><span class="dv">2</span>)</span>
<span id="cb411-6"><a href="#cb411-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (x, y, z)</span></code></pre>
        </div>
        <p>最初の行は、<code>z</code>が正の整数の無限リスト<code>[1..]</code>から要素を取得することを示している。次に<code>x</code>は、1から<code>z</code>までの整数の
          (有限)
          リスト<code>[1..z]</code>から要素を取得する。最後に<code>y</code>は、<code>x</code>から<code>z</code>までの整数のリストから要素を取得する。これで<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>1</mn>
                <mo>≤</mo>
                <mi>x</mi>
                <mo>≤</mo>
                <mi>y</mi>
                <mo>≤</mo>
                <mi>z</mi>
              </mrow>
              <annotation encoding="application/x-tex">1 \leqslant x \leqslant y \leqslant z</annotation>
            </semantics>
          </math>の3つの整数を自由に使える。関数<code>guard</code>は、<code>Bool</code>式を取り、unitのリストを返す。</p>
        <div class="sourceCode" id="cb412">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb412-1"><a href="#cb412-1" aria-hidden="true" tabindex="-1"></a><span class="ot">guard ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> [()]</span>
<span id="cb412-2"><a href="#cb412-2" aria-hidden="true" tabindex="-1"></a>guard <span class="dt">True</span>  <span class="ot">=</span> [()]</span>
<span id="cb412-3"><a href="#cb412-3" aria-hidden="true" tabindex="-1"></a>guard <span class="dt">False</span> <span class="ot">=</span> []</span></code></pre>
        </div>
        <p>この関数 (<code>MonadPlus</code>というより大きなクラスのメンバー)
          は、ここでは非ピタゴラス数を除外するために使われる。実際、bind
          (または関連する演算子<code>&gt;&gt;</code>)
          の実装を見ると、空リストが与えられると空リストが生成されることに気付くだろう。一方、空でないリスト
          (ここではunitを含む単リスト<code>[()]</code>)
          が与えられた場合、bindは継続を呼ぶ。ここでは<code>return(x, y, z)</code>だ。これは検証済みのピタゴラス数を持つ単リストを生成する。これらの単リストはすべて、内包するbindによって連結され、最終的な
          (無限の)
          結果を生成する。当然、<code>triple</code>の呼び出し側はリスト全体を消費できないが、Haskellは遅延評価言語なので問題ない。</p>
        <p>
          通常は3重にネストされたループを必要とする問題が、リストモナドと<code>do</code>記法のおかげで劇的に単純化された。それだけでは不十分と言わんばかりに、Haskellではこのコードをリスト内包表記を使ってさらに単純化する:
        </p>
        <div class="sourceCode" id="cb413">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb413-1"><a href="#cb413-1" aria-hidden="true" tabindex="-1"></a>triples <span class="ot">=</span> [(x, y, z) <span class="op">|</span> z <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>]</span>
<span id="cb413-2"><a href="#cb413-2" aria-hidden="true" tabindex="-1"></a>                     , x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>z]</span>
<span id="cb413-3"><a href="#cb413-3" aria-hidden="true" tabindex="-1"></a>                     , y <span class="ot">&lt;-</span> [x<span class="op">..</span>z]</span>
<span id="cb413-4"><a href="#cb413-4" aria-hidden="true" tabindex="-1"></a>                     , x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">^</span><span class="dv">2</span> <span class="op">==</span> z<span class="op">^</span><span class="dv">2</span>]</span></code></pre>
        </div>
        <p>これはリストモナド (厳密に言えば、<code>MonadPlus</code>)
          のためのさらなる糖衣構文だ。</p>
        <p>他の関数型言語や命令型言語でも、ジェネレーターやコルーチンという名のもとに同様の構造が見られることがある。</p>
        <h3 data-number="21.2.3" id="読み取り専用の状態"><span class="header-section-number">21.2.3</span> 読み取り専用の状態</h3>
        <p>外部の状態すなわち環境に対して読み取り専用でアクセスする関数は、その環境を追加の引数として取る関数に常に置き換え可能だ。純粋な関数<code>(a, e) -&gt; b</code>
          (ここで、<code>e</code>は環境の型)
          は、一見したところ、Kleisli矢のようには見えない。しかし、それを<code>a -&gt; (e -&gt; b)</code>にカリー化すれば、その装飾がお馴染みのreader関手であることがすぐ分かる:</p>
        <div class="sourceCode" id="cb414">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb414-1"><a href="#cb414-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Reader</span> e a <span class="ot">=</span> <span class="dt">Reader</span> (e <span class="ot">-&gt;</span> a)</span></code></pre>
        </div>
        <p>
          <code>Reader</code>を返す関数は、ある環境を与えると望んだ結果を生成するような作用を持つ、小さな実行可能コードを生成すると解釈できる。そのような作用を実行するためのヘルパー関数<code>runReader</code>がある:
        </p>
        <div class="sourceCode" id="cb415">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb415-1"><a href="#cb415-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runReader ::</span> <span class="dt">Reader</span> e a <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> a</span>
<span id="cb415-2"><a href="#cb415-2" aria-hidden="true" tabindex="-1"></a>runReader (<span class="dt">Reader</span> f) e <span class="ot">=</span> f e</span></code></pre>
        </div>
        <p>環境の値が異なれば生成される結果も異なりうる。</p>
        <p><code>Reader</code>を返す関数も<code>Reader</code>の作用自体も純粋であることに注意してほしい。</p>
        <p><code>Reader</code>モナド用にbindを実装するには、まず、環境<code>e</code>を取得して<code>b</code>を生成する関数を生成する必要がある:</p>
        <div class="sourceCode" id="cb416">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb416-1"><a href="#cb416-1" aria-hidden="true" tabindex="-1"></a>ra <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Reader</span> (\e <span class="ot">-&gt;</span> <span class="op">...</span>)</span></code></pre>
        </div>
        <p>ラムダ内では、作用<code>ra</code>を実行して<code>a</code>を生成できる:</p>
        <div class="sourceCode" id="cb417">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb417-1"><a href="#cb417-1" aria-hidden="true" tabindex="-1"></a>ra <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Reader</span> (\e <span class="ot">-&gt;</span> <span class="kw">let</span> a <span class="ot">=</span> runReader ra e</span>
<span id="cb417-2"><a href="#cb417-2" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">in</span> <span class="op">...</span>)</span></code></pre>
        </div>
        <p>次に、<code>a</code>を継続<code>k</code>に渡せば新しい作用<code>rb</code>が得られる:</p>
        <div class="sourceCode" id="cb418">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb418-1"><a href="#cb418-1" aria-hidden="true" tabindex="-1"></a>ra <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Reader</span> (\e <span class="ot">-&gt;</span> <span class="kw">let</span> a  <span class="ot">=</span> runReader ra e</span>
<span id="cb418-2"><a href="#cb418-2" aria-hidden="true" tabindex="-1"></a>                             rb <span class="ot">=</span> k a</span>
<span id="cb418-3"><a href="#cb418-3" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">in</span> <span class="op">...</span>)</span></code></pre>
        </div>
        <p>最後に、環境<code>e</code>で作用<code>rb</code>を実行できる:</p>
        <div class="sourceCode" id="cb419">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb419-1"><a href="#cb419-1" aria-hidden="true" tabindex="-1"></a>ra <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Reader</span> (\e <span class="ot">-&gt;</span> <span class="kw">let</span> a  <span class="ot">=</span> runReader ra e</span>
<span id="cb419-2"><a href="#cb419-2" aria-hidden="true" tabindex="-1"></a>                             rb <span class="ot">=</span> k a</span>
<span id="cb419-3"><a href="#cb419-3" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">in</span> runReader rb e)</span></code></pre>
        </div>
        <p><code>return</code>を実装するには、環境を無視しもとのままの値を返す作用を作成すればよい。</p>
        <p>いくつかの簡略化を経てまとめると、次の定義が得られる:</p>
        <div class="sourceCode" id="cb420">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb420-1"><a href="#cb420-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Reader</span> e) <span class="kw">where</span></span>
<span id="cb420-2"><a href="#cb420-2" aria-hidden="true" tabindex="-1"></a>    ra <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Reader</span> (\e <span class="ot">-&gt;</span> runReader (k (runReader ra e)) e)</span>
<span id="cb420-3"><a href="#cb420-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> x <span class="ot">=</span> <span class="dt">Reader</span> (\e <span class="ot">-&gt;</span> x)</span></code></pre>
        </div>
        <h3 data-number="21.2.4" id="書き込み専用の状態"><span class="header-section-number">21.2.4</span> 書き込み専用の状態</h3>
        <p>これは最初に例にしたログ生成と同じだ。装飾は<code>Writer</code>関手によって与えられる:</p>
        <div class="sourceCode" id="cb421">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb421-1"><a href="#cb421-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Writer</span> w a <span class="ot">=</span> <span class="dt">Writer</span> (a, w)</span></code></pre>
        </div>
        <p>完全を期すため、データコンストラクターをアンパックする小さなヘルパー関数<code>runWriter</code>も示そう:</p>
        <div class="sourceCode" id="cb422">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb422-1"><a href="#cb422-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runWriter ::</span> <span class="dt">Writer</span> w a <span class="ot">-&gt;</span> (a, w)</span>
<span id="cb422-2"><a href="#cb422-2" aria-hidden="true" tabindex="-1"></a>runWriter (<span class="dt">Writer</span> (a, w)) <span class="ot">=</span> (a, w)</span></code></pre>
        </div>
        <p>
          すでに見たとおり、<code>Writer</code>を合成可能にするには、<code>w</code>はモノイドでなければならない。bind演算子で書かれた<code>Writer</code>のモナドインスタンスを以下に示す:
        </p>
        <div class="sourceCode" id="cb423">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb423-1"><a href="#cb423-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> w) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Writer</span> w) <span class="kw">where</span></span>
<span id="cb423-2"><a href="#cb423-2" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Writer</span> (a, w)) <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="kw">let</span> (a&#39;, w&#39;) <span class="ot">=</span> runWriter (k a)</span>
<span id="cb423-3"><a href="#cb423-3" aria-hidden="true" tabindex="-1"></a>                            <span class="kw">in</span> <span class="dt">Writer</span> (a&#39;, w <span class="ot">`mappend`</span> w&#39;)</span>
<span id="cb423-4"><a href="#cb423-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Writer</span> (a, <span class="fu">mempty</span>)</span></code></pre>
        </div>
        <h3 data-number="21.2.5" id="状態"><span class="header-section-number">21.2.5</span> 状態</h3>
        <p>
          状態へ読み取り/書き込みアクセスする関数は、<code>Reader</code>と<code>Writer</code>の装飾を組み合わせる。それらは、追加の引数として状態を受け取り、結果として値/状態のペアを生成する純粋関数
          <code>(a, s) -&gt; (b, s)</code>
          と見なせる。カリー化すると、それらはKleisli矢<code>a -&gt; (s -&gt; (b, s))</code>の形になり、装飾は<code>State</code>関手へと抽象化される:
        </p>
        <div class="sourceCode" id="cb424">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb424-1"><a href="#cb424-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> (s <span class="ot">-&gt;</span> (a, s))</span></code></pre>
        </div>
        <p>ここでも、Kleisli矢は作用を返すものと見なせて、ヘルパー関数を使って実行できる:</p>
        <div class="sourceCode" id="cb425">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb425-1"><a href="#cb425-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb425-2"><a href="#cb425-2" aria-hidden="true" tabindex="-1"></a>runState (<span class="dt">State</span> f) s <span class="ot">=</span> f s</span></code></pre>
        </div>
        <p>初期状態が異なると、結果が異なりうるだけでなく、最終状態も異なりうる。</p>
        <p><code>State</code>モナドに対するbindの実装は<code>Reader</code>モナドの実装と非常によく似ている。ただし、各ステップで正しい状態を渡すように注意する必要がある:</p>
        <div class="sourceCode" id="cb426">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb426-1"><a href="#cb426-1" aria-hidden="true" tabindex="-1"></a>sa <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s&#39;) <span class="ot">=</span> runState sa s</span>
<span id="cb426-2"><a href="#cb426-2" aria-hidden="true" tabindex="-1"></a>                            sb <span class="ot">=</span> k a</span>
<span id="cb426-3"><a href="#cb426-3" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">in</span> runState sb s&#39;)</span></code></pre>
        </div>
        <p>インスタンス全体は次のとおりだ:</p>
        <div class="sourceCode" id="cb427">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb427-1"><a href="#cb427-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">State</span> s) <span class="kw">where</span></span>
<span id="cb427-2"><a href="#cb427-2" aria-hidden="true" tabindex="-1"></a>    sa <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s&#39;) <span class="ot">=</span> runState sa s</span>
<span id="cb427-3"><a href="#cb427-3" aria-hidden="true" tabindex="-1"></a>                            <span class="kw">in</span> runState (k a) s&#39;)</span>
<span id="cb427-4"><a href="#cb427-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (a, s))</span></code></pre>
        </div>
        <p>ヘルパーとしてのKleisli矢も2つあり、状態を操作するために使える。そのうちの1つは状態を調べるために取得する:</p>
        <div class="sourceCode" id="cb428">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb428-1"><a href="#cb428-1" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">State</span> s s</span>
<span id="cb428-2"><a href="#cb428-2" aria-hidden="true" tabindex="-1"></a>get <span class="ot">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> (s, s))</span></code></pre>
        </div>
        <p>もう1つは状態を全く新しいものに置き換える:</p>
        <div class="sourceCode" id="cb429">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb429-1"><a href="#cb429-1" aria-hidden="true" tabindex="-1"></a><span class="ot">put ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s ()</span>
<span id="cb429-2"><a href="#cb429-2" aria-hidden="true" tabindex="-1"></a>put s&#39; <span class="ot">=</span> <span class="dt">State</span> (\s <span class="ot">-&gt;</span> ((), s&#39;))</span></code></pre>
        </div>
        <h3 data-number="21.2.6" id="例外"><span class="header-section-number">21.2.6</span> 例外</h3>
        <p>
          例外をスローする命令型関数は、実際には部分関数――引数の値のいくつかに対して定義されていない関数だ。純粋全域関数に関して例外を最もシンプルに実装するには<code>Maybe</code>関手を使う。部分関数は全域関数へと拡張される。その全域関数は、意味があるときは常に<code>Just a</code>を返し、意味がないときは<code>Nothing</code>を返す。失敗の原因に関する何らかの情報も返したい場合は、<code>Either</code>関手を代わりに使える
          (第1の型は固定され、たとえば<code>String</code>とされる)。</p>
        <p>以下は<code>Maybe</code>の<code>Monad</code>インスタンスだ:</p>
        <div class="sourceCode" id="cb430">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb430-1"><a href="#cb430-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb430-2"><a href="#cb430-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb430-3"><a href="#cb430-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> a  <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> k a</span>
<span id="cb430-4"><a href="#cb430-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Just</span> a</span></code></pre>
        </div>
        <p><code>Maybe</code>についてのモナディック合成では、エラーが検出されたときは計算がきちんと短絡評価される
          (継続<code>k</code>が決して呼ばれない)
          ことに注意してほしい。それが例外に期待される振る舞いだ。</p>
        <h3 data-number="21.2.7" id="継続"><span class="header-section-number">21.2.7</span> 継続</h3>
        <p>
          これは「電話はしないでください、こちらから電話しますので！」という、採用面接のあとで経験しそうな状況だ。回答を直接得る代わりに、ある関数をハンドラーとして提供することになっており、そのハンドラーが呼ばれると結果が得られる。このスタイルのプログラミングが特に役立つのは、呼び出し時点で結果がわからない場合だ。たとえば、別のスレッドで評価される場合や、リモートのウェブサイトから配信される場合などだ。この場合のKleisli矢が返す関数は「残りの計算」を表すハンドラーを受け取る:
        </p>
        <div class="sourceCode" id="cb431">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb431-1"><a href="#cb431-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Cont</span> r a <span class="ot">=</span> <span class="dt">Cont</span> ((a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r)</span></code></pre>
        </div>
        <p>
          このハンドラー<code>a -&gt; r</code>は、最終的に呼び出されると型<code>r</code>の結果を生成し、その結果が最後に返される。継続は結果の型によってパラメーター化される。(実用上は、これはある種のステータスインジケーターである場合が多い。)
        </p>
        <p>Kleisli矢から返された作用を実行するためのヘルパー関数もある。それはハンドラーを取得して継続に渡す:</p>
        <div class="sourceCode" id="cb432">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb432-1"><a href="#cb432-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runCont ::</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb432-2"><a href="#cb432-2" aria-hidden="true" tabindex="-1"></a>runCont (<span class="dt">Cont</span> k) h <span class="ot">=</span> k h</span></code></pre>
        </div>
        <p>継続の合成は非常に難しいことで知られており、それゆえモナドや、特に<code>do</code>記法による処理は非常に有利だ。</p>
        <p>bindの実装について説明しよう。まず、本質だけに絞ったシグネチャに注目する:</p>
        <div class="sourceCode" id="cb433">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb433-1"><a href="#cb433-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> ((a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span></span>
<span id="cb433-2"><a href="#cb433-2" aria-hidden="true" tabindex="-1"></a>         (a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span></span>
<span id="cb433-3"><a href="#cb433-3" aria-hidden="true" tabindex="-1"></a>         ((b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r)</span></code></pre>
        </div>
        <p>目標は、ハンドラー<code>(b -&gt; r)</code>を受け取って結果<code>r</code>を生成する関数を作成することだ。そこで出発点はこうなる:</p>
        <div class="sourceCode" id="cb434">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb434-1"><a href="#cb434-1" aria-hidden="true" tabindex="-1"></a>ka <span class="op">&gt;&gt;=</span> kab <span class="ot">=</span> <span class="dt">Cont</span> (\hb <span class="ot">-&gt;</span> <span class="op">...</span>)</span></code></pre>
        </div>
        <p>このラムダの内部で、<code>ka</code>関数を、残りの計算を表す適切なハンドラーを添えて呼び出したい。そのハンドラーをラムダとして実装する:</p>
        <div class="sourceCode" id="cb435">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb435-1"><a href="#cb435-1" aria-hidden="true" tabindex="-1"></a>runCont ka (\a <span class="ot">-&gt;</span> <span class="op">...</span>)</span></code></pre>
        </div>
        <p>この場合、残りの計算は、まず<code>kab</code>を<code>a</code>で呼び出し、次に<code>hb</code>を結果の作用<code>kb</code>に渡すことを含む:</p>
        <div class="sourceCode" id="cb436">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb436-1"><a href="#cb436-1" aria-hidden="true" tabindex="-1"></a>runCont ka (\a <span class="ot">-&gt;</span> <span class="kw">let</span> kb <span class="ot">=</span> kab a</span>
<span id="cb436-2"><a href="#cb436-2" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span> runCont kb hb)</span></code></pre>
        </div>
        <p>ご覧のとおり、継続は裏返しに合成されている。最終的なハンドラー<code>hb</code>は、計算の最も内側の層から呼び出される。インスタンス全体は次のとおりだ:</p>
        <div class="sourceCode" id="cb437">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb437-1"><a href="#cb437-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb437-2"><a href="#cb437-2" aria-hidden="true" tabindex="-1"></a>    ka <span class="op">&gt;&gt;=</span> kab <span class="ot">=</span> <span class="dt">Cont</span> (\hb <span class="ot">-&gt;</span> runCont ka (\a <span class="ot">-&gt;</span> runCont (kab a) hb))</span>
<span id="cb437-3"><a href="#cb437-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Cont</span> (\ha <span class="ot">-&gt;</span> ha a)</span></code></pre>
        </div>
        <h3 data-number="21.2.8" id="インタラクティブな入力"><span class="header-section-number">21.2.8</span> インタラクティブな入力</h3>
        <p>
          これは最も厄介な問題であり、多くの混乱の源だ。明らかに、<code>getChar</code>のような関数は、キーボードから入力された文字を返すのなら、純粋ではあり得ない。しかし、コンテナ内の文字を返すのならどうだろう？
          そのコンテナから文字を除去する方法がない限り、この関数は純粋であると主張できる。<code>getChar</code>を呼び出すたびに、まったく同じコンテナが返される。概念としては、このコンテナには可能な文字すべての重ね合わせが含まれる。
        </p>
        <p>
          量子力学に馴染みがあれば、この比喩を問題なく理解できるだろう。これはシュレーディンガーの猫が入った箱のようなものだ――ただし、箱を開けたり中を覗いたりする方法はない。この箱は、組み込みの特別な<code>IO</code>関手を使って定義される。この例では<code>getChar</code>をKleisli矢として宣言できる:
        </p>
        <div class="sourceCode" id="cb438">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb438-1"><a href="#cb438-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getChar</span><span class="ot"> ::</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Char</span></span></code></pre>
        </div>
        <p>(実際には、unit型を取る関数は戻り値の型の値を選択するのと等価なので、<code>getChar</code>の宣言は単純に<code>getChar :: IO Char</code>となる。)</p>
        <p>
          <code>IO</code>は関手なので<code>fmap</code>を使って内容を操作できる。また、関手として、文字だけでなく任意の型を内容として保持できる。このアプローチの真の有用性が明らかになるのは、Haskellでの<code>IO</code>がモナドなのを考慮したときだ。これは<code>IO</code>オブジェクトを生成するKleisli矢を合成できることを意味する。
        </p>
        <p>Kleisli合成を使えば、<code>IO</code>オブジェクトの内容を覗き見できると思うかもしれない
          (またも量子力学で比喩すると「波動関数を収縮させる」ことにあたる)。実際、<code>getChar</code>は、文字を受け取る別のKleisli矢と合成できる。たとえば、受け取った文字を整数に変換するようなものと合成できる。注意点として、そのような2番目のKleisli矢は整数を<code>(IO Int)</code>としてしか返せない。ここでも、すべての可能な整数を重ね合わせることになる。以下同様だ。シュレーディンガーの猫は決して外に出ない。<code>IO</code>モナドに入ると、抜け出す方法はない。<code>IO</code>モナドについて<code>runState</code>や<code>runReader</code>と同等のものはない。<code>runIO</code>はないのだ！
        </p>
        <p>では、Kleisli矢の結果である<code>IO</code>オブジェクトを、他のKleisli矢と合成する以外に何ができるだろう？
          そう、<code>main</code>から返せる。Haskellでは<code>main</code>は次のシグネチャを持つ:</p>
        <div class="sourceCode" id="cb439">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb439-1"><a href="#cb439-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span></code></pre>
        </div>
        <p>そしてこれはKleisli矢と見なして構わない:</p>
        <div class="sourceCode" id="cb440">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb440-1"><a href="#cb440-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre>
        </div>
        <p>
          この観点からは、Haskellのプログラムは<code>IO</code>モナドを使った1つの大きなKleisli矢にすぎない。モナディック合成を使えば複数の小さなKleisli矢から合成できる。生成された<code>IO</code>オブジェクト
          (<code>IO</code>アクションとも呼ばれる)
          で何を行うかはランタイムシステム次第だ。</p>
        <p>
          矢自体が純粋関数であることに注目してほしい――それは一貫して純粋関数だ。純粋でない仕事はシステムへと追いやられている。<code>main</code>から返された<code>IO</code>アクションを最終的に実行するとき、あらゆる種類の汚れ仕事が行われる。たとえば、ユーザー入力の読み取り、ファイルの変更、不愉快なメッセージの表示、ディスクのフォーマット、などなどだ。Haskellのプログラムは決して手を汚すことはない
          (ただし、<code>unsafePerformIO</code>を呼び出す場合は除くが、それは別の話だ)。</p>
        <p>
          当然、Haskellは遅延評価なので<code>main</code>はほとんど即座に戻り、純粋でない仕事はすぐに始まる。<code>IO</code>アクションの実行中に、純粋な計算の結果が要求され評価される。そのため、実際には、プログラムの実行では純粋な
          (Haskellの) コードと純粋でない (システムの)
          コードが折り重なっている。</p>
        <p>
          <code>IO</code>モナドには別の解釈がある。さらに奇妙な解釈だが、数学モデルとしては完全な意味をなす。それは宇宙全体をプログラム中のオブジェクトとして扱う。概念として、命令型モデルは宇宙を外部のグローバルオブジェクトとして扱うため、入出力を実行する手続きにはそのオブジェクトとの相互作用による副作用が伴うことに着目してほしい。それらは宇宙の状態を読み取ることも変更することもできる。
        </p>
        <p>
          関数型プログラミングで状態を扱う方法はすでに知っている――Stateモナドを使えばよい。しかし、単純な状態とは違って、宇宙の状態を標準的なデータ構造を使って記述するのは簡単ではない。しかし、直接扱わない限り、その必要はない。型<code>RealWorld</code>が存在し、宇宙工学の奇跡によってランタイムがこの型のオブジェクトを提供できる、と仮定すれば十分だ。<code>IO</code>作用はただの関数だ:
        </p>
        <div class="sourceCode" id="cb441">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb441-1"><a href="#cb441-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">IO</span> a  <span class="ot">=</span>  <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (a, <span class="dt">RealWorld</span>)</span></code></pre>
        </div>
        <p>あるいは、<code>State</code>モナドとしてはこうなる:</p>
        <div class="sourceCode" id="cb442">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb442-1"><a href="#cb442-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">IO</span> <span class="ot">=</span> <span class="dt">State</span> <span class="dt">RealWorld</span></span></code></pre>
        </div>
        <p>ただし、<code>IO</code>モナドの<code>&gt;=&gt;</code>と<code>return</code>は言語に組み込まれている必要がある。</p>
        <h3 data-number="21.2.9" id="インタラクティブな出力"><span class="header-section-number">21.2.9</span> インタラクティブな出力</h3>
        <p>
          同じ<code>IO</code>モナドがインタラクティブな出力をカプセル化するのに使われる。<code>RealWorld</code>はすべての出力デバイスを含むと見なされる。なぜ単にHaskellから出力関数を呼び出して、何もしないふりをすることができないのか疑問に思うだろう。たとえば、なぜ次のように書くのだろう:
        </p>
        <div class="sourceCode" id="cb443">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb443-1"><a href="#cb443-1" aria-hidden="true" tabindex="-1"></a><span class="fu">putStr</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre>
        </div>
        <p>単純に次のように書くのではいけないのだろうか:</p>
        <div class="sourceCode" id="cb444">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb444-1"><a href="#cb444-1" aria-hidden="true" tabindex="-1"></a><span class="fu">putStr</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> ()</span></code></pre>
        </div>
        <p>理由は2つある:
          Haskellは遅延評価なので、出力――ここではunitオブジェクト――が全く使われない関数は呼び出されない。また、遅延評価でなかったとしても、そのような呼び出しの順序は自由に変更でき、出力を混乱させうる。Haskellで2つの関数を強制的に逐次実行する唯一の方法はデータ依存性を使うことだ。ある関数の入力は別の関数の出力に依存する必要がある。<code>IO</code>アクション間で<code>RealWorld</code>を受け渡せば逐次処理を強制できる。
        </p>
        <p>概念としては、以下のプログラム:</p>
        <div class="sourceCode" id="cb445">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb445-1"><a href="#cb445-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb445-2"><a href="#cb445-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb445-3"><a href="#cb445-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStr</span> <span class="st">&quot;Hello &quot;</span></span>
<span id="cb445-4"><a href="#cb445-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStr</span> <span class="st">&quot;World!&quot;</span></span></code></pre>
        </div>
        <p>では、「World!」と表示するアクションは「Hello」がすでに画面に表示されている宇宙を入力として受け取る。そして画面に「Hello
          World!」と表示された新しい世界を出力する。</p>
        <h2 data-number="21.3" id="おわりに-1"><span class="header-section-number">21.3</span> おわりに</h2>
        <p>
          当然ながらここではモナドを使うプログラミングのほんの表面を撫でたにすぎない。モナドは、命令型プログラミングで副作用を使って通常行われることを純粋関数で行うだけでなく、高度な制御と型安全性を備えて実現している。しかし、欠点がないわけではない。モナドへのよくある不満は、互いに簡単に合成できないことだ。もちろん、基本的なモナドのほとんどは、モナドトランスフォーマーライブラリを使って結合できる。たとえば状態と例外を組み合わせたモナドスタックを作成するのは比較的簡単だが、任意のモナドをスタックするためのレシピはない。
        </p>
        <h1 data-number="22" id="圏論から見たモナド"><span class="header-section-number">22</span> 圏論から見たモナド</h1>
        <p>
          モナドについてプログラマーに話すと、おそらく作用について話すことになるだろう。数学者にとっては、モナドは代数に関するものだ。代数については後で話そう――代数はプログラミングにおいて重要な役割を果たす――まずは、代数とモナドとの関係について少し直観を得てもらおうと思う。さしあたっては、やや身振り手振りでの議論になるが、我慢してほしい。
        </p>
        <p>代数とは式を作成・操作・評価することだ。式は演算子を使って組み立てられる。次の単純な式を考えてみよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>x</mi>
                  <mn>2</mn>
                </msup>
                <mo>+</mo>
                <mn>2</mn>
                <mi>x</mi>
                <mo>+</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">x^2 + 2 x + 1</annotation>
            </semantics>
          </math></p>
        <p>この式は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>のような変数と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>や<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>のような定数とを加算や乗算のような演算子で組み合わせて構成されている。プログラマーはよく式を木
          (tree) と見なす。</p>
        <p><img src="images/exptree.png" style="width:30.0%" /></p>
        <p>木はコンテナなので、より一般化すると、式は変数を格納するコンテナだと言える。圏論ではコンテナを自己関手として表す。型<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を変数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>に代入すると、式は型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">m\ a</annotation>
            </semantics>
          </math>を持つことになる。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>は式木を構成する自己関手だ。(非自明な分岐式は通常、再帰的に定義された自己関手を使って作成される。)</p>
        <p>式に対して実行できる最もありふりた操作は何だろう？
          それは置換だ。つまり、変数を式に置き換えることだ。たとえば、この例では<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>y</mi>
                <mo>−</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">y-1</annotation>
            </semantics>
          </math>に置き換えて次のようにできる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>y</mi>
                    <mo>−</mo>
                    <mn>1</mn>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mn>2</mn>
                </msup>
                <mo>+</mo>
                <mn>2</mn>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>y</mi>
                  <mo>−</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>+</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">(y - 1)^2 + 2 (y - 1) + 1</annotation>
            </semantics>
          </math></p>
        <p>何が起きたかというと、型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">m\ a</annotation>
            </semantics>
          </math>の式を取って型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>→</mo>
                <mi>m</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \to m\ b</annotation>
            </semantics>
          </math>への変換を適用した
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>y</mi>
              <annotation encoding="application/x-tex">y</annotation>
            </semantics>
          </math>の型を表す)。結果は型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">m\ b</annotation>
            </semantics>
          </math>の式になる。詳しく説明しよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>→</mo>
                  <mi>m</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mi>m</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">m\ a \to (a \to m\ b) \to m\ b</annotation>
            </semantics>
          </math></p>
        <p>そうだ、これはモナディックなバインドのシグネチャだ。</p>
        <p>これはちょっとしたモチベーションになる。さあ、モナドの計算に移ろう。数学者はプログラマとは異なる表記法を用いる。自己関手には文字<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>を使い、<code>join</code>には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>、<code>return</code>には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>というギリシャ文字を使うのが好みだ。<code>join</code>も<code>return</code>も多相関数なので、自然変換に対応すると推測できる。</p>
        <p>したがって、圏論では、モナドは自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>のペアを伴った自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>として定義される。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>は関手の平方<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>T</mi>
                <mn>2</mn>
              </msup>
              <annotation encoding="application/x-tex">T^2</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>へ戻る自然変換だ。この平方は単に関手をそれ自身と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mo>∘</mo>
                <mi>T</mi>
              </mrow>
              <annotation encoding="application/x-tex">T \circ T</annotation>
            </semantics>
          </math>のように合成したものだ
          (このような平方は自己関手でしか行えない):</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>μ</mi>
                <mo>∷</mo>
                <msup>
                  <mi>T</mi>
                  <mn>2</mn>
                </msup>
                <mo>→</mo>
                <mi>T</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mu \Colon T^2 \to T</annotation>
            </semantics>
          </math></p>
        <p>この自然変換の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>についてのコンポーネントは次の射だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>μ</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mi>T</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>T</mi>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mi>T</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mu_a \Colon T (T a) \to T a</annotation>
            </semantics>
          </math></p>
        <p>これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐇</mi>
                <mi>𝐚</mi>
                <mi>𝐬</mi>
                <mi>𝐤</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Hask}</annotation>
            </semantics>
          </math>では、<code>join</code>の定義に直接変換される。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>は恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>I</mi>
              <annotation encoding="application/x-tex">I</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>の間の自然変換だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>η</mi>
                <mo>∷</mo>
                <mi>I</mi>
                <mo>→</mo>
                <mi>T</mi>
              </mrow>
              <annotation encoding="application/x-tex">\eta \Colon I \to T</annotation>
            </semantics>
          </math></p>
        <p>対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>に対し<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>I</mi>
              <annotation encoding="application/x-tex">I</annotation>
            </semantics>
          </math>を作用させると単に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>になるのを考慮すると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>のコンポーネントは次の射によって与えられる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>η</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>T</mi>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\eta_a \Colon a \to T a</annotation>
            </semantics>
          </math></p>
        <p>これは<code>return</code>の定義に直接変換される。</p>
        <p>これらの自然変換にはいくつか追加で満たすべき規則がある。1つの観点としては、これらの規則によって自己関手<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>に対してKleisli圏を定義できる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の間のKleisli矢は射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>→</mo>
                <mi>T</mi>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \to T b</annotation>
            </semantics>
          </math>として定義されることを思い出そう。そのような2つの矢の合成
          (ここでは下付き文字<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>を添えた円で記す)
          は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>を使って実装できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <msub>
                  <mo>∘</mo>
                  <mi>T</mi>
                </msub>
                <mi>f</mi>
                <mo>=</mo>
                <msub>
                  <mi>μ</mi>
                  <mi>c</mi>
                </msub>
                <mo>∘</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>T</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>g</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>∘</mo>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">g \circ_T f = \mu_c \circ (T\ g) \circ f</annotation>
            </semantics>
          </math></p>
        <p>ただし</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>f</mi>
                    <mo>∷</mo>
                    <mi>a</mi>
                    <mo>→</mo>
                    <mi>T</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>b</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>g</mi>
                    <mo>∷</mo>
                    <mi>b</mi>
                    <mo>→</mo>
                    <mi>T</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>c</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                f \Colon a \to T\ b \\
                g \Colon b \to T\ c
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>ここで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>は関手であり、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>に適用できる。この式はHaskellの記法で理解した方が簡単だろう:</p>
        <div class="sourceCode" id="cb446">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb446-1"><a href="#cb446-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;=&gt;</span> g <span class="ot">=</span> join <span class="op">.</span> <span class="fu">fmap</span> g <span class="op">.</span> f</span></code></pre>
        </div>
        <p>あるいは、コンポーネントで表すとこうなる:</p>
        <div class="sourceCode" id="cb447">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb447-1"><a href="#cb447-1" aria-hidden="true" tabindex="-1"></a>(f <span class="op">&gt;=&gt;</span> g) a <span class="ot">=</span> join (<span class="fu">fmap</span> g (f a))</span></code></pre>
        </div>
        <p>代数的に解釈すると、単に2つの連続した置換を合成しているだけだ。</p>
        <p>Kleisli矢が圏を形成するために、それらの合成が結合性を持っていて、かつ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>η</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\eta_a</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>における恒等Kleisli矢であってほしい。この要件は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>のモナド則に変換できる。しかし、これらの規則は、別の方法で導出すればもっとモノイド則に似て見えてくる。実際、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>はしばしば<em>乗算</em>
          (multiplication)
          と呼ばれ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>は<em>単位</em>
          (unit) と呼ばれる。</p>
        <p>大まかに言うと、結合則は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>の立方<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>T</mi>
                <mn>3</mn>
              </msup>
              <annotation encoding="application/x-tex">T^3</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>に縮約するための2つの方法が同じ結果を与えなければならない、と述べている。左右2つの単位元則は、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>に適用された後に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>で縮約すると再び<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>が得られる、と述べている。</p>
        <p>少しトリッキーなのは自然変換と関手を合成しているからだ。そこで水平合成について少し復習するのがよいだろう。たとえば、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>T</mi>
                <mn>3</mn>
              </msup>
              <annotation encoding="application/x-tex">T^3</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>T</mi>
                <mn>2</mn>
              </msup>
              <annotation encoding="application/x-tex">T^2</annotation>
            </semantics>
          </math>の後に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>を合成したものと見なせる。これに、次の2つの自然変換の水平合成を適用できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>I</mi>
                  <mi>T</mi>
                </msub>
                <mo>∘</mo>
                <mi>μ</mi>
              </mrow>
              <annotation encoding="application/x-tex">I_T \circ \mu</annotation>
            </semantics>
          </math></p>
        <p><img src="images/assoc1.png" style="width:40.0%" /></p>
        <p>すると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mo>∘</mo>
                <mi>T</mi>
              </mrow>
              <annotation encoding="application/x-tex">T \circ T</annotation>
            </semantics>
          </math>が得られ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>を適用するとさらに<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>に縮約できる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>I</mi>
                <mi>T</mi>
              </msub>
              <annotation encoding="application/x-tex">I_T</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>への恒等自然変換だ。このような水平合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>I</mi>
                  <mi>T</mi>
                </msub>
                <mo>∘</mo>
                <mi>μ</mi>
              </mrow>
              <annotation encoding="application/x-tex">I_T \circ \mu</annotation>
            </semantics>
          </math>はよく<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mo>∘</mo>
                <mi>μ</mi>
              </mrow>
              <annotation encoding="application/x-tex">T \circ \mu</annotation>
            </semantics>
          </math>と短く表記される。この表記に曖昧さはない。なぜなら、ある関手を自然変換と合成するのは意味がなく、それゆえこの文脈では<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>は必ず<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>I</mi>
                <mi>T</mi>
              </msub>
              <annotation encoding="application/x-tex">I_T</annotation>
            </semantics>
          </math>を意味するからだ。</p>
        <p>(自己)
          関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <mi>𝐂</mi>
                <mo>,</mo>
                <mi>𝐂</mi>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}\mathbf{C}, \mathbf{C}{]}</annotation>
            </semantics>
          </math>に図式を描くこともできる。</p>
        <p><img src="images/assoc2.png" style="width:30.0%" /></p>
        <p>あるいは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>T</mi>
                <mn>3</mn>
              </msup>
              <annotation encoding="application/x-tex">T^3</annotation>
            </semantics>
          </math>を合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>T</mi>
                  <mn>2</mn>
                </msup>
                <mo>∘</mo>
                <mi>T</mi>
              </mrow>
              <annotation encoding="application/x-tex">T^2 \circ T</annotation>
            </semantics>
          </math>として扱い、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>μ</mi>
                <mo>∘</mo>
                <mi>T</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mu \circ T</annotation>
            </semantics>
          </math>を適用することもできる。その結果も<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mo>∘</mo>
                <mi>T</mi>
              </mrow>
              <annotation encoding="application/x-tex">T \circ T</annotation>
            </semantics>
          </math>として扱い、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>をまた使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>に戻せる。これら2つの経路は同じ結果を生成する必要がある。</p>
        <p><img src="images/assoc.png" style="width:30.0%" /></p>
        <p>同様に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>の後に恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>I</mi>
              <annotation encoding="application/x-tex">I</annotation>
            </semantics>
          </math>を合成したものに対して水平合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>η</mi>
                <mo>∘</mo>
                <mi>T</mi>
              </mrow>
              <annotation encoding="application/x-tex">\eta \circ T</annotation>
            </semantics>
          </math>を適用して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>T</mi>
                <mn>2</mn>
              </msup>
              <annotation encoding="application/x-tex">T^2</annotation>
            </semantics>
          </math>が得られ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>を使って戻せる。その結果は恒等自然変換を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>に直接適用したかのように同じになるはずだ。そして、同様のことが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mo>∘</mo>
                <mi>η</mi>
              </mrow>
              <annotation encoding="application/x-tex">T \circ \eta</annotation>
            </semantics>
          </math>にもあてはまると類推できる。</p>
        <p><img src="images/unitlawcomp-1.png" style="width:40.0%" /></p>
        <p>Kleisli矢の合成が実際に圏の規則を満たすことをこれらの規則が保証するのは納得できるだろう。</p>
        <p>モナドとモノイドの類似点は驚くべきものだ。どちらにも乗算<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>・単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>・結合則・単位元則が存在する。しかし、我々のモノイドの定義は狭すぎて、モナドをモノイドとしては記述できない。そこで、モノイドの概念を一般化しよう。</p>
        <h2 data-number="22.1" id="モノイダル圏"><span class="header-section-number">22.1</span> モノイダル圏</h2>
        <p>モノイドの従来の定義に戻ろう。それは二項演算と単位という特殊な要素を持つ集合だ。Haskellでは、これは型クラスとして表現できる:</p>
        <div class="sourceCode" id="cb448">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb448-1"><a href="#cb448-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monoid</span> m <span class="kw">where</span></span>
<span id="cb448-2"><a href="#cb448-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    mappend ::</span> m <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> m</span>
<span id="cb448-3"><a href="#cb448-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    mempty  ::</span> m</span></code></pre>
        </div>
        <p>二項演算<code>mappend</code>は結合的かつ単位的 (unital)
          でなければならない
          (すなわち、単位<code>mempty</code>による乗算はno-opだ)。</p>
        <p>Haskellでの<code>mappend</code>の定義はカリー化されていることに注意してほしい。これは<code>m</code>のすべての要素を次の関数に写すと解釈できる:</p>
        <div class="sourceCode" id="cb449">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb449-1"><a href="#cb449-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mappend</span><span class="ot"> ::</span> m <span class="ot">-&gt;</span> (m <span class="ot">-&gt;</span> m)</span></code></pre>
        </div>
        <p>この解釈こそがモノイドを単一対象圏として定義するもととなる。その単一対象圏の自己準同型
          (endomorphism)
          である<code>(m -&gt; m)</code>がモノイドの要素を表す。ただし、Haskellにはカリー化が組み込まれているので、乗算の別の定義から始めてもよい:</p>
        <div class="sourceCode" id="cb450">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb450-1"><a href="#cb450-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mu ::</span> (m, m) <span class="ot">-&gt;</span> m</span></code></pre>
        </div>
        <p>ここで、カルテシアン積<code>(m, m)</code>は乗算されるペアの始域になる。</p>
        <p>この定義は一般化への別の道を示唆する:
          カルテシアン積を圏論的な積に置き換えるというものだ。積が大域的に定義されている圏から始め、対象<code>m</code>を選択し、乗算を射として定義できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>μ</mi>
                <mo>∷</mo>
                <mi>m</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>m</mi>
                <mo>→</mo>
                <mi>m</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mu \Colon m\times{}m \to m</annotation>
            </semantics>
          </math></p>
        <p>ただし、問題が1つある:
          任意の圏では対象の内部を覗き見られないのに、どうすれば単位元を選択できるだろう？
          そのためのトリックがある。要素選択が単集合からの関数と等価である仕組みを覚えているだろうか？
          Haskellでは、<code>mempty</code>の定義を次の関数に置き換えられた:</p>
        <div class="sourceCode" id="cb451">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb451-1"><a href="#cb451-1" aria-hidden="true" tabindex="-1"></a><span class="ot">eta ::</span> () <span class="ot">-&gt;</span> m</span></code></pre>
        </div>
        <p>単集合は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>の終対象なので、終対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>t</mi>
              <annotation encoding="application/x-tex">t</annotation>
            </semantics>
          </math>を持つすべての圏にこの定義を一般化するのは自然だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>η</mi>
                <mo>∷</mo>
                <mi>t</mi>
                <mo>→</mo>
                <mi>m</mi>
              </mrow>
              <annotation encoding="application/x-tex">\eta \Colon t \to m</annotation>
            </semantics>
          </math></p>
        <p>これにより、要素について述べることなく単位「要素」を選べる。</p>
        <p>
          以前モノイドを単一対象圏として定義したときとは違って、ここではモノイダル則が自動的に満たされるわけではなく、それらを課す必要がある。しかし、それらを定式化するには、基礎となる圏論的な積そのもののモノイダル構造を確立しなければならない。まずはHaskellでモノイダル構造がどう機能するか思い出そう。
        </p>
        <p>結合性から始める。Haskellでは、対応する等式的規則 (equational law)
          はこうなる:</p>
        <div class="sourceCode" id="cb452">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb452-1"><a href="#cb452-1" aria-hidden="true" tabindex="-1"></a>mu x (mu y z) <span class="ot">=</span> mu (mu x y) z</span></code></pre>
        </div>
        <p>これを他の圏に一般化する前に、関数 (射)
          の等価性として書き直す必要がある。個々の変数に対する作用から離れた抽象化が必要だ――言い換えれば、ポイントフリー記法を使う必要がある。カルテシアン積は双関手だと分かっているので、左辺はこう書ける:</p>
        <div class="sourceCode" id="cb453">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb453-1"><a href="#cb453-1" aria-hidden="true" tabindex="-1"></a>(mu <span class="op">.</span> bimap <span class="fu">id</span> mu)(x, (y, z))</span></code></pre>
        </div>
        <p>そして右辺はこうなる:</p>
        <div class="sourceCode" id="cb454">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb454-1"><a href="#cb454-1" aria-hidden="true" tabindex="-1"></a>(mu <span class="op">.</span> bimap mu <span class="fu">id</span>)((x, y), z)</span></code></pre>
        </div>
        <p>
          これはほぼ希望どおりだ。残念ながら、厳密に言うとカルテシアン積には結合性がない――<code>(x, (y, z))</code>と<code>((x, y), z)</code>は異なる――ので、ポイントフリーでは書けない:
        </p>
        <div class="sourceCode" id="cb455">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb455-1"><a href="#cb455-1" aria-hidden="true" tabindex="-1"></a>mu <span class="op">.</span> bimap <span class="fu">id</span> mu <span class="ot">=</span> mu <span class="op">.</span> bimap mu <span class="fu">id</span></span></code></pre>
        </div>
        <p>一方、ペアのネスト2つは同型だ。それらの間を変換する結合子
          (associator) と呼ばれる可逆関数がある:</p>
        <div class="sourceCode" id="cb456">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb456-1"><a href="#cb456-1" aria-hidden="true" tabindex="-1"></a><span class="ot">alpha ::</span> ((a, b), c) <span class="ot">-&gt;</span> (a, (b, c))</span>
<span id="cb456-2"><a href="#cb456-2" aria-hidden="true" tabindex="-1"></a>alpha ((x, y), z) <span class="ot">=</span> (x, (y, z))</span></code></pre>
        </div>
        <p>結合子の助けを借りれば<code>mu</code>についての結合則をポイントフリーで書ける:</p>
        <div class="sourceCode" id="cb457">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb457-1"><a href="#cb457-1" aria-hidden="true" tabindex="-1"></a>mu <span class="op">.</span> bimap <span class="fu">id</span> mu <span class="op">.</span> alpha <span class="ot">=</span> mu <span class="op">.</span> bimap mu <span class="fu">id</span></span></code></pre>
        </div>
        <p>単位元則にも同様のトリックを適用できる。新しい記法では次のような形式になる:</p>
        <div class="sourceCode" id="cb458">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb458-1"><a href="#cb458-1" aria-hidden="true" tabindex="-1"></a>mu (eta (), x) <span class="ot">=</span> x</span>
<span id="cb458-2"><a href="#cb458-2" aria-hidden="true" tabindex="-1"></a>mu (x, eta ()) <span class="ot">=</span> x</span></code></pre>
        </div>
        <p>これらは次のように書き直せる:</p>
        <div class="sourceCode" id="cb459">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb459-1"><a href="#cb459-1" aria-hidden="true" tabindex="-1"></a>(mu <span class="op">.</span> bimap eta <span class="fu">id</span>) ((), x) <span class="ot">=</span> lambda ((), x)</span>
<span id="cb459-2"><a href="#cb459-2" aria-hidden="true" tabindex="-1"></a>(mu <span class="op">.</span> bimap <span class="fu">id</span> eta) (x, ()) <span class="ot">=</span> rho (x, ())</span></code></pre>
        </div>
        <p>2つの同型射のうち<code>lambda</code>は左単位子 (left unitor)
          と呼ばれ、<code>rho</code>は右単位子 (right unitor)
          と呼ばれる。これらが示すのは、unit
          <code>()</code>が同型を除いてカルテシアン積の恒等射であるという事実だ:
        </p>
        <div class="sourceCode" id="cb460">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb460-1"><a href="#cb460-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lambda ::</span> ((), a) <span class="ot">-&gt;</span> a</span>
<span id="cb460-2"><a href="#cb460-2" aria-hidden="true" tabindex="-1"></a>lambda ((), x) <span class="ot">=</span> x</span></code></pre>
        </div>
        <div class="sourceCode" id="cb461">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb461-1"><a href="#cb461-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rho ::</span> (a, ()) <span class="ot">-&gt;</span> a</span>
<span id="cb461-2"><a href="#cb461-2" aria-hidden="true" tabindex="-1"></a>rho (x, ()) <span class="ot">=</span> x</span></code></pre>
        </div>
        <p>したがって、ポイントフリー版の単位元則は次のようになる:</p>
        <div class="sourceCode" id="cb462">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb462-1"><a href="#cb462-1" aria-hidden="true" tabindex="-1"></a>mu <span class="op">.</span> bimap <span class="fu">id</span> eta <span class="ot">=</span> lambda</span>
<span id="cb462-2"><a href="#cb462-2" aria-hidden="true" tabindex="-1"></a>mu <span class="op">.</span> bimap eta <span class="fu">id</span> <span class="ot">=</span> rho</span></code></pre>
        </div>
        <p>
          ここまでで、<code>mu</code>と<code>eta</code>についてのポイントフリーなモノイダル則の定式化を、基礎となるカルテシアン積自体が型の圏におけるモノイダル乗算のように作用するという事実を用いて行った。ただし、留意すべき点として、カルテシアン積の結合則と単位元則は同型を除いてのみ有効だ。
        </p>
        <p>これらの規則は積と終対象を持つすべての圏に一般化できるとわかった。圏論的な積は確かに同型を除いて結合的であり、同様に、同型を除いて終対象は単位だ。結合子と2つの単位子は自然同型だ。規則は可換図式で表せる。</p>
        <p><img src="images/assocmon.png" style="width:50.0%" /></p>
        <p>積は双関手なので射のペアをリフトできることに注意してほしい――Haskellではそのために<code>bimap</code>が使われる。</p>
        <p>ここで立ち止まって、圏論的な積と終対象を持つあらゆる圏においてモノイドを定義できる、と述べられる。モノイダル則を満たすような対象<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>と2つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>を選択できるならば、モノイドが存在する。しかし、もっとうまくやれる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>について規則を定式化するために完全な圏論的な積は必要ない。射影を使う普遍的構成によって積が定義されるのを思い出してほしい。モノイダル則の定式化に射影は一切使わなかった。</p>
        <p>積ではないのに積のように振る舞う双関手は<span id="tensor_product" class="keyword">テンソル積</span> (tensor product)
          と呼ばれ、中置演算子<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mo>⊗</mo>
              <annotation encoding="application/x-tex">\otimes</annotation>
            </semantics>
          </math>で表されることが多い。テンソル積の一般的な定義は少しトリッキーだが、気にしないでよい。ここでは単にその特性を列挙する――最も重要なのは同型を除いた結合性だ。</p>
        <p>同様に、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>t</mi>
              <annotation encoding="application/x-tex">t</annotation>
            </semantics>
          </math>が終対象である必要はない。それが終対象であるという特性――つまり、どの対象からも一意な射が存在すること――を使ったことはない。必要なのは、それがテンソル積とうまく協調して働くことだ。つまり、同型を除いてテンソル積の単位であってほしい。以上をまとめてみよう:
        </p>
        <p>モノイダル圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>はテンソル積と呼ばれる双関手を伴う:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo>⊗</mo>
                <mo>∷</mo>
                <mi>𝐂</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
                <mo>→</mo>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">\otimes \Colon \mathbf{C}\times{}\mathbf{C} \to \mathbf{C}
              </annotation>
            </semantics>
          </math></p>
        <p>そして、単位対象と呼ばれる特定の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>i</mi>
              <annotation encoding="application/x-tex">i</annotation>
            </semantics>
          </math>と、それぞれ結合子・左単位子・右単位子と呼ばれる3つの自然同型写像も伴う:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <msub>
                      <mi>α</mi>
                      <mrow>
                        <mi>a</mi>
                        <mi>b</mi>
                        <mi>c</mi>
                      </mrow>
                    </msub>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>a</mi>
                      <mo>⊗</mo>
                      <mi>b</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                    <mo>⊗</mo>
                    <mi>c</mi>
                    <mo>→</mo>
                    <mi>a</mi>
                    <mo>⊗</mo>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>b</mi>
                      <mo>⊗</mo>
                      <mi>c</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <msub>
                      <mi>λ</mi>
                      <mi>a</mi>
                    </msub>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>i</mi>
                    <mo>⊗</mo>
                    <mi>a</mi>
                    <mo>→</mo>
                    <mi>a</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <msub>
                      <mi>ρ</mi>
                      <mi>a</mi>
                    </msub>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>a</mi>
                    <mo>⊗</mo>
                    <mi>i</mi>
                    <mo>→</mo>
                    <mi>a</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                \alpha_{a b c} &amp;\Colon (a \otimes b) \otimes c \to a \otimes (b \otimes c) \\
                \lambda_a &amp;\Colon i \otimes a \to a \\
                \rho_a &amp;\Colon a \otimes i \to a
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>(テンソル四重積を単純化するためのコヒーレンス条件 (coherence
          condition) も存在する。)</p>
        <p>重要なのは、よく知られた多くの双関手がテンソル積で記述できることだ。それは特に、積、余積、そしてすぐ後でみるように自己関手の合成
          (そしてDay convolutionのようなより深遠な積)
          に対して機能する。モノイダル圏は豊穣圏の定式化において不可欠な役割を果たすことになる。</p>
        <h2 data-number="22.2" id="モノイダル圏におけるモノイド"><span class="header-section-number">22.2</span>
          モノイダル圏におけるモノイド</h2>
        <p>より一般的な設定のモノイダル圏でモノイドを定義する準備が整った。対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>を選択することから始めよう。テンソル積を使えば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>の冪乗を形成できる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>の平方は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mo>⊗</mo>
                <mi>m</mi>
              </mrow>
              <annotation encoding="application/x-tex">m \otimes m</annotation>
            </semantics>
          </math>だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>の立方を形成する方法は2つあるが、それらは結合子を通じて同型だ。より高次の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>の冪乗についても同様だ
          (そこではコヒーレンス条件が必要になる)。モノイドを形成するには2つの射を選ぶ必要がある:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>μ</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>m</mi>
                    <mo>⊗</mo>
                    <mi>m</mi>
                    <mo>→</mo>
                    <mi>m</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>η</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>i</mi>
                    <mo>→</mo>
                    <mi>m</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                \mu &amp;\Colon m \otimes m \to m \\
                \eta &amp;\Colon i \to m
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>i</mi>
              <annotation encoding="application/x-tex">i</annotation>
            </semantics>
          </math>はテンソル積の単位対象だ。</p>
        <p><img src="images/monoid-1.jpg" style="width:40.0%" /></p>
        <p>これらの射は結合則および単位元則を満たさなければならない。それらは以下の可換図式で表せる:</p>
        <p><img src="images/assoctensor.jpg" style="width:50.0%" /></p>
        <p><img src="images/unitmon.jpg" style="width:50.0%" /></p>
        <p>テンソル積が双関手であることが不可欠なことに注意してほしい。これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>μ</mi>
                <mo>⊗</mo>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mu \otimes \mathbf{id}</annotation>
            </semantics>
          </math>や<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>η</mi>
                <mo>⊗</mo>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\eta \otimes \mathbf{id}</annotation>
            </semantics>
          </math>のような積を形成するためには射のペアをリフトする必要があるからだ。これらの図式は、圏論的な積に関するこれまでの結果を直接的に一般化しているだけだ。</p>
        <h2 data-number="22.3" id="モノイドとしてのモナド"><span class="header-section-number">22.3</span> モノイドとしてのモナド</h2>
        <p>
          モノイダル構造は思いがけないところに現れる。その1つが関手圏だ。少し目を細めれば、関手の合成が積の生成に見えてくるだろう。問題は、2つの関手は合成できるとは限らないことだ――一方の終域圏が他方の始域圏でなければならない。これは射の合成の一般的な規則に他ならない――そして、すでに知っているとおり、関手はまさに圏<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>内の射だ。ただし、自己射
          (同じ対象にループバックする射)
          と同様に自己関手も常に合成可能だ。任意の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>への自己関手は関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <mi>𝐂</mi>
                <mo>,</mo>
                <mi>𝐂</mi>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}\mathbf{C}, \mathbf{C}{]}</annotation>
            </semantics>
          </math>を形成する。その対象は自己関手であり、射はそれらの間の自然変換だ。この圏から任意の2つの対象、たとえば自己関手<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>を取って、3番目の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∘</mo>
                <mi>G</mi>
              </mrow>
              <annotation encoding="application/x-tex">F \circ G</annotation>
            </semantics>
          </math>――それらを合成した自己関手――を生成できる。</p>
        <p>自己関手の合成はテンソル積の良い候補だろうか？
          まず、それが双関手だと示さなければならない。それを使って射――ここでは自然変換――のペアをリフトできるだろうか？
          テンソル積で<code>bimap</code>に相当するもののシグネチャは次のようになるだろう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑏</mi>
                  <mi>𝑖</mi>
                  <mi>𝑚</mi>
                  <mi>𝑎</mi>
                  <mi>𝑝</mi>
                </mrow>
                <mo>∷</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>→</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>→</mo>
                  <mi>d</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>⊗</mo>
                  <mi>c</mi>
                  <mo>→</mo>
                  <mi>b</mi>
                  <mo>⊗</mo>
                  <mi>d</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{bimap} \Colon (a \to b) \to (c \to d) \to (a \otimes c
                \to b \otimes d)</annotation>
            </semantics>
          </math></p>
        <p>対象を自己関手で、矢印を自然変換で、テンソル積を合成で置き換えると、次のようになる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mo>→</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>G</mi>
                  <mo>→</mo>
                  <mi>G</mi>
                  <mi>′</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mo>∘</mo>
                  <mi>G</mi>
                  <mo>→</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mo>∘</mo>
                  <mi>G</mi>
                  <mi>′</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">(F \to F&#39;) \to (G \to G&#39;) \to (F \circ G \to F&#39; \circ
                G&#39;)</annotation>
            </semantics>
          </math></p>
        <p>これは水平合成の特殊なケースだと気付くだろう。</p>
        <p><img src="images/horizcomp.png" style="width:40.0%" /></p>
        <p>また、自由に使える恒等自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>I</mi>
              <annotation encoding="application/x-tex">I</annotation>
            </semantics>
          </math>も存在する。これは自己関手の合成――新しいテンソル積――の恒等射として機能する。さらに、関手の合成は結合的だ。実際に結合則と単位元則は厳密だ――結合子や2つの単位子は必要ない。したがって、自己関手は関手合成をテンソル積として伴う厳密なモノイダル圏を形成する。
        </p>
        <p>この圏でのモノイドとは何だろう？
          それは対象――自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>と、2つの射――自然変換だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>μ</mi>
                    <mo>∷</mo>
                    <mi>T</mi>
                    <mo>∘</mo>
                    <mi>T</mi>
                    <mo>→</mo>
                    <mi>T</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>η</mi>
                    <mo>∷</mo>
                    <mi>I</mi>
                    <mo>→</mo>
                    <mi>T</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                \mu \Colon T \circ T \to T \\
                \eta \Colon I \to T
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>それだけでなく、モノイダル則もある:</p>
        <p><img src="images/assoc.png" style="width:40.0%" /></p>
        <p><img src="images/unitlawcomp.png" style="width:50.0%" /></p>
        <p>これらはいままで見てきたモナド則そのものだ。これでSaunders Mac
          Laneの有名な引用が理解できるだろう:</p>
        <blockquote>
          <p>端的に言えば、モナドは自己関手からなる圏におけるモノイドに他ならない。</p>
        </blockquote>
        <p>これが関数プログラミングのカンファレンスのTシャツにプリントされているのを見たことがあるかもしれない。</p>
        <h2 data-number="22.4" id="随伴に基づくモナド"><span class="header-section-number">22.4</span> 随伴に基づくモナド</h2>
        <p><a href="#adjunctions">随伴</a><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>⊣</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \dashv R</annotation>
            </semantics>
          </math>は2つの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の間を行き来する一対の関手だ。それらを合成する方法は2つあり、2つの自己関手<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">R \circ L</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \circ R</annotation>
            </semantics>
          </math>が生じる。随伴によると、これらの自己関手は単位と余単位と呼ばれる2つの自然変換を通じて恒等関手と関係している:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>η</mi>
                    <mo>∷</mo>
                    <msub>
                      <mi>I</mi>
                      <mi>𝐃</mi>
                    </msub>
                    <mo>→</mo>
                    <mi>R</mi>
                    <mo>∘</mo>
                    <mi>L</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>ε</mi>
                    <mo>∷</mo>
                    <mi>L</mi>
                    <mo>∘</mo>
                    <mi>R</mi>
                    <mo>→</mo>
                    <msub>
                      <mi>I</mi>
                      <mi>𝐂</mi>
                    </msub>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                \eta \Colon I_{\mathbf{D}} \to R \circ L \\
                \varepsilon \Colon L \circ R \to I_{\mathbf{C}}
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>すぐ分かるとおり、随伴の単位はモナドの単位にそっくりだ。自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">R \circ L</annotation>
            </semantics>
          </math>は実際にモナドなのが分かる。必要なのは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>に対応する適切な<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>を定義することだけだ。これは自己関手の正方図式と自己関手自体との間の自然変換であり、随伴関手では次のように表される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
                <mo>→</mo>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">R \circ L \circ R \circ L \to R \circ L</annotation>
            </semantics>
          </math></p>
        <p>そして、実際、余単位を使えば真ん中の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \circ R</annotation>
            </semantics>
          </math>を潰せる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>の実際の式は水平合成で与えられる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>μ</mi>
                <mo>=</mo>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>ε</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mu = R \circ \varepsilon \circ L</annotation>
            </semantics>
          </math></p>
        <p>モナド則は随伴の単位と余単位によって満たされた恒等射と交換則に従う。</p>
        <p>随伴から派生したモナドをHaskellであまり見かけないのは、随伴には通常2つの圏が関わるからだ。ただし、冪乗すなわち関数オブジェクトの定義は例外だ。この随伴は次の2つの自己関手から形成される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>L</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>z</mi>
                    <mo>=</mo>
                    <mi>z</mi>
                    <mo>×</mo>
                    <mrow></mrow>
                    <mi>s</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>R</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>b</mi>
                    <mo>=</mo>
                    <mi>s</mi>
                    <mo>⇒</mo>
                    <mi>b</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                L\ z = z\times{}s \\
                R\ b = s \Rightarrow b
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>これらを合成するとお馴染みのstateモナドになるのが分かるだろう。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>L</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>z</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>=</mo>
                <mi>s</mi>
                <mo>⇒</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>z</mi>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>s</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">R\ (L\ z) = s \Rightarrow (z\times{}s)</annotation>
            </semantics>
          </math></p>
        <p>このモナドは以前Haskellで見たことがある:</p>
        <div class="sourceCode" id="cb463">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb463-1"><a href="#cb463-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> (s <span class="ot">-&gt;</span> (a, s))</span></code></pre>
        </div>
        <p>この随伴もHaskellに翻訳してみよう。左関手は積関手だ:</p>
        <div class="sourceCode" id="cb464">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb464-1"><a href="#cb464-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Prod</span> s a <span class="ot">=</span> <span class="dt">Prod</span> (a, s)</span></code></pre>
        </div>
        <p>そして右関手はreader関手だ:</p>
        <div class="sourceCode" id="cb465">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb465-1"><a href="#cb465-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Reader</span> s a <span class="ot">=</span> <span class="dt">Reader</span> (s <span class="ot">-&gt;</span> a)</span></code></pre>
        </div>
        <p>これらは随伴を形成する:</p>
        <div class="sourceCode" id="cb466">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb466-1"><a href="#cb466-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Adjunction</span> (<span class="dt">Prod</span> s) (<span class="dt">Reader</span> s) <span class="kw">where</span></span>
<span id="cb466-2"><a href="#cb466-2" aria-hidden="true" tabindex="-1"></a>  counit (<span class="dt">Prod</span> (<span class="dt">Reader</span> f, s)) <span class="ot">=</span> f s</span>
<span id="cb466-3"><a href="#cb466-3" aria-hidden="true" tabindex="-1"></a>  unit a <span class="ot">=</span> <span class="dt">Reader</span> (\s <span class="ot">-&gt;</span> <span class="dt">Prod</span> (a, s))</span></code></pre>
        </div>
        <p>積関手の後にreader関手を合成したものが実際にstate関手と等価なのは容易に納得できる:</p>
        <div class="sourceCode" id="cb467">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb467-1"><a href="#cb467-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> (s <span class="ot">-&gt;</span> (a, s))</span></code></pre>
        </div>
        <p>
          予想どおり、随伴の<code>unit</code>はstateモナドの<code>return</code>関数と等価だ。<code>counit</code>は、引数に作用する関数を評価することによって作用する。これは<code>runState</code>関数の非カリー化版と見なせる。
        </p>
        <div class="sourceCode" id="cb468">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb468-1"><a href="#cb468-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb468-2"><a href="#cb468-2" aria-hidden="true" tabindex="-1"></a>runState (<span class="dt">State</span> f) s <span class="ot">=</span> f s</span></code></pre>
        </div>
        <p>(非カリー化する理由は、<code>counit</code>でペアに作用するからだ)。</p>
        <p>ここでstateモナドの<code>join</code>を自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>のコンポーネントとして定義できる。そのためには3つの自然変換を水平合成したものが必要だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>μ</mi>
                <mo>=</mo>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>ε</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mu = R \circ \varepsilon \circ L</annotation>
            </semantics>
          </math></p>
        <p>言い換えると、余単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>をreader関手の1つのレベルに忍び込ませる必要がある。単に<code>fmap</code>を直接呼び出すことはできない。なぜなら、コンパイラが<code>Reader</code>関手のものではなく<code>State</code>関手のものを選択するだろうからだ。だが、reader関手の<code>fmap</code>は左関数合成にすぎないことを思い出してほしい。そのため、関数合成を直接使うことにする。
        </p>
        <p>まず、データコンストラクター<code>State</code>を切り離すことで<code>State</code>関手内の関数を公開する必要がある。これは<code>runState</code>を使って行われる。
        </p>
        <div class="sourceCode" id="cb469">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb469-1"><a href="#cb469-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ssa ::</span> <span class="dt">State</span> s (<span class="dt">State</span> s a)</span>
<span id="cb469-2"><a href="#cb469-2" aria-hidden="true" tabindex="-1"></a>runState<span class="ot"> ssa ::</span> s <span class="ot">-&gt;</span> (<span class="dt">State</span> s a, s)</span></code></pre>
        </div>
        <p>次に、<code>uncurry runState</code>によって定義される余単位に左合成する。最後に、<code>State</code>データコンストラクターに戻す:</p>
        <div class="sourceCode" id="cb470">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb470-1"><a href="#cb470-1" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> <span class="dt">State</span> s (<span class="dt">State</span> s a) <span class="ot">-&gt;</span> <span class="dt">State</span> s a</span>
<span id="cb470-2"><a href="#cb470-2" aria-hidden="true" tabindex="-1"></a>join ssa <span class="ot">=</span> <span class="dt">State</span> (<span class="fu">uncurry</span> runState <span class="op">.</span> runState ssa)</span></code></pre>
        </div>
        <p>これはまさに<code>State</code>モナドのための<code>join</code>の実装だ。</p>
        <p>あらゆる随伴からモナドが生じるだけでなく、逆もまた真だと分かる:
          あらゆるモナドは随伴関手2つの合成に分解できる。ただし、そのような分解は一意ではない。</p>
        <p>もう1つの自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \circ R</annotation>
            </semantics>
          </math>については次章で述べる。</p>
        <h1 data-number="23" id="コモナド"><span class="header-section-number">23</span> コモナド</h1>
        <p>モナドが使えるようになったので、双対性の恩恵を受けられ、矢を逆にして反対圏で作業するだけでコモナドを無料で手に入れられる。</p>
        <p>最も基本的なレベルでは、モナドはKleisli矢の合成に関するのを思い出してほしい:</p>
        <div class="sourceCode" id="cb471">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb471-1"><a href="#cb471-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> m b</span></code></pre>
        </div>
        <p>ここで<code>m</code>はモナドである関手だ。コモナドを文字<code>w</code>
          (逆さの<code>m</code>) で表すと、余Kleisli矢 (co-Kleisli arrow)
          を次の型の射として定義できる:</p>
        <div class="sourceCode" id="cb472">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb472-1"><a href="#cb472-1" aria-hidden="true" tabindex="-1"></a>w a <span class="ot">-&gt;</span> b</span></code></pre>
        </div>
        <p>余Kleisli矢についてfish演算子に相当するものは次のように定義される:</p>
        <div class="sourceCode" id="cb473">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb473-1"><a href="#cb473-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(=&gt;=) ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (w b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (w a <span class="ot">-&gt;</span> c)</span></code></pre>
        </div>
        <p>余Kleisli矢が圏を形成するには<code>extract</code>と呼ばれる恒等余Kleisli矢も必要だ:</p>
        <div class="sourceCode" id="cb474">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb474-1"><a href="#cb474-1" aria-hidden="true" tabindex="-1"></a><span class="ot">extract ::</span> w a <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <p>これは<code>return</code>の双対だ。さらに、左恒等射と右恒等射だけでなく結合則も必須だ。すべてをまとめると、Haskellではコモナドを次のように定義できる:</p>
        <div class="sourceCode" id="cb475">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb475-1"><a href="#cb475-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> w <span class="ot">=&gt;</span> <span class="dt">Comonad</span> w <span class="kw">where</span></span>
<span id="cb475-2"><a href="#cb475-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (=&gt;=) ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (w b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (w a <span class="ot">-&gt;</span> c)</span>
<span id="cb475-3"><a href="#cb475-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    extract ::</span> w a <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <p>実用上は、後で説明するように、わずかに異なるプリミティブが使われる。</p>
        <p>問題は、コモナドがプログラミングで何の役に立つかだ。</p>
        <h2 data-number="23.1" id="コモナドでのプログラミング"><span class="header-section-number">23.1</span>
          コモナドでのプログラミング</h2>
        <p>
          モナドとコモナドを比べてみよう。モナドはコンテナに値を入れる手段を<code>return</code>によって提供している。そして、内部に格納された値にはアクセスできない。もちろんモナドを実装するデータ構造は内容へのアクセスを提供してもよいが、それはおまけと見なされる。モナドから値を抽出するための一般的なインターフェースはない。例として見た<code>IO</code>モナドは内容を決して公開しないことを誇りとしている。
        </p>
        <p>一方、コモナドは単一の値を取り出す手段を提供している。そして、値を挿入する手段は提供しない。コモナドをコンテナと見なしたいなら、その中身はいつも事前に満たされていて、覗き見られるようになっている。</p>
        <p>Kleisli矢は値を受け取り、文脈で装飾した結果を生成する。同様に、余Kleisli矢は文脈全体と共に値を受け取り、結果を生成する。これは<span id="contextual_computation"
            class="keyword">文脈付き計算</span>
          (contextual computation) の実施例だ。</p>
        <h2 data-number="23.2" id="積コモナド"><span class="header-section-number">23.2</span> 積コモナド</h2>
        <p>Readerモナドを覚えているだろうか？
          それを導入した理由は、何らかの読み取り専用の環境<code>e</code>へのアクセスを必要とする計算を実装する問題に取り組むためだった。そのような計算は純粋関数として次の形で表せる:</p>
        <div class="sourceCode" id="cb476">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb476-1"><a href="#cb476-1" aria-hidden="true" tabindex="-1"></a>(a, e) <span class="ot">-&gt;</span> b</span></code></pre>
        </div>
        <p>それらをKleisli矢に変えるのにはカリー化を使った:</p>
        <div class="sourceCode" id="cb477">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb477-1"><a href="#cb477-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> b)</span></code></pre>
        </div>
        <p>しかし、これらの関数がすでに余Kleisli矢の形をしていることに注目してほしい。引数をもっと便利な関手の形式に書き換えてみよう:</p>
        <div class="sourceCode" id="cb478">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb478-1"><a href="#cb478-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Product</span> e a <span class="ot">=</span> <span class="dt">Prod</span> e a <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre>
        </div>
        <p>合成演算子は簡単に定義できる。合成しようとしている矢でも同じ環境を使えるようにすればよい:</p>
        <div class="sourceCode" id="cb479">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb479-1"><a href="#cb479-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(=&gt;=) ::</span> (<span class="dt">Product</span> e a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">Product</span> e b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (<span class="dt">Product</span> e a <span class="ot">-&gt;</span> c)</span>
<span id="cb479-2"><a href="#cb479-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">=&gt;=</span> g <span class="ot">=</span> \(<span class="dt">Prod</span> e a) <span class="ot">-&gt;</span> <span class="kw">let</span> b <span class="ot">=</span> f (<span class="dt">Prod</span> e a)</span>
<span id="cb479-3"><a href="#cb479-3" aria-hidden="true" tabindex="-1"></a>                          c <span class="ot">=</span> g (<span class="dt">Prod</span> e b)</span>
<span id="cb479-4"><a href="#cb479-4" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">in</span> c</span></code></pre>
        </div>
        <p><code>extract</code>の実装は環境を単に無視する:</p>
        <div class="sourceCode" id="cb480">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb480-1"><a href="#cb480-1" aria-hidden="true" tabindex="-1"></a>extract (<span class="dt">Prod</span> e a) <span class="ot">=</span> a</span></code></pre>
        </div>
        <p>
          当然ながら、積コモナドはreaderモナドとまったく同じ計算を実行するのに使える。ある意味で、環境をコモナドで実装するのはより自然だ――「文脈に沿った計算」の精神に則っている。一方、モナドは<code>do</code>記法という便利な構文糖を備えている。
        </p>
        <p>readerモナドと積コモナドの関係はさらに深く、reader関手が積関手の右随伴であるという事実に関連している。しかし、一般的には、コモナドはモナドとは異なる計算の概念を扱う。さらなる例について後で説明する。</p>
        <p>積コモナド<code>Product</code>は、タプルやレコードを含む任意の直積型へ簡単に一般化できる。</p>
        <h2 data-number="23.3" id="合成の分析"><span class="header-section-number">23.3</span> 合成の分析</h2>
        <p>
          双対化のプロセスを続けることで、モナディックなbindとjoinを双対化できた。別の方法として、モナドで用いたプロセスを繰り返すこともできる。そこではfish演算子の解剖学を研究した。そのアプローチの方が啓発的に思える。
        </p>
        <p>
          出発点は、合成演算子は<code>w a</code>をとり<code>c</code>を生成する余Kleisli矢を生成しなければならない、という認識だ。<code>c</code>を生成する唯一の方法は、2番目の関数を型<code>w b</code>の引数に適用することだ:
        </p>
        <div class="sourceCode" id="cb481">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb481-1"><a href="#cb481-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(=&gt;=) ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (w b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (w a <span class="ot">-&gt;</span> c)</span>
<span id="cb481-2"><a href="#cb481-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">=&gt;=</span> g <span class="ot">=</span> g <span class="op">...</span></span></code></pre>
        </div>
        <p>だが、<code>g</code>に与えうる型<code>w b</code>の値はどうすれば生成できるだろうか？
          型<code>w a</code>の引数と関数<code>f :: w a -&gt; b</code>は自由に使える。答えはbindの双対を定義することだ。それはextendと呼ばれる:</p>
        <div class="sourceCode" id="cb482">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb482-1"><a href="#cb482-1" aria-hidden="true" tabindex="-1"></a><span class="ot">extend ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</span></code></pre>
        </div>
        <p><code>extend</code>を使えば合成を実装できる:</p>
        <div class="sourceCode" id="cb483">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb483-1"><a href="#cb483-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">=&gt;=</span> g <span class="ot">=</span> g <span class="op">.</span> extend f</span></code></pre>
        </div>
        <p>次は<code>extend</code>を解剖できるだろうか？
          なぜ単に関数<code>w a -&gt; b</code>を引数<code>w a</code>に適用しないのか、と言いたくなるかもしれない。しかし、結果として得られる<code>b</code>を<code>w b</code>に変換する方法がないことにすぐ気付くだろう。コモナドには値をリフトする手段がないことを覚えておいてほしい。ここではモナドに類似した構成で<code>fmap</code>を使った。ここで<code>fmap</code>が使えるとすれば、型<code>w (w a)</code>の何かが自由に使える場合だけだ。<code>w a</code>を<code>w (w a)</code>に変えられさえすればよい。そして、便利なことに、それはまさに<code>join</code>の双対だ。それは<code>duplicate</code>と呼ばれる:
        </p>
        <div class="sourceCode" id="cb484">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb484-1"><a href="#cb484-1" aria-hidden="true" tabindex="-1"></a><span class="ot">duplicate ::</span> w a <span class="ot">-&gt;</span> w (w a)</span></code></pre>
        </div>
        <p>
          したがって、モナドと同様に、コモナドにも3つの等価な定義がある。すなわち、余Kleisli矢の使用、<code>extend</code>、<code>duplicate</code>だ。Haskellの<code>Control.Comonad</code>ライブラリから直接引用した定義を以下に示す:
        </p>
        <div class="sourceCode" id="cb485">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb485-1"><a href="#cb485-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> w <span class="ot">=&gt;</span> <span class="dt">Comonad</span> w <span class="kw">where</span></span>
<span id="cb485-2"><a href="#cb485-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  extract ::</span> w a <span class="ot">-&gt;</span> a</span>
<span id="cb485-3"><a href="#cb485-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  duplicate ::</span> w a <span class="ot">-&gt;</span> w (w a)</span>
<span id="cb485-4"><a href="#cb485-4" aria-hidden="true" tabindex="-1"></a>  duplicate <span class="ot">=</span> extend <span class="fu">id</span></span>
<span id="cb485-5"><a href="#cb485-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  extend ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</span>
<span id="cb485-6"><a href="#cb485-6" aria-hidden="true" tabindex="-1"></a>  extend f <span class="ot">=</span> <span class="fu">fmap</span> f <span class="op">.</span> duplicate</span></code></pre>
        </div>
        <p><code>extend</code>のデフォルト実装が<code>duplicate</code>によって提供され、逆も同様だ。したがって、どちらか1つをオーバーライドするだけでよい。</p>
        <p>これらの関数の背景にある直観は、一般にコモナドは型<code>a</code>の値で満たされたコンテナと見なせるという考えに基づいている
          (積コモナドは値が1つしかない特殊なケースだ)。「現在の」値という概念があり、それは<code>extract</code>によって簡単にアクセスできる。余Kleisli矢は現在の値に焦点を合わせて計算を実行するものの、周囲のすべての値にアクセスできる。コンウェイのライフゲームを考えてみてほしい。各セルには値が含まれる
          (通常は<code>True</code>か<code>False</code>だ)。ライフゲームに対応するコモナドは「現在の」セルに焦点を合わせたセルのグリッドだ。</p>
        <p>では<code>duplicate</code>は何をするのだろう？
          それはコモナディックなコンテナ<code>w a</code>を取ってコンテナのコンテナ<code>w (w a)</code>を生成する。つまり、それぞれのコンテナが<code>w a</code>内部の異なる<code>a</code>に焦点を合わせているという考え方だ。ライフゲームでは、グリッドのグリッドが得られる。外側のグリッドの各セルには、個別のセルに焦点を合わせた内側のグリッドが含まれている。
        </p>
        <p>
          次に<code>extend</code>を見てみよう。これは、余Kleisli矢と、複数の<code>a</code>で満たされたコモナディックなコンテナ<code>w a</code>を取る。そして、すべての<code>a</code>に計算を適用して<code>b</code>に置き換える。結果は複数の<code>b</code>で満たされたコモナディックなコンテナだ。そのために<code>extend</code>は、焦点を合わせる<code>a</code>を次々にシフトしていき、それぞれに余Kleisli矢を適用する。ライフゲームでは、余Kleisli矢は現在のセルの新しい状態を計算する。そのために文脈
          (すなわち最近傍セル)
          に注目する。<code>extend</code>のデフォルト実装はこの過程を示している。まず<code>duplicate</code>を呼び出してすべての可能な焦点を生成し、次にそのそれぞれに<code>f</code>を適用する。
        </p>
        <h2 data-number="23.4" id="streamコモナド"><span class="header-section-number">23.4</span> Streamコモナド</h2>
        <p>コンテナ内で焦点を合わせる要素を次々にシフトしていくこのプロセスを最もうまく説明できるのは無限ストリームの例だ。そのようなストリームはリストにそっくりだが、空のコンストラクターがない点が異なる:</p>
        <div class="sourceCode" id="cb486">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb486-1"><a href="#cb486-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stream</span> a <span class="ot">=</span> <span class="dt">Cons</span> a (<span class="dt">Stream</span> a)</span></code></pre>
        </div>
        <p>これは次の<code>Functor</code>にすぎない:</p>
        <div class="sourceCode" id="cb487">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb487-1"><a href="#cb487-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Stream</span> <span class="kw">where</span></span>
<span id="cb487-2"><a href="#cb487-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> f (<span class="dt">Cons</span> a as) <span class="ot">=</span> <span class="dt">Cons</span> (f a) (<span class="fu">fmap</span> f as)</span></code></pre>
        </div>
        <p>ストリームの焦点はその最初の要素なので、<code>extract</code>の実装は次のようになる:</p>
        <div class="sourceCode" id="cb488">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb488-1"><a href="#cb488-1" aria-hidden="true" tabindex="-1"></a>extract (<span class="dt">Cons</span> a _) <span class="ot">=</span> a</span></code></pre>
        </div>
        <p><code>duplicate</code>は、それぞれ異なる要素に焦点を合わせた複数のストリームからなるストリームを1つ生成する。</p>
        <div class="sourceCode" id="cb489">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb489-1"><a href="#cb489-1" aria-hidden="true" tabindex="-1"></a>duplicate (<span class="dt">Cons</span> a as) <span class="ot">=</span> <span class="dt">Cons</span> (<span class="dt">Cons</span> a as) (duplicate as)</span></code></pre>
        </div>
        <p>最初の要素はもとのストリーム、2番目の要素は元のストリームの尾部、3番目の要素はさらにその尾部、というように無限に続く。</p>
        <p>完全なインスタンスは次のとおりだ:</p>
        <div class="sourceCode" id="cb490">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb490-1"><a href="#cb490-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Comonad</span> <span class="dt">Stream</span> <span class="kw">where</span></span>
<span id="cb490-2"><a href="#cb490-2" aria-hidden="true" tabindex="-1"></a>    extract (<span class="dt">Cons</span> a _) <span class="ot">=</span> a</span>
<span id="cb490-3"><a href="#cb490-3" aria-hidden="true" tabindex="-1"></a>    duplicate (<span class="dt">Cons</span> a as) <span class="ot">=</span> <span class="dt">Cons</span> (<span class="dt">Cons</span> a as) (duplicate as)</span></code></pre>
        </div>
        <p>
          これは非常に関数的な観点でストリームを捉えている。おそらく命令型言語ではストリームを1要素だけシフトする<code>advance</code>メソッドから始めるだろう。しかし、ここでの<code>duplicate</code>はシフトされたすべてのストリームを一気に生成する。Haskellの遅延評価がこれを可能にし、望ましいものにさえしている。当然、<code>Stream</code>を実用的なものにするために、<code>advance</code>に類似したものも実装する:
        </p>
        <div class="sourceCode" id="cb491">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb491-1"><a href="#cb491-1" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span><span class="ot"> ::</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> a</span>
<span id="cb491-2"><a href="#cb491-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span> (<span class="dt">Cons</span> a as) <span class="ot">=</span> as</span></code></pre>
        </div>
        <p>ただし、これは決してコモナディックなインターフェイスの一部ではない。</p>
        <p>デジタル信号処理の経験があればすぐ分かるとおり、ストリームに対する余Kleisli矢は単なるデジタルフィルタであり、<code>extend</code>はフィルターされたストリームを生成する。</p>
        <p>簡単な例として、移動平均フィルターを実装してみよう。ストリームの<code>n</code>個の要素を合計する関数はこうなる:</p>
        <div class="sourceCode" id="cb492">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb492-1"><a href="#cb492-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sumS ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb492-2"><a href="#cb492-2" aria-hidden="true" tabindex="-1"></a>sumS n (<span class="dt">Cons</span> a as) <span class="ot">=</span> <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dv">0</span> <span class="kw">else</span> a <span class="op">+</span> sumS (n <span class="op">-</span> <span class="dv">1</span>) as</span></code></pre>
        </div>
        <p>また、ストリームの最初の<code>n</code>要素の平均を計算する関数はこうなる:</p>
        <div class="sourceCode" id="cb493">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb493-1"><a href="#cb493-1" aria-hidden="true" tabindex="-1"></a><span class="ot">average ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb493-2"><a href="#cb493-2" aria-hidden="true" tabindex="-1"></a>average n stm <span class="ot">=</span> (sumS n stm) <span class="op">/</span> (<span class="fu">fromIntegral</span> n)</span></code></pre>
        </div>
        <p>部分適用された<code>average n</code>は余Kleisli矢なので、ストリーム全体にわたって<code>extend</code>できる:</p>
        <div class="sourceCode" id="cb494">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb494-1"><a href="#cb494-1" aria-hidden="true" tabindex="-1"></a><span class="ot">movingAvg ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> a</span>
<span id="cb494-2"><a href="#cb494-2" aria-hidden="true" tabindex="-1"></a>movingAvg n <span class="ot">=</span> extend (average n)</span></code></pre>
        </div>
        <p>結果は移動平均のストリームとなる。</p>
        <p>ストリームは単方向1次元コモナドの例だ。これは簡単に双方向にしたり多次元に拡張したりできる。</p>
        <h2 data-number="23.5" id="圏論から見たコモナド"><span class="header-section-number">23.5</span> 圏論から見たコモナド</h2>
        <p>圏論でコモナドを定義することは双対性の平易な練習になる。モナドと同様に、自己関手<code>T</code>から始めよう。モナドを定義する2つの自然変換<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>は、コモナドでは単に反転される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>ε</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>T</mi>
                    <mo>→</mo>
                    <mi>I</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>δ</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>T</mi>
                    <mo>→</mo>
                    <msup>
                      <mi>T</mi>
                      <mn>2</mn>
                    </msup>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                \varepsilon &amp;\Colon T \to I \\
                \delta &amp;\Colon T \to T^2
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>これらの変換のコンポーネントは、<code>extract</code>および<code>duplicate</code>に対応する。コモナド則は鏡に映ったモナド則だ。これは驚くようなことではない。</p>
        <p>また、モナドは随伴から導出できる。双対性は随伴を反転させる:
          左随伴と右随伴が入れ替わる。また、合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">R \circ L</annotation>
            </semantics>
          </math>がモナドを定義するので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \circ R</annotation>
            </semantics>
          </math>はコモナドを定義すべきだ。随伴の余単位は次のようになる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>ε</mi>
                <mo>∷</mo>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
                <mo>→</mo>
                <mi>I</mi>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon \Colon L \circ R \to I</annotation>
            </semantics>
          </math></p>
        <p>この<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>は、コモナドの定義や、Haskellの<code>extract</code>のようなコンポーネントで見られるものと同じだ。随伴の単位:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>η</mi>
                <mo>∷</mo>
                <mi>I</mi>
                <mo>→</mo>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">\eta \Colon I \to R \circ L</annotation>
            </semantics>
          </math></p>
        <p>も、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \circ R</annotation>
            </semantics>
          </math>の途中に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">R \circ L</annotation>
            </semantics>
          </math>を挿入して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \circ R \circ L \circ R</annotation>
            </semantics>
          </math>を作成するのに使える。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>T</mi>
                <mn>2</mn>
              </msup>
              <annotation encoding="application/x-tex">T^2</annotation>
            </semantics>
          </math>を作ると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>δ</mi>
              <annotation encoding="application/x-tex">\delta</annotation>
            </semantics>
          </math>が定義され、コモナドの定義が完成する。</p>
        <p>モナドがモノイドであることもすでに見た。この宣言の双対にはコモナドが必要だが、ではコモノイドとは何だろう？
          モノイドとは単一対象圏である、という当初の定義を双対化しても興味深いものは何も得られない。すべての自己準同型を逆向きにすると別のモノイドが得られる。しかし、思い出してほしい。モナドへのアプローチで用いた定義は、モノイドとはモノイダル圏の対象であるという、より一般化されたものだ。その構成は2つの射に基づいていた:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>μ</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>m</mi>
                    <mo>⊗</mo>
                    <mi>m</mi>
                    <mo>→</mo>
                    <mi>m</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>η</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>i</mi>
                    <mo>→</mo>
                    <mi>m</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                \mu &amp;\Colon m \otimes m \to m \\
                \eta &amp;\Colon i \to m
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>これらの射を逆にするとモノイダル圏でのコモノイドができる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>δ</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>m</mi>
                    <mo>→</mo>
                    <mi>m</mi>
                    <mo>⊗</mo>
                    <mi>m</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>ε</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>m</mi>
                    <mo>→</mo>
                    <mi>i</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                \delta &amp;\Colon m \to m \otimes m \\
                \varepsilon &amp;\Colon m \to i
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>コモノイドの定義はHaskellで書くと:</p>
        <div class="sourceCode" id="cb495">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb495-1"><a href="#cb495-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Comonoid</span> m <span class="kw">where</span></span>
<span id="cb495-2"><a href="#cb495-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  split   ::</span> m <span class="ot">-&gt;</span> (m, m)</span>
<span id="cb495-3"><a href="#cb495-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  destroy ::</span> m <span class="ot">-&gt;</span> ()</span></code></pre>
        </div>
        <p>となり、ほぼ自明だ。明らかに<code>destroy</code>は引数を無視する:</p>
        <div class="sourceCode" id="cb496">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb496-1"><a href="#cb496-1" aria-hidden="true" tabindex="-1"></a>destroy _ <span class="ot">=</span> ()</span></code></pre>
        </div>
        <p>また、<code>split</code>は単に関数のペアだ:</p>
        <div class="sourceCode" id="cb497">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb497-1"><a href="#cb497-1" aria-hidden="true" tabindex="-1"></a>split x <span class="ot">=</span> (f x, g x)</span></code></pre>
        </div>
        <p>ここで、モノイドの単位元則と双対関係にあるコモノイド則について考えてみよう:</p>
        <div class="sourceCode" id="cb498">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb498-1"><a href="#cb498-1" aria-hidden="true" tabindex="-1"></a>lambda <span class="op">.</span> bimap destroy <span class="fu">id</span> <span class="op">.</span> split <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb498-2"><a href="#cb498-2" aria-hidden="true" tabindex="-1"></a>rho <span class="op">.</span> bimap <span class="fu">id</span> destroy <span class="op">.</span> split <span class="ot">=</span> <span class="fu">id</span></span></code></pre>
        </div>
        <p>ここで、<code>lambda</code>は左単位子で<code>rho</code>は右単位子だ
          (<a href="#monad-categorically">モノイダル圏</a>の定義を参照)。これらの定義を代入すると:</p>
        <div class="sourceCode" id="cb499">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb499-1"><a href="#cb499-1" aria-hidden="true" tabindex="-1"></a>lambda (bimap destroy <span class="fu">id</span> (split x))</span>
<span id="cb499-2"><a href="#cb499-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> lambda (bimap destroy <span class="fu">id</span> (f x, g x))</span>
<span id="cb499-3"><a href="#cb499-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> lambda ((), g x)</span>
<span id="cb499-4"><a href="#cb499-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> g x</span></code></pre>
        </div>
        <p>となり、<code>g = id</code>が示される。同様に、2番目の規則は<code>f = id</code>へと展開される。結論として:</p>
        <div class="sourceCode" id="cb500">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb500-1"><a href="#cb500-1" aria-hidden="true" tabindex="-1"></a>split x <span class="ot">=</span> (x, x)</span></code></pre>
        </div>
        <p>となり、Haskell
          (および一般に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>圏)
          では、すべての対象が自明にコモナドであることが示される。</p>
        <p>幸い、コモノイドを定義するともっと興味深いモノイダル圏も他にある。1つは自己関手からなる圏だ。そこで分かることとして、モナドが自己関手からなる圏におけるモノイドであるのと同様に:</p>
        <blockquote>
          <p>コモナドは自己関手からなる圏におけるコモノイドである。</p>
        </blockquote>
        <h2 data-number="23.6" id="storeコモナド"><span class="header-section-number">23.6</span> Storeコモナド</h2>
        <p>コモナドのもう1つの重要な例はstateモナドの双対だ。それはcostateコモナド、あるいはstoreコモナドと呼ばれる。</p>
        <p>以前、冪乗を定義する随伴によってstateモナドが生成されるのを見た:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>L</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>z</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>=</mo>
                    <mi>z</mi>
                    <mo>×</mo>
                    <mrow></mrow>
                    <mi>s</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>R</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>=</mo>
                    <mi>s</mi>
                    <mo>⇒</mo>
                    <mi>a</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                L\ z &amp;= z\times{}s \\
                R\ a &amp;= s \Rightarrow a
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>同じ随伴を使って、costateコモナドを定義しよう。コモナドは合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mo>∘</mo>
                <mi>R</mi>
              </mrow>
              <annotation encoding="application/x-tex">L \circ R</annotation>
            </semantics>
          </math>によって定義される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>L</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>R</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>=</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>s</mi>
                  <mo>⇒</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>×</mo>
                <mrow></mrow>
                <mi>s</mi>
              </mrow>
              <annotation encoding="application/x-tex">L\ (R\ a) = (s \Rightarrow a)\times{}s</annotation>
            </semantics>
          </math></p>
        <p>
          これをHaskellに変換するには、左<code>Prod</code>関手と右<code>Reader</code>関手との間の随伴から始める。<code>Reader</code>の後に<code>Prod</code>を合成するのは次の定義と等価だ:
        </p>
        <div class="sourceCode" id="cb501">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb501-1"><a href="#cb501-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Store</span> s a <span class="ot">=</span> <span class="dt">Store</span> (s <span class="ot">-&gt;</span> a) s</span></code></pre>
        </div>
        <p>対象<code>a</code>におけるこの随伴の余単位は次の射だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>ε</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>s</mi>
                    <mo>⇒</mo>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>s</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon_a \Colon ((s \Rightarrow a)\times{}s) \to a
              </annotation>
            </semantics>
          </math></p>
        <p>あるいは、Haskellの記法だと次のようになる:</p>
        <div class="sourceCode" id="cb502">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb502-1"><a href="#cb502-1" aria-hidden="true" tabindex="-1"></a>counit (<span class="dt">Prod</span> (<span class="dt">Reader</span> f, s)) <span class="ot">=</span> f s</span></code></pre>
        </div>
        <p>これが<code>extract</code>となる:</p>
        <div class="sourceCode" id="cb503">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb503-1"><a href="#cb503-1" aria-hidden="true" tabindex="-1"></a>extract (<span class="dt">Store</span> f s) <span class="ot">=</span> f s</span></code></pre>
        </div>
        <p>随伴の単位:</p>
        <div class="sourceCode" id="cb504">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb504-1"><a href="#cb504-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unit ::</span> a <span class="ot">-&gt;</span> <span class="dt">Reader</span> s (<span class="dt">Product</span> a, s)</span>
<span id="cb504-2"><a href="#cb504-2" aria-hidden="true" tabindex="-1"></a>unit a <span class="ot">=</span> <span class="dt">Reader</span> (\s <span class="ot">-&gt;</span> <span class="dt">Prod</span> (a, s))</span></code></pre>
        </div>
        <p>は、部分適用されたデータコンストラクターとして書き直せる:</p>
        <div class="sourceCode" id="cb505">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb505-1"><a href="#cb505-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Store</span><span class="ot"> f ::</span> s <span class="ot">-&gt;</span> <span class="dt">Store</span> f s</span></code></pre>
        </div>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>δ</mi>
              <annotation encoding="application/x-tex">\delta</annotation>
            </semantics>
          </math>、すなわち<code>duplicate</code>を水平合成として構成しよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>δ</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>L</mi>
                    <mo>∘</mo>
                    <mi>R</mi>
                    <mo>→</mo>
                    <mi>L</mi>
                    <mo>∘</mo>
                    <mi>R</mi>
                    <mo>∘</mo>
                    <mi>L</mi>
                    <mo>∘</mo>
                    <mi>R</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>δ</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>=</mo>
                    <mi>L</mi>
                    <mo>∘</mo>
                    <mi>η</mi>
                    <mo>∘</mo>
                    <mi>R</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                \delta &amp;\Colon L \circ R \to L \circ R \circ L \circ R \\
                \delta &amp;= L \circ \eta \circ R
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>は一番左の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>を通過する必要がある。この<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>は<code>Prod</code>関手だ。これは、ペアの左側の要素に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>すなわち<code>Store f</code>を作用させることを意味する
          (これが<code>Prod</code>の<code>fmap</code>が行うことだ)。すると、次の結果が得られる:</p>
        <div class="sourceCode" id="cb506">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb506-1"><a href="#cb506-1" aria-hidden="true" tabindex="-1"></a>duplicate (<span class="dt">Store</span> f s) <span class="ot">=</span> <span class="dt">Store</span> (<span class="dt">Store</span> f) s</span></code></pre>
        </div>
        <p>(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>δ</mi>
              <annotation encoding="application/x-tex">\delta</annotation>
            </semantics>
          </math>の式での<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>は恒等自然変換を表し、コンポーネントが恒等射なのを思い出してほしい)。</p>
        <p><code>Store</code>コモナドの完全な定義を以下に示す:</p>
        <div class="sourceCode" id="cb507">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb507-1"><a href="#cb507-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Comonad</span> (<span class="dt">Store</span> s) <span class="kw">where</span></span>
<span id="cb507-2"><a href="#cb507-2" aria-hidden="true" tabindex="-1"></a>  extract (<span class="dt">Store</span> f s) <span class="ot">=</span> f s</span>
<span id="cb507-3"><a href="#cb507-3" aria-hidden="true" tabindex="-1"></a>  duplicate (<span class="dt">Store</span> f s) <span class="ot">=</span> <span class="dt">Store</span> (<span class="dt">Store</span> f) s</span></code></pre>
        </div>
        <p>
          <code>Store</code>の<code>Reader</code>の部分は、<code>a</code>が型<code>s</code>の要素をキーにして一般化されたコンテナに格納されていると見なせる。たとえば、<code>s</code>が<code>Int</code>なら、<code>Reader Int a</code>は<code>a</code>の無限双方向ストリームだ。<code>Store</code>は、このコンテナとキー型の値とをペアにする。たとえば、<code>Reader Int a</code>は<code>Int</code>とペアになっている。この場合、<code>extract</code>はこの整数を使って無限ストリームにインデックスを作成する。<code>Store</code>の2番目の要素は現在位置と見なせる。
        </p>
        <p>
          この例についてさらに述べると、<code>duplicate</code>は<code>Int</code>によって添字付けされた新しい無限ストリームを作成する。このストリームは要素としてストリームを含む。特に、現在位置にはもとのストリームが含まれている。しかし、他の
          (正または負の)
          <code>Int</code>をキーとして使うと、新しいインデックスに位置するシフトされたストリームが得られる。
        </p>
        <p>
          一般に、<code>duplicate</code>された<code>Store</code>に<code>extract</code>が作用すると、もとの<code>Store</code>が生成されることを確信できる
          (実際、コモナドの恒等則では<code>extract . duplicate = id</code>と規定されている)。</p>
        <p>
          <code>Store</code>コモナドは<code>Lens</code>ライブラリの理論的基盤として重要だ。概念としては、<code>Store s a</code>コモナドは、型<code>s</code>をインデックスとしてdate型<code>a</code>の特定のサブ構造に
          (レンズのように)「焦点を合わせる」という考え方をカプセル化している。特に、ある関数が型:
        </p>
        <div class="sourceCode" id="cb508">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb508-1"><a href="#cb508-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> <span class="dt">Store</span> s a</span></code></pre>
        </div>
        <p>を取るなら、以下の関数のペアと等価だ:</p>
        <div class="sourceCode" id="cb509">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb509-1"><a href="#cb509-1" aria-hidden="true" tabindex="-1"></a><span class="ot">set ::</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb509-2"><a href="#cb509-2" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> a <span class="ot">-&gt;</span> s</span></code></pre>
        </div>
        <p>
          <code>a</code>が直積型である場合の<code>set</code>は、<code>a</code>内の型<code>s</code>のフィールドをセットする一方で、<code>a</code>の変更されたバージョンを返すように実装できる。同様に、<code>get</code>は<code>s</code>フィールドの値を<code>a</code>から読み取るように実装できる。これらの考え方については次章で詳しく説明する。
        </p>
        <h2 data-number="23.7" id="課題-17"><span class="header-section-number">23.7</span> 課題</h2>
        <ol type="1">
          <li><code>Store</code>コモナドを使ってコンウェイのライフゲームを実装せよ。ヒント:
            <code>s</code>の型は何がよいだろうか？
          </li>
        </ol>
        <h1 data-number="24" id="f-代数"><span class="header-section-number">24</span> F-代数</h1>
        <p>モノイドについて、集合として、単一対象圏として、モノイダル圏の対象としての定式化を見てきた。この単純な概念からどれだけの果汁をさらに搾り取れるだろうか？</p>
        <p>やってみよう。次の関数のペアを持つ集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>としてのモノイドの定義を取り上げる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>μ</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>m</mi>
                    <mo>×</mo>
                    <mrow></mrow>
                    <mi>m</mi>
                    <mo>→</mo>
                    <mi>m</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>η</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mn>1</mn>
                    <mo>→</mo>
                    <mi>m</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                \mu &amp;\Colon m\times{}m \to m \\
                \eta &amp;\Colon 1 \to m
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>ここで、1は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>の終対象――単集合だ。最初の関数は乗算
          (要素のペアを取って積を返す)
          を定義し、2番目の関数は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>から単位元を選択する。これらのシグネチャを持つ2つの関数ならどれでもモノイドになるわけではない。結合則と単位元則という追加の条件を課す必要がある。しかし、それはしばらく忘れて「潜在的なモノイド」について考えてみよう。関数のペアは、2つの関数集合のカルテシアン積の要素だ。これらの集合が冪乗対象として表現できるのは知っている:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>μ</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∈</mo>
                    <msup>
                      <mi>m</mi>
                      <mrow>
                        <mi>m</mi>
                        <mo>×</mo>
                        <mrow></mrow>
                        <mi>m</mi>
                      </mrow>
                    </msup>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>η</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∈</mo>
                    <msup>
                      <mi>m</mi>
                      <mn>1</mn>
                    </msup>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                \mu &amp;\in m^{m\times{}m} \\
                \eta &amp;\in m^1
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>これら2つの集合のカルテシアン積は次のとおりだ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>m</mi>
                  <mrow>
                    <mi>m</mi>
                    <mo>×</mo>
                    <mrow></mrow>
                    <mi>m</mi>
                  </mrow>
                </msup>
                <mo>×</mo>
                <mrow></mrow>
                <msup>
                  <mi>m</mi>
                  <mn>1</mn>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">m^{m\times{}m}\times{}m^1</annotation>
            </semantics>
          </math></p>
        <p>高校代数 (すべてのカルテシアン閉圏で機能する)
          を少し使えば次のように書き直せる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>m</mi>
                <mrow>
                  <mi>m</mi>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>m</mi>
                  <mo>+</mo>
                  <mn>1</mn>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">m^{m\times{}m + 1}</annotation>
            </semantics>
          </math></p>
        <p>記号<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mo>+</mo>
              <annotation encoding="application/x-tex">+</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>の余積を表す。ここで、関数のペアを次のような単一の関数――集合の要素――に置き換える:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>m</mi>
                <mo>+</mo>
                <mn>1</mn>
                <mo>→</mo>
                <mi>m</mi>
              </mrow>
              <annotation encoding="application/x-tex">m\times{}m + 1 \to m</annotation>
            </semantics>
          </math></p>
        <p>この関数集合のどの要素も潜在的なモノイドだ。</p>
        <p>この定式化の利点は、興味深い一般化を導くことだ。たとえば、この言語を使って群を記述するにはどうすればよいだろうか？
          群は、すべての要素に逆を対応させる関数が追加されたモノイドだ。後者は型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mo>→</mo>
                <mi>m</mi>
              </mrow>
              <annotation encoding="application/x-tex">m \to m</annotation>
            </semantics>
          </math>の関数だ。たとえば、整数は群を形成し、二項演算として加算、単位元として0、否定として正負反転を持つ。群を定義するには次の3つの関数から始める:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>m</mi>
                    <mo>×</mo>
                    <mrow></mrow>
                    <mi>m</mi>
                    <mo>→</mo>
                    <mi>m</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>m</mi>
                    <mo>→</mo>
                    <mi>m</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mn>1</mn>
                    <mo>→</mo>
                    <mi>m</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                m\times{}m \to m \\
                m \to m \\
                1 \to m
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>前と同様に、このトリプルを結合して1つの関数集合にできる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>m</mi>
                <mo>+</mo>
                <mi>m</mi>
                <mo>+</mo>
                <mn>1</mn>
                <mo>→</mo>
                <mi>m</mi>
              </mrow>
              <annotation encoding="application/x-tex">m\times{}m + m + 1 \to m</annotation>
            </semantics>
          </math></p>
        <p>1つの二項演算子 (加算)、1つの単項演算子 (否定)、1つの零項演算子
          (恒等射――ここでは0)
          から始めた。そして、それらを1つの関数に結合した。このシグネチャを持つすべての関数は、潜在的な群を定義する。</p>
        <p>同様のことを続けられる。たとえば、環を定義するにはもう1つの二項演算子と1つの零項演算子を追加する、などだ。毎回、左辺が冪乗の和
          (0乗――終対象――を含んでよい)
          であり、右辺が集合自体である関数型が得られる。</p>
        <p>きっと一般化に夢中になってしまうだろう。まず、集合を対象に、関数を射に置き換えられる。n項演算子は、n項積からの射として定義できる。これは有限積
          (finite product)
          をサポートする圏が必要であることを意味する。零項演算子については、終対象が存在する必要がある。したがって、カルテシアン圏が必要だ。これらの演算子を結合するには冪乗が必要なので、必要なのはカルテシアン閉圏だ。最終的に、この代数的な悪ふざけを完成させるには、余積が必要になる。
        </p>
        <p>あるいは、式の導出方法を忘れて、最終的な積に集中することもできる。射の左側にある積の和が自己関手を定義する。代わりに任意の自己関手<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>を選択するとどうなるだろう？
          その場合は圏に制約を課す必要はない。こうして得られたものはF-代数と呼ばれる。</p>
        <p>F-代数は、1つの自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>、1つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>、1つの射からなるトリプルだ。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ a \to a</annotation>
            </semantics>
          </math></p>
        <p>この対象はしばしば台 (carrier, underlying object)
          と呼ばれ、プログラミングの文脈ではキャリア<em>型</em>と呼ばれる。射は評価関数
          (evaluation function) または構造マップ (structure map)
          と呼ばれることが多い。関手<code>F</code>が式を形成し、それを射が評価すると考えてほしい。</p>
        <p>HaskellによるF-代数の定義を示す:</p>
        <div class="sourceCode" id="cb510">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb510-1"><a href="#cb510-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Algebra</span> f a <span class="ot">=</span> f a <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <p>代数はその評価関数で識別される。</p>
        <p>モノイドの例では、問題の関手は次のようになる:</p>
        <div class="sourceCode" id="cb511">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb511-1"><a href="#cb511-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MonF</span> a <span class="ot">=</span> <span class="dt">MEmpty</span> <span class="op">|</span> <span class="dt">MAppend</span> a a</span></code></pre>
        </div>
        <p>これはHaskellで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>1</mn>
                <mo>+</mo>
                <mi>a</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">1 + a \times{}a</annotation>
            </semantics>
          </math>を表したものだ
          (<g2>代数的データ構造</g2>を思い出してほしい)。</p>
        <p>環は次の関手を使って定義される:</p>
        <div class="sourceCode" id="cb512">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb512-1"><a href="#cb512-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RingF</span> a <span class="ot">=</span> <span class="dt">RZero</span></span>
<span id="cb512-2"><a href="#cb512-2" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">ROne</span></span>
<span id="cb512-3"><a href="#cb512-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">RAdd</span> a a</span>
<span id="cb512-4"><a href="#cb512-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">RMul</span> a a</span>
<span id="cb512-5"><a href="#cb512-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="dt">RNeg</span> a</span></code></pre>
        </div>
        <p>これはHaskellで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>1</mn>
                <mo>+</mo>
                <mn>1</mn>
                <mo>+</mo>
                <mi>a</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>a</mi>
                <mo>+</mo>
                <mi>a</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>a</mi>
                <mo>+</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">1 + 1 + a \times{}a + a \times{}a + a</annotation>
            </semantics>
          </math>を表したものだ。</p>
        <p>環の例としては整数の集合が挙げられる。<code>Integer</code>をキャリア型に選ぶと、評価関数を次のように定義できる。</p>
        <div class="sourceCode" id="cb513">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb513-1"><a href="#cb513-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evalZ ::</span> <span class="dt">Algebra</span> <span class="dt">RingF</span> <span class="dt">Integer</span></span>
<span id="cb513-2"><a href="#cb513-2" aria-hidden="true" tabindex="-1"></a>evalZ <span class="dt">RZero</span>      <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb513-3"><a href="#cb513-3" aria-hidden="true" tabindex="-1"></a>evalZ <span class="dt">ROne</span>       <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb513-4"><a href="#cb513-4" aria-hidden="true" tabindex="-1"></a>evalZ (<span class="dt">RAdd</span> m n) <span class="ot">=</span> m <span class="op">+</span> n</span>
<span id="cb513-5"><a href="#cb513-5" aria-hidden="true" tabindex="-1"></a>evalZ (<span class="dt">RMul</span> m n) <span class="ot">=</span> m <span class="op">*</span> n</span>
<span id="cb513-6"><a href="#cb513-6" aria-hidden="true" tabindex="-1"></a>evalZ (<span class="dt">RNeg</span> n)   <span class="ot">=</span> <span class="op">-</span>n</span></code></pre>
        </div>
        <p>同じ関手<code>RingF</code>に基づくF-代数は他にもたくさんある。たとえば、多項式も正方行列も環を形成する。</p>
        <p>ご覧のとおり、関手の役割は、評価に代数の評価子を使えるような式を生成することだ。ここまでは、非常に単純な式しか見てこなかった。しかし、より複雑な、再帰を使って定義できる式に関心があることも多い。</p>
        <h2 data-number="24.1" id="再帰"><span class="header-section-number">24.1</span> 再帰</h2>
        <p>任意の式木を生成する方法の1つは、関手の定義内の変数<code>a</code>を再帰で置き換えることだ。たとえば、環における任意の式は、木に似たデータ構造によって生成される:</p>
        <div class="sourceCode" id="cb514">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb514-1"><a href="#cb514-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">RZero</span></span>
<span id="cb514-2"><a href="#cb514-2" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">ROne</span></span>
<span id="cb514-3"><a href="#cb514-3" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">RAdd</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb514-4"><a href="#cb514-4" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">RMul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb514-5"><a href="#cb514-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="dt">RNeg</span> <span class="dt">Expr</span></span></code></pre>
        </div>
        <p>もとの環の評価子は再帰版に置き換えられる:</p>
        <div class="sourceCode" id="cb515">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb515-1"><a href="#cb515-1" aria-hidden="true" tabindex="-1"></a><span class="ot">evalZ ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb515-2"><a href="#cb515-2" aria-hidden="true" tabindex="-1"></a>evalZ <span class="dt">RZero</span>        <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb515-3"><a href="#cb515-3" aria-hidden="true" tabindex="-1"></a>evalZ <span class="dt">ROne</span>         <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb515-4"><a href="#cb515-4" aria-hidden="true" tabindex="-1"></a>evalZ (<span class="dt">RAdd</span> e1 e2) <span class="ot">=</span> evalZ e1 <span class="op">+</span> evalZ e2</span>
<span id="cb515-5"><a href="#cb515-5" aria-hidden="true" tabindex="-1"></a>evalZ (<span class="dt">RMul</span> e1 e2) <span class="ot">=</span> evalZ e1 <span class="op">*</span> evalZ e2</span>
<span id="cb515-6"><a href="#cb515-6" aria-hidden="true" tabindex="-1"></a>evalZ (<span class="dt">RNeg</span> e)     <span class="ot">=</span> <span class="op">-</span>(evalZ e)</span></code></pre>
        </div>
        <p>これはまだあまり実用的ではない。すべての整数を1の和で表現するのが強制されているからだ。もっとも、緊急用には役立つ。</p>
        <p>それにしても、F-代数の言葉で式木を記述するにはどうすればよいだろうか？
          関手の定義において、自由型変数を再帰的に置換の結果で置き換えるプロセスを、何らかの形で形式化する必要がある。これを段階的に行うことを想像してほしい。まず、深さ1の木を次のように定義する:</p>
        <div class="sourceCode" id="cb516">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb516-1"><a href="#cb516-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RingF1</span> a <span class="ot">=</span> <span class="dt">RingF</span> (<span class="dt">RingF</span> a)</span></code></pre>
        </div>
        <p><code>RingF</code>の定義の穴を、<code>RingF a</code>によって生成された深さ0の木で埋めている。深さ2の木も同様にして得られる:</p>
        <div class="sourceCode" id="cb517">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb517-1"><a href="#cb517-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RingF2</span> a <span class="ot">=</span> <span class="dt">RingF</span> (<span class="dt">RingF</span> (<span class="dt">RingF</span> a))</span></code></pre>
        </div>
        <p>これは次のようにも書ける:</p>
        <div class="sourceCode" id="cb518">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb518-1"><a href="#cb518-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RingF2</span> a <span class="ot">=</span> <span class="dt">RingF</span> (<span class="dt">RingF1</span> a)</span></code></pre>
        </div>
        <p>このプロセスを繰り返すことで、シンボリックな方程式を書ける:</p>
        <div class="sourceCode">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell">type RingF<sub>n+1</sub> a = RingF (RingF<sub>n</sub> a)</code></pre>
        </div>
        <p>
          概念としては、このプロセスを無限に何度も繰り返すことで<code>Expr</code>が得られる。<code>Expr</code>は<code>a</code>に依存しないことに注意してほしい。旅の出発点によらず、いつも同じ場所に辿り着く。これは任意の圏の任意の自己関手に常に当てはまるわけではないが、<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>圏では適切だ。</p>
        <p>当然、これは身振り手振りでの議論なので、後でより厳密に説明する。</p>
        <p>自己関手を無限回適用すると、<span id="fixed_point" class="keyword">不動点</span> (fixed point)
          という対象が生成される。この対象は次のように定義される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐹</mi>
                  <mi>𝑖</mi>
                  <mi>𝑥</mi>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
                <mo>=</mo>
                <mi>f</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mi>𝐹</mi>
                    <mi>𝑖</mi>
                    <mi>𝑥</mi>
                  </mrow>
                  <mspace width="0.222em"></mspace>
                  <mi>f</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Fix}\ f = f\ (\mathit{Fix}\ f)</annotation>
            </semantics>
          </math></p>
        <p>この定義の背景には、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐹</mi>
                  <mi>𝑖</mi>
                  <mi>𝑥</mi>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Fix}\ f</annotation>
            </semantics>
          </math>を得るために<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>を無限回適用しているので、さらにもう1回適用しても何も変わらない、という直観がある。Haskellでは、不動点の定義は次のようになる:</p>
        <div class="sourceCode" id="cb519">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb519-1"><a href="#cb519-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> (f (<span class="dt">Fix</span> f))</span></code></pre>
        </div>
        <p>おそらく、次のように、定義されている型の名前がコンストラクターの名前と別ならば、もっと読みやすくなる:</p>
        <div class="sourceCode" id="cb520">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb520-1"><a href="#cb520-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">In</span> (f (<span class="dt">Fix</span> f))</span></code></pre>
        </div>
        <p>しかし、ここでは広く使われている表記に従うことにする。コンストラクター<code>Fix</code>
          (あるいは好みによっては<code>In</code>) は関数と見なせる:</p>
        <div class="sourceCode" id="cb521">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb521-1"><a href="#cb521-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Fix</span><span class="ot"> ::</span> f (<span class="dt">Fix</span> f) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span></code></pre>
        </div>
        <p>また、関手適用を1層だけ剥がす関数もある:</p>
        <div class="sourceCode" id="cb522">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb522-1"><a href="#cb522-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unFix ::</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> f (<span class="dt">Fix</span> f)</span>
<span id="cb522-2"><a href="#cb522-2" aria-hidden="true" tabindex="-1"></a>unFix (<span class="dt">Fix</span> x) <span class="ot">=</span> x</span></code></pre>
        </div>
        <p>2つの関数は互いに逆だ。これらの関数は後で使うことになる。</p>
        <h2 data-number="24.2" id="f-代数の圏"><span class="header-section-number">24.2</span> F-代数の圏</h2>
        <p>この本の中で最も古いトリックについて述べよう:
          何か新しい対象を構築する方法を思いついたら、それらが圏を形成するかどうかを常に確認すべし。驚くことではないが、任意の自己関手<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>における代数は圏を形成する。その圏の対象は代数だ――台対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ a \to a</annotation>
            </semantics>
          </math>からなるペアで、どちらももとの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>からのものだ。</p>
        <p>この描像を完全なものにするには、F-代数の圏における射を定義する必要がある。射は、ある代数
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>f</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, f)</annotation>
            </semantics>
          </math>
          を別の代数
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>b</mi>
                <mo>,</mo>
                <mi>g</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(b, g)</annotation>
            </semantics>
          </math>
          に写さなければならない。これを、台を写す射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>――もとの圏で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>へ向かう射――と定義する。どの射でもいいわけではなく、2つの評価子と互換性がなければならない。(そのような構造保存射を<span id="homomorphism"
            class="keyword">準同型</span>と呼ぶ。)
          F-代数の準同型を定義する方法は次のとおりだ。まず、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>を次の写像にリフトできることに注目してほしい:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>m</mi>
                <mo>∷</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ m \Colon F\ a \to F\ b</annotation>
            </semantics>
          </math></p>
        <p>それから<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>を辿ると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>に行き着く。同様に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>を使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>に移ってから<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>を辿ってもよい。2つの経路が等しくなるようにしたい:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>∘</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>m</mi>
                <mo>=</mo>
                <mi>m</mi>
                <mo>∘</mo>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">g \circ F\ m = m \circ f</annotation>
            </semantics>
          </math></p>
        <p><a href="images/alg.png" width="30%"><img src="images/alg.png" alt="alg" /></a></p>
        <p>これが本当に圏であることは簡単に納得できる (ヒント:
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の恒等射については問題なく、また、準同型の合成は準同型だ)。
        </p>
        <p>F-代数の圏に始対象が存在するなら、それは<span id="initial_algebra" class="keyword">始代数</span> (initial algebra)
          と呼ばれる。この始代数の台を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>i</mi>
              <annotation encoding="application/x-tex">i</annotation>
            </semantics>
          </math>と呼び、その評価子を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>j</mi>
                <mo>∷</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>i</mi>
                <mo>→</mo>
                <mi>i</mi>
              </mrow>
              <annotation encoding="application/x-tex">j \Colon F\ i \to i</annotation>
            </semantics>
          </math>と呼ぼう。始代数の評価子である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>j</mi>
              <annotation encoding="application/x-tex">j</annotation>
            </semantics>
          </math>は同型射であることがわかる。この結果はLambekの定理として知られている。その証明は始対象の定義に依存している。定義では、始対象は他のF-代数への一意な準同型<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>の存在を必要とする。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>が準同型なので、次の図式は可換でなければならない:</p>
        <p><a href="images/alg2.png" width="30%"><img src="images/alg2.png" alt="alg2" /></a></p>
        <p>次に、台が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>i</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ i</annotation>
            </semantics>
          </math>である代数を構築しよう。そのような代数の評価子は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>i</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">F\ (F i)</annotation>
            </semantics>
          </math>
          から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>i</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ i</annotation>
            </semantics>
          </math>への射でなければならない。このような評価子は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>j</mi>
              <annotation encoding="application/x-tex">j</annotation>
            </semantics>
          </math>をリフトするだけで簡単に構成できる。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>j</mi>
                <mo>∷</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>i</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>i</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ j \Colon F\ (F\ i) \to F\ i</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>i</mi>
                <mo>,</mo>
                <mi>j</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(i, j)</annotation>
            </semantics>
          </math>
          は始代数なので、そこから
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>F</mi>
                <mi>i</mi>
                <mo>,</mo>
                <mi>F</mi>
                <mi>j</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(F i, F j)</annotation>
            </semantics>
          </math>
          への一意な準同型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>が必要だ。次の図式は可換でなければならない:
        </p>
        <p><a href="images/alg3a.png" width="30%"><img src="images/alg3a.png" alt="alg3a" /></a></p>
        <p>しかし、次のような自明な可換図式もある (どちらの経路も同じだ！):</p>
        <p><a href="images/alg3.png" width="30%"><img src="images/alg3.png" alt="alg3" /></a></p>
        <p>これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>j</mi>
              <annotation encoding="application/x-tex">j</annotation>
            </semantics>
          </math>が代数の準同型であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>i</mi>
                <mo>,</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>j</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(F\ i, F\ j)</annotation>
            </semantics>
          </math>
          を
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>i</mi>
                <mo>,</mo>
                <mi>j</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(i, j)</annotation>
            </semantics>
          </math>
          に写すことを示していると解釈できる。これら2つの図式を繋ぐと次のようになる:
        </p>
        <p><a href="images/alg4.png" width="60%"><img src="images/alg4.png" alt="alg4" /></a></p>
        <p>この図式は、同様に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>j</mi>
                <mo>∘</mo>
                <mi>m</mi>
              </mrow>
              <annotation encoding="application/x-tex">j \circ m</annotation>
            </semantics>
          </math>が代数の準同型であることを示していると解釈できる。この場合のみ2つの代数は同じだ。さらに、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>i</mi>
                <mo>,</mo>
                <mi>j</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(i, j)</annotation>
            </semantics>
          </math>
          は初期代数なので、それ自身から自身への準同型は1つしか存在できず、それはどの代数でも準同型だとわかっている恒等射<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>i</mi>
                <msub>
                  <mi>d</mi>
                  <mi>i</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">id_i</annotation>
            </semantics>
          </math>だ。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>j</mi>
                <mo>∘</mo>
                <mi>m</mi>
                <mo>=</mo>
                <mi>i</mi>
                <msub>
                  <mi>d</mi>
                  <mi>i</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">j \circ m = id_i</annotation>
            </semantics>
          </math>となる。この事実と左側の図式の可換律とを用いて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mo>∘</mo>
                <mi>j</mi>
                <mo>=</mo>
                <mi>i</mi>
                <msub>
                  <mi>d</mi>
                  <mrow>
                    <mi>F</mi>
                    <mi>i</mi>
                  </mrow>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">m\circ j=id_{Fi}</annotation>
            </semantics>
          </math>であることを証明できる。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>j</mi>
              <annotation encoding="application/x-tex">j</annotation>
            </semantics>
          </math>の逆であることを示しているため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>j</mi>
              <annotation encoding="application/x-tex">j</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>i</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ i</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>i</mi>
              <annotation encoding="application/x-tex">i</annotation>
            </semantics>
          </math>の間の同型射だ。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>i</mi>
                <mo>≅</mo>
                <mi>i</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ i \cong i</annotation>
            </semantics>
          </math></p>
        <p>しかし、これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>i</mi>
              <annotation encoding="application/x-tex">i</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>の不動点だと言っているにすぎない。以上が最初の身振り手振りでの議論の背景にある形式的証明だ。</p>
        <p>Haskellに戻ろう:
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>i</mi>
              <annotation encoding="application/x-tex">i</annotation>
            </semantics>
          </math>は<code>Fix f</code>で、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>j</mi>
              <annotation encoding="application/x-tex">j</annotation>
            </semantics>
          </math>はコンストラクター<code>Fix</code>、その逆は<code>unFix</code>だと理解している。Lambekの定理における同型からは、始代数を得るには関手<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>を取って引数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を<code>Fix f</code>に置き換えればよいことが分かる。また、不動点が<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>によらない理由も分かる。
        </p>
        <h2 data-number="24.3" id="自然数"><span class="header-section-number">24.3</span> 自然数</h2>
        <p>自然数もF-代数として定義できる。出発点は次のような射のペアだ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>z</mi>
                    <mi>e</mi>
                    <mi>r</mi>
                    <mi>o</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mn>1</mn>
                    <mo>→</mo>
                    <mi>N</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>s</mi>
                    <mi>u</mi>
                    <mi>c</mi>
                    <mi>c</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>N</mi>
                    <mo>→</mo>
                    <mi>N</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                zero &amp;\Colon 1 \to N \\
                succ &amp;\Colon N \to N
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>1番目は0を選択し、2番目はすべての数をその次の数に写す。前と同じように、この2つは1つにまとめられる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>1</mn>
                <mo>+</mo>
                <mi>N</mi>
                <mo>→</mo>
                <mi>N</mi>
              </mrow>
              <annotation encoding="application/x-tex">1 + N \to N</annotation>
            </semantics>
          </math></p>
        <p>左辺は関手を定義し、Haskellでは次のように書ける:</p>
        <div class="sourceCode" id="cb523">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb523-1"><a href="#cb523-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NatF</span> a <span class="ot">=</span> <span class="dt">ZeroF</span> <span class="op">|</span> <span class="dt">SuccF</span> a</span></code></pre>
        </div>
        <p>この関手の不動点 (生成される始代数)
          は、Haskellでは次のようにコード化できる:</p>
        <div class="sourceCode" id="cb524">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb524-1"><a href="#cb524-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Zero</span> <span class="op">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span></span></code></pre>
        </div>
        <p>自然数は、0か、ある数の次の数かのどちらかだ。これは自然数のPeano表現として知られている。</p>
        <h2 data-number="24.4" id="カタモルフィズム"><span class="header-section-number">24.4</span> カタモルフィズム</h2>
        <p>
          Haskellの表記で初期条件を書き直してみよう。始代数は<code>Fix f</code>と呼ばれる。その評価子はコンストラクター<code>Fix</code>だ。始代数から他の任意の代数への一意な射<code>m</code>が同じ関手上に存在する。台が<code>a</code>であり評価子が<code>alg</code>である代数を選択しよう。
        </p>
        <p><a href="images/alg5.png" width="40%"><img src="images/alg5.png" alt="alg5" /></a></p>
        <p>ところで、<code>m</code>が何なのかに注目してほしい:
          これは不動点の評価子であり、再帰的な式木全体の評価子だ。これを実装するための汎用的な方法を探そう。</p>
        <p>Lambekの定理はコンストラクター<code>Fix</code>が同型射であることを示している。その逆は<code>unFix</code>と呼ばれる。したがって、この図式で矢印の1つを反転して次のようにできる:
        </p>
        <p><a href="images/alg6.png" width="40%"><img src="images/alg6.png" alt="alg6" /></a></p>
        <p>この図式の可換条件を書こう:</p>
        <div class="sourceCode" id="cb525">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb525-1"><a href="#cb525-1" aria-hidden="true" tabindex="-1"></a>m <span class="ot">=</span> alg <span class="op">.</span> <span class="fu">fmap</span> m <span class="op">.</span> unFix</span></code></pre>
        </div>
        <p>
          この方程式は<code>m</code>の再帰的な定義として解釈できる。再帰は関手<code>f</code>を使って作成されたすべての有限木に対して停止する。そのことは、<code>fmap m</code>が関手<code>f</code>の最上層の下で動作することに着目すれば分かる。言い換えると、それはもとの木の子に対して機能する。子は常にもとの木より1レベル浅くなる。
        </p>
        <p>
          <code>Fix f</code>を使って構築された木に<code>m</code>を適用するとどうなるか述べよう。まず、<code>unFix</code>の作用によってコンストラクターが剥がれ、木の最上位があらわになる。次に、最上位ノードのすべての子に<code>m</code>を適用する。それにより、型<code>a</code>の結果が生成される。最後に、非再帰的評価子<code>alg</code>を適用することで、これらの結果を結合する。重要な点は、評価子<code>alg</code>が単純な非再帰関数であることだ。
        </p>
        <p>これは任意の代数<code>alg</code>に対して行えるので、代数をパラメーターに取って<code>m</code>と呼ばれる関数を返す高階関数を定義することは意味がある。この高階関数はカタモルフィズム
          (catamorphism) と呼ばれる。</p>
        <div class="sourceCode" id="cb526">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb526-1"><a href="#cb526-1" aria-hidden="true" tabindex="-1"></a><span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb526-2"><a href="#cb526-2" aria-hidden="true" tabindex="-1"></a>cata alg <span class="ot">=</span> alg <span class="op">.</span> <span class="fu">fmap</span> (cata alg) <span class="op">.</span> unFix</span></code></pre>
        </div>
        <p>例を見てみよう。自然数を定義する関手を考える:</p>
        <div class="sourceCode" id="cb527">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb527-1"><a href="#cb527-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NatF</span> a <span class="ot">=</span> <span class="dt">ZeroF</span> <span class="op">|</span> <span class="dt">SuccF</span> a</span></code></pre>
        </div>
        <p>台の型として<code>(Int, Int)</code>を選択し、代数を次のように定義する:</p>
        <div class="sourceCode" id="cb528">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb528-1"><a href="#cb528-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">NatF</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb528-2"><a href="#cb528-2" aria-hidden="true" tabindex="-1"></a>fib <span class="dt">ZeroF</span> <span class="ot">=</span> (<span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb528-3"><a href="#cb528-3" aria-hidden="true" tabindex="-1"></a>fib (<span class="dt">SuccF</span> (m, n)) <span class="ot">=</span> (n, m <span class="op">+</span> n)</span></code></pre>
        </div>
        <p>この代数のカタモルフィズム<code>cata fib</code>でフィボナッチ数が計算されることは容易に納得できる。</p>
        <p>一般に、<code>NatF</code>の代数は漸化式を定義する。つまり、現在の要素の値を前の要素によって表す。そして、カタモルフィズムは一連の要素のうちn番目のものを評価する。</p>
        <h2 data-number="24.5" id="畳み込み"><span class="header-section-number">24.5</span> 畳み込み</h2>
        <p><code>e</code>のリストは次の関手の始代数だ:</p>
        <div class="sourceCode" id="cb529">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb529-1"><a href="#cb529-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ListF</span> e a <span class="ot">=</span> <span class="dt">NilF</span> <span class="op">|</span> <span class="dt">ConsF</span> e a</span></code></pre>
        </div>
        <p>実際、<code>List e</code>と呼ばれる再帰の結果で変数<code>a</code>を置き換えると、次のようになる:</p>
        <div class="sourceCode" id="cb530">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb530-1"><a href="#cb530-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> e <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> e (<span class="dt">List</span> e)</span></code></pre>
        </div>
        <p>
          list関手の代数は、台の特定の型を選択し、2つのコンストラクターについてパターンマッチングを行う関数を定義する。<code>NilF</code>に対するその値は、空リストを評価する方法を表す。また、<code>ConsF</code>に対する値は、現在の要素をそれ以前の累積値と組み合わせる方法を表す。
        </p>
        <p>例として、リストの長さを計算するために使える代数を次に示す
          (台の型は<code>Int</code>だ):</p>
        <div class="sourceCode" id="cb531">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb531-1"><a href="#cb531-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lenAlg ::</span> <span class="dt">ListF</span> e <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb531-2"><a href="#cb531-2" aria-hidden="true" tabindex="-1"></a>lenAlg (<span class="dt">ConsF</span> e n) <span class="ot">=</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb531-3"><a href="#cb531-3" aria-hidden="true" tabindex="-1"></a>lenAlg <span class="dt">NilF</span> <span class="ot">=</span> <span class="dv">0</span></span></code></pre>
        </div>
        <p>実際、結果として得られるカタモルフィズム<code>cata lenAlg</code>によってリストの長さが計算される。評価関数は、(1)
          リスト要素とアキュムレータを受け取って新しいアキュムレータを返す関数と、(2)
          開始値 (ここでは0)
          とを組み合わせたものであることに注目してほしい。値の型とアキュムレータの型は台の型によって与えられる。</p>
        <p>これを従来のHaskellの定義と比較してみよう:</p>
        <div class="sourceCode" id="cb532">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb532-1"><a href="#cb532-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> <span class="ot">=</span> <span class="fu">foldr</span> (\e n <span class="ot">-&gt;</span> n <span class="op">+</span> <span class="dv">1</span>) <span class="dv">0</span></span></code></pre>
        </div>
        <p><code>foldr</code>の2つの引数は代数の2つのコンポーネントそのものだ。</p>
        <p>別の例を見てみよう:</p>
        <div class="sourceCode" id="cb533">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb533-1"><a href="#cb533-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sumAlg ::</span> <span class="dt">ListF</span> <span class="dt">Double</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb533-2"><a href="#cb533-2" aria-hidden="true" tabindex="-1"></a>sumAlg (<span class="dt">ConsF</span> e s) <span class="ot">=</span> e <span class="op">+</span> s</span>
<span id="cb533-3"><a href="#cb533-3" aria-hidden="true" tabindex="-1"></a>sumAlg <span class="dt">NilF</span> <span class="ot">=</span> <span class="fl">0.0</span></span></code></pre>
        </div>
        <p>再び、これを次のものと比較する:</p>
        <div class="sourceCode" id="cb534">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb534-1"><a href="#cb534-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> <span class="ot">=</span> <span class="fu">foldr</span> (\e s <span class="ot">-&gt;</span> e <span class="op">+</span> s) <span class="fl">0.0</span></span></code></pre>
        </div>
        <p>ご覧のとおり、<code>foldr</code>はリストに対してカタモルフィズムを特殊化して便利にしたものにすぎない。</p>
        <h2 data-number="24.6" id="余代数"><span class="header-section-number">24.6</span> 余代数</h2>
        <p>いつものように、F-余代数という双対構成があり、射が逆向きになっている:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>→</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \to F\ a</annotation>
            </semantics>
          </math></p>
        <p>任意の関手についての余代数も、その余代数的構造を保存する準同型を伴った圏を形成する。その圏の終対象
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>t</mi>
                <mo>,</mo>
                <mi>u</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(t, u)</annotation>
            </semantics>
          </math>
          は終余代数 (terminal / final coalgebra) と呼ばれる。他のすべての代数
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>f</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, f)</annotation>
            </semantics>
          </math>
          では、次の図式を可換にする一意な準同型<code>m</code>が存在する:
        </p>
        <p><a href="images/alg7.png" width="40%"><img src="images/alg7.png" alt="alg7" /></a></p>
        <p>終余代数はその関手の不動点であり、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>u</mi>
                <mo>∷</mo>
                <mi>t</mi>
                <mo>→</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>t</mi>
              </mrow>
              <annotation encoding="application/x-tex">u \Colon t \to F\ t</annotation>
            </semantics>
          </math>が同型射である
          (余代数に関するLambekの定理) ことを意味する:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>t</mi>
                <mo>≅</mo>
                <mi>t</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ t \cong t</annotation>
            </semantics>
          </math></p>
        <p>終余代数は通常、プログラミングでは、(無限であってもよい)
          データ構造または遷移系を生成するためのレシピとして解釈される。</p>
        <p>始代数の評価にカタモルフィズムが使えるのと同様に、終余代数の余評価にはアナモルフィズム
          (anamorphism) が使える:</p>
        <div class="sourceCode" id="cb535">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb535-1"><a href="#cb535-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ana ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span>
<span id="cb535-2"><a href="#cb535-2" aria-hidden="true" tabindex="-1"></a>ana coalg <span class="ot">=</span> <span class="dt">Fix</span> <span class="op">.</span> <span class="fu">fmap</span> (ana coalg) <span class="op">.</span> coalg</span></code></pre>
        </div>
        <p>余代数の正準的な例は、不動点が型<code>e</code>の要素の無限ストリームであるような関手に基づいている。これがその関手だ:</p>
        <div class="sourceCode" id="cb536">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb536-1"><a href="#cb536-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">StreamF</span> e a <span class="ot">=</span> <span class="dt">StreamF</span> e a</span>
<span id="cb536-2"><a href="#cb536-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre>
        </div>
        <p>そして、これがその不動点だ:</p>
        <div class="sourceCode" id="cb537">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb537-1"><a href="#cb537-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stream</span> e <span class="ot">=</span> <span class="dt">Stream</span> e (<span class="dt">Stream</span> e)</span></code></pre>
        </div>
        <p><code>StreamF e</code>の余代数は、型<code>a</code>のシードを取り、ある要素と次のシードからなるペアを生成する関数だ
          (ペアを<code>StreamF</code>というファンシーな名前で呼んでいる)。</p>
        <p>無限数列を生成する余代数の簡単な例はすぐ生成できる。たとえば、自乗や逆数などのリストだ。</p>
        <p>
          もっと興味深い例としては、素数のリストを生成する余代数がある。無限リストを台として使うのが秘訣だ。最初のシードはリスト<code>[2..]</code>になる。次のシードはこのリストの尾部から2の倍数をすべて除いたものになる。これは奇数のリストであり、3から始まる。次の段階では、このリストの尾部を取って3の倍数をすべて除く。エラトステネスの篩を作っているのに気付いただろう。この余代数は次の関数で実装される:
        </p>
        <div class="sourceCode" id="cb538">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb538-1"><a href="#cb538-1" aria-hidden="true" tabindex="-1"></a><span class="ot">era ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">StreamF</span> <span class="dt">Int</span> [<span class="dt">Int</span>]</span>
<span id="cb538-2"><a href="#cb538-2" aria-hidden="true" tabindex="-1"></a>era (p <span class="op">:</span> ns) <span class="ot">=</span> <span class="dt">StreamF</span> p (<span class="fu">filter</span> (notdiv p) ns)</span>
<span id="cb538-3"><a href="#cb538-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> notdiv p n <span class="ot">=</span> n <span class="ot">`mod`</span> p <span class="op">/=</span> <span class="dv">0</span></span></code></pre>
        </div>
        <p>この余代数のアナモルフィズムは素数のリストを生成する:</p>
        <div class="sourceCode" id="cb539">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb539-1"><a href="#cb539-1" aria-hidden="true" tabindex="-1"></a>primes <span class="ot">=</span> ana era [<span class="dv">2</span><span class="op">..</span>]</span></code></pre>
        </div>
        <p>
          ストリームは無限リストなので、Haskellのリストに変換できるはずだ。そのためには、同じ関手<code>StreamF</code>を使って代数を形成したうえでカタモルフィズムを実行すればよい。たとえば、次のカタモルフィズムはストリームをリストに変換する:
        </p>
        <div class="sourceCode" id="cb540">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb540-1"><a href="#cb540-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toListC ::</span> <span class="dt">Fix</span> (<span class="dt">StreamF</span> e) <span class="ot">-&gt;</span> [e]</span>
<span id="cb540-2"><a href="#cb540-2" aria-hidden="true" tabindex="-1"></a>toListC <span class="ot">=</span> cata al</span>
<span id="cb540-3"><a href="#cb540-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">where</span><span class="ot"> al ::</span> <span class="dt">StreamF</span> e [e] <span class="ot">-&gt;</span> [e]</span>
<span id="cb540-4"><a href="#cb540-4" aria-hidden="true" tabindex="-1"></a>         al (<span class="dt">StreamF</span> e a) <span class="ot">=</span> e <span class="op">:</span> a</span></code></pre>
        </div>
        <p>ここでは、同じ不動点が同じ自己関手の始代数でもあり終余代数でもある。これは任意の圏でいつも成り立つわけでない。一般に、自己関手には不動点が多数ありうる
          (不動点がないこともある)。始代数はいわゆる最小不動点で、終余代数は最大不動点だ。ただし、Haskellでは両方とも同じ式で定義され、一致する。</p>
        <p>リストのアナモルフィズムはunfoldと呼ばれる。有限リストを作成するには、関手を改変して<code>Maybe</code>のペアを作成する:</p>
        <div class="sourceCode" id="cb541">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb541-1"><a href="#cb541-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unfoldr ::</span> (b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, b)) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a]</span></code></pre>
        </div>
        <p><code>Nothing</code>の値でリストの生成が終了する。</p>
        <p>余代数の面白い例として、レンズに関するものが挙げられる。レンズはゲッターとセッターのペアとして表せる:</p>
        <div class="sourceCode" id="cb542">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb542-1"><a href="#cb542-1" aria-hidden="true" tabindex="-1"></a><span class="ot">set ::</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb542-2"><a href="#cb542-2" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> a <span class="ot">-&gt;</span> s</span></code></pre>
        </div>
        <p>
          ここで、通常、<code>a</code>は型<code>s</code>のフィールドを持つ直積データ型だ。ゲッターはそのフィールドの値を取得し、セッターはそのフィールドを新しい値に置き換える。これら2つの関数は1つにまとめられる:
        </p>
        <div class="sourceCode" id="cb543">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb543-1"><a href="#cb543-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> (s, s <span class="ot">-&gt;</span> a)</span></code></pre>
        </div>
        <p>この関数はさらに次のように書き直せる:</p>
        <div class="sourceCode" id="cb544">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb544-1"><a href="#cb544-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">-&gt;</span> <span class="dt">Store</span> s a</span></code></pre>
        </div>
        <p>ここで次のような関手を定義した:</p>
        <div class="sourceCode" id="cb545">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb545-1"><a href="#cb545-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Store</span> s a <span class="ot">=</span> <span class="dt">Store</span> (s <span class="ot">-&gt;</span> a) s</span></code></pre>
        </div>
        <p>これは積の和から構成される単純な代数的関手ではないことに注意してほしい。これには冪乗<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>a</mi>
                <mi>s</mi>
              </msup>
              <annotation encoding="application/x-tex">a^s</annotation>
            </semantics>
          </math>が含まれる。</p>
        <p>レンズはこの関手の余代数であり、台の型は<code>a</code>だ。<code>Store s</code>がコモナドでもあることは以前にも見た。行儀の良い
          (well-behaved)
          レンズは、コモナドの構造と適合する余代数に対応することが分かる。これについては次章で説明する。</p>
        <h2 data-number="24.7" id="課題-18"><span class="header-section-number">24.7</span> 課題</h2>
        <ol type="1">
          <li>1変数多項式の環について評価関数を実装せよ。多項式は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>x</mi>
                <annotation encoding="application/x-tex">x</annotation>
              </semantics>
            </math>の冪乗の係数のリストとして表せる。たとえば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mn>4</mn>
                  <msup>
                    <mi>x</mi>
                    <mn>2</mn>
                  </msup>
                  <mo>−</mo>
                  <mn>1</mn>
                </mrow>
                <annotation encoding="application/x-tex">4x^2-1</annotation>
              </semantics>
            </math>は、(0乗項から始めて)
            <code>[-1, 0, 4]</code>と表される。
          </li>
          <li>前の構成を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <msup>
                    <mi>x</mi>
                    <mn>2</mn>
                  </msup>
                  <mi>y</mi>
                  <mo>−</mo>
                  <mn>3</mn>
                  <msup>
                    <mi>y</mi>
                    <mn>3</mn>
                  </msup>
                  <mi>z</mi>
                </mrow>
                <annotation encoding="application/x-tex">x^2y-3y^3z</annotation>
              </semantics>
            </math>のような、独立変数を多数含む多項式に一般化せよ。</li>
          <li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mn>2</mn>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mn>2</mn>
                </mrow>
                <annotation encoding="application/x-tex">2\times{}2</annotation>
              </semantics>
            </math>行列の環について代数を実装せよ。</li>
          <li>自然数の自乗のリストを生成するようなアナモルフィズムを持つ余代数を定義せよ。</li>
          <li><code>unfoldr</code>を使って、最初の<g2>n</g2>個の素数のリストを生成せよ。</li>
        </ol>
        <h1 data-number="25" id="モナドの代数"><span class="header-section-number">25</span> モナドの代数</h1>
        <p>
          もし自己関手を式の定義方法だと解釈するなら、代数は式の評価、モナドは式の形成と操作だということになる。代数とモナドを組み合わせることで、多くの機能が得られるだけでなく、いくつかの興味深い質問にも答えられる。そのような疑問の1つはモナドと随伴の関係に関するものだ。これまで見てきたように、すべての随伴はモナド
          (およびコモナド) を<a href="#monads-categorically">定義する</a>。問題は、すべてのモナド
          (コモナド)
          は随伴から導出できるのかということだ。できる、というのが答えだ。任意のモナドを生成する随伴の族が存在する。そのような随伴を2つ紹介する。</p>
        <p><img src="images/pigalg.png" style="width:25.0%" /></p>
        <p>定義を確認しよう。モナドは、あるコヒーレンス条件を満たす2つの自然変換を伴う自己関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>だ。それらの変換の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>におけるコンポーネントは次のとおりだ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <msub>
                      <mi>η</mi>
                      <mi>a</mi>
                    </msub>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>a</mi>
                    <mo>→</mo>
                    <mi>m</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <msub>
                      <mi>μ</mi>
                      <mi>a</mi>
                    </msub>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>m</mi>
                    <mspace width="0.222em"></mspace>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>m</mi>
                      <mspace width="0.222em"></mspace>
                      <mi>a</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                    <mo>→</mo>
                    <mi>m</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                \eta_a &amp;\Colon a \to m\ a \\
                \mu_a &amp;\Colon m\ (m\ a) \to m\ a
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>同じ自己関手についての代数は、ある特定の対象の選択――台<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>――であり、次の射を伴う:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                  <mi>𝑔</mi>
                </mrow>
                <mo>∷</mo>
                <mi>m</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{alg} \Colon m\ a \to a</annotation>
            </semantics>
          </math></p>
        <p>まず注目すべきは、代数が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>η</mi>
                  <mi>a</mi>
                </msub>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\eta_aa</annotation>
            </semantics>
          </math>とは逆向きに進んでいることだ。直観では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>η</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\eta_a</annotation>
            </semantics>
          </math>は型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の値から自明な式を作る。第1のコヒーレンス条件は、代数をモナドと互換性のあるものにするものであり、台が<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>であるその代数でこの式を評価するともとの値が返されることを保証する:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                  <mi>𝑔</mi>
                </mrow>
                <mo>∘</mo>
                <msub>
                  <mi>η</mi>
                  <mi>a</mi>
                </msub>
                <mo>=</mo>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mi>a</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{alg} \circ \eta_a = \mathbf{id}_a</annotation>
            </semantics>
          </math></p>
        <p>第2の条件は、2重にネストされた式<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>m</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">m\ (m\ a)</annotation>
            </semantics>
          </math>
          を評価する方法は2つある、という事実に基づく。まず<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>μ</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\mu_a</annotation>
            </semantics>
          </math>を適用して式をフラット化してから、次に代数の評価子を使えばよい。あるいは、リフトされた評価子を適用して内側の式を評価してから、その結果に評価子を適用してもよい。これら2つの戦略を等価にしたい:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                  <mi>𝑔</mi>
                </mrow>
                <mo>∘</mo>
                <msub>
                  <mi>μ</mi>
                  <mi>a</mi>
                </msub>
                <mo>=</mo>
                <mrow>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                  <mi>𝑔</mi>
                </mrow>
                <mo>∘</mo>
                <mi>m</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                  <mi>𝑔</mi>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{alg} \circ \mu_a = \mathit{alg} \circ m\ \mathit{alg}
              </annotation>
            </semantics>
          </math></p>
        <p>ここで、射<code>m alg</code>は関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>を使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑎</mi>
                <mi>𝑙</mi>
                <mi>𝑔</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{alg}</annotation>
            </semantics>
          </math>をリフトした結果だ。次の可換図式はこれら2つの条件を示している
          (後のことを想定して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>に置き換えた):</p>
        <p><img src="images/talg1.png" /></p>
        <p><img src="images/talg2.png" /></p>
        <p>これらの条件はHaskellでも表現できる:</p>
        <div class="sourceCode" id="cb546">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb546-1"><a href="#cb546-1" aria-hidden="true" tabindex="-1"></a>alg <span class="op">.</span> <span class="fu">return</span> <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb546-2"><a href="#cb546-2" aria-hidden="true" tabindex="-1"></a>alg <span class="op">.</span> join <span class="ot">=</span> alg <span class="op">.</span> <span class="fu">fmap</span> alg</span></code></pre>
        </div>
        <p>
          簡単な例を見てみよう。リスト自己関手の代数は、ある型<code>a</code>と、<code>a</code>のリストから<code>a</code>を生成する関数とで構成される。この関数は<code>foldr</code>を使って表せる。そのためには、要素の型とアキュムレータの型を、両方とも同じ<code>a</code>になるように選ぶ:
        </p>
        <div class="sourceCode" id="cb547">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb547-1"><a href="#cb547-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <p>
          この特定の代数は、引数が2つの関数<code>f</code>と値<code>z</code>によって指定される。list関手はモナドでもあり、<code>return</code>は値を単要素リストに変換する。代数の合成は、ここでは<code>foldr f z</code>であり、<code>return</code>の後で<code>x</code>を取る:
        </p>
        <div class="sourceCode" id="cb548">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb548-1"><a href="#cb548-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> f z [x] <span class="ot">=</span> x <span class="ot">`f`</span> z</span></code></pre>
        </div>
        <p>ただし、<code>f</code>の作用を中置記法で表した。代数がモナドと互換性があるのは、すべての<code>x</code>に対して次のコヒーレンス条件が満たされる場合だ:</p>
        <div class="sourceCode" id="cb549">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb549-1"><a href="#cb549-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">`f`</span> z <span class="ot">=</span> x</span></code></pre>
        </div>
        <p><code>f</code>を二項演算子と見なすと、この条件は<code>z</code>が右単位元であることを示している。</p>
        <p>
          第2のコヒーレンス条件は、リストのリストに対して作用する。<code>join</code>の作用は個々のリストを連結する。その後で結果のリストを畳み込めばよい。一方で、まず個々のリストを畳み込み、次に結果のリストを畳み込んでもよい。ここでも、<code>f</code>を二項演算子と見なすと、この条件はその二項演算の結合性を示している。これらの条件は<code>(a, f, z)</code>がモノイドである場合には確実に満たされる。
        </p>
        <h2 data-number="25.1" id="t-代数"><span class="header-section-number">25.1</span> T-代数</h2>
        <p>数学者はモナドを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>と呼ぶのを好むので、それらと互換性のある代数をT-代数と呼ぶ。圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>における任意のモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>についてのT-代数は圏を形成する。この圏はEilenberg-Moore圏と呼ばれ、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐂</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{C}^T</annotation>
            </semantics>
          </math>と表記されることが多い。この圏の射は代数の準同型だ。それらはF-代数について定義されているのを見たのと同じ準同型だ。</p>
        <p>T-代数は台対象と評価子からなるペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>f</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, f)</annotation>
            </semantics>
          </math>
          だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐂</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{C}^T</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>への自明な忘却関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>U</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">U^T</annotation>
            </semantics>
          </math>が存在し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>f</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, f)</annotation>
            </semantics>
          </math>
          を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>に写す。また、T-代数の準同型を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の台対象間の射のうち対応するものに写す。随伴について議論したとき、忘却関手への左随伴は自由関手と呼ばれると述べたのを覚えているだろう。
        </p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>U</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">U^T</annotation>
            </semantics>
          </math>への左随伴は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>F</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">F^T</annotation>
            </semantics>
          </math>と呼ばれる。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐂</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{C}^T</annotation>
            </semantics>
          </math>内の自由代数に写す。この自由代数の台は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">T\ a</annotation>
            </semantics>
          </math>だ。その評価子は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>T</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">T\ (T\ a)</annotation>
            </semantics>
          </math>
          から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">T\ a</annotation>
            </semantics>
          </math>へ戻る射だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>はモナドなので、モナディックな<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>μ</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\mu_a</annotation>
            </semantics>
          </math>
          (Haskellでの<code>join</code>) を評価子として使える。</p>
        <p>さらに、これがT-代数であることも示す必要がある。そのためには、次の2つのコヒーレンス条件が満たされなければならない:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mrow>
                      <mi>𝑎</mi>
                      <mi>𝑙</mi>
                      <mi>𝑔</mi>
                    </mrow>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∘</mo>
                    <msub>
                      <mi>η</mi>
                      <mrow>
                        <mi>T</mi>
                        <mi>a</mi>
                      </mrow>
                    </msub>
                    <mo>=</mo>
                    <msub>
                      <mrow>
                        <mi>𝐢</mi>
                        <mi>𝐝</mi>
                      </mrow>
                      <mrow>
                        <mi>T</mi>
                        <mi>a</mi>
                      </mrow>
                    </msub>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mrow>
                      <mi>𝑎</mi>
                      <mi>𝑙</mi>
                      <mi>𝑔</mi>
                    </mrow>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∘</mo>
                    <msub>
                      <mi>μ</mi>
                      <mi>a</mi>
                    </msub>
                    <mo>=</mo>
                    <mrow>
                      <mi>𝑎</mi>
                      <mi>𝑙</mi>
                      <mi>𝑔</mi>
                    </mrow>
                    <mo>∘</mo>
                    <mi>T</mi>
                    <mspace width="0.222em"></mspace>
                    <mrow>
                      <mi>𝑎</mi>
                      <mi>𝑙</mi>
                      <mi>𝑔</mi>
                    </mrow>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                \mathit{alg} &amp;\circ \eta_{Ta} = \mathbf{id}_{Ta} \\
                \mathit{alg} &amp;\circ \mu_a = \mathit{alg} \circ T\ \mathit{alg}
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>しかし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>を代数に代入すれば、これらはモナド則にすぎない。</p>
        <p>ご存知のように、すべての随伴はモナドを定義する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>F</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">F^T</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>U</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">U^T</annotation>
            </semantics>
          </math>の間の随伴は、Eilenberg-Moore圏の構成で使われたモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>そのものを定義することがわかる。この構成はすべてのモナドに対して行えるので、すべてのモナドは随伴から生成できる、と結論できる。後ほど、同じモナドを生成する別の随伴が存在することを示す。</p>
        <p>計画はこうだ:
          まず、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>F</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">F^T</annotation>
            </semantics>
          </math>が実際に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>U</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">U^T</annotation>
            </semantics>
          </math>の左随伴であることを示す。そのために、この随伴の単位と余単位を定義し、対応する三角恒等式が満たされているのを証明する。次に、この随伴によって生成されるモナドが、実際にもとのモナドであることを示す。</p>
        <p>随伴の単位は次の自然変換だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>η</mi>
                <mo>∷</mo>
                <mi>I</mi>
                <mo>→</mo>
                <msup>
                  <mi>U</mi>
                  <mi>T</mi>
                </msup>
                <mo>∘</mo>
                <msup>
                  <mi>F</mi>
                  <mi>T</mi>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">\eta \Colon I \to U^T \circ F^T</annotation>
            </semantics>
          </math></p>
        <p>この変換の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>におけるコンポーネントを計算してみよう。恒等関手によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>が得られる。自由関手は自由代数
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>,</mo>
                <msub>
                  <mi>μ</mi>
                  <mi>a</mi>
                </msub>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(T\ a, \mu_a)</annotation>
            </semantics>
          </math>
          を生成し、忘却関手はそれを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">T\ a</annotation>
            </semantics>
          </math>に縮約する。以上により、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">T\ a</annotation>
            </semantics>
          </math>への写像が得られる。単にモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>の単位をこの随伴の単位として使うことにする。
        </p>
        <p>余単位を見てみよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>ε</mi>
                <mo>∷</mo>
                <msup>
                  <mi>F</mi>
                  <mi>T</mi>
                </msup>
                <mo>∘</mo>
                <msup>
                  <mi>U</mi>
                  <mi>T</mi>
                </msup>
                <mo>→</mo>
                <mi>I</mi>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon \Colon F^T \circ U^T \to I</annotation>
            </semantics>
          </math></p>
        <p>あるT-代数
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>f</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, f)</annotation>
            </semantics>
          </math>
          におけるコンポーネントを計算してみよう。忘却関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>を忘れており、自由関手はペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>,</mo>
                <msub>
                  <mi>μ</mi>
                  <mi>a</mi>
                </msub>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(T\ a, \mu_a)</annotation>
            </semantics>
          </math>
          を生成する。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>f</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, f)</annotation>
            </semantics>
          </math>
          における余単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>を定義するには、Eilenberg-Moore圏内の正しい射、すなわち次のようなT-代数の準同型が必要だ:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>T</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo>,</mo>
                  <msub>
                    <mi>μ</mi>
                    <mi>a</mi>
                  </msub>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>f</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">(T\ a, \mu_a) \to (a, f)</annotation>
            </semantics>
          </math></p>
        <p>このような準同型は台<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">T\ a</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>に写す必要がある。忘れられた評価子<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>を復活させよう。今度はそれをT-代数の準同型として使う。実際、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>をT-代数にしたのと同じ可換図式は、それがT-代数の準同型だと示すものとも見なせる:</p>
        <p><img src="images/talg31.png" /></p>
        <p>したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>f</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, f)</annotation>
            </semantics>
          </math>
          (T-代数の圏の対象)
          における余単位の自然変換のコンポーネント<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>と定義した。</p>
        <p>随伴を完成させるには、単位と余単位が三角恒等式を満たすことも示す必要がある。それらの三角形はこう描ける:</p>
        <p><img src="images/talg4.png" /></p>
        <p>最初のものはモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>の単位則より成り立つ。2つ目のものはT-代数の規則
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>f</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, f)</annotation>
            </semantics>
          </math>
          だ。
        </p>
        <p>以上より、これら2つの関手が随伴を形成することが示せた:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>F</mi>
                  <mi>T</mi>
                </msup>
                <mo>⊣</mo>
                <msup>
                  <mi>U</mi>
                  <mi>T</mi>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">F^T \dashv U^T</annotation>
            </semantics>
          </math></p>
        <p>すべての随伴はモナドを生成する。往復旅行</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>U</mi>
                  <mi>T</mi>
                </msup>
                <mo>∘</mo>
                <msup>
                  <mi>F</mi>
                  <mi>T</mi>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">U^T \circ F^T</annotation>
            </semantics>
          </math></p>
        <p>は、対応するモナドを生成する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の自己関手だ。対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>に対する作用を見てみよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>F</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">F^T</annotation>
            </semantics>
          </math>によって作られる自由代数は
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>,</mo>
                <msub>
                  <mi>μ</mi>
                  <mi>a</mi>
                </msub>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(T\ a, \mu_a)</annotation>
            </semantics>
          </math>
          だ。忘却関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>U</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">U^T</annotation>
            </semantics>
          </math>は評価子を削除する。したがって、確かに次が得られる:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>U</mi>
                  <mi>T</mi>
                </msup>
                <mo>∘</mo>
                <msup>
                  <mi>F</mi>
                  <mi>T</mi>
                </msup>
                <mo>=</mo>
                <mi>T</mi>
              </mrow>
              <annotation encoding="application/x-tex">U^T \circ F^T = T</annotation>
            </semantics>
          </math></p>
        <p>予想どおり、随伴の単位はモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>の単位だ。</p>
        <p>随伴の余単位では次の式からモナディックな乗算が生成されるのを覚えているだろう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>μ</mi>
                <mo>=</mo>
                <mi>R</mi>
                <mo>∘</mo>
                <mi>ε</mi>
                <mo>∘</mo>
                <mi>L</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mu = R \circ \varepsilon \circ L</annotation>
            </semantics>
          </math></p>
        <p>これは3つの自然変換の水平合成であり、そのうち2つは恒等自然変換で、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>L</mi>
              <annotation encoding="application/x-tex">L</annotation>
            </semantics>
          </math>に写すものと<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>R</mi>
              <annotation encoding="application/x-tex">R</annotation>
            </semantics>
          </math>に写すものだ。真ん中のものは余単位で、ある代数
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>f</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, f)</annotation>
            </semantics>
          </math>
          におけるコンポーネントが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>であるような自然変換だ。
        </p>
        <p>コンポーネント<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>μ</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\mu_a</annotation>
            </semantics>
          </math>を計算してみよう。まず、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>F</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">F^T</annotation>
            </semantics>
          </math>の後に水平合成すると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>F</mi>
                  <mi>T</mi>
                </msup>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">F^T\ a</annotation>
            </semantics>
          </math>における<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>のコンポーネントが得られる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>F</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">F^T</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を代数
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>,</mo>
                <msub>
                  <mi>μ</mi>
                  <mi>a</mi>
                </msub>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(T\ a, \mu_a)</annotation>
            </semantics>
          </math>
          に渡し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>は評価子を選択するので、結果は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>μ</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\mu_a</annotation>
            </semantics>
          </math>になる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>U</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">U^T</annotation>
            </semantics>
          </math>による左側の水平合成は何も変更しない。なぜなら、射に対する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>U</mi>
                <mi>T</mi>
              </msup>
              <annotation encoding="application/x-tex">U^T</annotation>
            </semantics>
          </math>の作用は自明だからだ。したがって、実際に、随伴から得られる<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>はもとのモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>と同じだ。
        </p>
        <h2 data-number="25.2" id="kleisli圏-2"><span class="header-section-number">25.2</span> Kleisli圏</h2>
        <p>Kleisli圏についてはすでに見た。別の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>とモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>で構成された圏だ。これを圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>𝐂</mi>
                <mi>T</mi>
              </msub>
              <annotation encoding="application/x-tex">\mathbf{C}_T</annotation>
            </semantics>
          </math>と呼ぼう。Kleisli圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>𝐂</mi>
                <mi>T</mi>
              </msub>
              <annotation encoding="application/x-tex">\mathbf{C}_T</annotation>
            </semantics>
          </math>の対象は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の対象だが、射については違う。Kleisli圏での<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>f</mi>
                <mi>𝐊</mi>
              </msub>
              <annotation encoding="application/x-tex">f_{\mathbf{K}}</annotation>
            </semantics>
          </math>は、もとの圏での<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">T\ b</annotation>
            </semantics>
          </math>への射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>に対応する。この射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>へのKleisli矢と呼ぶ。</p>
        <p>Kleisli圏における射の合成はKleisli矢のモナディック合成によって定義される。例として、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>g</mi>
                <mi>𝐊</mi>
              </msub>
              <annotation encoding="application/x-tex">g_{\mathbf{K}}</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>f</mi>
                <mi>𝐊</mi>
              </msub>
              <annotation encoding="application/x-tex">f_{\mathbf{K}}</annotation>
            </semantics>
          </math>の後に合成するとする。Kleisli圏において:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <msub>
                      <mi>f</mi>
                      <mi>𝐊</mi>
                    </msub>
                    <mo>∷</mo>
                    <mi>a</mi>
                    <mo>→</mo>
                    <mi>b</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <msub>
                      <mi>g</mi>
                      <mi>𝐊</mi>
                    </msub>
                    <mo>∷</mo>
                    <mi>b</mi>
                    <mo>→</mo>
                    <mi>c</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                f_{\mathbf{K}} \Colon a \to b \\
                g_{\mathbf{K}} \Colon b \to c
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>のとき、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>において対応するものは、次のとおりだ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>f</mi>
                    <mo>∷</mo>
                    <mi>a</mi>
                    <mo>→</mo>
                    <mi>T</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>b</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>g</mi>
                    <mo>∷</mo>
                    <mi>b</mi>
                    <mo>→</mo>
                    <mi>T</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>c</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                f \Colon a \to T\ b \\
                g \Colon b \to T\ c
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>次のような合成:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>h</mi>
                  <mi>𝐊</mi>
                </msub>
                <mo>=</mo>
                <msub>
                  <mi>g</mi>
                  <mi>𝐊</mi>
                </msub>
                <mo>∘</mo>
                <msub>
                  <mi>f</mi>
                  <mi>𝐊</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">h_{\mathbf{K}} = g_{\mathbf{K}} \circ f_{\mathbf{K}}</annotation>
            </semantics>
          </math></p>
        <p>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>でのKleisli矢として定義する。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>h</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>a</mi>
                    <mo>→</mo>
                    <mi>T</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>c</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>h</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>=</mo>
                    <mi>μ</mi>
                    <mo>∘</mo>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>T</mi>
                      <mspace width="0.222em"></mspace>
                      <mi>g</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                    <mo>∘</mo>
                    <mi>f</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                h &amp;\Colon a \to T\ c \\
                h &amp;= \mu \circ (T\ g) \circ f
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>Haskellでは次のように記述できる:</p>
        <div class="sourceCode" id="cb550">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb550-1"><a href="#cb550-1" aria-hidden="true" tabindex="-1"></a>h <span class="ot">=</span> join <span class="op">.</span> <span class="fu">fmap</span> g <span class="op">.</span> f</span></code></pre>
        </div>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>𝐂</mi>
                <mi>T</mi>
              </msub>
              <annotation encoding="application/x-tex">\mathbf{C}_T</annotation>
            </semantics>
          </math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>があり、対象に対しては自明な働きをする。射に対しては、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>の戻り値を装飾するKleisli射を作成することによって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>𝐂</mi>
                <mi>T</mi>
              </msub>
              <annotation encoding="application/x-tex">\mathbf{C}_T</annotation>
            </semantics>
          </math>の射に写す。次のような射が与えられたとき:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon a \to b</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>𝐂</mi>
                <mi>T</mi>
              </msub>
              <annotation encoding="application/x-tex">\mathbf{C}_T</annotation>
            </semantics>
          </math>には、次の対応するKleisli矢を持つ射ができる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>η</mi>
                <mo>∘</mo>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">\eta \circ f</annotation>
            </semantics>
          </math></p>
        <p>Haskellでは次のように記述できる:</p>
        <div class="sourceCode" id="cb551">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb551-1"><a href="#cb551-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> <span class="op">.</span> f</span></code></pre>
        </div>
        <p>また、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>𝐂</mi>
                <mi>T</mi>
              </msub>
              <annotation encoding="application/x-tex">\mathbf{C}_T</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>へ戻る関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>も定義できる。それはKleisli圏から対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を取り、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">T\ a</annotation>
            </semantics>
          </math>に写す。次のKleisli矢に対応する射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>f</mi>
                <mi>𝐊</mi>
              </msub>
              <annotation encoding="application/x-tex">f_{\mathbf{K}}</annotation>
            </semantics>
          </math>に対する作用:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon a \to T\ b</annotation>
            </semantics>
          </math></p>
        <p>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の射:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">T\ a \to T\ b</annotation>
            </semantics>
          </math></p>
        <p>であり、まず<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>をリフトしてから<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>を適用することで得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>μ</mi>
                  <mrow>
                    <mi>T</mi>
                    <mi>b</mi>
                  </mrow>
                </msub>
                <mo>∘</mo>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mu_{T b} \circ T\ f</annotation>
            </semantics>
          </math></p>
        <p>Haskellの記法だと次のようになる:</p>
        <div class="sourceCode">
          <pre class="sourceCode haskell"><code class="sourceCode haskell">G f<sub>T</sub> = join . fmap f</code></pre>
        </div>
        <p>これはモナディックなバインドの<code>join</code>に基づく定義に見えるだろう。</p>
        <p>2つの関手が随伴を形成しているのは容易に理解できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>⊣</mo>
                <mi>G</mi>
              </mrow>
              <annotation encoding="application/x-tex">F \dashv G</annotation>
            </semantics>
          </math></p>
        <p>そして、それらの合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mo>∘</mo>
                <mi>F</mi>
              </mrow>
              <annotation encoding="application/x-tex">G \circ F</annotation>
            </semantics>
          </math>はもとのモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>を再現する。</p>
        <p>したがって、これは同じモナドを生成する2番目の随伴だ。実際、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐀</mi>
                  <mi>𝐝</mi>
                  <mi>𝐣</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mo>,</mo>
                  <mi>T</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Adj}(\mathbf{C}, T)</annotation>
            </semantics>
          </math>
          という随伴全体の圏が存在し、その結果、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>において同じモナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>が生成される。その圏では、いま見たKleisli随伴が始対象で、Eilenberg-Moore随伴が終対象だ。</p>
        <h2 data-number="25.3" id="コモナドの余代数"><span class="header-section-number">25.3</span> コモナドの余代数</h2>
        <p>同様の構成は任意の<a href="#comonads">コモナド</a><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>W</mi>
              <annotation encoding="application/x-tex">W</annotation>
            </semantics>
          </math>に対して行える。コモナドが成立する余代数の圏を定義できる。それらの余代数は次の図式を可換にする:</p>
        <p><img src="images/talg5.png" /></p>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑐</mi>
                <mi>𝑜</mi>
                <mi>𝑎</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{coa}</annotation>
            </semantics>
          </math>は台が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>である余代数の余評価射
          (coevaluation morphism) だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑐</mi>
                  <mi>𝑜</mi>
                  <mi>𝑎</mi>
                </mrow>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>W</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{coa} \Colon a \to W\ a</annotation>
            </semantics>
          </math></p>
        <p>そして、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>δ</mi>
              <annotation encoding="application/x-tex">\delta</annotation>
            </semantics>
          </math>はコモナドを定義する2つの自然変換だ
          (Haskellでは、これらのコンポーネントは<code>extract</code>および<code>duplicate</code>と呼ばれる)。</p>
        <p>これらの余代数の圏から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>へは自明な忘却関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>U</mi>
                <mi>W</mi>
              </msup>
              <annotation encoding="application/x-tex">U^W</annotation>
            </semantics>
          </math>が存在する。それはただ余評価を忘れている。その右随伴<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>F</mi>
                <mi>W</mi>
              </msup>
              <annotation encoding="application/x-tex">F^W</annotation>
            </semantics>
          </math>について考えよう。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>U</mi>
                  <mi>W</mi>
                </msup>
                <mo>⊣</mo>
                <msup>
                  <mi>F</mi>
                  <mi>W</mi>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">U^W \dashv F^W</annotation>
            </semantics>
          </math></p>
        <p>忘却関手のこの右随伴は余自由関手 (cofree functor)
          と呼ばれる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>F</mi>
                <mi>W</mi>
              </msup>
              <annotation encoding="application/x-tex">F^W</annotation>
            </semantics>
          </math>は余自由余代数
          (cofree coalgebra)
          を生成する。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>に余代数
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>W</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>,</mo>
                <msub>
                  <mi>δ</mi>
                  <mi>a</mi>
                </msub>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(W\ a, \delta_a)</annotation>
            </semantics>
          </math>
          を割り当てる。随伴はもとのコモナドを合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>U</mi>
                  <mi>W</mi>
                </msup>
                <mo>∘</mo>
                <msup>
                  <mi>F</mi>
                  <mi>W</mi>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">U^W \circ F^W</annotation>
            </semantics>
          </math>として再生成する。
        </p>
        <p>同様に、余Kleisli矢から余Kleisli圏を構築し、対応する随伴からコモナドを再生成できる。</p>
        <h2 data-number="25.4" id="レンズ"><span class="header-section-number">25.4</span> レンズ</h2>
        <p>レンズの話に戻ろう。レンズは余代数を使って書ける:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑐</mi>
                  <mi>𝑜</mi>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                  <msub>
                    <mi>𝑔</mi>
                    <mi>𝑠</mi>
                  </msub>
                </mrow>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mrow>
                  <mi>𝑆</mi>
                  <mi>𝑡</mi>
                  <mi>𝑜</mi>
                  <mi>𝑟</mi>
                  <mi>𝑒</mi>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mi>s</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{coalg_s} \Colon a \to \mathit{Store}\ s\ a</annotation>
            </semantics>
          </math></p>
        <p>ここで関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑆</mi>
                  <mi>𝑡</mi>
                  <mi>𝑜</mi>
                  <mi>𝑟</mi>
                  <mi>𝑒</mi>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mi>s</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Store}\ s</annotation>
            </semantics>
          </math>は次のとおりだ:</p>
        <div class="sourceCode" id="cb552">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb552-1"><a href="#cb552-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Store</span> s a <span class="ot">=</span> <span class="dt">Store</span> (s <span class="ot">-&gt;</span> a) s</span></code></pre>
        </div>
        <p>この余代数は、以下の関数のペアとしても表せる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>s</mi>
                    <mi>e</mi>
                    <mi>t</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>a</mi>
                    <mo>→</mo>
                    <mi>s</mi>
                    <mo>→</mo>
                    <mi>a</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>g</mi>
                    <mi>e</mi>
                    <mi>t</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>a</mi>
                    <mo>→</mo>
                    <mi>s</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                set &amp;\Colon a \to s \to a \\
                get &amp;\Colon a \to s
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>は「すべて」(all)
          を表し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>s</mi>
              <annotation encoding="application/x-tex">s</annotation>
            </semantics>
          </math>はその「小さな」(small)
          一部だと考えてほしい)。このペアに関して、次が成り立つ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑐</mi>
                  <mi>𝑜</mi>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                  <msub>
                    <mi>𝑔</mi>
                    <mi>𝑠</mi>
                  </msub>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>=</mo>
                <mrow>
                  <mi>𝑆</mi>
                  <mi>𝑡</mi>
                  <mi>𝑜</mi>
                  <mi>𝑟</mi>
                  <mi>𝑒</mi>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mi>𝑠</mi>
                    <mi>𝑒</mi>
                    <mi>𝑡</mi>
                  </mrow>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mi>𝑔</mi>
                    <mi>𝑒</mi>
                    <mi>𝑡</mi>
                  </mrow>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{coalg_s}\ a = \mathit{Store}\ (\mathit{set}\ a)\
                (\mathit{get}\ a)</annotation>
            </semantics>
          </math></p>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>は型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の値だ。部分適用された<code>set</code>は関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>s</mi>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">s \to a</annotation>
            </semantics>
          </math>であることに注意してほしい。</p>
        <p>また、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑆</mi>
                  <mi>𝑡</mi>
                  <mi>𝑜</mi>
                  <mi>𝑟</mi>
                  <mi>𝑒</mi>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mi>s</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Store}\ s</annotation>
            </semantics>
          </math>がコモナドなのも分かっている。</p>
        <div class="sourceCode" id="cb553">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb553-1"><a href="#cb553-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Comonad</span> (<span class="dt">Store</span> s) <span class="kw">where</span></span>
<span id="cb553-2"><a href="#cb553-2" aria-hidden="true" tabindex="-1"></a>  extract (<span class="dt">Store</span> f s) <span class="ot">=</span> f s</span>
<span id="cb553-3"><a href="#cb553-3" aria-hidden="true" tabindex="-1"></a>  duplicate (<span class="dt">Store</span> f s) <span class="ot">=</span> <span class="dt">Store</span> (<span class="dt">Store</span> f) s</span></code></pre>
        </div>
        <p>問題は、あるレンズがこのコモナドの余代数になる条件は何かということだ。第1のコヒーレンス条件:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>ε</mi>
                  <mi>a</mi>
                </msub>
                <mo>∘</mo>
                <mrow>
                  <mi>𝑐</mi>
                  <mi>𝑜</mi>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                  <mi>𝑔</mi>
                </mrow>
                <mo>=</mo>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mi>a</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon_a \circ \mathit{coalg} = %
                \mathbf{id}_{a}%
              </annotation>
            </semantics>
          </math></p>
        <p>は、次のように解釈できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>s</mi>
                <mi>e</mi>
                <mi>t</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>g</mi>
                  <mi>e</mi>
                  <mi>t</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>=</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">set\ a\ (get\ a) = a</annotation>
            </semantics>
          </math></p>
        <p>このレンズ則は、構造体<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>のフィールドを以前の値に設定しても何も変わらないという事実を表す。</p>
        <p>第2の条件:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑓</mi>
                  <mi>𝑚</mi>
                  <mi>𝑎</mi>
                  <mi>𝑝</mi>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mi>𝑐</mi>
                  <mi>𝑜</mi>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                  <mi>𝑔</mi>
                </mrow>
                <mo>∘</mo>
                <mrow>
                  <mi>𝑐</mi>
                  <mi>𝑜</mi>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                  <mi>𝑔</mi>
                </mrow>
                <mo>=</mo>
                <msub>
                  <mi>δ</mi>
                  <mi>a</mi>
                </msub>
                <mo>∘</mo>
                <mrow>
                  <mi>𝑐</mi>
                  <mi>𝑜</mi>
                  <mi>𝑎</mi>
                  <mi>𝑙</mi>
                  <mi>𝑔</mi>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{fmap}\ \mathit{coalg} \circ \mathit{coalg} = \delta_a
                \circ \mathit{coalg}</annotation>
            </semantics>
          </math></p>
        <p>は、もう少し手間がかかる。まず、<code>store</code>関手の<code>fmap</code>の定義を思い出してほしい:</p>
        <div class="sourceCode" id="cb554">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb554-1"><a href="#cb554-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> g (<span class="dt">Store</span> f s) <span class="ot">=</span> <span class="dt">Store</span> (g <span class="op">.</span> f) s</span></code></pre>
        </div>
        <p><code>fmap coalg</code>を<code>coalg</code>の結果に適用すると、次のようになる:</p>
        <div class="sourceCode" id="cb555">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb555-1"><a href="#cb555-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Store</span> (coalg <span class="op">.</span> set a) (get a)</span></code></pre>
        </div>
        <p>一方、<code>duplicate</code>を<code>coalg</code>の結果に適用すると、次のようになる:</p>
        <div class="sourceCode" id="cb556">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb556-1"><a href="#cb556-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Store</span> (<span class="dt">Store</span> (set a)) (get a)</span></code></pre>
        </div>
        <p>これら2つの式が等しくなるには、<code>Store</code>の下の2つの関数はどのような<code>s</code>に作用しても等しくなければならない。</p>
        <div class="sourceCode" id="cb557">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb557-1"><a href="#cb557-1" aria-hidden="true" tabindex="-1"></a>coalg (set a s) <span class="ot">=</span> <span class="dt">Store</span> (set a) s</span></code></pre>
        </div>
        <p><code>coalg</code>を展開すると、次が得られる:</p>
        <div class="sourceCode" id="cb558">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb558-1"><a href="#cb558-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Store</span> (set (set a s)) (get (set a s)) <span class="ot">=</span> <span class="dt">Store</span> (set a) s</span></code></pre>
        </div>
        <p>これは残り2つのレンズ則と等価だ。1つめ:</p>
        <div class="sourceCode" id="cb559">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb559-1"><a href="#cb559-1" aria-hidden="true" tabindex="-1"></a>set (set a s) <span class="ot">=</span> set a</span></code></pre>
        </div>
        <p>は、フィールドの値を2回設定するのは1回設定するのと同じだと示している。2つめ:</p>
        <div class="sourceCode" id="cb560">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb560-1"><a href="#cb560-1" aria-hidden="true" tabindex="-1"></a>get (set a s) <span class="ot">=</span> s</span></code></pre>
        </div>
        <p>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>s</mi>
              <annotation encoding="application/x-tex">s</annotation>
            </semantics>
          </math>に設定されたフィールドの値を取得すると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>s</mi>
              <annotation encoding="application/x-tex">s</annotation>
            </semantics>
          </math>が返されることを示す。</p>
        <p>言い換えれば、行儀の良いレンズはまさに<code>store</code>関手のコモナド余代数だ。</p>
        <h2 data-number="25.5" id="課題-19"><span class="header-section-number">25.5</span> 課題</h2>
        <ol type="1">
          <li>
            <p>自由関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mrow>
                    <mi>F</mi>
                    <mo>∷</mo>
                    <mi>C</mi>
                    <mo>→</mo>
                    <msup>
                      <mi>C</mi>
                      <mi>T</mi>
                    </msup>
                  </mrow>
                  <annotation encoding="application/x-tex">F \Colon C \to C^T</annotation>
                </semantics>
              </math>の射に対する作用は何か。ヒント:
              モナディックな<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mi>μ</mi>
                  <annotation encoding="application/x-tex">\mu</annotation>
                </semantics>
              </math>について自然条件を使う。</p>
          </li>
          <li>
            <p>次の随伴を定義せよ:</p>
            <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
                <semantics>
                  <mrow>
                    <msup>
                      <mi>U</mi>
                      <mi>W</mi>
                    </msup>
                    <mo>⊣</mo>
                    <msup>
                      <mi>F</mi>
                      <mi>W</mi>
                    </msup>
                  </mrow>
                  <annotation encoding="application/x-tex">U^W \dashv F^W</annotation>
                </semantics>
              </math></p>
          </li>
          <li>
            <p>上記の随伴がもとのコモナドを再現するのを証明せよ。</p>
          </li>
        </ol>
        <h1 data-number="26" id="ends-and-coends"><span class="header-section-number">26</span> エンドとコエンド</h1>
        <p>圏内の射に適用できる直観はたくさんあるが、誰もが同意できるのは、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への射があれば、2つの対象には何らかの「関連がある」というものだ。ある意味で、射はこの関係の証明だ。すべてのポセット圏では射が関係<em>である</em>ので、それは一目瞭然だ。一般に、2つの対象間での同じ関係の「証明」は複数存在しうる。それらの証明はhom集合と呼ばれる集合を形成する。対象を変化させると、対象のペアから「証明」の集合への写像が得られる。この写像は関手的だ――1番目の引数については反変で、2番目の引数については共変だ。これは、圏内の対象間に大域的な関係を確立していると見なせる。この関係は次のhom関手で表せる:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mo>−</mo>
                  <mo>,</mo>
                  <mo>=</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>∷</mo>
                <msup>
                  <mi>𝐂</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
                <mo>→</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(-, =) \Colon \mathbf{C}^\mathit{op}\times{}\mathbf{C}
                \to \mathbf{Set}</annotation>
            </semantics>
          </math></p>
        <p>一般に、このような関手はすべて、圏内の対象間の関係を確立するものとして解釈できる。関係には2つの異なる圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>が含まれる場合もある。そのような関係を表す関手は、次のようなシグネチャを持ち、プロ関手
          (profunctor) と呼ばれる。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mo>∷</mo>
                <msup>
                  <mi>𝐃</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
                <mo>→</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">p \Colon \mathbf{D}^\mathit{op}\times{}\mathbf{C} \to
                \mathbf{Set}</annotation>
            </semantics>
          </math></p>
        <p>これは数学者によると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>へのプロ関手
          (反転に注意) であり、スラッシュ付き矢印で記される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mo>↛</mo>
                <mi>𝐃</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C} \nrightarrow \mathbf{D}</annotation>
            </semantics>
          </math></p>
        <p>プロ関手は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>の対象と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の対象の間の<span id="proof-relevant_relation" class="keyword">証明で関連した関係</span>
          (proof-relevant relation)
          と見なせる。ここで、集合の要素は関係の証明を象徴している。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ a\ b</annotation>
            </semantics>
          </math>が空の場合は常に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の間に関係はない。関係は対称である必要はないことに注意してほしい。</p>
        <p>もう1つの有用な直観は、自己関手はコンテナであるという考え方の一般化だ。型が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ a\ b</annotation>
            </semantics>
          </math>のプロ関手の値は、型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の要素をキーとする<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>のコンテナと見なせる。特に、homプロ関手の要素は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への関数だ。</p>
        <p>
          Haskellでは、プロ関手は2引数の型コンストラクター<code>p</code>として定義され、関数のペアをリフトする<code>dimap</code>と呼ばれるメソッドを備えている。そのペアのうち最初の関数は「間違った」方向を向いている:
        </p>
        <div class="sourceCode" id="cb561">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb561-1"><a href="#cb561-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Profunctor</span> p <span class="kw">where</span></span>
<span id="cb561-2"><a href="#cb561-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    dimap ::</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p c d</span></code></pre>
        </div>
        <p>
          プロ関手の関手性は、<code>a</code>が<code>b</code>に関連しているという証明があれば、<code>c</code>が<code>d</code>に関連しているという証明も、<code>c</code>から<code>a</code>への射と<code>b</code>から<code>d</code>への別の射がある限り成り立つことを示している。あるいは、最初の関数は新しいキーを古いキーに変換し、2番目の関数はコンテナの内容を変更するとも見なせる。
        </p>
        <p>1つの圏内で作用するプロ関手では、型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ a\ a</annotation>
            </semantics>
          </math>の対角要素からかなり多くの情報が取り出せる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>に関連していることは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>b</mi>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">b \to a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>→</mo>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \to c</annotation>
            </semantics>
          </math>という射のペアがある限り証明できる。さらには、単一の射を使って非対角値に到達することもできる。たとえば、射<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon a \to b</annotation>
            </semantics>
          </math>がある場合、ペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">⟨</mo>
                <mi>f</mi>
                <mo>,</mo>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mi>b</mi>
                </msub>
                <mo stretchy="false" form="postfix">⟩</mo>
              </mrow>
              <annotation encoding="application/x-tex">\langle f, %
                \mathbf{id}_{b}%
                \rangle</annotation>
            </semantics>
          </math>をリフトすることで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ b\ b</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ a\ b</annotation>
            </semantics>
          </math>に移動できる:</p>
        <div class="sourceCode" id="cb562">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb562-1"><a href="#cb562-1" aria-hidden="true" tabindex="-1"></a>dimap f <span class="fu">id</span><span class="ot"> pbb ::</span> p a b</span></code></pre>
        </div>
        <p>あるいは、ペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">⟨</mo>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mi>a</mi>
                </msub>
                <mo>,</mo>
                <mi>f</mi>
                <mo stretchy="false" form="postfix">⟩</mo>
              </mrow>
              <annotation encoding="application/x-tex">\langle %
                \mathbf{id}_{a}%
                , f \rangle</annotation>
            </semantics>
          </math>をリフトすることで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ a\ a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ a\ b</annotation>
            </semantics>
          </math>に移動することもできる:</p>
        <div class="sourceCode" id="cb563">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb563-1"><a href="#cb563-1" aria-hidden="true" tabindex="-1"></a>dimap <span class="fu">id</span> f<span class="ot"> paa ::</span> p a b</span></code></pre>
        </div>
        <h2 data-number="26.1" id="対角自然変換"><span class="header-section-number">26.1</span> 対角自然変換</h2>
        <p>
          プロ関手は関手なので、それらの間の自然変換は通常の方法で定義できる。ただし、多くの場合は2つのプロ関手の対角要素間の写像を定義するだけで十分だ。このような変換は、対角要素を非対角要素に接続できる2つの方法を反映した可換条件を満たす場合、対角自然変換と呼ばれる。関手圏<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <msup>
                  <mi>𝐂</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
                <mo>,</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}\mathbf{C}^\mathit{op}\times{}\mathbf{C}, \mathbf{Set}{]}
              </annotation>
            </semantics>
          </math>のメンバーである2つのプロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>について、その間の対角自然変換は次のような射の族だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>→</mo>
                <mi>q</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_a \Colon p\ a\ a \to q\ a\ a</annotation>
            </semantics>
          </math></p>
        <p>そこではあらゆる<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon a \to b</annotation>
            </semantics>
          </math>について次の図式が可換となる:</p>
        <p><img src="images/end.jpg" style="width:35.0%" /></p>
        <p>これは自然条件よりも厳密に弱いことに注意してほしい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <msup>
                  <mi>𝐂</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
                <mo>,</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}\mathbf{C}^\mathit{op}\times{}\mathbf{C}, \mathbf{Set}{]}
              </annotation>
            </semantics>
          </math>内の自然変換なら、前記の図式は2つの自然性の正方図式と1つの関手性条件
          (合成を保持するプロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>)
          から構成できる:</p>
        <p><img src="images/end-1.jpg" style="width:40.0%" /></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <msup>
                  <mi>𝐂</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
                <mo>,</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}\mathbf{C}^\mathit{op}\times{}\mathbf{C}, \mathbf{Set}{]}
              </annotation>
            </semantics>
          </math>内の自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>のコンポーネントは、対象のペア<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mrow>
                  <mi>a</mi>
                  <mi>b</mi>
                </mrow>
              </msub>
              <annotation encoding="application/x-tex">\alpha_{a b}</annotation>
            </semantics>
          </math>によって添字付けされていることに注意してほしい。一方で、対角自然変換は1つの対象によって添字付けされる。なぜなら、対応するプロ関手の対角要素のみを写すからだ。</p>
        <h2 data-number="26.2" id="エンド"><span class="header-section-number">26.2</span> エンド</h2>
        <p>いまや「代数」から圏論の「微積分」と見なせるものへ進む準備ができた。エンド
          (およびコエンド)
          の微積分は、古典的な微積分から、その概念だけでなく、いくつかの記法さえ借用している。特に、コエンドは無限和あるいは積分として理解でき、エンドは無限積に類似している。Diracのデルタ関数に似たものさえある。</p>
        <p>エンドは極限を一般化したもので、関手がプロ関手に置き換えられている。錐の代わりに、くさび
          (wedge)
          がある。くさびの底面はプロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>の対角要素によって形成される。くさびの頂点は対象
          (ここでは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>値のプロ関手を想定しているため、集合)
          であり、側面は頂点を底面内の集合に写す関数の族だ。この族は、1つの多相関数――戻り値の型が多相である関数――と見なせる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>α</mi>
                <mo>∷</mo>
                <mo>∀</mo>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>.</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mi>𝑎</mi>
                  <mi>𝑝</mi>
                  <mi>𝑒</mi>
                  <mi>𝑥</mi>
                </mrow>
                <mo>→</mo>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\alpha \Colon \forall a\ .\ \mathit{apex} \to p\ a\ a
              </annotation>
            </semantics>
          </math></p>
        <p>錐とは違って、くさびには底面の頂点同士を接続する関数はない。しかし、すでに見たとおり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の任意の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon a \to b</annotation>
            </semantics>
          </math>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ a\ a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ b\ b</annotation>
            </semantics>
          </math>の両方を共通の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ a\ b</annotation>
            </semantics>
          </math>に接続できる。したがって、次の図式が可換だと主張できる:</p>
        <p><img src="images/end-2.jpg" /></p>
        <p>これは<span id="wedge_condition" class="keyword">くさび条件</span>
          (wedge condition) と呼ばれる。これは次のように書ける:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mi>a</mi>
                </msub>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
                <mo>∘</mo>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
                <mo>=</mo>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
                <mspace width="0.222em"></mspace>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mi>b</mi>
                </msub>
                <mo>∘</mo>
                <msub>
                  <mi>α</mi>
                  <mi>b</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">p\ %
                \mathbf{id}_{a}%
                \ f \circ \alpha_a = p\ f\ %
                \mathbf{id}_{b}%
                \circ \alpha_b</annotation>
            </semantics>
          </math></p>
        <p>あるいは、Haskellの記法を使うと次のようになる:</p>
        <div class="sourceCode" id="cb564">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb564-1"><a href="#cb564-1" aria-hidden="true" tabindex="-1"></a>dimap <span class="fu">id</span> f <span class="op">.</span> alpha <span class="ot">=</span> dimap f <span class="fu">id</span> <span class="op">.</span> alpha</span></code></pre>
        </div>
        <p>ここで普遍的構成を使って進み、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>のエンドを普遍くさび
          (universal wedge)
          として定義する。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>e</mi>
              <annotation encoding="application/x-tex">e</annotation>
            </semantics>
          </math>と関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>π</mi>
              <annotation encoding="application/x-tex">\pi</annotation>
            </semantics>
          </math>の族の組で、頂点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と族<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>α</mi>
              <annotation encoding="application/x-tex">\alpha</annotation>
            </semantics>
          </math>の組からなる他のすべてのくさびについて一意な関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>h</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>e</mi>
              </mrow>
              <annotation encoding="application/x-tex">h \Colon a \to e</annotation>
            </semantics>
          </math>が存在し、すべての三角図式を可換にする:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>π</mi>
                  <mi>a</mi>
                </msub>
                <mo>∘</mo>
                <mi>h</mi>
                <mo>=</mo>
                <msub>
                  <mi>α</mi>
                  <mi>a</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">\pi_a \circ h = \alpha_a</annotation>
            </semantics>
          </math></p>
        <p><img src="images/end-21.jpg" /></p>
        <p>エンドの記号は、下付きの「積分変数」を添えた積分記号だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mo>∫</mo>
                  <mi>c</mi>
                </msub>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>c</mi>
                <mspace width="0.222em"></mspace>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">\int_c p\ c\ c</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>π</mi>
              <annotation encoding="application/x-tex">\pi</annotation>
            </semantics>
          </math>のコンポーネントはエンドの射影マップ
          (projection map) と呼ばれる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>π</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <msub>
                  <mo>∫</mo>
                  <mi>c</mi>
                </msub>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>c</mi>
                <mspace width="0.222em"></mspace>
                <mi>c</mi>
                <mo>→</mo>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\pi_a \Colon \int_c p\ c\ c \to p\ a\ a</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>が離散圏
          (恒等射以外の射がない)
          の場合、エンドは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>全体にわたる<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>のすべての対角要素の大域的な積になる。後ほど説明するが、より一般には、この積とエンドの間にはイコライザを介した関係がある。</p>
        <p>Haskellでは、エンドの式は全称量化子 (universal quantifier)
          に直接変換される:</p>
        <div class="sourceCode" id="cb565">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb565-1"><a href="#cb565-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> a<span class="op">.</span> p a a</span></code></pre>
        </div>
        <p>厳密に言うと、これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>のすべての対角要素の積に過ぎないが、くさび条件は<a
            href="https://bartoszmilewski.com/2017/04/11/profunctor-parametricity/">パラメトリック性</a>
          (parametricity)
          によって自動的に満たされる。任意の関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon a \to b</annotation>
            </semantics>
          </math>について、くさび条件は次のようになる:</p>
        <div class="sourceCode" id="cb566">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb566-1"><a href="#cb566-1" aria-hidden="true" tabindex="-1"></a>dimap f <span class="fu">id</span> <span class="op">.</span> <span class="fu">pi</span> <span class="ot">=</span> dimap <span class="fu">id</span> f <span class="op">.</span> <span class="fu">pi</span></span></code></pre>
        </div>
        <p>あるいは、型アノテーションを付けると次のようになる:</p>
        <div class="sourceCode">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell">dimap f id<sub>b</sub> . pi<sub>b</sub> = dimap id<sub>a</sub> f . pi<sub>a</sub></code></pre>
        </div>
        <p>この式の両辺の型は:</p>
        <div class="sourceCode" id="cb567">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb567-1"><a href="#cb567-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> (<span class="kw">forall</span> c<span class="op">.</span> p c c) <span class="ot">-&gt;</span> p a b</span></code></pre>
        </div>
        <p>であり、<code>pi</code>は多相射影だ:</p>
        <div class="sourceCode" id="cb568">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb568-1"><a href="#cb568-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pi</span><span class="ot"> ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> <span class="kw">forall</span> c<span class="op">.</span> (<span class="kw">forall</span> a<span class="op">.</span> p a a) <span class="ot">-&gt;</span> p c c</span>
<span id="cb568-2"><a href="#cb568-2" aria-hidden="true" tabindex="-1"></a><span class="fu">pi</span> e <span class="ot">=</span> e</span></code></pre>
        </div>
        <p>ここで、型推論によって自動的に<code>e</code>の正しいコンポーネントが選択される。</p>
        <p>錐のすべての可換条件を1つの自然変換として表せたように、すべてのくさび条件も1つの対角自然変換にまとめられる。そのためには、定関手<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>をある定プロ関手
          (constant profunctor)
          へと一般化する必要がある。その定プロ関手は、対象のすべてのペアを単一の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>に写し、射のすべてのペアをその対象の恒等射に写す。くさびは、その関手からプロ関手<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>への対角自然変換だ。実際、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>がすべての射を単一の恒等関数にリフトすることに気付けば、対角自然性の六角形はくさびのダイヤモンドへと収縮できる。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>以外の終域圏に対してもエンドを定義できるが、これ以降では集合値プロ関手
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>-valued
          profunctor) とそのエンドのみを扱う。</p>
        <h2 data-number="26.3" id="イコライザとしてのエンド"><span class="header-section-number">26.3</span> イコライザとしてのエンド</h2>
        <p>エンドの定義における可換条件はイコライザを用いて書ける。まず、2つの関数を定義しよう
          (ここではHaskellの表記の方が数学的表記よりユーザー・フレンドリーだと思うので、そちらを使う)。これらの関数はくさび条件の2つの収束分岐
          (converging branch) に対応する:</p>
        <div class="sourceCode" id="cb569">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb569-1"><a href="#cb569-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lambda ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> p a a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a b</span>
<span id="cb569-2"><a href="#cb569-2" aria-hidden="true" tabindex="-1"></a>lambda paa f <span class="ot">=</span> dimap <span class="fu">id</span> f paa</span>
<span id="cb569-3"><a href="#cb569-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb569-4"><a href="#cb569-4" aria-hidden="true" tabindex="-1"></a><span class="ot">rho ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> p b b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a b</span>
<span id="cb569-5"><a href="#cb569-5" aria-hidden="true" tabindex="-1"></a>rho pbb f <span class="ot">=</span> dimap f <span class="fu">id</span> pbb</span></code></pre>
        </div>
        <p>どちらの関数もプロ関手<code>p</code>の対角要素を次の型の多相関数に写す:</p>
        <div class="sourceCode" id="cb570">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb570-1"><a href="#cb570-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ProdP</span> p <span class="ot">=</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a b</span></code></pre>
        </div>
        <p>これらの関数の型は異なる。しかし、<code>p</code>のすべての対角要素を集めて大きな直積型を1つ形成すれば、それらの型を単一化できる。</p>
        <div class="sourceCode" id="cb571">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb571-1"><a href="#cb571-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">DiaProd</span> p <span class="ot">=</span> <span class="dt">DiaProd</span> (<span class="kw">forall</span> a<span class="op">.</span> p a a)</span></code></pre>
        </div>
        <p>関数<code>lambda</code>と<code>rho</code>はこの直積型から2つの写像を導く:</p>
        <div class="sourceCode" id="cb572">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb572-1"><a href="#cb572-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lambdaP ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> <span class="dt">DiaProd</span> p <span class="ot">-&gt;</span> <span class="dt">ProdP</span> p</span>
<span id="cb572-2"><a href="#cb572-2" aria-hidden="true" tabindex="-1"></a>lambdaP (<span class="dt">DiaProd</span> paa) <span class="ot">=</span> lambda paa</span>
<span id="cb572-3"><a href="#cb572-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb572-4"><a href="#cb572-4" aria-hidden="true" tabindex="-1"></a><span class="ot">rhoP ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> <span class="dt">DiaProd</span> p <span class="ot">-&gt;</span> <span class="dt">ProdP</span> p</span>
<span id="cb572-5"><a href="#cb572-5" aria-hidden="true" tabindex="-1"></a>rhoP (<span class="dt">DiaProd</span> paa) <span class="ot">=</span> rho paa</span></code></pre>
        </div>
        <p>
          <code>p</code>のエンドはこれら2つの関数のイコライザだ。イコライザは2つの関数が等しい最大の部分集合を選択することに注意してほしい。ここでは、くさびの図式が可換となるようなすべての対角要素の積の部分集合が選択される。
        </p>
        <h2 data-number="26.4" id="エンドとしての自然変換"><span class="header-section-number">26.4</span> エンドとしての自然変換</h2>
        <p>エンドの最も重要な例は自然変換の集合だ。2つの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>G</mi>
              <annotation encoding="application/x-tex">G</annotation>
            </semantics>
          </math>の間の自然変換は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>G</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(F\ a, G\ a)</annotation>
            </semantics>
          </math>
          という形式のhom集合から選択された射の族だ。もし自然条件がなければ、自然変換の集合はこれらすべてのhom集合の積にすぎないだろう。実際、Haskellでは次のようになる:</p>
        <div class="sourceCode" id="cb573">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb573-1"><a href="#cb573-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> a<span class="op">.</span> f a <span class="ot">-&gt;</span> g a</span></code></pre>
        </div>
        <p>Haskellでこれが動作する理由は、自然性がパラメトリック性に従うためだ。ただし、Haskell以外では、このようなhom集合に渡るすべての対角要素が自然変換を生成するわけではない。しかし、写像:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">⟨</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="false" form="postfix">⟩</mo>
                <mo>→</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>G</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\langle a, b \rangle \to \mathbf{C}(F\ a, G\ b)</annotation>
            </semantics>
          </math></p>
        <p>がプロ関手であることに注目すれば、そのエンドを研究するのは意味がある。くさび条件は次のとおりだ:</p>
        <p><img src="images/end1.jpg" style="width:40.0%" /></p>
        <p>集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mo>∫</mo>
                  <mi>c</mi>
                </msub>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mi>G</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\int_c \mathbf{C}(F\ c, G\ c)</annotation>
            </semantics>
          </math>
          から要素を1つだけ選択しよう。この要素は2つの射影によって特定の変換の2つのコンポーネントに写される。それらを次のように呼ぼう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <msub>
                      <mi>τ</mi>
                      <mi>a</mi>
                    </msub>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>F</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                    <mo>→</mo>
                    <mi>G</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <msub>
                      <mi>τ</mi>
                      <mi>b</mi>
                    </msub>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>F</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>b</mi>
                    <mo>→</mo>
                    <mi>G</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>b</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                \tau_a &amp;\Colon F\ a \to G\ a \\
                \tau_b &amp;\Colon F\ b \to G\ b
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>図式の左側の分岐では、一対の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">⟨</mo>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mi>a</mi>
                </msub>
                <mo>,</mo>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
                <mo stretchy="false" form="postfix">⟩</mo>
              </mrow>
              <annotation encoding="application/x-tex">\langle %
                \mathbf{id}_{a}%
                , G\ f \rangle</annotation>
            </semantics>
          </math>をリフトするのにhom関手を使う。このようなリフトを前置合成と後置合成として一度に実装したのを思い出してほしい。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>τ</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\tau_a</annotation>
            </semantics>
          </math>に作用するとき、リフトされたペアから次が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>G</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
                <mo>∘</mo>
                <msub>
                  <mi>τ</mi>
                  <mi>a</mi>
                </msub>
                <mo>∘</mo>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mi>a</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">G\ f \circ \tau_a \circ %
                \mathbf{id}_{a}%
              </annotation>
            </semantics>
          </math></p>
        <p>図式のもう一方の分岐からは次が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mi>b</mi>
                </msub>
                <mo>∘</mo>
                <msub>
                  <mi>τ</mi>
                  <mi>b</mi>
                </msub>
                <mo>∘</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">%
                \mathbf{id}_{b}%
                \circ \tau_b \circ F\ f</annotation>
            </semantics>
          </math></p>
        <p>くさび条件が要求するこれらの等価性は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>τ</mi>
              <annotation encoding="application/x-tex">\tau</annotation>
            </semantics>
          </math>の自然条件に他ならない。</p>
        <h2 data-number="26.5" id="コエンド"><span class="header-section-number">26.5</span> コエンド</h2>
        <p>予想どおり、エンドの双対はコエンドと呼ばれる。それはくさびの双対で構成され、余くさび
          (cowedge) と呼ばれる (cowedgeの発音はco-wedgeで、cow-edgeではない)。</p>
        <figure>
          <img src="images/end-31.jpg" title="エッジの効いた牛 (edgy cow)？" style="width:25.0%" alt="エッジの効いた牛 (An edgy cow)？" />
          <figcaption aria-hidden="true">エッジの効いた牛 (An edgy
            cow)？</figcaption>
        </figure>
        <p>コエンドの記号は、上付きの「積分変数」を添えた積分記号だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mo>∫</mo>
                  <mi>c</mi>
                </msup>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>c</mi>
                <mspace width="0.222em"></mspace>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">\int^c p\ c\ c</annotation>
            </semantics>
          </math></p>
        <p>エンドが積に関連しているのと同様に、コエンドは余積あるいは和に関連している
          (この観点でコエンドは和の極限である積分に似ている)。射影を持つのではなく、プロ関手の対角要素からコエンドに向かう単射を持つ。余くさび条件がなければ、プロ関手<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>のコエンドは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ a\ a</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ b\ b</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>c</mi>
                <mspace width="0.222em"></mspace>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ c\ c</annotation>
            </semantics>
          </math>などのどれかだと言えただろう。あるいは、コエンドが単なる集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ a\ a</annotation>
            </semantics>
          </math>になるような<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>が存在すると言えただろう。エンドの定義で使った全称量化子は、コエンドでは存在量化子
          (existential quantifier) になる。</p>
        <p>このため、擬似Haskellでは、コエンドを次のように定義する:</p>
        <div class="sourceCode" id="cb574">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb574-1"><a href="#cb574-1" aria-hidden="true" tabindex="-1"></a>exists a<span class="op">.</span> p a a</span></code></pre>
        </div>
        <p>Haskellで存在量化子を実装する標準的な方法では、全称量化されたデータコンストラクターを用いる。したがって、次のように定義できる:</p>
        <div class="sourceCode" id="cb575">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb575-1"><a href="#cb575-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Coend</span> p <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Coend</span> (p a a)</span></code></pre>
        </div>
        <p>この背後にあるロジックは、型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ a\ a</annotation>
            </semantics>
          </math>の族のうち任意の型の値を使うなら、どのような<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を選択してもコエンドを構築できるというものだ。</p>
        <p>エンドがイコライザを使って定義できるのと同様に、コエンドは<span id="coequalizer" class="keyword">コイコライザ</span> (coequalizer)
          を使って記述できる。すべての余くさび条件は、要約すると、可能なすべての関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>b</mi>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">b \to a</annotation>
            </semantics>
          </math>に対して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ a\ b</annotation>
            </semantics>
          </math>の単一の巨大な余積を取ることだ。これはHaskellでは存在型
          (existential type) として表現される:</p>
        <div class="sourceCode" id="cb576">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb576-1"><a href="#cb576-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SumP</span> p <span class="ot">=</span> <span class="kw">forall</span> a b<span class="op">.</span> <span class="dt">SumP</span> (b <span class="ot">-&gt;</span> a) (p a b)</span></code></pre>
        </div>
        <p>この直和型を評価する方法は2つある。<code>dimap</code>を使って関数をリフトする方法と、プロ関手<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>に適用する方法だ:</p>
        <div class="sourceCode" id="cb577">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb577-1"><a href="#cb577-1" aria-hidden="true" tabindex="-1"></a>lambda,<span class="ot"> rho ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> <span class="dt">SumP</span> p <span class="ot">-&gt;</span> <span class="dt">DiagSum</span> p</span>
<span id="cb577-2"><a href="#cb577-2" aria-hidden="true" tabindex="-1"></a>lambda (<span class="dt">SumP</span> f pab) <span class="ot">=</span> <span class="dt">DiagSum</span> (dimap f <span class="fu">id</span> pab)</span>
<span id="cb577-3"><a href="#cb577-3" aria-hidden="true" tabindex="-1"></a>rho    (<span class="dt">SumP</span> f pab) <span class="ot">=</span> <span class="dt">DiagSum</span> (dimap <span class="fu">id</span> f pab)</span></code></pre>
        </div>
        <p>ここで、<code>DiagSum</code>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>の対角要素の和だ:</p>
        <div class="sourceCode" id="cb578">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb578-1"><a href="#cb578-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DiagSum</span> p <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">DiagSum</span> (p a a)</span></code></pre>
        </div>
        <p>
          これら2つの関数のコイコライザはコエンドだ。コイコライザを<code>DiagSum p</code>から得るには、<code>lambda</code>または<code>rho</code>を同じ引数に対して適用することで得られる値を同一視する。ここで、引数は関数<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>b</mi>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">b \to a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ a\ b</annotation>
            </semantics>
          </math>の要素のペアだ。<code>lambda</code>と<code>rho</code>を適用すると、潜在的に異なる2つの値が生成され、それらの型は<code>DiagSum p</code>だ。コエンドでは、これらの2つの値が同一視され、余くさび条件が自動的に満たされる。
        </p>
        <p>集合内の関連する要素を同一視するこのプロセスは形式的に、商を取る、と呼ばれる。商を定義するには<span id="equivalence_relation" class="keyword">同値関係</span>
          (equivalence
          relation)
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mo>∼</mo>
              <annotation encoding="application/x-tex">\sim</annotation>
            </semantics>
          </math>が必要だ。同値関係は反射律・対称律・推移律を満たす:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right"></mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mi>a</mi>
                    <mo>∼</mo>
                    <mi>a</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right"></mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mtext mathvariant="normal">if</mtext>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                    <mo>∼</mo>
                    <mi>b</mi>
                    <mspace width="0.222em"></mspace>
                    <mtext mathvariant="normal">then</mtext>
                    <mspace width="0.222em"></mspace>
                    <mi>b</mi>
                    <mo>∼</mo>
                    <mi>a</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right"></mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mtext mathvariant="normal">if</mtext>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                    <mo>∼</mo>
                    <mi>b</mi>
                    <mspace width="0.222em"></mspace>
                    <mtext mathvariant="normal">and</mtext>
                    <mspace width="0.222em"></mspace>
                    <mi>b</mi>
                    <mo>∼</mo>
                    <mi>c</mi>
                    <mspace width="0.222em"></mspace>
                    <mtext mathvariant="normal">then</mtext>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                    <mo>∼</mo>
                    <mi>c</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                &amp;a \sim a \\
                &amp;\text{if}\ a \sim b\ \text{then}\ b \sim a \\
                &amp;\text{if}\ a \sim b\ \text{and}\ b \sim c\ \text{then}\ a \sim c
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>このような関係は集合を同値クラスに分割する。各クラスは相互に関連する要素で構成される。商集合は各クラスから1人の代表を選んで作られる。古典的な例は、同値関係を持つ整数のペアとしての有理数の定義だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>∼</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>c</mi>
                  <mo>,</mo>
                  <mi>d</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mtext mathvariant="normal">iff</mtext>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>*</mo>
                <mi>d</mi>
                <mo>=</mo>
                <mi>b</mi>
                <mo>*</mo>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">(a, b) \sim (c, d)\ \text{iff}\ a * d = b * c</annotation>
            </semantics>
          </math></p>
        <p>これが同値関係なのは簡単に確認できる。ペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a, b)</annotation>
            </semantics>
          </math>
          は分数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mfrac>
                <mi>a</mi>
                <mi>b</mi>
              </mfrac>
              <annotation encoding="application/x-tex">\frac{a}{b}</annotation>
            </semantics>
          </math>として解釈され、分子と分母が公約数を持つものは同一視される。有理数はそのような分数の同値クラスだ。
        </p>
        <p>
          極限と余極限についての以前の議論から、hom関手は連続的であり、すなわち極限を保存することを思い出してほしい。双対性より、反変hom関手は余極限を極限に変える。これらの特性はエンドとコエンドに一般化でき、それぞれ極限と余極限を一般化したものだ。特に、コエンドをエンドに変換するのに非常に便利な恒等射が得られる:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msup>
                    <mo>∫</mo>
                    <mi>x</mi>
                  </msup>
                  <mi>p</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>x</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>x</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <msub>
                  <mo>∫</mo>
                  <mi>x</mi>
                </msub>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>p</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>x</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>x</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}(\int^x p\ x\ x, c) \cong \int_x \mathbf{Set}(p\ x\
                x, c)</annotation>
            </semantics>
          </math></p>
        <p>擬似Haskellで見てみよう:</p>
        <div class="sourceCode">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell">(exists x. p x x) -> c ≅ forall x. p x x -> c</code></pre>
        </div>
        <p>
          これは、存在型を取る関数は多相関数と等価だと示している。これは完全に理にかなっている。なぜなら、そのような関数は、存在型にエンコードされる可能性のある型ならどれでも処理できるようになっている必要があるからだ。これは、直和型を受け入れる関数についての、すべての型に対応したハンドラーのタプルを持ったcase式として実装される、という原則と同じだ。ここでは、直和型はコエンドに置き換えられ、ハンドラーの族はエンドすなわち多相関数になる。
        </p>
        <h2 data-number="26.6" id="忍者米田の補題"><span class="header-section-number">26.6</span> 忍者米田の補題</h2>
        <p>米田の補題に現れる自然変換の集合はエンドを使ってエンコードでき、結果として以下の定式化が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mo>∫</mo>
                  <mi>z</mi>
                </msub>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>z</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>z</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\int_z \mathbf{Set}(\mathbf{C}(a, z), F\ z) \cong F\ a
              </annotation>
            </semantics>
          </math></p>
        <p>双対として次の式も存在する:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mo>∫</mo>
                  <mi>z</mi>
                </msup>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>z</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>×</mo>
                <mrow></mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>z</mi>
                <mo>≅</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\int^z \mathbf{C}(z, a)\times{}F\ z \cong F\ a</annotation>
            </semantics>
          </math></p>
        <p>この恒等式はDiracのデルタ関数の式
          (関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>δ</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>−</mo>
                  <mi>z</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\delta(a - z)</annotation>
            </semantics>
          </math>、というより<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>=</mo>
                <mi>z</mi>
              </mrow>
              <annotation encoding="application/x-tex">a = z</annotation>
            </semantics>
          </math>に無限大のピークを持つ分布)
          を強く連想させる。ここでは、hom関手がデルタ関数の役目を果たしている。</p>
        <p>これら2つの恒等式を合わせて忍者米田の補題 (Ninja Yoneda lemma)
          と呼ぶことがある。</p>
        <p>2番目の式を証明するには米田埋め込みからの帰結を使う。その帰結によると、2つの対象が同型となるのは、それらのhom関手が同型である場合に限られる。言い換えると、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≅</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \cong b</annotation>
            </semantics>
          </math>となるのは、次の型の自然変換:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐂</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>b</mi>
                    <mo>,</mo>
                    <mo>=</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{Set}](\mathbf{C}(a, -), \mathbf{C}(b, =))
              </annotation>
            </semantics>
          </math></p>
        <p>があって同型射である場合だけだ。</p>
        <p>まず、証明したい同型の左辺を、任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>に向かうhom関手の内側に代入する:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msup>
                    <mo>∫</mo>
                    <mi>z</mi>
                  </msup>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>z</mi>
                    <mo>,</mo>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>z</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}(\int^z \mathbf{C}(z, a)\times{}F\ z, c)</annotation>
            </semantics>
          </math></p>
        <p>継続の引数を使うと、コエンドをエンドに置き換えられる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mo>∫</mo>
                  <mi>z</mi>
                </msub>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>z</mi>
                    <mo>,</mo>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>z</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\int_z \mathbf{Set}(\mathbf{C}(z, a)\times{}F\ z, c)</annotation>
            </semantics>
          </math></p>
        <p>これで積と冪乗の間の随伴を利用できるようになった:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mo>∫</mo>
                  <mi>z</mi>
                </msub>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐂</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>z</mi>
                    <mo>,</mo>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <msup>
                    <mi>c</mi>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>F</mi>
                      <mspace width="0.222em"></mspace>
                      <mi>z</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                  </msup>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\int_z \mathbf{Set}(\mathbf{C}(z, a), c^{(F\ z)})</annotation>
            </semantics>
          </math></p>
        <p>米田の補題を使って「積分を実行」し、次が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>c</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">c^{(F\ a)}</annotation>
            </semantics>
          </math></p>
        <p>(関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>c</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>z</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">c^{(F z)}</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>について反変なので、米田の補題の反変版を使っていることに注意してほしい。)</p>
        <p>この冪乗対象は次のhom集合について同型だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}(F\ a, c)</annotation>
            </semantics>
          </math></p>
        <p>最後に、米田埋め込みを利用して同型射に辿り着く:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mo>∫</mo>
                  <mi>z</mi>
                </msup>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>z</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>×</mo>
                <mrow></mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>z</mi>
                <mo>≅</mo>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\int^z \mathbf{C}(z, a)\times{}F\ z \cong F\ a</annotation>
            </semantics>
          </math></p>
        <h2 data-number="26.7" id="プロ関手の合成"><span class="header-section-number">26.7</span> プロ関手の合成</h2>
        <p>プロ関手が記述するのは関係――より正確には証明に関連する関係――だ、という考え方をさらに検討しよう。つまり、集合<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ a\ b</annotation>
            </semantics>
          </math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>に関連する証明の集合を表す。2つの関係<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>があるなら、それらを合成できる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>q</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
                <mspace width="0.222em"></mspace>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">q\ b\ c</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>c</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">p\ c\ a</annotation>
            </semantics>
          </math>が両方とも空でないような中間対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>が存在する場合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>p</mi>
              <annotation encoding="application/x-tex">p</annotation>
            </semantics>
          </math>の後に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>q</mi>
              <annotation encoding="application/x-tex">q</annotation>
            </semantics>
          </math>を合成したものを介して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>に関連していると言える。この新しい関係の証明はすべて、個々の関係の証明のペアだ。したがって、存在量化子はコエンドに対応し、2つの集合のカルテシアン積は「証明のペア」に対応する、という理解に基づいて、次の式を使ってプロ関手の合成を定義できる:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>q</mi>
                  <mo>∘</mo>
                  <mi>p</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
                <mo>=</mo>
                <msup>
                  <mo>∫</mo>
                  <mi>c</mi>
                </msup>
                <mi>p</mi>
                <mspace width="0.222em"></mspace>
                <mi>c</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>q</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
                <mspace width="0.222em"></mspace>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">(q \circ p)\ a\ b = \int^c p\ c\ a\times{}q\ b\ c</annotation>
            </semantics>
          </math></p>
        <p>Haskellの<code>Data.Profunctor.Composition</code>でのプロ関手は、名前をいくらか変更したうえで、こう定義されている:</p>
        <div class="sourceCode" id="cb579">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb579-1"><a href="#cb579-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Procompose</span> q p a b <span class="kw">where</span></span>
<span id="cb579-2"><a href="#cb579-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Procompose</span><span class="ot"> ::</span> q a c <span class="ot">-&gt;</span> p c b <span class="ot">-&gt;</span> <span class="dt">Procompose</span> q p a b</span></code></pre>
        </div>
        <p>これは一般化代数的データ型 (generalized algebraic data type)
          すなわちGADTの構文を使っており、自由型変数 (ここでは<code>c</code>)
          が自動的に存在量化される。したがって、(非カリー化された)
          データ・コンストラクター<code>Procompose</code>は次と等価だ:</p>
        <div class="sourceCode" id="cb580">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb580-1"><a href="#cb580-1" aria-hidden="true" tabindex="-1"></a>exists c<span class="op">.</span> (q a c, p c b)</span></code></pre>
        </div>
        <p>
          こうして定義された合成の単位はhom関手だ――これは忍者米田の補題からすぐに導出される。したがって、プロ関手が射の役目を果たす圏があるかを問うのは理にかなっている。ある、というのがその問いの答えだ。ただし、プロ関手の合成に関する結合則と恒等則は自然同型を除いてのみ満たされることに注意する必要がある。それらの結合則と恒等則が同型を除いて満たされる圏は、(<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏よりも一般化された名前で)
          双圏 (bicategory)
          と呼ばれる。すなわち、双圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐏</mi>
                <mi>𝐫</mi>
                <mi>𝐨</mi>
                <mi>𝐟</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Prof}</annotation>
            </semantics>
          </math>では、対象は圏であり、射はプロ関手であり、射同士の間の射
          (別名2-セル)
          は自然変換だ。実際には、さらに先に進むことができる。なぜなら、プロ関手以外にも圏間の射としての通常の関手があるからだ。2種類の射を持つ圏は二重圏
          (double category) と呼ばれる。</p>
        <p>プロ関手はHaskellのlensライブラリとarrowライブラリで重要な役目を果たしている。</p>
        <h1 data-number="27" id="kan拡張"><span class="header-section-number">27</span> Kan拡張</h1>
        <p>ここまでは、主に1つの圏または1対の圏を扱ってきた。しかし、それでは制約が強すぎる場合もある。</p>
        <p>たとえば、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>で極限を定義するとき、添字圏
          (index category)
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>を導入し、錐の基礎となるパターンのテンプレートとした。錐の頂点のテンプレートとしては、別の自明な圏を導入した方が理にかなっていただろう。それなのに、代わりに<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>への定関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>を使った。
        </p>
        <p>この不自然さを正す時が来た。極限を3つの圏を使って定義しよう。初めに、添字圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>について考える。これは錐の底面を指す関手――図式関手
          (diagram functor) だ。</p>
        <p><img src="images/kan2.jpg" style="width:40.0%" /></p>
        <p>新しく追加された圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟏</mn>
              <annotation encoding="application/x-tex">\mathbf{1}</annotation>
            </semantics>
          </math>は、1つの対象
          (および1つの恒等射)
          を含む。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>からこの圏への関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>だけしかない。対象はすべて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟏</mn>
              <annotation encoding="application/x-tex">\mathbf{1}</annotation>
            </semantics>
          </math>内の唯一の対象に写され、射はすべて恒等射に写される。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟏</mn>
              <annotation encoding="application/x-tex">\mathbf{1}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>はどれも、この錐の潜在的な頂点を指す。</p>
        <p><img src="images/kan15.jpg" style="width:40.0%" /></p>
        <p>錐は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∘</mo>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">F \circ K</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>への自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∘</mo>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">F \circ K</annotation>
            </semantics>
          </math>はもとの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>Δ</mi>
                <mi>c</mi>
              </msub>
              <annotation encoding="application/x-tex">\Delta_c</annotation>
            </semantics>
          </math>とまったく同じことを行う。次の図式はこの変換を示している。</p>
        <p><img src="images/kan3-e1492120491591.jpg" style="width:40.0%" /></p>
        <p>ここで、そのような関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>のうち「最高」のものを選択するような普遍性を定義できる。この<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟏</mn>
              <annotation encoding="application/x-tex">\mathbf{1}</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>の極限である対象に写し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∘</mo>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">F \circ K</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>への自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>がそれに対応する射影を提供する。この普遍関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>に沿った<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>の右Kan拡張
          (right Kan extension)
          と呼ばれ、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Ran}_{K}D</annotation>
            </semantics>
          </math>で表される。</p>
        <p>普遍性を定式化しよう。錐がもう1つあるとする――別の関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">F&#39;</annotation>
            </semantics>
          </math>と、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>′</mi>
                <mo>∘</mo>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">F&#39; \circ K</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>への自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>ε</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon&#39;</annotation>
            </semantics>
          </math>から構成された錐だ。</p>
        <p><img src="images/kan31-e1492120512209.jpg" style="width:40.0%" /></p>
        <p>Kan拡張<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>=</mo>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">F = \mathbf{Ran}_{K}D</annotation>
            </semantics>
          </math>が存在するなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">F&#39;</annotation>
            </semantics>
          </math>からそれへの一意な自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>σ</mi>
              <annotation encoding="application/x-tex">\sigma</annotation>
            </semantics>
          </math>が必ず存在し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>ε</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon&#39;</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>を通じて次のように分解される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>ε</mi>
                <mi>′</mi>
                <mo>=</mo>
                <mi>ε</mi>
                <mspace width="0.222em"></mspace>
                <mi>.</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>σ</mi>
                  <mo>∘</mo>
                  <mi>K</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon&#39; = \varepsilon\ .\ (\sigma \circ K)</annotation>
            </semantics>
          </math></p>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>σ</mi>
                <mo>∘</mo>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">\sigma \circ K</annotation>
            </semantics>
          </math>は2つの自然変換の水平合成だ
          (片方は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>における恒等自然変換だ)。この変換は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>によって垂直合成される。</p>
        <p><img src="images/kan5.jpg" style="width:40.0%" /></p>
        <p>コンポーネントとしては、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>i</mi>
              <annotation encoding="application/x-tex">i</annotation>
            </semantics>
          </math>に作用するとき、次が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>ε</mi>
                <msub>
                  <mi>′</mi>
                  <mi>i</mi>
                </msub>
                <mo>=</mo>
                <msub>
                  <mi>ε</mi>
                  <mi>i</mi>
                </msub>
                <mo>∘</mo>
                <msub>
                  <mi>σ</mi>
                  <mrow>
                    <mi>K</mi>
                    <mi>i</mi>
                  </mrow>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon&#39;_i = \varepsilon_i \circ \sigma_{K i}
              </annotation>
            </semantics>
          </math></p>
        <p>この例において、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟏</mn>
              <annotation encoding="application/x-tex">\mathbf{1}</annotation>
            </semantics>
          </math>の単一の対象に対応する<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>σ</mi>
              <annotation encoding="application/x-tex">\sigma</annotation>
            </semantics>
          </math>のコンポーネントは1つしかない。したがって、これは実際に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">F&#39;</annotation>
            </semantics>
          </math>が定義する錐の頂点から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Ran}_{K}D</annotation>
            </semantics>
          </math>が定義する普遍錐の頂点へ向かう一意な射だ。その可換条件はまさに極限の定義で求められているものだ。</p>
        <p>しかし、重要なのは、自明圏 (trivial category)
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟏</mn>
              <annotation encoding="application/x-tex">\mathbf{1}</annotation>
            </semantics>
          </math>を任意の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐀</mi>
              <annotation encoding="application/x-tex">\mathbf{A}</annotation>
            </semantics>
          </math>に自由に置き換えてよく、右Kan拡張の定義は有効なままだということだ。
        </p>
        <h2 data-number="27.1" id="右kan拡張"><span class="header-section-number">27.1</span> 右Kan拡張</h2>
        <p>関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>K</mi>
                <mo>∷</mo>
                <mi>𝐈</mi>
                <mo>→</mo>
                <mi>𝐀</mi>
              </mrow>
              <annotation encoding="application/x-tex">K \Colon \mathbf{I} \to \mathbf{A}</annotation>
            </semantics>
          </math>に沿った関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>D</mi>
                <mo>∷</mo>
                <mi>𝐈</mi>
                <mo>→</mo>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">D \Colon \mathbf{I} \to \mathbf{C}</annotation>
            </semantics>
          </math>の右Kan拡張は関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∷</mo>
                <mi>𝐀</mi>
                <mo>→</mo>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">F \Colon \mathbf{A} \to \mathbf{C}</annotation>
            </semantics>
          </math>であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Ran}_{K}D</annotation>
            </semantics>
          </math>と表記され、自然変換</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>ε</mi>
                <mo>∷</mo>
                <mi>F</mi>
                <mo>∘</mo>
                <mi>K</mi>
                <mo>→</mo>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon \Colon F \circ K \to D</annotation>
            </semantics>
          </math></p>
        <p>を伴い、他のすべての関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>′</mi>
                <mo>∷</mo>
                <mi>𝐀</mi>
                <mo>→</mo>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">F&#39; \Colon \mathbf{A} \to \mathbf{C}</annotation>
            </semantics>
          </math>と自然変換</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>ε</mi>
                <mi>′</mi>
                <mo>∷</mo>
                <mi>F</mi>
                <mi>′</mi>
                <mo>∘</mo>
                <mi>K</mi>
                <mo>→</mo>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon&#39; \Colon F&#39; \circ K \to D</annotation>
            </semantics>
          </math></p>
        <p>について、一意な自然変換</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>σ</mi>
                <mo>∷</mo>
                <mi>F</mi>
                <mi>′</mi>
                <mo>→</mo>
                <mi>F</mi>
              </mrow>
              <annotation encoding="application/x-tex">\sigma \Colon F&#39; \to F</annotation>
            </semantics>
          </math></p>
        <p>が存在し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>ε</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon&#39;</annotation>
            </semantics>
          </math>を分解する:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>ε</mi>
                <mi>′</mi>
                <mo>=</mo>
                <mi>ε</mi>
                <mspace width="0.222em"></mspace>
                <mi>.</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>σ</mi>
                  <mo>∘</mo>
                  <mi>K</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon&#39; = \varepsilon\ .\ (\sigma \circ K)</annotation>
            </semantics>
          </math></p>
        <p>これはかなり長ったらしいが、図式ならすっきりと描ける:</p>
        <p><img src="images/kan7.jpg" style="width:40.0%" /></p>
        <p>この図式はあることに気付くと興味深く見えてくる。それはKan拡張が、ある意味で「関手の積」の逆のように作用していることだ。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Ran}_{K}D</annotation>
            </semantics>
          </math>に対して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>D</mi>
                <mi>/</mi>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">D/K</annotation>
            </semantics>
          </math>という表記を使う著者さえいる。実際、その表記なら、右Kan拡張の余単位とも呼ばれる<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>の定義は単純な簡約のように見える:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>ε</mi>
                <mo>∷</mo>
                <mi>D</mi>
                <mi>/</mi>
                <mi>K</mi>
                <mo>∘</mo>
                <mi>K</mi>
                <mo>→</mo>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon \Colon D/K \circ K \to D</annotation>
            </semantics>
          </math></p>
        <p>Kan拡張には別の解釈もある。関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>が圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐀</mi>
              <annotation encoding="application/x-tex">\mathbf{A}</annotation>
            </semantics>
          </math>の中に埋め込むとする。最も単純なケースでは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>は単に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐀</mi>
              <annotation encoding="application/x-tex">\mathbf{A}</annotation>
            </semantics>
          </math>の部分圏になる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>に写す関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐀</mi>
              <annotation encoding="application/x-tex">\mathbf{A}</annotation>
            </semantics>
          </math>全体で定義された関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>に拡張できるだろうか？
          理想的には、そのような拡張によって合成<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∘</mo>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">F \circ K</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>と同型になる。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>の始域を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐀</mi>
              <annotation encoding="application/x-tex">\mathbf{A}</annotation>
            </semantics>
          </math>に拡張する。しかし、本格的な同型射は通常は求めすぎで、その半分で十分だ。つまり、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∘</mo>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">F \circ K</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>への片道の自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>ε</mi>
              <annotation encoding="application/x-tex">\varepsilon</annotation>
            </semantics>
          </math>だけでよい。(逆方向は左Kan拡張が指す。)</p>
        <p><img src="images/kan6.jpg" style="width:40.0%" /></p>
        <p>当然、この埋め込みの描像は、極限のような例では破綻する。関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>が対象の単射ではなく、すなわちhom集合の忠実関手ではないからだ。その場合、Kan拡張は失われた情報を推定するために最善を尽くす。</p>
        <h2 data-number="27.2" id="随伴としてのkan拡張"><span class="header-section-number">27.2</span> 随伴としてのKan拡張</h2>
        <p>さて、右Kan拡張が任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>
          (および決まった<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>)
          に対して存在するとしよう。この場合、(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>をダッシュで置き換えた)
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <mo>−</mo>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Ran}_{K}-</annotation>
            </semantics>
          </math>は関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <mi>𝐈</mi>
                <mo>,</mo>
                <mi>𝐂</mi>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}\mathbf{I}, \mathbf{C}{]}</annotation>
            </semantics>
          </math>から関手圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <mi>𝐀</mi>
                <mo>,</mo>
                <mi>𝐂</mi>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}\mathbf{A}, \mathbf{C}{]}</annotation>
            </semantics>
          </math>への関手だ。この関手は前置合成関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo>−</mo>
                <mo>∘</mo>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">- \circ K</annotation>
            </semantics>
          </math>に対する右随伴であることが分かる。この前置合成関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <mi>𝐀</mi>
                <mo>,</mo>
                <mi>𝐂</mi>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}\mathbf{A}, \mathbf{C}{]}</annotation>
            </semantics>
          </math>内の関手を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <mi>𝐈</mi>
                <mo>,</mo>
                <mi>𝐂</mi>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}\mathbf{I}, \mathbf{C}{]}</annotation>
            </semantics>
          </math>内の関手に写す。随伴は次のとおりだ:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐈</mi>
                  <mo>,</mo>
                  <mi>𝐂</mi>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mo>∘</mo>
                  <mi>K</mi>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐀</mi>
                  <mo>,</mo>
                  <mi>𝐂</mi>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <msub>
                    <mrow>
                      <mi>𝐑</mi>
                      <mi>𝐚</mi>
                      <mi>𝐧</mi>
                    </mrow>
                    <mi>K</mi>
                  </msub>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{I}, \mathbf{C}](F&#39; \circ K, D) \cong [\mathbf{A},
                \mathbf{C}](F&#39;, \mathbf{Ran}_{K}D)</annotation>
            </semantics>
          </math></p>
        <p>これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>ε</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon&#39;</annotation>
            </semantics>
          </math>と呼んでいたすべての自然変換が、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>σ</mi>
              <annotation encoding="application/x-tex">\sigma</annotation>
            </semantics>
          </math>と呼んでいた一意な自然変換に対応しているという事実を言い換えたものだ。</p>
        <p><img src="images/kan92.jpg" style="width:40.0%" /></p>
        <p>さらに、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と同じになるように選んだ場合は、恒等関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>I</mi>
                <mi>𝐂</mi>
              </msub>
              <annotation encoding="application/x-tex">I_{\mathbf{C}}</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>に置き換えられる。すると、次の恒等式が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐂</mi>
                  <mo>,</mo>
                  <mi>𝐂</mi>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mo>∘</mo>
                  <mi>K</mi>
                  <mo>,</mo>
                  <msub>
                    <mi>I</mi>
                    <mi>𝐂</mi>
                  </msub>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐀</mi>
                  <mo>,</mo>
                  <mi>𝐂</mi>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <msub>
                    <mrow>
                      <mi>𝐑</mi>
                      <mi>𝐚</mi>
                      <mi>𝐧</mi>
                    </mrow>
                    <mi>K</mi>
                  </msub>
                  <msub>
                    <mi>I</mi>
                    <mi>𝐂</mi>
                  </msub>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{C}, \mathbf{C}](F&#39; \circ K, I_{\mathbf{C}}) \cong
                [\mathbf{A}, \mathbf{C}](F&#39;, \mathbf{Ran}_{K}I_{\mathbf{C}})</annotation>
            </semantics>
          </math></p>
        <p>これで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <msub>
                  <mi>I</mi>
                  <mi>𝐂</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Ran}_{K}I_{\mathbf{C}}</annotation>
            </semantics>
          </math>と同じになるような<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">F&#39;</annotation>
            </semantics>
          </math>を選択できる。その場合、右辺は恒等自然変換を含み、それに対応して、左辺から次の自然変換が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>ε</mi>
                <mo>∷</mo>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <msub>
                  <mi>I</mi>
                  <mi>𝐂</mi>
                </msub>
                <mo>∘</mo>
                <mi>K</mi>
                <mo>→</mo>
                <msub>
                  <mi>I</mi>
                  <mi>𝐂</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon \Colon \mathbf{Ran}_{K}I_{\mathbf{C}} \circ K \to
                I_{\mathbf{C}}</annotation>
            </semantics>
          </math></p>
        <p>これは随伴の余単位によく似ている:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <msub>
                  <mi>I</mi>
                  <mi>𝐂</mi>
                </msub>
                <mo>⊣</mo>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Ran}_{K}I_{\mathbf{C}} \dashv K</annotation>
            </semantics>
          </math></p>
        <p>実際、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>に沿った恒等関手の右Kan拡張を使って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>の左随伴を計算できる。そのためには、もう1つの条件が必要だ:
          右Kan拡張は関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>によって保存されなければならない。このKan拡張の保存が意味するのは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>を前置合成した関手のKan拡張を計算すると、もとのKan拡張に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>を前置合成したのと同じ結果が得られるということだ。ここでは、この条件は次のように単純化される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>K</mi>
                <mo>∘</mo>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <msub>
                  <mi>I</mi>
                  <mi>𝐂</mi>
                </msub>
                <mo>≅</mo>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">K \circ \mathbf{Ran}_{K}I_{\mathbf{C}} \cong \mathbf{Ran}_{K}K
              </annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>による除算で表記すると、前述の随伴は次のように記述できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>I</mi>
                <mi>/</mi>
                <mi>K</mi>
                <mo>⊣</mo>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">I/K \dashv K</annotation>
            </semantics>
          </math></p>
        <p>これは随伴がある種の逆を表しているという直観を裏付ける。また、保存の条件は次のようになる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>K</mi>
                <mo>∘</mo>
                <mi>I</mi>
                <mi>/</mi>
                <mi>K</mi>
                <mo>≅</mo>
                <mi>K</mi>
                <mi>/</mi>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">K \circ I/K \cong K/K</annotation>
            </semantics>
          </math></p>
        <p>ある関手自身に沿った右Kan拡張<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>K</mi>
                <mi>/</mi>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">K/K</annotation>
            </semantics>
          </math>は余稠密性モナド
          (codensity monad) と呼ばれる。</p>
        <p>随伴の式は重要な結果だ。なぜなら、これからすぐ見るように、エンド
          (コエンド) を使ってKan拡張を計算でき、したがって、右 (左)
          随伴を見出す実用的な手段が得られるからだ。</p>
        <h2 data-number="27.3" id="左kan拡張"><span class="header-section-number">27.3</span> 左Kan拡張</h2>
        <p>左Kan拡張を与えるような双対構成が存在する。直観を得るために、余極限の定義から始めて、単元圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟏</mn>
              <annotation encoding="application/x-tex">\mathbf{1}</annotation>
            </semantics>
          </math>を使うようにそれを再構築しよう。余錐を作るには、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>D</mi>
                <mo>∷</mo>
                <mi>𝐈</mi>
                <mo>→</mo>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">D \Colon \mathbf{I} \to \mathbf{C}</annotation>
            </semantics>
          </math>を使って底面を形成し、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∷</mo>
                <mn>𝟏</mn>
                <mo>→</mo>
                <mi>𝐂</mi>
              </mrow>
              <annotation encoding="application/x-tex">F \Colon \mathbf{1} \to \mathbf{C}</annotation>
            </semantics>
          </math>を使って頂点を選択する。</p>
        <p><img src="images/kan81.jpg" style="width:40.0%" /></p>
        <p>余錐の側面である単射は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∘</mo>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">F \circ K</annotation>
            </semantics>
          </math>への自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>のコンポーネントだ。</p>
        <p><img src="images/kan10a.jpg" style="width:40.0%" /></p>
        <p>余極限は普遍余錐だ。したがって、他のすべての関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">F&#39;</annotation>
            </semantics>
          </math>と自然変換</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>η</mi>
                <mi>′</mi>
                <mo>∷</mo>
                <mi>D</mi>
                <mo>→</mo>
                <mi>F</mi>
                <mi>′</mi>
                <mo>∘</mo>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">\eta&#39; \Colon D \to F&#39; \circ K</annotation>
            </semantics>
          </math></p>
        <p><img src="images/kan10b.jpg" style="width:40.0%" /></p>
        <p>について、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">F&#39;</annotation>
            </semantics>
          </math>への一意な自然変換<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>σ</mi>
              <annotation encoding="application/x-tex">\sigma</annotation>
            </semantics>
          </math></p>
        <p><img src="images/kan14.jpg" style="width:40.0%" /></p>
        <p>が存在する。ただし:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>η</mi>
                <mi>′</mi>
                <mo>=</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>σ</mi>
                  <mo>∘</mo>
                  <mi>K</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mi>.</mi>
                <mspace width="0.222em"></mspace>
                <mi>η</mi>
              </mrow>
              <annotation encoding="application/x-tex">\eta&#39; = (\sigma \circ K)\ .\ \eta</annotation>
            </semantics>
          </math></p>
        <p>これは次の図式で表される:</p>
        <p><img src="images/kan112.jpg" style="width:40.0%" /></p>
        <p>単元圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟏</mn>
              <annotation encoding="application/x-tex">\mathbf{1}</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐀</mi>
              <annotation encoding="application/x-tex">\mathbf{A}</annotation>
            </semantics>
          </math>に置き換えると、この定義は左Kan拡張の定義へと自然に一般化される。左Kan拡張は<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <mi>D</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Lan}_{K}D</annotation>
            </semantics>
          </math>と表記される。</p>
        <p><img src="images/kan12.jpg" style="width:40.0%" /></p>
        <p>自然変換:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>η</mi>
                <mo>∷</mo>
                <mi>D</mi>
                <mo>→</mo>
                <msub>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <mi>D</mi>
                <mo>∘</mo>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">\eta \Colon D \to \mathbf{Lan}_{K}D \circ K</annotation>
            </semantics>
          </math></p>
        <p>は左Kan拡張の単位と呼ばれる。</p>
        <p>先ほどと同様に、自然変換の間の1対1の対応関係:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>η</mi>
                <mi>′</mi>
                <mo>=</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>σ</mi>
                  <mo>∘</mo>
                  <mi>K</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mi>.</mi>
                <mspace width="0.222em"></mspace>
                <mi>η</mi>
              </mrow>
              <annotation encoding="application/x-tex">\eta&#39; = (\sigma \circ K)\ .\ \eta</annotation>
            </semantics>
          </math></p>
        <p>を随伴によって作り直せる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐀</mi>
                  <mo>,</mo>
                  <mi>𝐂</mi>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mrow>
                      <mi>𝐋</mi>
                      <mi>𝐚</mi>
                      <mi>𝐧</mi>
                    </mrow>
                    <mi>K</mi>
                  </msub>
                  <mi>D</mi>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐈</mi>
                  <mo>,</mo>
                  <mi>𝐂</mi>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>D</mi>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mo>∘</mo>
                  <mi>K</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{A}, \mathbf{C}](\mathbf{Lan}_{K}D, F&#39;) \cong
                [\mathbf{I}, \mathbf{C}](D, F&#39; \circ K)</annotation>
            </semantics>
          </math></p>
        <p>つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>の前置合成について、左Kan拡張は左随伴で、右Kan拡張は右随伴だ。</p>
        <p>恒等関手の右Kan拡張が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>の左随伴を計算するのに使われるように、恒等関手の左Kan拡張は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>の右随伴だと分かる
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>は随伴の単位だとする):</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>K</mi>
                <mo>⊣</mo>
                <msub>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <msub>
                  <mi>I</mi>
                  <mi>𝐂</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">K \dashv \mathbf{Lan}_{K}I_{\mathbf{C}}</annotation>
            </semantics>
          </math></p>
        <p>2つの結果を組み合わせると、次が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <msub>
                  <mi>I</mi>
                  <mi>𝐂</mi>
                </msub>
                <mo>⊣</mo>
                <mi>K</mi>
                <mo>⊣</mo>
                <msub>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <msub>
                  <mi>I</mi>
                  <mi>𝐂</mi>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Ran}_{K}I_{\mathbf{C}} \dashv K \dashv
                \mathbf{Lan}_{K}I_{\mathbf{C}}</annotation>
            </semantics>
          </math></p>
        <h2 data-number="27.4" id="エンドとしてのkan拡張"><span class="header-section-number">27.4</span> エンドとしてのKan拡張</h2>
        <p>Kan拡張の真の力は、エンド (およびコエンド)
          を使って計算できるという事実に由来する。簡単のため終域圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>である場合に注目するが、どの式も任意の圏に拡張できる。</p>
        <p>Kan拡張を使えば関手の作用をもとの始域の外側に拡張できる、という考え方を再検討してみよう。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐀</mi>
              <annotation encoding="application/x-tex">\mathbf{A}</annotation>
            </semantics>
          </math>の中に埋め込むとする。関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>D</mi>
              <annotation encoding="application/x-tex">D</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐈</mi>
              <annotation encoding="application/x-tex">\mathbf{I}</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>に写す。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>の像内の任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>、すなわち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>=</mo>
                <mi>K</mi>
                <mspace width="0.222em"></mspace>
                <mi>i</mi>
              </mrow>
              <annotation encoding="application/x-tex">a = K\ i</annotation>
            </semantics>
          </math>に対し、拡張された関手は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>D</mi>
                <mspace width="0.222em"></mspace>
                <mi>i</mi>
              </mrow>
              <annotation encoding="application/x-tex">D\ i</annotation>
            </semantics>
          </math>に写す。問題は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>の像の外側にある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐀</mi>
              <annotation encoding="application/x-tex">\mathbf{A}</annotation>
            </semantics>
          </math>内の対象をどうするかだ。考え方は、そのような対象はどれも、たくさんの射を通じて<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>の像内のすべての対象と潜在的に繋がっている、というものだ。関手はそれらの射を保存しなければならない。対象<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>K</mi>
              <annotation encoding="application/x-tex">K</annotation>
            </semantics>
          </math>の像への射の全体は次のhom関手によって特徴づけられる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐀</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>K</mi>
                  <mspace width="0.222em"></mspace>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{A}(a, K\ -)</annotation>
            </semantics>
          </math></p>
        <p><img src="images/kan13.jpg" style="width:40.0%" /></p>
        <p>このhom関手は2つの関手の合成であることに注意してほしい:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐀</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>K</mi>
                  <mspace width="0.222em"></mspace>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>=</mo>
                <mi>𝐀</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>∘</mo>
                <mi>K</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{A}(a, K\ -) = \mathbf{A}(a, -) \circ K</annotation>
            </semantics>
          </math></p>
        <p>右Kan拡張は関手合成の右随伴だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐈</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mo>∘</mo>
                  <mi>K</mi>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐀</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mo>,</mo>
                  <msub>
                    <mrow>
                      <mi>𝐑</mi>
                      <mi>𝐚</mi>
                      <mi>𝐧</mi>
                    </mrow>
                    <mi>K</mi>
                  </msub>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{I}, \mathbf{Set}](F&#39; \circ K, D) \cong [\mathbf{A},
                \mathbf{Set}](F&#39;, \mathbf{Ran}_{K}D)</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">F&#39;</annotation>
            </semantics>
          </math>をhom関手に置き換えるとどうなるか見てみよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐈</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐀</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>∘</mo>
                  <mi>K</mi>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐀</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐀</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <msub>
                    <mrow>
                      <mi>𝐑</mi>
                      <mi>𝐚</mi>
                      <mi>𝐧</mi>
                    </mrow>
                    <mi>K</mi>
                  </msub>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{I}, \mathbf{Set}](\mathbf{A}(a, -) \circ K, D) \cong
                [\mathbf{A}, \mathbf{Set}](\mathbf{A}(a, -), \mathbf{Ran}_{K}D)</annotation>
            </semantics>
          </math></p>
        <p>そして、先ほどの合成で表すとこうなる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐈</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐀</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>K</mi>
                    <mspace width="0.222em"></mspace>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐀</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐀</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <msub>
                    <mrow>
                      <mi>𝐑</mi>
                      <mi>𝐚</mi>
                      <mi>𝐧</mi>
                    </mrow>
                    <mi>K</mi>
                  </msub>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{I}, \mathbf{Set}](\mathbf{A}(a, K\ -), D) \cong
                [\mathbf{A}, \mathbf{Set}](\mathbf{A}(a, -), \mathbf{Ran}_{K}D)</annotation>
            </semantics>
          </math></p>
        <p>右辺は米田の補題を使って簡潔にできる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐈</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐀</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>K</mi>
                    <mspace width="0.222em"></mspace>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <mi>D</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{I}, \mathbf{Set}](\mathbf{A}(a, K\ -), D) \cong
                \mathbf{Ran}_{K}D\ a</annotation>
            </semantics>
          </math></p>
        <p>ここで、自然変換の集合をエンドに書き直すと、右Kan拡張に対する非常に便利な式が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <mi>D</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>≅</mo>
                <msub>
                  <mo>∫</mo>
                  <mi>i</mi>
                </msub>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐀</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>K</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>i</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>i</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Ran}_{K}D\ a \cong \int_i \mathbf{Set}(\mathbf{A}(a, K\
                i), D\ i)</annotation>
            </semantics>
          </math></p>
        <p>左Kan拡張に対しても、コエンドによって同様の式が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <mi>D</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>=</mo>
                <msup>
                  <mo>∫</mo>
                  <mi>i</mi>
                </msup>
                <mi>𝐀</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>K</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>×</mo>
                <mrow></mrow>
                <mi>D</mi>
                <mspace width="0.222em"></mspace>
                <mi>i</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Lan}_{K}D\ a = \int^i \mathbf{A}(K\ i, a)\times{}D\ i
              </annotation>
            </semantics>
          </math></p>
        <p>確認のため、これが実際に関手合成に対する左随伴であることを証明しよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐀</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mrow>
                      <mi>𝐋</mi>
                      <mi>𝐚</mi>
                      <mi>𝐧</mi>
                    </mrow>
                    <mi>K</mi>
                  </msub>
                  <mi>D</mi>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐈</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>D</mi>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mo>∘</mo>
                  <mi>K</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{A}, \mathbf{Set}](\mathbf{Lan}_{K}D, F&#39;) \cong
                [\mathbf{I}, \mathbf{Set}](D, F&#39; \circ K)</annotation>
            </semantics>
          </math></p>
        <p>左辺に前述の式を代入しよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐀</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msup>
                    <mo>∫</mo>
                    <mi>i</mi>
                  </msup>
                  <mi>𝐀</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>K</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>i</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>D</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{A}, \mathbf{Set}](\int^i \mathbf{A}(K\ i, -)\times{}D\
                i, F&#39;)</annotation>
            </semantics>
          </math></p>
        <p>これは自然変換の集合なので、エンドに書き直せる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mo>∫</mo>
                  <mi>a</mi>
                </msub>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msup>
                    <mo>∫</mo>
                    <mi>i</mi>
                  </msup>
                  <mi>𝐀</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>K</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>i</mi>
                    <mo>,</mo>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>D</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\int_a \mathbf{Set}(\int^i \mathbf{A}(K\ i, a)\times{}D\ i,
                F&#39;\ a)</annotation>
            </semantics>
          </math></p>
        <p>Hom関手の連続性を使って、コエンドをエンドに置き換えられる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mo>∫</mo>
                  <mi>a</mi>
                </msub>
                <msub>
                  <mo>∫</mo>
                  <mi>i</mi>
                </msub>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐀</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>K</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>i</mi>
                    <mo>,</mo>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>D</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\int_a \int_i \mathbf{Set}(\mathbf{A}(K\ i, a)\times{}D\ i,
                F&#39;\ a)</annotation>
            </semantics>
          </math></p>
        <p>積と冪乗についての随伴が使える:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mo>∫</mo>
                  <mi>a</mi>
                </msub>
                <msub>
                  <mo>∫</mo>
                  <mi>i</mi>
                </msub>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐀</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>K</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>i</mi>
                    <mo>,</mo>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mspace width="0.222em"></mspace>
                  <msup>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>F</mi>
                      <mi>′</mi>
                      <mspace width="0.222em"></mspace>
                      <mi>a</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                    <mrow>
                      <mi>D</mi>
                      <mspace width="0.222em"></mspace>
                      <mi>i</mi>
                    </mrow>
                  </msup>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\int_a \int_i \mathbf{Set}(\mathbf{A}(K\ i, a),\ (F&#39;\ a)^{D\
                i})</annotation>
            </semantics>
          </math></p>
        <p>この冪乗は、対応するhom集合と同型だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mo>∫</mo>
                  <mi>a</mi>
                </msub>
                <msub>
                  <mo>∫</mo>
                  <mi>i</mi>
                </msub>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐀</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>K</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>i</mi>
                    <mo>,</mo>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mspace width="0.222em"></mspace>
                  <mi>𝐀</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>D</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>i</mi>
                    <mo>,</mo>
                    <mi>F</mi>
                    <mi>′</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\int_a \int_i \mathbf{Set}(\mathbf{A}(K\ i, a),\ \mathbf{A}(D\ i,
                F&#39;\ a))</annotation>
            </semantics>
          </math></p>
        <p>Fubiniの定理と呼ばれる定理より、2つのエンドを交換してよい:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mo>∫</mo>
                  <mi>i</mi>
                </msub>
                <msub>
                  <mo>∫</mo>
                  <mi>a</mi>
                </msub>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐀</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>K</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>i</mi>
                    <mo>,</mo>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mspace width="0.222em"></mspace>
                  <mi>A</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>D</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>i</mi>
                    <mo>,</mo>
                    <mi>F</mi>
                    <mi>′</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\int_i \int_a \mathbf{Set}(\mathbf{A}(K\ i, a),\ A(D\ i, F&#39;\
                a))</annotation>
            </semantics>
          </math></p>
        <p>内側のエンドは2つの関手間の自然変換の集合を表しているので、米田の補題を使える:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mo>∫</mo>
                  <mi>i</mi>
                </msub>
                <mi>𝐀</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>D</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mspace width="0.222em"></mspace>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>K</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>i</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\int_i \mathbf{A}(D\ i, F&#39;\ (K\ i))</annotation>
            </semantics>
          </math></p>
        <p>この自然変換の集合はまさに、証明しようとしていた随伴の右辺を形成する:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐈</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>D</mi>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mi>′</mi>
                  <mo>∘</mo>
                  <mi>K</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{I}, \mathbf{Set}](D, F&#39; \circ K)</annotation>
            </semantics>
          </math></p>
        <p>このようなエンド・コエンド・米田の補題を使った計算は、エンドの「微積分」としてはごく典型的なものだ。</p>
        <h2 data-number="27.5" id="haskellでのkan拡張"><span class="header-section-number">27.5</span> HaskellでのKan拡張</h2>
        <p>Kan拡張のエンド・コエンドの式はHaskellに簡単に変換できる。右Kan拡張から始めよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐑</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <mi>D</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>≅</mo>
                <msub>
                  <mo>∫</mo>
                  <mi>i</mi>
                </msub>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐀</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>K</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>i</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>D</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>i</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Ran}_{K}D\ a \cong \int_i \mathbf{Set}(\mathbf{A}(a, K\
                i), D\ i)</annotation>
            </semantics>
          </math></p>
        <p>エンドを全称量化子に、hom集合を関数型に置き換える:</p>
        <div class="sourceCode" id="cb581">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb581-1"><a href="#cb581-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Ran</span> k d a <span class="ot">=</span> <span class="dt">Ran</span> (<span class="kw">forall</span> i<span class="op">.</span> (a <span class="ot">-&gt;</span> k i) <span class="ot">-&gt;</span> d i)</span></code></pre>
        </div>
        <p>
          この定義を見ると、<code>Ran</code>には、関数を適用できる型<code>a</code>の値と、2つの関手<code>k</code>と<code>d</code>の間の自然変換が含まれている必要があることは明らかだ。たとえば、<code>k</code>がtree関手、<code>d</code>がlist関手だとして、<code>Ran Tree [] String</code>が与えられたとする。これに関数:
        </p>
        <div class="sourceCode" id="cb582">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb582-1"><a href="#cb582-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span></span></code></pre>
        </div>
        <p>
          を渡すと<code>Int</code>のリストが返される、などだ。右Kan拡張はこの関数を使って木を生成し、再パッケージしてリストにする。たとえば、文字列から構文解析木を生成するパーサーを渡すと、その木の深さ優先トラバースに対応するリストが得られる。
        </p>
        <p>右Kan拡張は、関手<code>d</code>を恒等関手に置き換えれば、任意の関手の左随伴を計算するために使える。これにより、関手<code>k</code>の左随伴は、次の型の多相関数の集合で表される:</p>
        <div class="sourceCode" id="cb583">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb583-1"><a href="#cb583-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> i<span class="op">.</span> (a <span class="ot">-&gt;</span> k i) <span class="ot">-&gt;</span> i</span></code></pre>
        </div>
        <p><code>k</code>がモノイドの圏からの忘却関手だとしよう。すると、全称量化子はすべてのモノイドに及ぶ。もちろんHaskellではモノイダル則を表現できないが、以下は結果の自由関手の適切な近似になっている
          (忘却関手<code>k</code>は対象における恒等関手だ):</p>
        <div class="sourceCode" id="cb584">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb584-1"><a href="#cb584-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Lst</span> a <span class="ot">=</span> <span class="kw">forall</span> i<span class="op">.</span> <span class="dt">Monoid</span> i <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> i) <span class="ot">-&gt;</span> i</span></code></pre>
        </div>
        <p>期待どおり、自由モノイド、すなわちHaskellのリストが得られる:</p>
        <div class="sourceCode" id="cb585">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb585-1"><a href="#cb585-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toLst ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Lst</span> a</span>
<span id="cb585-2"><a href="#cb585-2" aria-hidden="true" tabindex="-1"></a>toLst as <span class="ot">=</span> \f <span class="ot">-&gt;</span> <span class="fu">foldMap</span> f as</span>
<span id="cb585-3"><a href="#cb585-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb585-4"><a href="#cb585-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fromLst ::</span> <span class="dt">Lst</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb585-5"><a href="#cb585-5" aria-hidden="true" tabindex="-1"></a>fromLst f <span class="ot">=</span> f (\a <span class="ot">-&gt;</span> [a])</span></code></pre>
        </div>
        <p>この左Kan拡張はコエンドだ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>K</mi>
                </msub>
                <mi>D</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>=</mo>
                <msup>
                  <mo>∫</mo>
                  <mi>i</mi>
                </msup>
                <mi>𝐀</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>K</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>×</mo>
                <mrow></mrow>
                <mi>D</mi>
                <mspace width="0.222em"></mspace>
                <mi>i</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Lan}_{K}D\ a = \int^i \mathbf{A}(K\ i, a)\times{}D\ i
              </annotation>
            </semantics>
          </math></p>
        <p>したがって、存在量化子へと翻訳される。記号的にはこうなる:</p>
        <div class="sourceCode" id="cb586">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb586-1"><a href="#cb586-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Lan</span> k d a <span class="ot">=</span> exists i<span class="op">.</span> (k i <span class="ot">-&gt;</span> a, d i)</span></code></pre>
        </div>
        <p>これはHaskellでは<em>GADT</em>、あるいは全称量化されたデータコンストラクターを使ってコード化できる:</p>
        <div class="sourceCode" id="cb587">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb587-1"><a href="#cb587-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Lan</span> k d a <span class="ot">=</span> <span class="kw">forall</span> i<span class="op">.</span> <span class="dt">Lan</span> (k i <span class="ot">-&gt;</span> a) (d i)</span></code></pre>
        </div>
        <p>
          このデータ構造を解釈すると、不特定の数の<code>i</code>を含むコンテナを取って<code>a</code>を1つ生成する関数を含むものだと言える。また、それらの<code>i</code>のコンテナも持つ。<code>i</code>が何かは分からないので、このデータ構造で唯一できるのは、<code>i</code>のコンテナを取得し、自然変換を使って関手<code>k</code>で定義されたコンテナに再パックし、関数を呼んで<code>a</code>を得ることだけだ。たとえば、<code>d</code>が木で<code>k</code>がリストの場合は、木を直列化して得られるリストで関数を呼べば<code>a</code>が得られる。
        </p>
        <p>左Kan拡張は関手の右随伴を計算するために使える。積関手の右随伴が冪乗なのは知っているので、Kan拡張を使って実装してみよう:</p>
        <div class="sourceCode" id="cb588">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb588-1"><a href="#cb588-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Exp</span> a b <span class="ot">=</span> <span class="dt">Lan</span> ((,) a) <span class="dt">I</span> b</span></code></pre>
        </div>
        <p>これが実際に関数型と同型であることは、次の関数のペアによって分かる:</p>
        <div class="sourceCode" id="cb589">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb589-1"><a href="#cb589-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toExp ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Exp</span> a b</span>
<span id="cb589-2"><a href="#cb589-2" aria-hidden="true" tabindex="-1"></a>toExp f <span class="ot">=</span> <span class="dt">Lan</span> (f <span class="op">.</span> <span class="fu">fst</span>) (<span class="dt">I</span> ())</span>
<span id="cb589-3"><a href="#cb589-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb589-4"><a href="#cb589-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fromExp ::</span> <span class="dt">Exp</span> a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)</span>
<span id="cb589-5"><a href="#cb589-5" aria-hidden="true" tabindex="-1"></a>fromExp (<span class="dt">Lan</span> f (<span class="dt">I</span> x)) <span class="ot">=</span> \a <span class="ot">-&gt;</span> f (a, x)</span></code></pre>
        </div>
        <p>すでに一般的な場合について説明したとおり、次のような段階を経ることに注意してほしい:</p>
        <ol type="1">
          <li>まず、<code>x</code>のコンテナ (ここでは単なる自明な恒等コンテナ)
            と関数<code>f</code>を取得した。</li>
          <li>次に、そのコンテナを、恒等関手と関手のペアとの間の自然変換を使って再パックした。</li>
          <li>最後に、関数<code>f</code>を呼んだ。</li>
        </ol>
        <h2 data-number="27.6" id="自由関手"><span class="header-section-number">27.6</span> 自由関手</h2>
        <p>Kan拡張の興味深い応用として自由関手 (free functor)
          の構成がある。これは以下のような実際的な問題の解となる:
          対象の写像である型コンストラクターがあるとする。その型コンストラクターをもとに関手を定義することは可能だろうか？
          言い換えると、その型コンストラクターを完全な自己関手へと拡張するような射の写像を定義できるだろうか？</p>
        <p>鍵となる観察は、型コンストラクターは離散圏を始域とする関手として表現できる、というものだ。離散圏の射は恒等射だけだ。圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>が与えられたとき、単に恒等射以外の射を捨て去れば、いつでも離散圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix" mathvariant="bold">|</mo>
                <mi>𝐂</mi>
                <mo stretchy="true" form="postfix" mathvariant="bold">|</mo>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{|C|}</annotation>
            </semantics>
          </math>を構成できる。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix" mathvariant="bold">|</mo>
                <mi>𝐂</mi>
                <mo stretchy="true" form="postfix" mathvariant="bold">|</mo>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{|C|}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>への関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>は、対象の単純な写像、すなわちHaskellで型コンストラクターと呼ばれるものになる。また、標準関手
          (canonical functor)
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>J</mi>
              <annotation encoding="application/x-tex">J</annotation>
            </semantics>
          </math>も存在し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix" mathvariant="bold">|</mo>
                <mi>𝐂</mi>
                <mo stretchy="true" form="postfix" mathvariant="bold">|</mo>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{|C|}</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内へ注入する:
          それは対象についての (および恒等射についての)
          恒等関手だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>J</mi>
              <annotation encoding="application/x-tex">J</annotation>
            </semantics>
          </math>に沿った左Kan拡張は、存在するなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>への関手だ:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi>𝐚</mi>
                    <mi>𝐧</mi>
                  </mrow>
                  <mi>J</mi>
                </msub>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>=</mo>
                <msup>
                  <mo>∫</mo>
                  <mi>i</mi>
                </msup>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>J</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>×</mo>
                <mrow></mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>i</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Lan}_{J}F\ a = \int^i \mathbf{C}(J\ i, a)\times{}F\ i
              </annotation>
            </semantics>
          </math></p>
        <p>これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>に基づく自由関手と呼ばれる。</p>
        <p>Haskellでは、次のように書ける:</p>
        <div class="sourceCode" id="cb590">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb590-1"><a href="#cb590-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FreeF</span> f a <span class="ot">=</span> <span class="kw">forall</span> i<span class="op">.</span> <span class="dt">FMap</span> (i <span class="ot">-&gt;</span> a) (f i)</span></code></pre>
        </div>
        <p>実際、すべての型コンストラクター<code>f</code>について<code>FreeF f</code>は関手となる:</p>
        <div class="sourceCode" id="cb591">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb591-1"><a href="#cb591-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">FreeF</span> f) <span class="kw">where</span></span>
<span id="cb591-2"><a href="#cb591-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> g (<span class="dt">FMap</span> h fi) <span class="ot">=</span> <span class="dt">FMap</span> (g <span class="op">.</span> h) fi</span></code></pre>
        </div>
        <p>ご覧のとおり、自由関手は、関数と引数の両方を記録することで関数のリフトを偽装する。それは、関数合成を記録することによって、リフトされた関数を累積する。関手則は自動的に満たされる。この構成は論文<a
            href="http://okmij.org/ftp/Haskell/extensible/more.pdf">Freer Monads,
            More Extensible Effects</a>で使われたものだ。</p>
        <p>別の方法として、右Kan拡張も同じ目的に使える:</p>
        <div class="sourceCode" id="cb592">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb592-1"><a href="#cb592-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">FreeF</span> f a <span class="ot">=</span> <span class="dt">FreeF</span> (<span class="kw">forall</span> i<span class="op">.</span> (a <span class="ot">-&gt;</span> i) <span class="ot">-&gt;</span> f i)</span></code></pre>
        </div>
        <p>これが実際に関手であることは簡単に確認できる:</p>
        <div class="sourceCode" id="cb593">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb593-1"><a href="#cb593-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">FreeF</span> f) <span class="kw">where</span></span>
<span id="cb593-2"><a href="#cb593-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> g (<span class="dt">FreeF</span> r) <span class="ot">=</span> <span class="dt">FreeF</span> (\bi <span class="ot">-&gt;</span> r (bi <span class="op">.</span> g))</span></code></pre>
        </div>
        <h1 data-number="28" id="豊穣圏"><span class="header-section-number">28</span> 豊穣圏</h1>
        <p>圏が<em>小さい</em>とは、対象が集合を形成することだ。しかし、集合より大きいものの存在も知られている。有名な話として、すべての集合の集合は、標準的な集合論
          (選択公理を含めて議論されることもあるツェルメロ＝フレンケル集合論)
          では形成できない。つまり、すべての集合の圏は大きいことになる。グロタンディーク宇宙
          (Grothendieck universe)
          などの数学的トリックがいくつかあって、集合を超える集まりを定義するのに使える。それらのトリックによって大きい圏について語れるようになる。</p>
        <p>
          任意の2つの対象間の射が集合を形成するような圏は、<em>局所的に小さい</em>、という。それらが集合を形成しないなら、定義のいくつかは再考する必要がある。特に、射を集合から選ぶことさえできない場合、射の合成とは何を意味するのだろう？
          解決策は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内の対象からなるhom集合を他の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>からの<em>対象</em>で置き換えることによって、ブートストラップすることだ。ただし、一般に、対象には要素がないため、個々の射については語れない点が異なる。<span id="enriched"
            class="keyword">豊穣</span>圏 (enriched category)
          のすべての特性を、hom対象に対して実行できる操作全体として定義する必要がある。そのためには、hom対象を提供する圏は、追加の構造を持たなければならない――モノイダル圏でなければならない。このモノイダルを圏<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>と呼ぶとき、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>上の豊穣圏だと言える。</p>
        <p>
          大きさの理由に加えて、hom集合をただの集合以上の構造があるものへと一般化することも興味深そうだ。たとえば、従来の圏には対象間の距離という概念はない。2つの対象は射によって接続されているかいないかのどちらかだ。ある対象に接続されているすべての対象は近傍
          (neighbors)
          と呼ばれる。現実の人生とは違って、圏においては、友人の友人の友人は、親友と同じくらい近しい。適切な豊穣圏では、対象間の距離を定義できる。</p>
        <p>豊穣圏について経験を積むべき極めて実用的な理由はもう1つある。それは、圏に関する知識の非常に有用なオンライン情報源である<a
            href="https://ncatlab.org/">nLab</a>が主に豊穣圏について書かれているからだ。</p>
        <h2 data-number="28.1" id="なぜモノイダル圏か"><span class="header-section-number">28.1</span> なぜモノイダル圏か？</h2>
        <p>豊穣圏を構築する際には、モノイダル圏を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>に置き換え、hom対象をhom集合に置き換えれば、通常の定義を復元できることに留意する必要がある。これを実現する一番良い方法は、通常の定義から始めて、ポイントフリーな方法で――つまり、集合の要素に名前を付けずに――再定式化を繰り返すことだ。
        </p>
        <p>まず、合成の定義から始めよう。通常は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(b, c)</annotation>
            </semantics>
          </math>
          からの射1つと<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          からの射1つからなる射のペアを取り、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, c)</annotation>
            </semantics>
          </math>
          からの射に写す。言い換えれば、次の写像だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(b, c)\times{}\mathbf{C}(a, b) \to \mathbf{C}(a, c)
              </annotation>
            </semantics>
          </math></p>
        <p>これは集合間の関数だ――片方は2つのhom集合のカルテシアン積だ。この式は、カルテシアン積をより一般的な何かに置き換えれば容易に一般化できる。圏論的な積でもよいが、さらに進んで、完全に一般的なテンソル積を使ってもよい。
        </p>
        <p>次は恒等射の番だ。個々の要素は、hom集合から選択する代わりに、単集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟏</mn>
              <annotation encoding="application/x-tex">\mathbf{1}</annotation>
            </semantics>
          </math>の関数を使って定義できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>j</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mn>𝟏</mn>
                <mo>→</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">j_a \Colon \mathbf{1} \to \mathbf{C}(a, a)</annotation>
            </semantics>
          </math></p>
        <p>ここでも単集合は終対象に置き換えられるが、さらに進んでテンソル積の単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>i</mi>
              <annotation encoding="application/x-tex">i</annotation>
            </semantics>
          </math>にも置き換えられる。</p>
        <p>ご覧のように、あるモノイダル圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>から取った対象は、hom集合を置き換える候補として適している。</p>
        <h2 data-number="28.2" id="モノイダル圏-1"><span class="header-section-number">28.2</span> モノイダル圏</h2>
        <p>モノイダル圏については前にも述べたが、定義をもう一度述べておく価値はある。モノイダル圏は、テンソル積を双関手として定義する:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo>⊗</mo>
                <mo>∷</mo>
                <mi>𝐕</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>𝐕</mi>
                <mo>→</mo>
                <mi>𝐕</mi>
              </mrow>
              <annotation encoding="application/x-tex">\otimes \Colon \mathbf{V}\times{}\mathbf{V} \to \mathbf{V}
              </annotation>
            </semantics>
          </math></p>
        <p>このテンソル積は結合的なのが望ましいが、自然同型を除いた結合則さえ満たせば十分だ。この同型射は結合子と呼ばれる。そのコンポーネントはこうなる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mrow>
                    <mi>a</mi>
                    <mi>b</mi>
                    <mi>c</mi>
                  </mrow>
                </msub>
                <mo>∷</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>⊗</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>⊗</mo>
                <mi>c</mi>
                <mo>→</mo>
                <mi>a</mi>
                <mo>⊗</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>⊗</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_{a b c} \Colon (a \otimes b) \otimes c \to a \otimes (b
                \otimes c)</annotation>
            </semantics>
          </math></p>
        <p>これは3つの引数すべてにおいて自然である必要がある。</p>
        <p>モノイダル圏はまた、テンソル積の単位として機能する特別な単位対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>i</mi>
              <annotation encoding="application/x-tex">i</annotation>
            </semantics>
          </math>を、これも自然同型を除いて一意に定義する必要がある。これら2つの同型は、それぞれ左単位子・右単位子と呼ばれ、次の構成要素を持つ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <msub>
                      <mi>λ</mi>
                      <mi>a</mi>
                    </msub>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>i</mi>
                    <mo>⊗</mo>
                    <mi>a</mi>
                    <mo>→</mo>
                    <mi>a</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <msub>
                      <mi>ρ</mi>
                      <mi>a</mi>
                    </msub>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>a</mi>
                    <mo>⊗</mo>
                    <mi>i</mi>
                    <mo>→</mo>
                    <mi>a</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                \lambda_a &amp;\Colon i \otimes a \to a \\
                \rho_a &amp;\Colon a \otimes i \to a
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>結合子と単位子はコヒーレンス条件を満たす必要がある:</p>
        <p><img src="images/assoc.jpg" /></p>
        <p><img src="images/idcoherence.jpg" /></p>
        <p>モノイダル圏が<span id="symmetric" class="keyword">対称</span>
          (symmetric) と呼ばれる条件は、自然同型がコンポーネント:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>γ</mi>
                  <mrow>
                    <mi>a</mi>
                    <mi>b</mi>
                  </mrow>
                </msub>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>⊗</mo>
                <mi>b</mi>
                <mo>→</mo>
                <mi>b</mi>
                <mo>⊗</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\gamma_{a b} \Colon a \otimes b \to b \otimes a</annotation>
            </semantics>
          </math></p>
        <p>を持ち、その平方が恒等射であり:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>γ</mi>
                  <mrow>
                    <mi>b</mi>
                    <mi>a</mi>
                  </mrow>
                </msub>
                <mo>∘</mo>
                <msub>
                  <mi>γ</mi>
                  <mrow>
                    <mi>a</mi>
                    <mi>b</mi>
                  </mrow>
                </msub>
                <mo>=</mo>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mrow>
                    <mi>a</mi>
                    <mo>⊗</mo>
                    <mi>b</mi>
                  </mrow>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">\gamma_{b a} \circ \gamma_{a b} = %
                \mathbf{id}_{a \otimes b}%
              </annotation>
            </semantics>
          </math></p>
        <p>かつモノイダル構造と一致していることだ。</p>
        <p>モノイダル圏に関して興味深いのは、内部hom (関数オブジェクト)
          をテンソル積に対する右随伴として定義できることだ。この関数オブジェクト、すなわち冪乗の標準的な定義は、右随伴を通じて圏論的な積へと向かっていたことを思い出してほしい。そのような対象が存在する圏をカルテシアン閉圏と呼んだ。モノイダル圏の内部homを定義する随伴は次のとおりだ:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐕</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>⊗</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>∼</mo>
                <mi>𝐕</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mi>b</mi>
                    <mo>,</mo>
                    <mi>c</mi>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{V}(a \otimes b, c) \sim \mathbf{V}(a, [b, c])
              </annotation>
            </semantics>
          </math></p>
        <p><a href="http://www.tac.mta.ca/tac/reprints/articles/10/tr10.pdf">G.
            M.
            Kelly</a>にならって、内部homを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <mi>b</mi>
                <mo>,</mo>
                <mi>c</mi>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}b, c{]}</annotation>
            </semantics>
          </math>と表記しよう。この随伴の余単位は自然変換であり、そのコンポーネントは評価射
          (evaluation morphism) と呼ばれる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>ε</mi>
                  <mrow>
                    <mi>a</mi>
                    <mi>b</mi>
                  </mrow>
                </msub>
                <mo>∷</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>b</mi>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <mo>⊗</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon_{a b} \Colon ([a, b] \otimes a) \to b</annotation>
            </semantics>
          </math></p>
        <p>テンソル積が非対称なら、次の随伴を使って、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <mo stretchy="false" form="prefix">[</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>c</mi>
                <mo stretchy="false" form="postfix">]</mo>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}{[}a, c{]}{]}</annotation>
            </semantics>
          </math>で示される別の内部homを定義できることに注目してほしい:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐕</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>⊗</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>∼</mo>
                <mi>𝐕</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mrow>
                      <mo stretchy="true" form="prefix">[</mo>
                      <mi>a</mi>
                      <mo>,</mo>
                      <mi>c</mi>
                      <mo stretchy="true" form="postfix">]</mo>
                    </mrow>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{V}(a \otimes b, c) \sim \mathbf{V}(b, [[a, c]])
              </annotation>
            </semantics>
          </math></p>
        <p>両方が定義されているモノイダル圏は<span id="biclosed" class="keyword">双閉</span> (biclosed)
          と呼ばれる。双閉ではない圏の例としては<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内の自己関手の圏があり、関手合成がテンソル積として機能する。この圏はモナドを定義するのに使った。</p>
        <h2 data-number="28.3" id="豊饒圏"><span class="header-section-number">28.3</span> 豊饒圏</h2>
        <p>モノイダル圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>上の豊穣圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>は、hom集合をhom対象で置き換える。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>のすべてのペアに対し、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          を関連付けよう。hom集合に使ったのと同じ表記をhom対象にも使うことにする。ただし、hom対象が射を含まないことには注意が必要だ。一方で、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>はhom集合と射を持つ正則圏
          (豊穣化されていない圏)
          だ。したがって、集合を完全に一掃したわけではない――絨毯で覆って見えなくしただけだ。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の個々の射については語れないため、射の合成を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>内の射の族に置き換える:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo>∘</mo>
                <mo>∷</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>⊗</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\circ \Colon \mathbf{C}(b, c) \otimes \mathbf{C}(a, b) \to
                \mathbf{C}(a, c)</annotation>
            </semantics>
          </math></p>
        <p><img src="images/composition.jpg" style="width:40.0%" /></p>
        <p>同様に、恒等射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>内の射の族に置き換える:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>j</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mi>i</mi>
                <mo>→</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">j_a \Colon i \to \mathbf{C}(a, a)</annotation>
            </semantics>
          </math></p>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>i</mi>
              <annotation encoding="application/x-tex">i</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>内のテンソル単位だ。</p>
        <p><img src="images/id.jpg" style="width:40.0%" /></p>
        <p>合成の結合則は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>内の結合子で定義される:</p>
        <p><img src="images/compcoherence.jpg" /></p>
        <p>単位則も同様に単位子として表現される:</p>
        <p><img src="images/rightid.jpg" /></p>
        <p><img src="images/leftid.jpg" /></p>
        <h2 data-number="28.4" id="前順序"><span class="header-section-number">28.4</span> 前順序</h2>
        <p>前順序はやせた圏として定義され、その中のhom集合はどれも空集合か単集合だ。集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          が空でないことは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>以下であることの証明と解釈される。そのような圏は、2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐹</mi>
                <mi>𝑎</mi>
                <mi>𝑙</mi>
                <mi>𝑠</mi>
                <mi>𝑒</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{False}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑇</mi>
                <mi>𝑟</mi>
                <mi>𝑢</mi>
                <mi>𝑒</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{True}</annotation>
            </semantics>
          </math>とも呼ばれる)
          だけを含む非常に単純なモノイダル圏上の豊穣圏だと解釈できる。必須の恒等射に加えて、この圏には<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>への単一の射がある。これを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>0</mn>
                <mo>→</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">0 \to 1</annotation>
            </semantics>
          </math>と呼ぼう。単純なモノイダル構造をその中に確立できる。そのためには、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>の単純な算術をモデル化したテンソル積を使う
          (たとえば、0でない積は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>1</mn>
                <mo>⊗</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">1 \otimes 1</annotation>
            </semantics>
          </math>だけだ)。この圏の恒等対象は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>だ。これは厳密なモノイダル圏であり、つまり結合子と単位子は恒等射だ。</p>
        <p>前順序のhom集合は空集合か単集合なので、ちっぽけな圏からのhom対象に簡単に置き換えられる。豊穣化された前順序<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>は、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の任意のペアについてのhom対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          を持つ。この対象は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>以下なら<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>で、そうでなければ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>だ。</p>
        <p>合成を見てみよう。任意の2つの対象のテンソル積は通常は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>で、両方が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>のときだけ<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>となる。テンソル積が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>の場合、合成射には2つの候補がある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mn>0</mn>
              </msub>
              <annotation encoding="application/x-tex">%
                \mathbf{id}_{0}%
              </annotation>
            </semantics>
          </math>または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>0</mn>
                <mo>→</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">0 \to 1</annotation>
            </semantics>
          </math>のいずれかだ。しかし、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>の場合、候補は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">%
                \mathbf{id}_{1}%
              </annotation>
            </semantics>
          </math>だけだ。これを再翻訳して関係に戻すと、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant b</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>b</mi>
                <mo>≤</mo>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">b \leqslant c</annotation>
            </semantics>
          </math>の場合は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>c</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant c</annotation>
            </semantics>
          </math>となり、必要としていた推移則そのものになる。</p>
        <p>恒等射についてはどうだろう？
          それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          への射だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>からの射は1つだけで、恒等射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">%
                \mathbf{id}_{1}%
              </annotation>
            </semantics>
          </math>だ。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>である必要がある。これは前順序の反射則<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>≤</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \leqslant a</annotation>
            </semantics>
          </math>を意味する。したがって、前順序を豊饒圏として実装すると、推移則と反射則の両方が自動的に強制される。</p>
        <h2 data-number="28.5" id="距離空間"><span class="header-section-number">28.5</span> 距離空間</h2>
        <p><a href="http://www.tac.mta.ca/tac/reprints/articles/1/tr1.pdf">ウィリアム・ローヴェア</a>
          (William Lawvere)
          による興味深い例がある。ローヴェアは豊穣圏を使って距離空間 (metric
          space)
          を定義できることに気付いた。距離空間は任意の2対象間の距離を定義する。この距離は非負実数だ。取り得る値に無限大を含めると便利だ。距離が無限大の場合、一方の対象から他方の対象へ到達する方法はない。</p>
        <p>
          距離には、満たさなければならない自明な特性がいくつかある。その1つは、ある対象からそれ自身への距離は0でなければならない、というものだ。もう1つは三角不等式で、直線距離は中継地点同士の距離の合計を超えない、というものだ。距離が対称である必要がないのは、最初は奇妙に思えるかもしれないが、ローヴェアによる説明どおりに、ある方向へは坂を上り、逆方向へは坂を下るのを想像すれば分かる。いずれにしても、対称性は追加の制約として後から課してもよい。
        </p>
        <p>さて、どうすれば距離空間を圏論の言葉で語れるだろうか？
          それには、hom対象が距離であるような圏を構築する必要がある。注意してほしいのは、距離は射ではなくhom対象だということだ。一体どうすればhom対象が数値になるだろう？
          それらの数値が対象であるようなモノイダル圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>さえ構築できればよい。非負実数
          (と無限大)
          は全順序を形成するので、やせた圏として扱える。このような2つの数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>y</mi>
              <annotation encoding="application/x-tex">y</annotation>
            </semantics>
          </math>の間の射は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>x</mi>
                <mo>≥</mo>
                <mi>y</mi>
              </mrow>
              <annotation encoding="application/x-tex">x \geqslant y</annotation>
            </semantics>
          </math>の場合だけ存在する
          (註:
          これは前順序の定義での伝統的な向きとは逆だ)。モノイダル構造は加算で与えられ、0が単位対象として機能する。言い換えると、2つの数値のテンソル積はそれらの合計だ。</p>
        <p>距離空間は、このようなモノイダル圏上の豊穣圏だ。対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>へのhom対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          は、非負の (無限大を取り得る)
          数であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への距離と呼ばれる。このような圏で恒等射と合成に何ができるか見てみよう。</p>
        <p>我々の定義では、0という数であるテンソル単位からhom対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          への射は次の関係になる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>0</mn>
                <mo>≥</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">0 \geqslant \mathbf{C}(a, a)</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          は負の数ではないため、この条件は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>への距離が常に0であることを示す。良し！</p>
        <p>では合成について語ろう。隣接する2つのhom対象のテンソル積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>⊗</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(b, c) \otimes \mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          から始める。テンソル積は、2つの距離の合計として定義された。合成は、この積から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, c)</annotation>
            </semantics>
          </math>
          への、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>内の射だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>内の射は「以上」の関係として定義される。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への距離と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>への距離の合計は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>への距離以上になる。もっとも、これは標準的な三角不等式にすぎない。良し！</p>
        <p>距離空間を豊饒圏へと再投影することにより、三角不等式と自己距離0が「無料で」得られる。</p>
        <h2 data-number="28.6" id="豊穣関手"><span class="header-section-number">28.6</span> 豊穣関手</h2>
        <p>関手の定義には射の写像が含まれる。豊穣化された設定では、個々の射という概念がないため、hom対象を一括して扱う必要がある。Hom対象はモノイダル圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>内の対象であり、それらの間には自由に使える射がある。したがって、同一のモノイダル圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>上の複数の豊穣圏について、それらの間に豊穣関手を定義することは意味がある。そうすれば、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>内の射を使って2つの豊穣圏の間でhom対象を写せる。</p>
        <p>2つの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐃</mi>
              <annotation encoding="application/x-tex">\mathbf{D}</annotation>
            </semantics>
          </math>の間の<span id="enriched_functor" class="keyword">豊穣関手</span> (enriched functor)
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>は、対象を対象に写すだけでなく、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の対象のすべてのペアに対して<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>内の射を割り当てる:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>F</mi>
                  <mrow>
                    <mi>a</mi>
                    <mi>b</mi>
                  </mrow>
                </msub>
                <mo>∷</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mi>𝐃</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">F_{a b} \Colon \mathbf{C}(a, b) \to \mathbf{D}(F\ a, F\ b)
              </annotation>
            </semantics>
          </math></p>
        <p>関手は構造を保持する写像だ。普通の関手については、それは合成と恒等射を保存することを意味した。豊穣化された設定においては、合成の保存とは次の図式が可換であることを意味する:</p>
        <p><img src="images/functorcomp.jpg" /></p>
        <p>恒等射の保存は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐕</mi>
              <annotation encoding="application/x-tex">\mathbf{V}</annotation>
            </semantics>
          </math>内の射のうち恒等射を「選択」するものの保存に置き換えられる。</p>
        <p><img src="images/functorid.jpg" /></p>
        <h2 data-number="28.7" id="自己豊穣化"><span class="header-section-number">28.7</span> 自己豊穣化</h2>
        <p>閉じた対称モノイダル圏は、hom集合を内部hom (定義は上記を参照)
          に置き換えることによって自己豊穣化できる。そのためには、内部homについての合成則を定義する必要がある。言い換えると、次のシグネチャを持つ射を実装する必要がある:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mo>⊗</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">[b, c] \otimes [a, b] \to [a, c]</annotation>
            </semantics>
          </math></p>
        <p>これはプログラミングでの他のタスクと大差ない。ただし、圏論では通常、ポイントフリー実装を使う。まず、これを要素とするような集合を指定する。ここでは、次のhom集合のメンバーだ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐕</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mi>b</mi>
                    <mo>,</mo>
                    <mi>c</mi>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <mo>⊗</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>b</mi>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <mo>,</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>c</mi>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{V}([b, c] \otimes [a, b], [a, c])</annotation>
            </semantics>
          </math></p>
        <p>このhom集合は次と同型だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐕</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mrow>
                      <mo stretchy="true" form="prefix">[</mo>
                      <mi>b</mi>
                      <mo>,</mo>
                      <mi>c</mi>
                      <mo stretchy="true" form="postfix">]</mo>
                    </mrow>
                    <mo>⊗</mo>
                    <mrow>
                      <mo stretchy="true" form="prefix">[</mo>
                      <mi>a</mi>
                      <mo>,</mo>
                      <mi>b</mi>
                      <mo stretchy="true" form="postfix">]</mo>
                    </mrow>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>⊗</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{V}(([b, c] \otimes [a, b]) \otimes a, c)</annotation>
            </semantics>
          </math></p>
        <p>ここで、内部hom<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">[</mo>
                <mi>a</mi>
                <mo>,</mo>
                <mi>c</mi>
                <mo stretchy="false" form="postfix">]</mo>
              </mrow>
              <annotation encoding="application/x-tex">{[}a, c{]}</annotation>
            </semantics>
          </math>の定義で出てきた随伴を使った。この新しい集合に射を構築できるなら、随伴はもとの集合の射を指し、そして、その射は合成として使える。その射は、自由に使えるいくつかの射を合成することによって構築される。まず、結合子<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>α</mi>
                <mrow>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mi>b</mi>
                    <mo>,</mo>
                    <mi>c</mi>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <mspace width="0.222em"></mspace>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>b</mi>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <mspace width="0.222em"></mspace>
                  <mi>a</mi>
                </mrow>
              </msub>
              <annotation encoding="application/x-tex">\alpha_{[b, c]\ [a, b]\ a}</annotation>
            </semantics>
          </math>を使って左側の式を再結合できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mi>b</mi>
                    <mo>,</mo>
                    <mi>c</mi>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <mo>⊗</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>b</mi>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>⊗</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mo>⊗</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>b</mi>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <mo>⊗</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">([b, c] \otimes [a, b]) \otimes a \to [b, c] \otimes ([a, b]
                \otimes a)</annotation>
            </semantics>
          </math></p>
        <p>続けて、随伴の余単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>ε</mi>
                <mrow>
                  <mi>a</mi>
                  <mi>b</mi>
                </mrow>
              </msub>
              <annotation encoding="application/x-tex">\varepsilon_{a b}</annotation>
            </semantics>
          </math>を使える:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mo>⊗</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>b</mi>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <mo>⊗</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mo>⊗</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">[b, c] \otimes ([a, b] \otimes a) \to [b, c] \otimes b
              </annotation>
            </semantics>
          </math></p>
        <p>もう一度余単位<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>ε</mi>
                <mrow>
                  <mi>b</mi>
                  <mi>c</mi>
                </mrow>
              </msub>
              <annotation encoding="application/x-tex">\varepsilon_{b c}</annotation>
            </semantics>
          </math>を使うと<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>が得られる。以上より射が構築できた:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>ε</mi>
                  <mrow>
                    <mi>b</mi>
                    <mi>c</mi>
                  </mrow>
                </msub>
                <mspace width="0.222em"></mspace>
                <mi>.</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mrow>
                      <mi>𝐢</mi>
                      <mi>𝐝</mi>
                    </mrow>
                    <mrow>
                      <mo stretchy="true" form="prefix">[</mo>
                      <mi>b</mi>
                      <mo>,</mo>
                      <mi>c</mi>
                      <mo stretchy="true" form="postfix">]</mo>
                    </mrow>
                  </msub>
                  <mo>⊗</mo>
                  <msub>
                    <mi>ε</mi>
                    <mrow>
                      <mi>a</mi>
                      <mi>b</mi>
                    </mrow>
                  </msub>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mi>.</mi>
                <mspace width="0.222em"></mspace>
                <msub>
                  <mi>α</mi>
                  <mrow>
                    <mrow>
                      <mo stretchy="true" form="prefix">[</mo>
                      <mi>b</mi>
                      <mo>,</mo>
                      <mi>c</mi>
                      <mo stretchy="true" form="postfix">]</mo>
                    </mrow>
                    <mrow>
                      <mo stretchy="true" form="prefix">[</mo>
                      <mi>a</mi>
                      <mo>,</mo>
                      <mi>b</mi>
                      <mo stretchy="true" form="postfix">]</mo>
                    </mrow>
                    <mi>a</mi>
                  </mrow>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">\varepsilon_{b c}\ .\ (%
                \mathbf{id}_{{[b, c]}}%
                \otimes \varepsilon_{a b})\ .\ \alpha_{[b, c] [a, b] a}</annotation>
            </semantics>
          </math></p>
        <p>これは次のhom集合の要素だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐕</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mrow>
                      <mo stretchy="true" form="prefix">[</mo>
                      <mi>b</mi>
                      <mo>,</mo>
                      <mi>c</mi>
                      <mo stretchy="true" form="postfix">]</mo>
                    </mrow>
                    <mo>⊗</mo>
                    <mrow>
                      <mo stretchy="true" form="prefix">[</mo>
                      <mi>a</mi>
                      <mo>,</mo>
                      <mi>b</mi>
                      <mo stretchy="true" form="postfix">]</mo>
                    </mrow>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>⊗</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>c</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{V}(([b, c] \otimes [a, b]) \otimes a, c)</annotation>
            </semantics>
          </math></p>
        <p>随伴によって、目指していた合成則が得られるだろう。</p>
        <p>同様に、恒等射:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>j</mi>
                  <mi>a</mi>
                </msub>
                <mo>∷</mo>
                <mi>i</mi>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">j_a \Colon i \to [a, a]</annotation>
            </semantics>
          </math></p>
        <p>は次のhom集合のメンバーだ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐕</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>i</mi>
                  <mo>,</mo>
                  <mrow>
                    <mo stretchy="true" form="prefix">[</mo>
                    <mi>a</mi>
                    <mo>,</mo>
                    <mi>a</mi>
                    <mo stretchy="true" form="postfix">]</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{V}(i, [a, a])</annotation>
            </semantics>
          </math></p>
        <p>これは、随伴を通じて、次と同型だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐕</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>i</mi>
                  <mo>⊗</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{V}(i \otimes a, a)</annotation>
            </semantics>
          </math></p>
        <p>このhom集合は左恒等射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>λ</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">\lambda_a</annotation>
            </semantics>
          </math>を含むことが分かっている。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>j</mi>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">j_a</annotation>
            </semantics>
          </math>は随伴の下の像として定義できる。</p>
        <p>自己豊穣化の実際的な例としては、プログラミング言語における型のプロトタイプとして機能する圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>が挙げられる。以前、それがカルテシアン積に対するモノイダル閉圏であることを見た。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>では、任意の2集合間のhom集合はそれ自体が集合であるため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内の対象になる。それが冪乗集合の同型であることは分かっているので、外部homと内部homは等価となる。さらに、自己豊穣化を通じて、冪乗集合をhom対象として使えて、合成を冪乗対象のカルテシアン積として表現できるのも分かった。
        </p>
        <h2 data-number="28.8" id="mathbf2-圏との関係"><span class="header-section-number">28.8</span>
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏との関係
        </h2>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏については、(小さい)
          圏の圏である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>の文脈において説明した。圏間の射は関手だが、追加の構造がある:
          関手間の自然変換だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏では、対象は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>-セル、射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セル、射間の射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セルと呼ばれることが多い。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>-セルは圏、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルは関手、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セルは自然変換だ。</p>
        <p>しかし、2つの圏の間の関手も圏を形成することに注意してほしい。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>に実際にあるのは、hom集合というより<em>hom圏</em>だ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>上の豊穣圏として扱えるのと同様に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>上の豊穣圏として扱えることが知られている。さらに一般的に、すべての圏が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>上の豊穣圏として扱えるのと同様に、すべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>上の豊穣圏とみなせる。</p>
        <h1 data-number="29" id="トポイ"><span class="header-section-number">29</span> トポイ</h1>
        <p>
          プログラミングから離れてハードコアな数学に飛び込んでしまったかもしれないのは分かっている。しかし、プログラミングにおける次の大きな革命が何をもたらすのか、理解のためにどんな数学が必要となるのかは、誰にも分からない。すでにいくつか非常に興味深いアイデアがある。連続時間での関数型リアクティブプログラミング、Haskellの型システムの依存型による拡張、ホモトピー型理論のプログラミングにおける探究などだ。
        </p>
        <p>
          ここまでは、値の<em>集合</em>を使って何気なく型を区別してきた。これは厳密には正しくない。なぜなら、このようなアプローチはある事実を考慮していないからだ。それは、プログラミングでは値を<em>計算</em>し、そして計算は時間のかかるプロセスであり、極端な場合には停止しない可能性がある、という事実だ。すべてのチューリング完全な言語は発散計算
          (divergent computation) を含む。</p>
        <p>
          また、集合論には、計算機科学の基礎として、そして数学自体の基礎としても、最適とは言い難い根本的な理由がある。良い比喩としては、集合論は特定のアーキテクチャに結び付けられたアセンブリ言語だといえる。別のアーキテクチャで計算を実行したいなら、より一般的なツールを使う必要がある。
        </p>
        <p>可能性の1つは、集合の代わりに空間 (space)
          を使うことだ。空間は構造がより豊かで、集合を使わずに定義できる。通常、空間に関連付けられるものの1つは位相幾何学
          (topology)
          で、連続性などを定義するために必要だ。位相幾何学への従来のアプローチは、ご想像のとおり、集合論によるものだ。特に、部分集合は位相幾何学の中心的な概念だ。驚くまでもないが、圏論の研究者たちはこの概念を<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>以外の圏に一般化した。集合論に代わるものとしてふさわしい性質を持つ圏の型は<span id="topos" class="keyword">トポス</span> (topos, 複数形: トポイtopoi)
          と呼ばれ、部分集合を一般化した概念などを提供する。</p>
        <h2 data-number="29.1" id="部分対象分類子"><span class="header-section-number">29.1</span> 部分対象分類子</h2>
        <p>要素ではなく関数を使って部分集合の概念を表現することから始めよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への任意の関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の部分集合――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>の下にある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の像――を定義する。しかし、同一の部分集合を定義する関数はたくさんある。もっと具体的にする必要がある。まず初めに、単射関数――複数の要素を1つに潰さない関数に焦点を当てよう。単射関数
          (injective function)
          はある集合を別の集合に「注入」する。有限集合における単射関数は、ある集合の要素を別の集合の要素に接続する平行な矢として視覚化できる。当然、最初の集合を2つ目の集合より大きくすることはできない。そうでないと矢は必然的に収束する。曖昧さはまだ残っている:
          別の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">a&#39;</annotation>
            </semantics>
          </math>と、その集合から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への別の単射関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">f&#39;</annotation>
            </semantics>
          </math>があって、同じ部分集合が選ばれる可能性がある。しかし、そのような集合が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と同型でなければならないことは容易に納得できる。この事実を利用して、部分集合を、終域の同型によって関連付けられた単射関数の族として定義できる。より正確には、2つの単射関数:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>f</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>a</mi>
                    <mo>→</mo>
                    <mi>b</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>f</mi>
                    <mi>′</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>a</mi>
                    <mi>′</mi>
                    <mo>→</mo>
                    <mi>b</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                f &amp;\Colon a \to b \\
                f&#39; &amp;\Colon a&#39; \to b
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>が等価になるのは、同型射:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>h</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>a</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">h \Colon a \to a&#39;</annotation>
            </semantics>
          </math></p>
        <p>が存在する場合だ。ただし:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>=</mo>
                <mi>f</mi>
                <mi>′</mi>
                <mspace width="0.222em"></mspace>
                <mi>.</mi>
                <mspace width="0.222em"></mspace>
                <mi>h</mi>
              </mrow>
              <annotation encoding="application/x-tex">f = f&#39;\ .\ h</annotation>
            </semantics>
          </math></p>
        <p>このような等価な単射の族は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の部分集合を定義する。</p>
        <p><img src="images/subsetinjection.jpg" style="width:40.0%" /></p>
        <p>この定義は、単射関数をモノ射 (monomorphism)
          に置き換えることで任意の圏にリフトできる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>へのモノ射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>は普遍性によって定義されることを思い出してほしい。任意の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>c</mi>
              <annotation encoding="application/x-tex">c</annotation>
            </semantics>
          </math>および任意の射のペア:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>g</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>c</mi>
                    <mo>→</mo>
                    <mi>a</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="right" style="text-align: right">
                    <mi>g</mi>
                    <mi>′</mi>
                  </mtd>
                  <mtd columnalign="left" style="text-align: left">
                    <mo>∷</mo>
                    <mi>c</mi>
                    <mo>→</mo>
                    <mi>a</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{aligned}
                g &amp;\Colon c \to a \\
                g&#39; &amp;\Colon c \to a
                \end{aligned}
              </annotation>
            </semantics>
          </math></p>
        <p>のうち次を満たすもの:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mspace width="0.222em"></mspace>
                <mi>.</mi>
                <mspace width="0.222em"></mspace>
                <mi>g</mi>
                <mo>=</mo>
                <mi>m</mi>
                <mspace width="0.222em"></mspace>
                <mi>.</mi>
                <mspace width="0.222em"></mspace>
                <mi>g</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">m\ .\ g = m\ .\ g&#39;</annotation>
            </semantics>
          </math></p>
        <p>については<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>=</mo>
                <mi>g</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">g = g&#39;</annotation>
            </semantics>
          </math>である必要がある。</p>
        <p><img src="images/monomorphism.jpg" style="width:40.0%" /></p>
        <p>集合においてこの定義をより理解しやすくするには、関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>がモノ射で<em>ない</em>ことが何を意味するかを考えるとよい。その場合は<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の2つの異なる要素が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の1つの要素に写されるだろう。そして、それら2つの要素についてのみ違いがある2つの関数<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">g&#39;</annotation>
            </semantics>
          </math>を見つけられる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>を後置合成すると、その違いは見えなくなる。</p>
        <p><img src="images/notmono.jpg" style="width:40.0%" /></p>
        <p>部分集合を定義する別の方法もある: 特性関数 (characteristic function)
          と呼ばれる単一の関数を使う方法だ。これは、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>から2要素集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Ω</mi>
              <annotation encoding="application/x-tex">\Omega</annotation>
            </semantics>
          </math>への関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>χ</mi>
              <annotation encoding="application/x-tex">\chi</annotation>
            </semantics>
          </math>だ。この関数は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の要素のうち部分集合のメンバーである要素に
          “true” を割り当て、メンバーではない要素に “false” を割り当てる。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Ω</mi>
              <annotation encoding="application/x-tex">\Omega</annotation>
            </semantics>
          </math>の要素を
          “true”
          に指定することの意味を明確にする必要が残る。ここで標準的なトリックが使える:
          単集合から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Ω</mi>
              <annotation encoding="application/x-tex">\Omega</annotation>
            </semantics>
          </math>への関数を使えばよい。この関数を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑡</mi>
                <mi>𝑟</mi>
                <mi>𝑢</mi>
                <mi>𝑒</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{true}</annotation>
            </semantics>
          </math>と呼ぼう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑡</mi>
                  <mi>𝑟</mi>
                  <mi>𝑢</mi>
                  <mi>𝑒</mi>
                </mrow>
                <mo>∷</mo>
                <mn>1</mn>
                <mo>→</mo>
                <mi>Ω</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{true} \Colon 1 \to \Omega</annotation>
            </semantics>
          </math></p>
        <p><img src="images/true.jpg" style="width:40.0%" /></p>
        <p>これらの定義の組み合わせ方によっては、部分対象 (subobject)
          が何であるかだけでなく、特別な対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Ω</mi>
              <annotation encoding="application/x-tex">\Omega</annotation>
            </semantics>
          </math>についても要素に触れずに定義できる。ここでのアイデアは、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑡</mi>
                <mi>𝑟</mi>
                <mi>𝑢</mi>
                <mi>𝑒</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{true}</annotation>
            </semantics>
          </math>が「総称」部分対象を表すようにしたい、というものだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>では、これは2要素の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Ω</mi>
              <annotation encoding="application/x-tex">\Omega</annotation>
            </semantics>
          </math>から1要素の部分集合を選ぶ。これは最大限に総称的だ。ここで選ばれたものがれっきとした部分集合なのは明らかだ。なぜなら、この部分集合には<em>ない</em>要素が<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Ω</mi>
              <annotation encoding="application/x-tex">\Omega</annotation>
            </semantics>
          </math>にはもう1つあるからだ。</p>
        <p>より一般的な条件では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑡</mi>
                <mi>𝑟</mi>
                <mi>𝑢</mi>
                <mi>𝑒</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{true}</annotation>
            </semantics>
          </math>を終対象から<em>分類対象</em>
          (classifying object)
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Ω</mi>
              <annotation encoding="application/x-tex">\Omega</annotation>
            </semantics>
          </math>へのモノ射として定義する。ただし、分類対象の定義が必要になる。つまり、この対象を特性関数に結びつける普遍性が必要だ。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>では、特性関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>χ</mi>
              <annotation encoding="application/x-tex">\chi</annotation>
            </semantics>
          </math>に沿った<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑡</mi>
                <mi>𝑟</mi>
                <mi>𝑢</mi>
                <mi>𝑒</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{true}</annotation>
            </semantics>
          </math>の引き戻しが、部分集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>とそれを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>に埋め込む単射関数の両方を定義することが知られている。その引き戻し図式を以下に示す:
        </p>
        <p><img src="images/pullback.jpg" style="width:40.0%" /></p>
        <p>この図式を分析してみよう。引き戻しの式は次のとおりだ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑡</mi>
                  <mi>𝑟</mi>
                  <mi>𝑢</mi>
                  <mi>𝑒</mi>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mi>.</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mi>𝑢</mi>
                  <mi>𝑛</mi>
                  <mi>𝑖</mi>
                  <mi>𝑡</mi>
                </mrow>
                <mo>=</mo>
                <mi>χ</mi>
                <mspace width="0.222em"></mspace>
                <mi>.</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{true}\ .\ \mathit{unit} = \chi\ .\ f</annotation>
            </semantics>
          </math></p>
        <p>関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑡</mi>
                  <mi>𝑟</mi>
                  <mi>𝑢</mi>
                  <mi>𝑒</mi>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mi>.</mi>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mi>𝑢</mi>
                  <mi>𝑛</mi>
                  <mi>𝑖</mi>
                  <mi>𝑡</mi>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{true}\ .\ \mathit{unit}</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>のすべての要素を
          “true”
          に写す。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>のすべての要素を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の要素のうち<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>χ</mi>
              <annotation encoding="application/x-tex">\chi</annotation>
            </semantics>
          </math>が
          “true”
          であるものに写す必要がある。定義より、これらは特性関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>χ</mi>
              <annotation encoding="application/x-tex">\chi</annotation>
            </semantics>
          </math>によって指定される部分集合の要素だ。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>の像はまさに求めていた部分集合だ。引き戻しの普遍性によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>が単射であることが保証される。</p>
        <p>この引き戻し図式は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>以外の圏の分類対象を定義するのに使える。そのような圏には終対象が必要で、それによってモノ射<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑡</mi>
                <mi>𝑟</mi>
                <mi>𝑢</mi>
                <mi>𝑒</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{true}</annotation>
            </semantics>
          </math>を定義できる。また、引き戻しも必要だ――実際の要件は、すべて有限の極限を持つことだ
          (引き戻しは有限の極限の一例だ)。これらの仮定の下で、分類対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Ω</mi>
              <annotation encoding="application/x-tex">\Omega</annotation>
            </semantics>
          </math>を、すべてのモノ射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>について引き戻し図式を完成させる一意な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>χ</mi>
              <annotation encoding="application/x-tex">\chi</annotation>
            </semantics>
          </math>が存在する、という特性によって定義する。</p>
        <p>この特性を分析しよう。引き戻しを構築するとき、3つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Ω</mi>
              <annotation encoding="application/x-tex">\Omega</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>と、2つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑡</mi>
                <mi>𝑟</mi>
                <mi>𝑢</mi>
                <mi>𝑒</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{true}</annotation>
            </semantics>
          </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>χ</mi>
              <annotation encoding="application/x-tex">\chi</annotation>
            </semantics>
          </math>が与えられる。引き戻しの存在は、図式を可換にするような、2つの射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑢</mi>
                <mi>𝑛</mi>
                <mi>𝑖</mi>
                <mi>𝑡</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{unit}</annotation>
            </semantics>
          </math>
          (後者は終対象の定義によって一意に決定される)
          を伴った最適な対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を見つけられることを意味する。</p>
        <p>ここでは連立微分方程式を解いている。つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math><em>と</em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の両方を変化させることで<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Ω</mi>
              <annotation encoding="application/x-tex">\Omega</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑡</mi>
                <mi>𝑟</mi>
                <mi>𝑢</mi>
                <mi>𝑒</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{true}</annotation>
            </semantics>
          </math>について解いている。与えられた<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>および<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>について、モノ射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon a \to b</annotation>
            </semantics>
          </math>がある場合とない場合がある。しかし、もしあるなら、何らかの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>χ</mi>
              <annotation encoding="application/x-tex">\chi</annotation>
            </semantics>
          </math>の引き戻しにしたい。さらに、この<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>χ</mi>
              <annotation encoding="application/x-tex">\chi</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>によって一意に決定されるようにしたい。</p>
        <p>モノ射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>と特性関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>χ</mi>
              <annotation encoding="application/x-tex">\chi</annotation>
            </semantics>
          </math>の間に1対1の対応関係があるとは言えない。なぜなら、引き戻しは同型を除いて一意なだけだからだ。しかし、部分集合を等価な単射の族として以前定義したのを思い出してほしい。これを一般化するには、<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の部分対象を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>への等価なモノ射の族として定義すればよい。このモノ射の族は、先ほどの図式における等価な引き戻しの族と1対1で対応している。</p>
        <p>したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の部分対象の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑆</mi>
                  <mi>𝑢</mi>
                  <mi>𝑏</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Sub}(b)</annotation>
            </semantics>
          </math>
          をモノ射の族として定義でき、それが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Ω</mi>
              <annotation encoding="application/x-tex">\Omega</annotation>
            </semantics>
          </math>への射の集合と同型であることがわかる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑆</mi>
                  <mi>𝑢</mi>
                  <mi>𝑏</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>b</mi>
                  <mo>,</mo>
                  <mi>Ω</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Sub}(b) \cong \mathbf{C}(b, \Omega)</annotation>
            </semantics>
          </math></p>
        <p>偶然にも、これは2つの関手の自然同型だ。言い換えれば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑆</mi>
                  <mi>𝑢</mi>
                  <mi>𝑏</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Sub}(-)</annotation>
            </semantics>
          </math>
          は表現可能 (反変)
          関手であり、その表現は対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Ω</mi>
              <annotation encoding="application/x-tex">\Omega</annotation>
            </semantics>
          </math>だ。</p>
        <h2 data-number="29.2" id="トポス"><span class="header-section-number">29.2</span> トポス</h2>
        <p>トポスは次のような圏だ:</p>
        <ol type="1">
          <li>カルテシアン閉である: 積・終対象・(積の右随伴として定義される)
            冪乗のすべてを持つ。</li>
          <li>すべての有限図式について極限を持つ。</li>
          <li>部分対象分類子<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>Ω</mi>
                <annotation encoding="application/x-tex">\Omega</annotation>
              </semantics>
            </math>がある。</li>
        </ol>
        <p>これらの特性によって、トポスはほとんどの用途で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>の代わりになる。さらに、定義から導かれる追加の特性もある。たとえば、トポスは始対象も含めてすべての有限の余極限を持つ。</p>
        <p>部分対象分類子を終対象2つの余積 (和)
          として――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>におけるのと同様に――定義するのは魅力的だが、もっと一般化したい。これが当てはまるトポイはブーリアンと呼ばれる。</p>
        <h2 data-number="29.3" id="トポイと論理"><span class="header-section-number">29.3</span> トポイと論理</h2>
        <p>集合論では、特性関数は、集合の要素の特性――<span id="predicate" class="keyword">述語</span> (predicate)
          を定義するものと解釈されうる。述語は、一部の要素に対しては真となり、他の要素に対しては偽となる。述語<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑖</mi>
                <mi>𝑠</mi>
                <mi>𝐸</mi>
                <mi>𝑣</mi>
                <mi>𝑒</mi>
                <mi>𝑛</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{isEven}</annotation>
            </semantics>
          </math>は自然数の集合から偶数の部分集合を選択する。トポスでは、述語の概念を対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Ω</mi>
              <annotation encoding="application/x-tex">\Omega</annotation>
            </semantics>
          </math>への射に一般化できる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>Ω</mi>
              <annotation encoding="application/x-tex">\Omega</annotation>
            </semantics>
          </math>が真偽対象
          (truth object) と呼ばれることがあるのはこのためだ。</p>
        <p>述語は論理の構成要素だ。トポスには、論理を研究するのに必要な全装備が揃っている。積は論理積
          (<em>and</em>) に対応し、余積は論理和 (<em>or</em>)
          に対応し、冪乗は論理包含に対応する。排中律
          (または、等価なものとして、二重否定除去)
          を除く論理学の標準的な公理すべてがトポスに含まれている。これが、トポスの論理が構成的論理
          (constructive logic) あるいは直観主義論理 (intuitionistic logic)
          に対応する理由だ。</p>
        <p>
          直観主義論理は計算機科学から予想外に支持され、着実に定着していっている。排中律という古典的な概念は、絶対的な真実があるという信念に基づいている。つまり、すべての記述は真か偽のいずれかであり、古代ローマ人が言ったように、<em>tertium
            non datur</em> (第3の道はない)
          ということだ。しかし、何かの真偽を知るための方法は、それを証明または反証できるかどうかだけだ。証明とはプロセスであり、計算だ――そして、知ってのとおり、計算には時間とリソースがかかる。場合によっては、停止しないこともある。有限の時間で証明できない命題を真実であると主張するのは無意味だ。トポスは、より繊細な真偽対象を持ち、興味深い論理をモデル化するためのより一般的な枠組みを提供する。
        </p>
        <h2 data-number="29.4" id="課題-20"><span class="header-section-number">29.4</span> 課題</h2>
        <ol type="1">
          <li>特性関数に沿った<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>𝑡</mi>
                  <mi>𝑟</mi>
                  <mi>𝑢</mi>
                  <mi>𝑒</mi>
                </mrow>
                <annotation encoding="application/x-tex">\mathit{true}</annotation>
              </semantics>
            </math>の引き戻しである関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>f</mi>
                <annotation encoding="application/x-tex">f</annotation>
              </semantics>
            </math>は単射でなければならないことを示せ。</li>
        </ol>
        <h1 data-number="30" id="ローヴェアセオリー"><span class="header-section-number">30</span> ローヴェア・セオリー</h1>
        <p>最近では、モナドに言及せずには関数型プログラミングについて語れない。しかし、並行宇宙においては、エウジニオ・モッジがモナドではなくローヴェアのセオリー
          (Lawvere theory)
          に着目した可能性もあっただろう。そのような宇宙を探検しよう。</p>
        <h2 data-number="30.1" id="普遍代数"><span class="header-section-number">30.1</span> 普遍代数</h2>
        <p>
          代数を様々な抽象レベルで記述する方法はたくさんある。モノイド・群・環などを記述するための汎用言語を見つけたい。最も単純なレベルでは、これらのすべての構造によって、集合の要素に対する<em>演算</em>と、それらの演算によって満たされなければならないいくつかの<em>規則</em>が定義される。たとえば、モノイドは結合則を満たす二項演算によって定義できる。さらに、単位元と単位元則もある。しかし、少し想像力を働かせれば、単位元は零項演算――引数を取らず集合の特別な要素を返す操作――に変えられる。群について述べるには、受け取った要素の逆を返す単項演算子を追加する。それに対応する左逆元則と右逆元則がある。環では2つの二項演算子といくつかの規則が定義される。以下同様だ。
        </p>
        <p>大枠としては、代数はさまざまな値の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>についての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>項演算の集合と、等式の恒等射の集合によって定義される。これらの恒等射はすべて全称量化されている。たとえば、結合性の等式はすべての可能な3要素の組み合わせについて満たされる必要がある、などだ。</p>
        <p>ちなみに、これは0 (加算についての単位)
          が乗算について逆を持たないという単純な理由から、フィールドを考慮から除外する。フィールドの逆元則は全称量化できない。</p>
        <p>この普遍代数の定義は、演算 (関数)
          を射に置き換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>以外の圏にも拡張できる。集合の代わりに、(総称対象と呼ばれる)
          対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を選ぶ。単項演算は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の準同型にすぎない。しかし、それ以外の<span id="arity" class="keyword">アリティ</span> (arity, 演算の引数の数)
          についてはどうだろう？ 二項演算 (アリティ2)
          は、積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>×</mo>
                <mrow></mrow>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \times{}a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>へ戻る射として定義できる。一般の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>項演算は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>乗から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>への射だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>α</mi>
                  <mi>n</mi>
                </msub>
                <mo>∷</mo>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">\alpha_n \Colon a^n \to a</annotation>
            </semantics>
          </math></p>
        <p>零項演算は、終対象
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の0乗)
          からの射だ。したがって、あらゆる代数を定義するために必要なのはある圏だけで、その圏の対象は1つの特別な対象<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の冪乗だ。特定の代数は、この圏のhom集合として符号化されている。これがローヴェア・セオリーの概略だ。</p>
        <p>ローヴェア・セオリーの導出は多くのステップを経るため、道順を示しておく:</p>
        <ol type="1">
          <li>有限集合の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>𝐅</mi>
                  <mi>𝐢</mi>
                  <mi>𝐧</mi>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <annotation encoding="application/x-tex">\mathbf{FinSet}</annotation>
              </semantics>
            </math>。</li>
          <li>そのスケルトン<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>𝐅</mi>
                <annotation encoding="application/x-tex">\mathbf{F}</annotation>
              </semantics>
            </math>。</li>
          <li>その反対圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <msup>
                  <mi>𝐅</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation>
              </semantics>
            </math>。</li>
          <li>ローヴェア・セオリー<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>𝐋</mi>
                <annotation encoding="application/x-tex">\mathbf{L}</annotation>
              </semantics>
            </math>:
            圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>𝐋</mi>
                  <mi>𝐚</mi>
                  <mi>𝐰</mi>
                </mrow>
                <annotation encoding="application/x-tex">\mathbf{Law}</annotation>
              </semantics>
            </math>内のある対象。</li>
          <li>ローヴェア圏のモデル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>M</mi>
                <annotation encoding="application/x-tex">M</annotation>
              </semantics>
            </math>:
            圏
            <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mrow>
                    <mi>𝐌</mi>
                    <mi>𝐨</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mrow>
                      <mi>𝐋</mi>
                      <mi>𝐚</mi>
                      <mi>𝐰</mi>
                    </mrow>
                    <mo>,</mo>
                    <mrow>
                      <mi>𝐒</mi>
                      <mi>𝐞</mi>
                      <mi>𝐭</mi>
                    </mrow>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                </mrow>
                <annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{Law},\mathbf{Set})</annotation>
              </semantics>
            </math>
            内のある対象。
          </li>
        </ol>
        <p><img src="images/lawvere1.png" style="width:80.0%" /></p>
        <h2 data-number="30.2" id="ローヴェアセオリー-1"><span class="header-section-number">30.2</span> ローヴェア・セオリー</h2>
        <p>複数あるローヴェア・セオリーはすべて共通のバックボーンを共有している。ローヴェア・セオリーにおけるすべての対象は、ただ1つの対象から積を使って生成される
          (実際に、ただの冪乗だ)。しかし、一般の圏では、これらの積をどのように定義するのだろうか？
          より単純な圏からの写像を使って積を定義できることが知られている。事実として、このより単純な圏は積ではなく余積を定義する可能性があり、その場合は<em>反変</em>関手を使ってそれらを終域圏に埋め込む。反変関手は、余積を積に変換し、単射を射影に変換する。
        </p>
        <p>ローヴェア圏のバックボーンとして自然な選択肢は、有限集合の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐅</mi>
                <mi>𝐢</mi>
                <mi>𝐧</mi>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{FinSet}</annotation>
            </semantics>
          </math>だ。これは空集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>⌀</mi>
              <annotation encoding="application/x-tex">\varnothing</annotation>
            </semantics>
          </math>、単集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>、2要素集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>などを含む。この圏の対象はすべて、余積を使って単集合から生成できる
          (空集合は零項余積の特殊なケースとして扱う)。たとえば、2要素集合は2つの単集合の和<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>2</mn>
                <mo>=</mo>
                <mn>1</mn>
                <mo>+</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">2 = 1 + 1</annotation>
            </semantics>
          </math>だ。Haskellでも次のように表現される:</p>
        <div class="sourceCode" id="cb594">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb594-1"><a href="#cb594-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Two</span> <span class="ot">=</span> <span class="dt">Either</span> () ()</span></code></pre>
        </div>
        <p>しかし、空集合は1つしかないと考えるのが自然だとしても、単集合は異なるものが多数存在してよい。典型的な例として、集合<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>1</mn>
                <mo>+</mo>
                <mi>⌀</mi>
              </mrow>
              <annotation encoding="application/x-tex">1 + \varnothing</annotation>
            </semantics>
          </math>と集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>⌀</mi>
                <mo>+</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">\varnothing + 1</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>はすべて同型であるにもかかわらず、それぞれ異なる。集合の圏の余積は結合則を満たさない。この状況を解決するには、すべての同型集合を同一視する圏を構成すればよい。そのような圏は<span
            id="skeleton" class="keyword">スケルトン</span> (skeleton)
          と呼ばれる。言い換えれば、すべてのローヴェア・セオリーのバックボーンは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐅</mi>
                <mi>𝐢</mi>
                <mi>𝐧</mi>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{FinSet}</annotation>
            </semantics>
          </math>のスケルトン<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>だ。この圏の対象は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐅</mi>
                <mi>𝐢</mi>
                <mi>𝐧</mi>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{FinSet}</annotation>
            </semantics>
          </math>の要素数に対応した
          (0を含む)
          自然数と同一視できる。余積は加算の役目を果たす。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>内の射は有限集合間の関数に対応する。例として、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>⌀</mi>
              <annotation encoding="application/x-tex">\varnothing</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>への
          (空集合を始対象とする)
          一意な射があり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>⌀</mi>
              <annotation encoding="application/x-tex">\varnothing</annotation>
            </semantics>
          </math>への射は
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>⌀</mi>
                <mo>→</mo>
                <mi>⌀</mi>
              </mrow>
              <annotation encoding="application/x-tex">\varnothing \to \varnothing</annotation>
            </semantics>
          </math>を除いて)
          なく、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>への射
          (単射)
          は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>あり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>への射は1つある、などが挙げられる。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>内のある対象を表し、同型によって同一視された<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐅</mi>
                <mi>𝐢</mi>
                <mi>𝐧</mi>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{FinSet}</annotation>
            </semantics>
          </math>内のすべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>要素集合に対応する。</p>
        <p>圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>を使うと、<span id="Lawvere_theory" class="keyword">ローヴェア・セオリー</span>を、次の特別な関手を伴う圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>として形式的に定義できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>I</mi>
                  <mi>𝐋</mi>
                </msub>
                <mo>∷</mo>
                <msup>
                  <mi>𝐅</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>→</mo>
                <mi>𝐋</mi>
              </mrow>
              <annotation encoding="application/x-tex">I_{\mathbf{L}} \Colon \mathbf{F}^\mathit{op}\to \mathbf{L}
              </annotation>
            </semantics>
          </math></p>
        <p>この関手は対象の全単射である必要があり、有限積を保存する必要がある
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐅</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation>
            </semantics>
          </math>内の積と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>内の余積は同じだ):</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>I</mi>
                  <mi>𝐋</mi>
                </msub>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>m</mi>
                  <mo>×</mo>
                  <mrow></mrow>
                  <mi>n</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>=</mo>
                <msub>
                  <mi>I</mi>
                  <mi>𝐋</mi>
                </msub>
                <mspace width="0.222em"></mspace>
                <mi>m</mi>
                <mo>×</mo>
                <mrow></mrow>
                <msub>
                  <mi>I</mi>
                  <mi>𝐋</mi>
                </msub>
                <mspace width="0.222em"></mspace>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">I_{\mathbf{L}}\ (m\times{}n) = I_{\mathbf{L}}\
                m\times{}I_{\mathbf{L}}\ n</annotation>
            </semantics>
          </math></p>
        <p>この関手は対象における恒等関係と見なされることがある。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>内と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内とで対象が同じであることを表すからだ。そこで、これらに同じ名前を使うことにし、自然数で表そう。ただし、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>内の対象は集合と同じではないことに注意してほしい
          (それらは同型集合のクラスだ)。</p>
        <p>一般に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内のhom集合は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐅</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation>
            </semantics>
          </math>内のhom集合よりも豊穣だ。これらは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐅</mi>
                <mi>𝐢</mi>
                <mi>𝐧</mi>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{FinSet}</annotation>
            </semantics>
          </math>内の関数に対応する射以外の射も含むことがある
          (後者は<span id="basic_product_operation" class="keyword">基本的な積操作</span> (basic product operation)
          とも呼ばれる)。ローヴェア・セオリーの等式的規則はそれらの射へ符号化されている。</p>
        <p>鍵となる観察は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>内の単集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内で同じく<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>と呼ばれる対象に写され、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内の他のすべての対象が自動的にこの対象の冪乗になることだ。たとえば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>内の2要素集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>は余積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>1</mn>
                <mo>+</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">1+1</annotation>
            </semantics>
          </math>であるため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内の積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>1</mn>
                <mo>×</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">1 \times 1</annotation>
            </semantics>
          </math>
          (または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mn>1</mn>
                <mn>2</mn>
              </msup>
              <annotation encoding="application/x-tex">1^2</annotation>
            </semantics>
          </math>)
          に写される必要がある。この意味で、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>の対数のように振る舞う。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内の射には、関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>I</mi>
                <mi>𝐋</mi>
              </msub>
              <annotation encoding="application/x-tex">I_{\mathbf{L}}</annotation>
            </semantics>
          </math>によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>から転送されたものもある。それらは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>で構造としての役目を果たす。特に、余積単射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>i</mi>
                <mi>k</mi>
              </msub>
              <annotation encoding="application/x-tex">i_k</annotation>
            </semantics>
          </math>は積射影<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>p</mi>
                <mi>k</mi>
              </msub>
              <annotation encoding="application/x-tex">p_k</annotation>
            </semantics>
          </math>になる。直観として有用なのは、射影:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>p</mi>
                  <mi>k</mi>
                </msub>
                <mo>∷</mo>
                <msup>
                  <mn>1</mn>
                  <mi>n</mi>
                </msup>
                <mo>→</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">p_k \Colon 1^n \to 1</annotation>
            </semantics>
          </math></p>
        <p>を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>個の変数のうち第<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>k</mi>
              <annotation encoding="application/x-tex">k</annotation>
            </semantics>
          </math>番目以外のすべてを無視するような関数のプロトタイプとして想像することだ。逆に、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>内の定常射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>n</mi>
                <mo>→</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">n \to 1</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内では対角射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>1</mn>
                <mo>→</mo>
                <msup>
                  <mn>1</mn>
                  <mi>n</mi>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">1 \to 1^n</annotation>
            </semantics>
          </math>になる。これらは変数の複製に相当する。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内の射のうちで興味深いのは、射影以外の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>項演算を定義するものだ。それらの射によって、あるローヴェア・セオリーと別のものとが区別される。それらは乗算・加算・単位元の選択などで、代数を定義する。しかし、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>を完全な圏にするためには、複合操作<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>n</mi>
                <mo>→</mo>
                <mi>m</mi>
              </mrow>
              <annotation encoding="application/x-tex">n \to m</annotation>
            </semantics>
          </math>
          (あるいは、等価なものとして、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mn>1</mn>
                  <mi>n</mi>
                </msup>
                <mo>→</mo>
                <msup>
                  <mn>1</mn>
                  <mi>m</mi>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">1^n \to 1^m</annotation>
            </semantics>
          </math>)
          も必要だ。圏の構造が単純なため、これらは型<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>n</mi>
                <mo>→</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">n \to 1</annotation>
            </semantics>
          </math>のより単純な射の積だとわかる。これは、積を返す関数は関数の積である
          (あるいは、前に見たように、hom関手は連続である)
          という言明を一般化したものだ。</p>
        <p><img src="images/lawvere1.png" style="width:80.0%" /></p>
        <p>ローヴェア・セオリー<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐅</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation>
            </semantics>
          </math>に基づいており、積を定義する「退屈な」射はそこから継承されている。それは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>項操作
          (点線の矢印) を記述するような「興味深い」射を追加する。</p>
        <p>ローヴェア・セオリーは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mi>𝐚</mi>
                <mi>𝐰</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Law}</annotation>
            </semantics>
          </math>を形成する。この圏の射は関手であり、有限積を保存し関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>I</mi>
              <annotation encoding="application/x-tex">I</annotation>
            </semantics>
          </math>と可換だ。このような2つのセオリー
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>𝐋</mi>
                <mo>,</mo>
                <msub>
                  <mi>I</mi>
                  <mi>𝐋</mi>
                </msub>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(\mathbf{L}, I_{\mathbf{L}})</annotation>
            </semantics>
          </math>
          と
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mrow>
                  <mi>𝐋</mi>
                  <mi mathvariant="bold">′</mi>
                </mrow>
                <mo>,</mo>
                <mi>I</mi>
                <msub>
                  <mi>′</mi>
                  <mrow>
                    <mi>𝐋</mi>
                    <mi mathvariant="bold">′</mi>
                  </mrow>
                </msub>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(\mathbf{L&#39;}, I&#39;_{\mathbf{L&#39;}})</annotation>
            </semantics>
          </math>
          が与えられた場合、それらの間の射は関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mo>∷</mo>
                <mi>𝐋</mi>
                <mo>→</mo>
                <mrow>
                  <mi>𝐋</mi>
                  <mi mathvariant="bold">′</mi>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">F \Colon \mathbf{L} \to \mathbf{L&#39;}</annotation>
            </semantics>
          </math>となり、次のようになる:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>F</mi>
                    <mspace width="0.222em"></mspace>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>m</mi>
                      <mo>×</mo>
                      <mi>n</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                    <mo>=</mo>
                    <mi>F</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>m</mi>
                    <mo>×</mo>
                    <mi>F</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>n</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>F</mi>
                    <mo>∘</mo>
                    <msub>
                      <mi>I</mi>
                      <mi>𝐋</mi>
                    </msub>
                    <mo>=</mo>
                    <mi>I</mi>
                    <msub>
                      <mi>′</mi>
                      <mrow>
                        <mi>𝐋</mi>
                        <mi mathvariant="bold">′</mi>
                      </mrow>
                    </msub>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                F\ (m \times n) = F\ m \times F\ n \\
                F \circ I_{\mathbf{L}} = I&#39;_{\mathbf{L&#39;}}
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>ローヴェア・セオリーの間の射は、あるセオリーの解釈の考え方を別のセオリーの中へ封入する。たとえば、群の乗算は、逆を無視すれば、モノイドの乗算と解釈できる。</p>
        <p>ローヴェア圏の最も単純で自明な例は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐅</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation>
            </semantics>
          </math>自体だ
          (これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>I</mi>
                <mi>𝐋</mi>
              </msub>
              <annotation encoding="application/x-tex">I_{\mathbf{L}}</annotation>
            </semantics>
          </math>についての恒等関手の選択に対応する)。演算や規則を持たないこのローヴェア・セオリーは、たまたま<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mi>𝐚</mi>
                <mi>𝐰</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Law}</annotation>
            </semantics>
          </math>の始対象でもある。</p>
        <p>この時点でローヴェア・セオリーの自明でない例を示せば非常に有益だろうが、モデルとは何かを先に理解しておかなければ、説明が困難だ。</p>
        <h2 data-number="30.3" id="ローヴェアセオリーにおけるモデル"><span class="header-section-number">30.3</span>
          ローヴェア・セオリーにおけるモデル</h2>
        <p>
          ローヴェア・セオリーを理解するための鍵は、ある1つのセオリーは同じ構造を共有する多くの個別の代数を一般化している、と理解することだ。たとえば、モノイドのローヴェア・セオリーは、モノイドであることの本質を説明している。それはすべてのモノイドで有効である必要がある。特定のモノイドはそのようなセオリーのモデルとなる。あるモデルは、ローヴェア・セオリー<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>から集合の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への関手として定義される。(モデルに他の圏を使う一般化されたローヴェア・セオリーもあるが、ここでは<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>のみ説明する。)
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>の構造は積に大きく依存するため、そのような関手は有限積を保存する必要がある。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>のモデルは、ローヴェア・セオリー<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>の上の代数とも呼ばれ、次の関手によって定義される:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>M</mi>
                    <mo>∷</mo>
                    <mi>𝐋</mi>
                    <mo>→</mo>
                    <mrow>
                      <mi>𝐒</mi>
                      <mi>𝐞</mi>
                      <mi>𝐭</mi>
                    </mrow>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>M</mi>
                    <mspace width="0.222em"></mspace>
                    <mrow>
                      <mo stretchy="true" form="prefix">(</mo>
                      <mi>a</mi>
                      <mo>×</mo>
                      <mi>b</mi>
                      <mo stretchy="true" form="postfix">)</mo>
                    </mrow>
                    <mo>≅</mo>
                    <mi>M</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>a</mi>
                    <mo>×</mo>
                    <mi>M</mi>
                    <mspace width="0.222em"></mspace>
                    <mi>b</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                M \Colon \mathbf{L} \to \mathbf{Set}\\
                M\ (a \times b) \cong M\ a \times M\ b
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>積の保存は<em>同型を除いて</em>のみ必要であることに注意してほしい。これは非常に重要だ。なぜなら、積を厳密に保存すると、ほとんどの興味深いセオリーが棄却されるからだ。</p>
        <p>モデルによる積の保存とは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>M</mi>
              <annotation encoding="application/x-tex">M</annotation>
            </semantics>
          </math>の像が、集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>M</mi>
                <mspace width="0.222em"></mspace>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">M\ 1</annotation>
            </semantics>
          </math>――<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>からの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>の像――の冪乗によって生成された一連の集合であることを意味する。この集合を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と呼ぼう。(この集合は<em>ソート</em>
          (sort) と呼ばれることがあり、このような代数は<span id="single-sorted" class="keyword">シングルソート</span> (single-sorted)
          と呼ばれる。ローヴェア・セオリーのマルチソート代数 (multi-sorted
          algebra) への一般化も存在する。)
          特に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>からの二項演算は次の関数に写される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>×</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \times a \to a</annotation>
            </semantics>
          </math></p>
        <p>あらゆる関手と同じく、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内の複数の射が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内の同じ関数に潰されることがある。</p>
        <p>ちなみに、すべての規則は全称量化された等価性であるという事実は、すべてのローヴェア・セオリーが自明なモデルを持つことを意味する:
          恒等射は、すべての対象を単集合に写し、すべての射をその上の定関数に写す。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mo>→</mo>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">m \to n</annotation>
            </semantics>
          </math>という形式の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内の一般の射は、次の関数に写される:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>a</mi>
                  <mi>m</mi>
                </msup>
                <mo>→</mo>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">a^m \to a^n</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>M</mi>
              <annotation encoding="application/x-tex">M</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>N</mi>
              <annotation encoding="application/x-tex">N</annotation>
            </semantics>
          </math>という2つの異なるモデルがある場合、それらの間の自然変換は、添字<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>が付けられた関数の族になる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>μ</mi>
                  <mi>n</mi>
                </msub>
                <mo>∷</mo>
                <mi>M</mi>
                <mspace width="0.222em"></mspace>
                <mi>n</mi>
                <mo>→</mo>
                <mi>N</mi>
                <mspace width="0.222em"></mspace>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mu_n \Colon M\ n \to N\ n</annotation>
            </semantics>
          </math></p>
        <p>または、等価なものとして:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>μ</mi>
                  <mi>n</mi>
                </msub>
                <mo>∷</mo>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
                <mo>→</mo>
                <msup>
                  <mi>b</mi>
                  <mi>n</mi>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">\mu_n \Colon a^n \to b^n</annotation>
            </semantics>
          </math></p>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>b</mi>
                <mo>=</mo>
                <mi>N</mi>
                <mspace width="0.222em"></mspace>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">b = N\ 1</annotation>
            </semantics>
          </math>だ。</p>
        <p>自然条件によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>項演算の保存が保証されることに注意してほしい:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>N</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
                <mo>∘</mo>
                <msub>
                  <mi>μ</mi>
                  <mi>n</mi>
                </msub>
                <mo>=</mo>
                <msub>
                  <mi>μ</mi>
                  <mn>1</mn>
                </msub>
                <mo>∘</mo>
                <mi>M</mi>
                <mspace width="0.222em"></mspace>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">N\ f \circ \mu_n = \mu_1 \circ M\ f</annotation>
            </semantics>
          </math></p>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>n</mi>
                <mo>→</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon n \to 1</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>における<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>項演算だ。</p>
        <p>モデルを定義する関数は、モデルの圏である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐋</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L}, \mathbf{Set})</annotation>
            </semantics>
          </math>
          を、射としての自然変換を伴って形成する。</p>
        <p>自明なローヴェア圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐅</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation>
            </semantics>
          </math>のモデルを考えてみよう。そのようなモデルは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>での値<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>M</mi>
                <mspace width="0.222em"></mspace>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">M\ 1</annotation>
            </semantics>
          </math>によって完全に決定される。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>M</mi>
                <mspace width="0.222em"></mspace>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">M\ 1</annotation>
            </semantics>
          </math>は任意の集合でよいため、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>が含む集合と同じ数のモデルがある。さらに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msup>
                    <mi>𝐅</mi>
                    <mrow>
                      <mi>𝑜</mi>
                      <mi>𝑝</mi>
                    </mrow>
                  </msup>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{F}^\mathit{op}, \mathbf{Set})</annotation>
            </semantics>
          </math>
          内のすべての射
          (関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>M</mi>
              <annotation encoding="application/x-tex">M</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>N</mi>
              <annotation encoding="application/x-tex">N</annotation>
            </semantics>
          </math>の間の自然変換)
          は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>M</mi>
                <mspace width="0.222em"></mspace>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">M\ 1</annotation>
            </semantics>
          </math>におけるコンポーネントによって一意に決定される。逆に、すべての関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>M</mi>
                <mspace width="0.222em"></mspace>
                <mn>1</mn>
                <mo>→</mo>
                <mi>N</mi>
                <mspace width="0.222em"></mspace>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">M\ 1 \to N\ 1</annotation>
            </semantics>
          </math>は、2つのモデル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>M</mi>
              <annotation encoding="application/x-tex">M</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>N</mi>
              <annotation encoding="application/x-tex">N</annotation>
            </semantics>
          </math>の間に自然変換を引き起こす。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msup>
                    <mi>𝐅</mi>
                    <mrow>
                      <mi>𝑜</mi>
                      <mi>𝑝</mi>
                    </mrow>
                  </msup>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{F}^\mathit{op}, \mathbf{Set})</annotation>
            </semantics>
          </math>
          は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>と同値だ。</p>
        <h2 data-number="30.4" id="モノイドのセオリー"><span class="header-section-number">30.4</span> モノイドのセオリー</h2>
        <p>ローヴェア・セオリーの最も単純で重要な例は、モノイドの構造を記述することだ。それは、すべての可能なモノイドの構造を抽出した単一のセオリーだ。つまり、そのモデルはモノイドの圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>全体に及ぶ。すでに述べた<a
            href="#free-monoids">普遍的構成</a>は、射の部分集合を同一視すれば、すべてのモノイドが適切な自由モノイドから得られることを示していた。したがって、1つの自由モノイドですべてのモノイドがすでに一般化されている。しかし、自由モノイドは無数に存在する。モノイドに対するローヴェア・セオリー<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>𝐋</mi>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐧</mi>
                </mrow>
              </msub>
              <annotation encoding="application/x-tex">\mathbf{L}_{\mathbf{Mon}}</annotation>
            </semantics>
          </math>は、それらすべてを1つのエレガントな構成にまとめる。</p>
        <p>すべてのモノイドには単位が必要なので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>𝐋</mi>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐧</mi>
                </mrow>
              </msub>
              <annotation encoding="application/x-tex">\mathbf{L}_{\mathbf{Mon}}</annotation>
            </semantics>
          </math>内には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>への特別な射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>が必要だ。これに対応する射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>内にはないことに注意してほしい。そのような射の存在を仮定すると、逆向きの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>への射になるので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐅</mi>
                <mi>𝐢</mi>
                <mi>𝐧</mi>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{FinSet}</annotation>
            </semantics>
          </math>内では、単集合から空集合への関数になるだろう。しかし、そのような関数は存在しない。</p>
        <p>次に、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>2</mn>
                <mo>→</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">2 \to 1</annotation>
            </semantics>
          </math>を考える。これは、すべての二項演算のプロトタイプを含む<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>𝐋</mi>
                  <mrow>
                    <mi>𝐌</mi>
                    <mi>𝐨</mi>
                    <mi>𝐧</mi>
                  </mrow>
                </msub>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>2</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}_{\mathbf{Mon}}(2, 1)</annotation>
            </semantics>
          </math>
          のメンバーだ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>𝐋</mi>
                    <mrow>
                      <mi>𝐌</mi>
                      <mi>𝐨</mi>
                      <mi>𝐧</mi>
                    </mrow>
                  </msub>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L}_{\mathbf{Mon}}, \mathbf{Set})
              </annotation>
            </semantics>
          </math>
          のモデルを構成するとき、これらの射はカルテシアン積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>M</mi>
                <mspace width="0.222em"></mspace>
                <mn>1</mn>
                <mo>×</mo>
                <mi>M</mi>
                <mspace width="0.222em"></mspace>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">M\ 1 \times M\ 1</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>M</mi>
                <mspace width="0.222em"></mspace>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">M\ 1</annotation>
            </semantics>
          </math>への関数に写される。言い換えると、引数2つを取る関数になる。</p>
        <p>問題は、モノイダル演算子のみを使って何種類の2引数関数を実装できるかだ。2つの引数を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>と呼ぼう。両方の引数を無視してモノイダル単位を返す関数が1つある。それから、それぞれ<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>を返す2つの射影がある。さらに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mi>b</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mi>a</mi>
                <mo>,</mo>
                <mi>a</mi>
                <mi>a</mi>
                <mo>,</mo>
                <mi>b</mi>
                <mi>b</mi>
                <mo>,</mo>
                <mi>a</mi>
                <mi>a</mi>
                <mi>b</mi>
                <mo>,</mo>
                <mi>…</mi>
              </mrow>
              <annotation encoding="application/x-tex">ab, ba, aa, bb, aab, \ldots</annotation>
            </semantics>
          </math>などを返す関数が続く。実際には、このような2引数関数は、生成元<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>を伴う自由モノイドの要素と同じ数だけ存在する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>𝐋</mi>
                  <mrow>
                    <mi>𝐌</mi>
                    <mi>𝐨</mi>
                    <mi>𝐧</mi>
                  </mrow>
                </msub>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>2</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}_{\mathbf{Mon}}(2, 1)</annotation>
            </semantics>
          </math>
          はモデルの1つが自由モノイドであるため、これらすべての射を含む必要があることに注意してほしい。自由モノイドでは、これらは別々の関数に対応する。他のモデルでは<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>𝐋</mi>
                  <mrow>
                    <mi>𝐌</mi>
                    <mi>𝐨</mi>
                    <mi>𝐧</mi>
                  </mrow>
                </msub>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>2</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}_{\mathbf{Mon}}(2, 1)</annotation>
            </semantics>
          </math>
          の複数の射が1つの関数へと潰される場合があるが、自由モノイドではそうならない。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>個の生成元<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>n</mi>
                <mo>*</mo>
              </msup>
              <annotation encoding="application/x-tex">n^*</annotation>
            </semantics>
          </math>を使って自由モノイドを表せば、hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>2</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(2, 1)</annotation>
            </semantics>
          </math>
          を、モノイドの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>内のhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐧</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msup>
                    <mn>1</mn>
                    <mo>*</mo>
                  </msup>
                  <mo>,</mo>
                  <msup>
                    <mn>2</mn>
                    <mo>*</mo>
                  </msup>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}(1^*, 2^*)</annotation>
            </semantics>
          </math>
          と同一視できる。一般に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>𝐋</mi>
                  <mrow>
                    <mi>𝐌</mi>
                    <mi>𝐨</mi>
                    <mi>𝐧</mi>
                  </mrow>
                </msub>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>m</mi>
                  <mo>,</mo>
                  <mi>n</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}_{\mathbf{Mon}}(m, n)</annotation>
            </semantics>
          </math>
          を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐧</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msup>
                    <mi>n</mi>
                    <mo>*</mo>
                  </msup>
                  <mo>,</mo>
                  <msup>
                    <mi>m</mi>
                    <mo>*</mo>
                  </msup>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}(n^*, m^*)</annotation>
            </semantics>
          </math>
          とできる。言い換えると、圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>𝐋</mi>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐧</mi>
                </mrow>
              </msub>
              <annotation encoding="application/x-tex">\mathbf{L}_{\mathbf{Mon}}</annotation>
            </semantics>
          </math>は自由モノイドの圏の逆だ。</p>
        <p>モノイドに関するローヴェア・セオリーの<em>モデル</em>の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msub>
                    <mi>𝐋</mi>
                    <mrow>
                      <mi>𝐌</mi>
                      <mi>𝐨</mi>
                      <mi>𝐧</mi>
                    </mrow>
                  </msub>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L}_{\mathbf{Mon}}, \mathbf{Set})
              </annotation>
            </semantics>
          </math>
          は、すべてのモノイドの圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐌</mi>
                <mi>𝐨</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mon}</annotation>
            </semantics>
          </math>と等価だ。</p>
        <h2 data-number="30.5" id="ローヴェアセオリーとモナド"><span class="header-section-number">30.5</span>
          ローヴェア・セオリーとモナド</h2>
        <p>覚えていると思うが、代数のセオリーはモナドを使って――特に<a
            href="#algebras-for-monads">モナドの代数</a>で――記述できる。ローヴェア・セオリーとモナドがつながっているのは驚くべきことではない。</p>
        <p>まず、ローヴェア・セオリーからモナドがどのように導出されるかを見てみよう。導出は忘却関手と自由関手の間の<a href="#freeforgetful-adjunctions">随伴</a>を経る。忘却関手<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>U</mi>
              <annotation encoding="application/x-tex">U</annotation>
            </semantics>
          </math>は、ある集合を各モデルに割り当てる。その集合は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐋</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L}, \mathbf{Set})</annotation>
            </semantics>
          </math>
          からの関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>M</mi>
              <annotation encoding="application/x-tex">M</annotation>
            </semantics>
          </math>を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内の対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>において評価することで得られる。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>U</mi>
              <annotation encoding="application/x-tex">U</annotation>
            </semantics>
          </math>を導出するもう1つの方法は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐅</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation>
            </semantics>
          </math>が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mi>𝐚</mi>
                <mi>𝐰</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Law}</annotation>
            </semantics>
          </math>の始対象であるという事実を利用することだ。これは、すべてのローヴェア・セオリー<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>に対し、一意な関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>𝐅</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>→</mo>
                <mi>𝐋</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}\to \mathbf{L}</annotation>
            </semantics>
          </math>があることを意味する。この関手は、モデル上に逆向きの関手を引き起こす
          (モデルはセオリー<em>から</em>集合への関手だからだ):</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐋</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <msup>
                    <mi>𝐅</mi>
                    <mrow>
                      <mi>𝑜</mi>
                      <mi>𝑝</mi>
                    </mrow>
                  </msup>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L}, \mathbf{Set}) \to
                \mathbf{Mod}(\mathbf{F}^\mathit{op}, \mathbf{Set})</annotation>
            </semantics>
          </math></p>
        <p>ただし、すでに議論したように、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐅</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation>
            </semantics>
          </math>のモデルの圏は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>と同値だ。したがって、次の忘却関手が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>U</mi>
                <mo>∷</mo>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐋</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">U \Colon \mathbf{Mod}(\mathbf{L}, \mathbf{Set}) \to \mathbf{Set}
              </annotation>
            </semantics>
          </math></p>
        <p>このように定義された<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>U</mi>
              <annotation encoding="application/x-tex">U</annotation>
            </semantics>
          </math>は左随伴としての自由関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>を常に持つことが示せる。</p>
        <p>このことは有限集合の場合には容易に分かる。自由関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>は自由代数を生成する。自由代数は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐋</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L}, \mathbf{Set})</annotation>
            </semantics>
          </math>
          内の特定のモデルであり、生成元の有限集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>から生成される。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>F</mi>
              <annotation encoding="application/x-tex">F</annotation>
            </semantics>
          </math>は表現可能関手として実装できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mo>−</mo>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>∷</mo>
                <mi>𝐋</mi>
                <mo>→</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(n, -) \Colon \mathbf{L} \to \mathbf{Set}</annotation>
            </semantics>
          </math></p>
        <p>これが本当に自由であることを示すには、忘却関手への左随伴であることさえ証明すればよい:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐌</mi>
                  <mi>𝐨</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐋</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>n</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>M</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mi>U</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>M</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Mod}(\mathbf{L}(n, -), M) \cong \mathbf{Set}(n, U(M))
              </annotation>
            </semantics>
          </math></p>
        <p>右辺を単純化しよう:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mi>U</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>M</mi>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mi>M</mi>
                  <mspace width="0.222em"></mspace>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <msup>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>M</mi>
                    <mspace width="0.222em"></mspace>
                    <mn>1</mn>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mi>n</mi>
                </msup>
                <mo>≅</mo>
                <mi>M</mi>
                <mspace width="0.222em"></mspace>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}(n, U(M)) \cong \mathbf{Set}(n, M\ 1) \cong (M\ 1)^n
                \cong M\ n</annotation>
            </semantics>
          </math></p>
        <p>(射の集合が冪乗と同型であり、ここでは単に積の反復であるという事実を使った。)
          随伴は米田の補題の結果だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">[</mo>
                  <mi>𝐋</mi>
                  <mo>,</mo>
                  <mrow>
                    <mi>𝐒</mi>
                    <mi>𝐞</mi>
                    <mi>𝐭</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">]</mo>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>𝐋</mi>
                  <mrow>
                    <mo stretchy="true" form="prefix">(</mo>
                    <mi>n</mi>
                    <mo>,</mo>
                    <mo>−</mo>
                    <mo stretchy="true" form="postfix">)</mo>
                  </mrow>
                  <mo>,</mo>
                  <mi>M</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>≅</mo>
                <mi>M</mi>
                <mspace width="0.222em"></mspace>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">[\mathbf{L}, \mathbf{Set}](\mathbf{L}(n, -), M) \cong M\ n
              </annotation>
            </semantics>
          </math></p>
        <p>まとめると、忘却関手と自由関手によって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>上の<a href="#monads-categorically">モナド</a><math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mo>=</mo>
                <mi>U</mi>
                <mo>∘</mo>
                <mi>F</mi>
              </mrow>
              <annotation encoding="application/x-tex">T = U \circ F</annotation>
            </semantics>
          </math>が定義される。したがって、すべてのローヴェア・セオリーはモナドを生成する。</p>
        <p>モデルに対する<a href="#algebras-for-monads">モナドの代数</a>の圏はモデルの圏と同値であることが分かる。</p>
        <p>モナドを使って形成された式の評価方法はモナド代数によって定義されるのを思い出しただろう。ローヴェア・セオリーは、式の生成に使えるn項演算を定義する。モデルは、それらの式を評価する手段を提供する。</p>
        <p>しかし、モナドとローヴェア・セオリーは双方向の関係にはない。有限的モナド
          (finitary monad)
          からのみローヴェア・セオリーが導出される。有限的モナドは有限的関手に基づく。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>上のある有限的関手は、有限集合への作用によって完全に決定される。任意の集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>への作用は、次のコエンドを使って評価できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>=</mo>
                <msup>
                  <mo>∫</mo>
                  <mi>n</mi>
                </msup>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
                <mo>×</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>F</mi>
                  <mspace width="0.222em"></mspace>
                  <mi>n</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">F\ a = \int^n a^n \times (F\ n)</annotation>
            </semantics>
          </math></p>
        <p>コエンドは余積すなわち和の一般化なので、この式は冪級数展開の一般化になる。あるいは、関手は一般化したコンテナだ、という直観に頼ってもよい。その場合、<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の有限的コンテナは、形と内容の和として記述できる。ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>F</mi>
                <mspace width="0.222em"></mspace>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">F\ n</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>個の要素を格納するための形の集合だ。また、内容は要素の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>タプルであり、それ自体が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>a</mi>
                <mi>n</mi>
              </msup>
              <annotation encoding="application/x-tex">a^n</annotation>
            </semantics>
          </math>の要素だ。たとえば、(関手としての)
          リストは有限的であり、アリティごとに1つの形を持つ。木はアリティごとにより多くの形を持つ、なども挙げられる。</p>
        <p>まず第一に、ローヴェア・セオリーから生成されたすべてのモナドは有限的であり、コエンドとして表せる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>T</mi>
                  <mi>𝐋</mi>
                </msub>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>=</mo>
                <msup>
                  <mo>∫</mo>
                  <mi>n</mi>
                </msup>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
                <mo>×</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">T_{\mathbf{L}}\ a = \int^n a^n \times \mathbf{L}(n, 1)
              </annotation>
            </semantics>
          </math></p>
        <p>逆に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>上の任意の有限的モナド<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>に対してローヴェア・セオリーを構築できる。まず、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>についてのKleisli圏を構築する。覚えていると思うが、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>へのKleisli圏内の射は、台となる圏内の射によって与えられる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>→</mo>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">a \to T\ b</annotation>
            </semantics>
          </math></p>
        <p>有限集合に限定すると、これは次のようになる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mo>→</mo>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">m \to T\ n</annotation>
            </semantics>
          </math></p>
        <p>このKleisli圏の有限集合に限定された反対圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msubsup>
                <mrow>
                  <mi>𝐊</mi>
                  <mi>𝐥</mi>
                </mrow>
                <mi>T</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msubsup>
              <annotation encoding="application/x-tex">\mathbf{Kl}^\mathit{op}_{T}</annotation>
            </semantics>
          </math>こそ、求めていたローヴェア・セオリーだ。特に、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内のn項演算を記述するhom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation>
            </semantics>
          </math>
          は、hom集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mrow>
                    <mi>𝐊</mi>
                    <mi>𝐥</mi>
                  </mrow>
                  <mi>T</mi>
                </msub>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>1</mn>
                  <mo>,</mo>
                  <mi>n</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Kl}_{T}(1, n)</annotation>
            </semantics>
          </math>
          によって与えられる。</p>
        <p>プログラミングで遭遇するほとんどのモナドは有限的モナドであることが知られている。ただし、継続モナドという注目すべき例外は除く。ローヴェア・セオリーの概念は、有限的演算を超えて拡張することも可能だ。</p>
        <h2 data-number="30.6" id="コエンドとしてのモナド"><span class="header-section-number">30.6</span> コエンドとしてのモナド</h2>
        <p>コエンドの式について詳しく見ていこう。</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>T</mi>
                  <mi>𝐋</mi>
                </msub>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>=</mo>
                <msup>
                  <mo>∫</mo>
                  <mi>n</mi>
                </msup>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
                <mo>×</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">T_{\mathbf{L}}\ a = \int^n a^n \times \mathbf{L}(n, 1)
              </annotation>
            </semantics>
          </math></p>
        <p>まず、このコエンドは、次のように定義された<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>内のプロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>P</mi>
              <annotation encoding="application/x-tex">P</annotation>
            </semantics>
          </math>に置き換えられる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>P</mi>
                <mspace width="0.222em"></mspace>
                <mi>n</mi>
                <mspace width="0.222em"></mspace>
                <mi>m</mi>
                <mo>=</mo>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
                <mo>×</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>m</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">P\ n\ m = a^n \times \mathbf{L}(m, 1)</annotation>
            </semantics>
          </math></p>
        <p>このプロ関手は最初の引数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>について反変だ。これが射をどうリフトするかを考えよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐅</mi>
                <mi>𝐢</mi>
                <mi>𝐧</mi>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{FinSet}</annotation>
            </semantics>
          </math>内の射は有限集合の間の写像<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>m</mi>
                <mo>→</mo>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon m \to n</annotation>
            </semantics>
          </math>だ。このような写像は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>要素の集合から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>要素を
          (重複は許容して)
          選ぶことを表している。つまり、次のように<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の冪乗の写像へリフトできる
          (方向に注意してほしい):</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
                <mo>→</mo>
                <msup>
                  <mi>a</mi>
                  <mi>m</mi>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">a^n \to a^m</annotation>
            </semantics>
          </math></p>
        <p>このリフトでは、単純に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>要素タプル
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <msub>
                  <mi>a</mi>
                  <mn>1</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>a</mi>
                  <mn>2</mn>
                </msub>
                <mo>,</mo>
                <mi>.</mi>
                <mi>.</mi>
                <mi>.</mi>
                <msub>
                  <mi>a</mi>
                  <mi>n</mi>
                </msub>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a_1, a_2, ...a_n)</annotation>
            </semantics>
          </math>
          から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>要素が
          (重複を許容して) 選択される。
        </p>
        <p><img src="images/liftpower.png" style="width:50.0%" /></p>
        <p>たとえば、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>f</mi>
                  <mi>k</mi>
                </msub>
                <mo>∷</mo>
                <mn>1</mn>
                <mo>→</mo>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">f_k \Colon 1 \to n</annotation>
            </semantics>
          </math>を考えよう。これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>要素集合から第<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>k</mi>
              <annotation encoding="application/x-tex">k</annotation>
            </semantics>
          </math>番目の要素を選択したものだ。これをリフトしたものは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の要素を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>個含むタプルを取って第<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>k</mi>
              <annotation encoding="application/x-tex">k</annotation>
            </semantics>
          </math>番目の要素を返す関数となる。</p>
        <p>あるいは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>m</mi>
                <mo>→</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon m \to 1</annotation>
            </semantics>
          </math>を考えよう。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>要素すべてを1に写す定関数だ。リフトすると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>の要素を1つ取って<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>回複製する関数となる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>λ</mi>
                <mrow></mrow>
                <mi>x</mi>
                <mo>→</mo>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <munder>
                    <munder>
                      <mrow>
                        <mi>x</mi>
                        <mo>,</mo>
                        <mi>x</mi>
                        <mo>,</mo>
                        <mspace width="0.222em"></mspace>
                        <mi>.</mi>
                        <mi>.</mi>
                        <mi>.</mi>
                        <mspace width="0.222em"></mspace>
                        <mo>,</mo>
                        <mi>x</mi>
                      </mrow>
                      <mo accent="true">⏟</mo>
                    </munder>
                    <mi>m</mi>
                  </munder>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\lambda{}x \to (\underbrace{x, x,\ ...\ , x}_{m})</annotation>
            </semantics>
          </math></p>
        <p>いま扱っているプロ関手が2番目の引数について共変であることは、自明だとはすぐに言えないことに気付いたと思う。hom関手<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>m</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(m, 1)</annotation>
            </semantics>
          </math>
          なら確かに<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>について反変だ。しかし、いま扱っているコエンドは圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>ではなく圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>のものだ。このコエンドの変数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>は有限集合
          (あるいはそのスケルトン)
          に渡る。圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>の逆を含む。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>内の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>m</mi>
                <mo>→</mo>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">m \to n</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mi>m</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(n, m)</annotation>
            </semantics>
          </math>
          のメンバーだ
          (埋め込みは関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>I</mi>
                <mi>𝐋</mi>
              </msub>
              <annotation encoding="application/x-tex">I_{\mathbf{L}}</annotation>
            </semantics>
          </math>から得られる)。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>への関手としての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>m</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(m, 1)</annotation>
            </semantics>
          </math>
          について、関手性を確認しよう。関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>m</mi>
                <mo>→</mo>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon m \to n</annotation>
            </semantics>
          </math>をリフトしたいので、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>m</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(m, 1)</annotation>
            </semantics>
          </math>
          から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation>
            </semantics>
          </math>
          への関数を実装するのが目標になる。関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>に対応して、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内に<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>m</mi>
              <annotation encoding="application/x-tex">m</annotation>
            </semantics>
          </math>への射が存在する
          (方向に注意してほしい)。この射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>m</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(m, 1)</annotation>
            </semantics>
          </math>
          に前置合成すると<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation>
            </semantics>
          </math>
          の部分集合が得られる。</p>
        <p><img src="images/liftl.png" /></p>
        <p>関数<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>1</mn>
                <mo>→</mo>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">1 \to n</annotation>
            </semantics>
          </math>をリフトすれば<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>1</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(1, 1)</annotation>
            </semantics>
          </math>
          から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation>
            </semantics>
          </math>
          に移れることに注目してほしい。この事実は後で使う。</p>
        <p>反変関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>a</mi>
                <mi>n</mi>
              </msup>
              <annotation encoding="application/x-tex">a^n</annotation>
            </semantics>
          </math>と共変関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>m</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(m, 1)</annotation>
            </semantics>
          </math>
          の積はプロ関手<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>𝐅</mi>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑝</mi>
                  </mrow>
                </msup>
                <mo>×</mo>
                <mi>𝐅</mi>
                <mo>→</mo>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}\times \mathbf{F} \to \mathbf{Set}
              </annotation>
            </semantics>
          </math>だ。コエンドをプロ関手の対角要素すべての余積
          (非交和)として定義できることを思い出してほしい。それらの対角要素のうちいくつかは同一視できる。この同一視は余くさび条件に対応している。</p>
        <p>ここで、コエンドはすべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>に渡る集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
                <mo>×</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">a^n \times \mathbf{L}(n, 1)</annotation>
            </semantics>
          </math>
          の非交和として始まる。同一視は<a href="#ends-and-coends">コエンドをコイコライザとして</a>表現することで生成できる。ある非対角項<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
                <mo>×</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>m</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">a^n \times \mathbf{L}(m, 1)</annotation>
            </semantics>
          </math>
          から始めよう。対角項を得るには、射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>m</mi>
                <mo>→</mo>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon m \to n</annotation>
            </semantics>
          </math>を積の1番目か2番目のコンポーネントに適用すればよい。そして2つの結果は同一視される。</p>
        <p><img src="images/equalize1.png" /></p>
        <p>前に示したように、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mn>1</mn>
                <mo>→</mo>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon 1 \to n</annotation>
            </semantics>
          </math>をリフトすると以下の2つの変換が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
                <mo>→</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">a^n \to a</annotation>
            </semantics>
          </math></p>
        <p>および:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>1</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>→</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(1, 1) \to \mathbf{L}(n, 1)</annotation>
            </semantics>
          </math></p>
        <p>したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
                <mo>×</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>1</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">a^n \times \mathbf{L}(1, 1)</annotation>
            </semantics>
          </math>
          から始めて、以下の両方に到達できる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>×</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>1</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">a \times \mathbf{L}(1, 1)</annotation>
            </semantics>
          </math></p>
        <p>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">⟨</mo>
                <mi>f</mi>
                <mo>,</mo>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mo stretchy="false" form="postfix">⟩</mo>
              </mrow>
              <annotation encoding="application/x-tex">\langle f, \mathbf{id}\rangle</annotation>
            </semantics>
          </math>をリフトして得られ、また:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
                <mo>×</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">a^n \times \mathbf{L}(n, 1)</annotation>
            </semantics>
          </math></p>
        <p>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="false" form="prefix">⟨</mo>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mo>,</mo>
                <mi>f</mi>
                <mo stretchy="false" form="postfix">⟩</mo>
              </mrow>
              <annotation encoding="application/x-tex">\langle \mathbf{id}, f \rangle</annotation>
            </semantics>
          </math>をリフトして得られる。しかし、これは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
                <mo>×</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">a^n \times \mathbf{L}(n, 1)</annotation>
            </semantics>
          </math>
          の要素すべてが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>×</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>1</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">a \times \mathbf{L}(1, 1)</annotation>
            </semantics>
          </math>
          と同一視できるという意味ではない。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation>
            </semantics>
          </math>
          の要素すべてが<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>1</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(1, 1)</annotation>
            </semantics>
          </math>
          から到達できるわけではないからだ。リフトできるのは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>からの射だけなのを思い出してほしい。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐋</mi>
              <annotation encoding="application/x-tex">\mathbf{L}</annotation>
            </semantics>
          </math>内の非自明な<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>n</mi>
              <annotation encoding="application/x-tex">n</annotation>
            </semantics>
          </math>項演算は射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mn>1</mn>
                <mo>→</mo>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon 1 \to n</annotation>
            </semantics>
          </math>をリフトしても構築できない。</p>
        <p>言い換えると、同一視できるのは、基本射 (basic morphism)
          を適用することによって<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>1</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(1, 1)</annotation>
            </semantics>
          </math>
          から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation>
            </semantics>
          </math>
          に到達できるようなコエンド式のすべての加数だけだ。これらはすべて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>a</mi>
                <mo>×</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>1</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">a \times \mathbf{L}(1, 1)</annotation>
            </semantics>
          </math>
          と同値だ。基本射は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>内の射の像だ。</p>
        <p>ローヴェア・セオリーの最も単純なケースである<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐅</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation>
            </semantics>
          </math>自体で、これがどのように機能するかを見てみよう。そのようなセオリーでは、すべての<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation>
            </semantics>
          </math>
          が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>1</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(1, 1)</annotation>
            </semantics>
          </math>
          から到達できる。なぜなら、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>1</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(1, 1)</annotation>
            </semantics>
          </math>
          は恒等射だけを含む単元圏であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation>
            </semantics>
          </math>
          は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐅</mi>
              <annotation encoding="application/x-tex">\mathbf{F}</annotation>
            </semantics>
          </math>内の単射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>1</mn>
                <mo>→</mo>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">1 \to n</annotation>
            </semantics>
          </math>に対応する<em>基本射</em>だけを含むからだ。したがって、余積に含まれる加数はすべて同値なので次が得られる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>=</mo>
                <mi>a</mi>
                <mo>×</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>1</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>=</mo>
                <mi>a</mi>
              </mrow>
              <annotation encoding="application/x-tex">T\ a = a \times \mathbf{L}(1, 1) = a</annotation>
            </semantics>
          </math></p>
        <p>これは恒等モナドだ。</p>
        <h2 data-number="30.7" id="副作用のローヴェアセオリー"><span class="header-section-number">30.7</span>
          副作用のローヴェア・セオリー</h2>
        <p>
          モナドとローヴェア・セオリーは非常に強く関連しているので、プログラミングでローヴェア・セオリーをモナドの代わりとして使えるかを問うのは自然なことだ。モナドの大きな問題点は合成しにくいことだ。モナドトランスフォーマーを作るための汎用のレシピはない。その面でローヴェア・セオリーは有利で、余積とテンソル積を使って合成できる。一方、有限的モナド以外はローヴェア・セオリーに容易に変換できない。ここでの例外は継続モナドだ。この分野での研究が進んでいる
          (参考文献を参照のこと)。</p>
        <p>ローヴェア・セオリーが副作用の記述にどう使えるか説明するため、単純な例として、例外について説明する。例外は伝統的には<code>Maybe</code>モナドで実装される。</p>
        <p><code>Maybe</code>モナドは零項演算<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>0</mn>
                <mo>→</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">0 \to 1</annotation>
            </semantics>
          </math>だけを伴うローヴェア・セオリーによって生成される。このセオリーのモデルは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>をある集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>に写し、零項演算を次の関数に写す関手だ:</p>
        <div class="sourceCode" id="cb595">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb595-1"><a href="#cb595-1" aria-hidden="true" tabindex="-1"></a><span class="ot">    raise ::</span> () <span class="ot">-&gt;</span> a</span></code></pre>
        </div>
        <p><code>Maybe</code>モナドはコエンド式を使って復元できる。零項演算を追加すると、hom集合<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation>
            </semantics>
          </math>
          にどんな影響があるか検討してみよう。新しく
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msup>
                <mi>𝐅</mi>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑝</mi>
                </mrow>
              </msup>
              <annotation encoding="application/x-tex">\mathbf{F}^\mathit{op}</annotation>
            </semantics>
          </math>にはない)
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>0</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(0, 1)</annotation>
            </semantics>
          </math>
          が作られる以外にも、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>n</mi>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{L}(n, 1)</annotation>
            </semantics>
          </math>
          に新しい射が追加される。これらは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>n</mi>
                <mo>→</mo>
                <mn>0</mn>
              </mrow>
              <annotation encoding="application/x-tex">n \to 0</annotation>
            </semantics>
          </math>の型の射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>0</mn>
                <mo>→</mo>
                <mn>1</mn>
              </mrow>
              <annotation encoding="application/x-tex">0 \to 1</annotation>
            </semantics>
          </math>と合成した結果だ。このような寄与はすべて、コエンド式では<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>a</mi>
                  <mn>0</mn>
                </msup>
                <mo>×</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>0</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">a^0 \times \mathbf{L}(0, 1)</annotation>
            </semantics>
          </math>
          と同一視される。それらを得るには:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msup>
                  <mi>a</mi>
                  <mi>n</mi>
                </msup>
                <mo>×</mo>
                <mi>𝐋</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mn>0</mn>
                  <mo>,</mo>
                  <mn>1</mn>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">a^n \times \mathbf{L}(0, 1)</annotation>
            </semantics>
          </math></p>
        <p>をもとに<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mn>0</mn>
                <mo>→</mo>
                <mi>n</mi>
              </mrow>
              <annotation encoding="application/x-tex">0 \to n</annotation>
            </semantics>
          </math>を2種類の方法でリフトすればよいからだ。</p>
        <p><img src="images/equalize2.png" /></p>
        <p>このコエンドの縮約は:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <msub>
                  <mi>T</mi>
                  <mi>𝐋</mi>
                </msub>
                <mspace width="0.222em"></mspace>
                <mi>a</mi>
                <mo>=</mo>
                <msup>
                  <mi>a</mi>
                  <mn>0</mn>
                </msup>
                <mo>+</mo>
                <msup>
                  <mi>a</mi>
                  <mn>1</mn>
                </msup>
              </mrow>
              <annotation encoding="application/x-tex">T_{\mathbf{L}}\ a = a^0 + a^1</annotation>
            </semantics>
          </math></p>
        <p>あるいは、Haskellの記法では:</p>
        <div class="sourceCode" id="cb596">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb596-1"><a href="#cb596-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">type</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Either</span> () a</span></code></pre>
        </div>
        <p>となり、次と等価だ:</p>
        <div class="sourceCode" id="cb597">
          <pre
            class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb597-1"><a href="#cb597-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre>
        </div>
        <p>このローヴェア・セオリーは例外の送出のみをサポートしており、例外の処理はサポートしていないことに注意してほしい。</p>
        <h2 data-number="30.8" id="課題-21"><span class="header-section-number">30.8</span> 課題</h2>
        <ol type="1">
          <li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>𝐅</mi>
                <annotation encoding="application/x-tex">\mathbf{F}</annotation>
              </semantics>
            </math>
            (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>𝐅</mi>
                  <mi>𝐢</mi>
                  <mi>𝐧</mi>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <annotation encoding="application/x-tex">\mathbf{FinSet}</annotation>
              </semantics>
            </math>のスケルトン)
            内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mn>2</mn>
                <annotation encoding="application/x-tex">2</annotation>
              </semantics>
            </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mn>3</mn>
                <annotation encoding="application/x-tex">3</annotation>
              </semantics>
            </math>へのすべての射を列挙せよ。</li>
          <li>モノイドのローヴェア・セオリーについてのモデルの圏が、リストモナドについてのモナド代数の圏と同値であることを示せ。</li>
          <li>モノイドのローヴェア・セオリーはリストモナドを生成する。その二項演算は、対応するKleisli矢を使って生成できることを示せ。</li>
          <li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mtext mathvariant="bold">𝐅𝐢𝐧𝐒𝐞𝐭</mtext>
                <annotation encoding="application/x-tex">\textbf{FinSet}</annotation>
              </semantics>
            </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
              </semantics>
            </math>の部分圏であり、それを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
              </semantics>
            </math>に埋め込む関手が存在する。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
              </semantics>
            </math>の関手はすべて<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>𝐅</mi>
                  <mi>𝐢</mi>
                  <mi>𝐧</mi>
                  <mi>𝐒</mi>
                  <mi>𝐞</mi>
                  <mi>𝐭</mi>
                </mrow>
                <annotation encoding="application/x-tex">\mathbf{FinSet}</annotation>
              </semantics>
            </math>に制約できる。有限的関手がそれ自身の制限の左Kan拡張であることを示せ。</li>
        </ol>
        <h2 data-number="30.9" id="参考文献-5"><span class="header-section-number">30.9</span> 参考文献</h2>
        <ol type="1">
          <li><a href="http://www.tac.mta.ca/tac/reprints/articles/5/tr5.pdf">Functorial
              Semantics of Algebraic Theories</a>, F. William Lawvere</li>
          <li><a href="http://homepages.inf.ed.ac.uk/gdp/publications/Comp_Eff_Monads.pdf">Notions
              of computation determine monads</a>, Gordon Plotkin and John Power</li>
        </ol>
        <h1 data-number="31" id="モナドモノイド圏"><span class="header-section-number">31</span> モナド・モノイド・圏</h1>
        <p>
          区切り良く圏論の本を終わらせることはできない。学ぶべきことは常にある。圏論は広大な題材だ。それと同時に、同じテーマ・コンセプト・パターンが明らかに何度も繰り返されている。すべての概念はKan拡張である、という格言があるとおり、Kan拡張を使えば極限・余極限・モナド・米田の補題などを導出できる。圏自体の概念は抽象化のあらゆるレベルに現れる。モノイドとモナドの概念も同様だ。最も基本となるものはどれだろうか？
          結局のところ、それらはすべて相互に関連しており、抽象化の終わりのないサイクルで互いにつながっている。それらの相互関係を示すことが、この本を締めくくるのにふさわしいと判断した。</p>
        <h2 data-number="31.1" id="双圏"><span class="header-section-number">31.1</span> 双圏</h2>
        <p>
          圏論で特に難しい側面の1つは、絶えず視点が切り替わることだ。たとえば、集合の圏を考えてみてほしい。我々は要素によって集合を定義することに慣れている。空集合には要素がない。単集合には要素が1つある。2つの集合のカルテシアン積はペアの集合であり、以下同様だ。しかし、<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>圏について述べるときにお願いしたのは、集合の内容を忘れて、代わりにそれらの間の射
          (矢)
          に集中することだった。時々、カバーの下を覗くことが許されたのは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内の特定の普遍的構成が要素の観点で何を記述しているか知るためだった。そうして、終対象は1つの要素からなる集合であることなどが分かった。しかし、それらは健全性確認にすぎなかった。</p>
        <p>関手は圏の写像として定義される。写像を圏内の射と見なすのは自然だ。関手は、圏
          (サイズに関する問題を避けたいなら、小さい圏)
          の圏の射だと分かった。関手を矢として扱うと、圏の内部 (その対象と射)
          に対するその作用についての情報を失うことになる。これは、集合の要素に対する関数の作用についての情報が、その関数を<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐞</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Set}</annotation>
            </semantics>
          </math>内の矢として扱うと失われるのと同じだ。しかし、任意の2つの圏の間の関手も圏を形成する。今度は、ある圏の矢であったものを別の圏の対象と見なすことが求められる。関手圏では関手が対象であり、自然変換が射だ。同一のものが、ある圏では矢であり、別の圏では対象であり得ることが発見された。対象を名詞とし矢を動詞とする素朴な考え方は成り立たない。
        </p>
        <p>2つの観点を切り替える代わりに、1つの観点に統合しようとすることもできる。そうすることで<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏の概念が得られる。この圏では、対象を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>-セル、射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セル、射間の射を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セルと呼ぶ。</p>
        <figure>
          <img src="images/twocat.png" style="width:35.0%" alt="0-セルa, b、1-セルf, g、および2-セル\alpha。" />
          <figcaption aria-hidden="true"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mn>0</mn>
                <annotation encoding="application/x-tex">0</annotation>
              </semantics>
            </math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                </mrow>
                <annotation encoding="application/x-tex">a, b</annotation>
              </semantics>
            </math>、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mn>1</mn>
                <annotation encoding="application/x-tex">1</annotation>
              </semantics>
            </math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>f</mi>
                  <mo>,</mo>
                  <mi>g</mi>
                </mrow>
                <annotation encoding="application/x-tex">f, g</annotation>
              </semantics>
            </math>、および<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mn>2</mn>
                <annotation encoding="application/x-tex">2</annotation>
              </semantics>
            </math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>α</mi>
                <annotation encoding="application/x-tex">\alpha</annotation>
              </semantics>
            </math>。</figcaption>
        </figure>
        <p>圏の圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>は端的な例だ。圏が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>-セル、関手が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セル、自然変換が<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セルとなる。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏の規則が示すのは、任意の2つの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>-セル間の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルが圏を形成する
          (言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>b</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, b)</annotation>
            </semantics>
          </math>
          はhom集合ではなくhom圏だ)
          ということだ。このことは、任意の2つの圏の間の関手は関手圏を形成する、という以前の主張とよく一致している。</p>
        <p>特に、任意の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>-セルからそれ自体に戻る<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルも圏
          (hom圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>)
          を形成するが、その圏はさらに豊かな構造を持っている。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          のメンバーは<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>内の矢または<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          内の対象と見なせる。これらは矢なので互いに合成できる。しかし、それらを対象として見ると、合成は対象の1つのペアから1つの対象への写像になる。それは実際に、積に――正確にはテンソル積に――非常によく似ている。このテンソル積は恒等<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルという単位を持つ。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏では、hom圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          は自動的にモノイダル圏になり、そのテンソル積は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルの合成として定義される。結合則と単位元則は、対応する圏の規則から単に除かれる。</p>
        <p>これが何を意味するのかを、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏の標準的な例である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>で見てみよう。hom圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝐂</mi>
                  <mi>𝐚</mi>
                  <mi>𝐭</mi>
                </mrow>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}(a, a)</annotation>
            </semantics>
          </math>
          は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>上の自己関手の圏だ。その中では、自己関手の合成がテンソル積の役目を果たしている。恒等関手はこの積の単位だ。自己関手がモノイダル圏を形成することは以前にも見た
          (その事実をモナドの定義で使った)
          ものの、これはもっと一般的な現象だと分かる。つまり、すべての<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏内の自己-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルはモノイダル圏を形成する。これについては、後でモナドを一般化するときに再度説明する。</p>
        <p>覚えているだろうが、一般のモノイダル圏では、モノイダル則がきちんと満たされていることは主張しなかった。多くの場合、単位元則と結合則が同型を除いて満たされていれば十分だった。<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>-圏では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          のモノイダル則は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルの合成則から導かれる。これらの規則は厳密なので、厳密なモノイダル圏が常に得られる。しかし、これらの規則は緩和することもできる。たとえば、恒等<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mrow>
                  <mi>𝐢</mi>
                  <mi>𝐝</mi>
                </mrow>
                <mi>a</mi>
              </msub>
              <annotation encoding="application/x-tex">%
                \mathbf{id}_{a}%
              </annotation>
            </semantics>
          </math>と別の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mo>∷</mo>
                <mi>a</mi>
                <mo>→</mo>
                <mi>b</mi>
              </mrow>
              <annotation encoding="application/x-tex">f \Colon a \to b</annotation>
            </semantics>
          </math>の合成は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>f</mi>
              <annotation encoding="application/x-tex">f</annotation>
            </semantics>
          </math>と等しいのではなく、同型であると言える。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルの同型は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セルを使って定義される。言い換えると、次のような<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セル:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>ρ</mi>
                <mo>∷</mo>
                <mi>f</mi>
                <mo>∘</mo>
                <msub>
                  <mrow>
                    <mi>𝐢</mi>
                    <mi>𝐝</mi>
                  </mrow>
                  <mi>a</mi>
                </msub>
                <mo>→</mo>
                <mi>f</mi>
              </mrow>
              <annotation encoding="application/x-tex">\rho \Colon f \circ %
                \mathbf{id}_{a}%
                \to f</annotation>
            </semantics>
          </math></p>
        <p>と、その逆が存在する。</p>
        <figure>
          <img src="images/bicat.png" style="width:35.0%" alt="双圏の恒等則は同型 (可逆な2-セル\rho) を除いて成り立つ。" />
          <figcaption aria-hidden="true">双圏の恒等則は同型
            (可逆な<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mn>2</mn>
                <annotation encoding="application/x-tex">2</annotation>
              </semantics>
            </math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mi>ρ</mi>
                <annotation encoding="application/x-tex">\rho</annotation>
              </semantics>
            </math>)
            を除いて成り立つ。</figcaption>
        </figure>
        <p>左恒等射と結合則についても同じことができる。このような緩和された<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>𝟐</mn>
              <annotation encoding="application/x-tex">\mathbf{2}</annotation>
            </semantics>
          </math>圏は、双圏
          (bicategory) と呼ばれる
          (いくつか追加のコヒーレンシーの規則があるが、ここでは省略する)。</p>
        <p>予想どおり、双圏での自己-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルは、規則が厳密でない一般化されたモノイダル圏を形成する。</p>
        <p>双圏の興味深い例としてスパン (span)
          の圏が挙げられる。2つの対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>b</mi>
              <annotation encoding="application/x-tex">b</annotation>
            </semantics>
          </math>の間のスパンは、対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>x</mi>
              <annotation encoding="application/x-tex">x</annotation>
            </semantics>
          </math>および次の1対の射だ:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>f</mi>
                    <mo>∷</mo>
                    <mi>x</mi>
                    <mo>→</mo>
                    <mi>a</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>g</mi>
                    <mo>∷</mo>
                    <mi>x</mi>
                    <mo>→</mo>
                    <mi>b</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                f \Colon x \to a \\
                g \Colon x \to b
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p><img src="images/span.png" style="width:35.0%" /></p>
        <p>圏論的な積の定義でスパンを使ったことを覚えているだろう。ここでは、スパンを双圏での<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルと見なそう。最初のステップは、スパンの合成を定義することだ。隣接したスパンがあるとする:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>f</mi>
                    <mi>′</mi>
                    <mo>∷</mo>
                    <mi>y</mi>
                    <mo>→</mo>
                    <mi>b</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>g</mi>
                    <mi>′</mi>
                    <mo>∷</mo>
                    <mi>y</mi>
                    <mo>→</mo>
                    <mi>c</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                f&#39; \Colon y \to b \\
                g&#39; \Colon y \to c
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p><img src="images/compspan.png" style="width:50.0%" /></p>
        <p>それらの合成は第3のスパンになり、ある<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>を頂点とする。最も自然な選択は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>f</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">f&#39;</annotation>
            </semantics>
          </math>に沿った<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>g</mi>
              <annotation encoding="application/x-tex">g</annotation>
            </semantics>
          </math>の引き戻しだ。引き戻しとは次の2つの射を伴う対象<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>z</mi>
              <annotation encoding="application/x-tex">z</annotation>
            </semantics>
          </math>であることを思い出してほしい:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>h</mi>
                    <mo>∷</mo>
                    <mi>z</mi>
                    <mo>→</mo>
                    <mi>x</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>h</mi>
                    <mi>′</mi>
                    <mo>∷</mo>
                    <mi>z</mi>
                    <mo>→</mo>
                    <mi>y</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                h \Colon z \to x \\
                h&#39; \Colon z \to y
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>ただし:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mo>∘</mo>
                <mi>h</mi>
                <mo>=</mo>
                <mi>f</mi>
                <mi>′</mi>
                <mo>∘</mo>
                <mi>h</mi>
                <mi>′</mi>
              </mrow>
              <annotation encoding="application/x-tex">g \circ h = f&#39; \circ h&#39;</annotation>
            </semantics>
          </math></p>
        <p>が、このような対象すべてについて普遍とする。</p>
        <p><img src="images/pullspan.png" style="width:35.0%" /></p>
        <p>ここでは、集合の圏でのスパンに注目しよう。この場合、引き戻しはカルテシアン積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>x</mi>
                <mo>×</mo>
                <mi>y</mi>
              </mrow>
              <annotation encoding="application/x-tex">x \times y</annotation>
            </semantics>
          </math>からのペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <mi>p</mi>
                <mo>,</mo>
                <mi>q</mi>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(p, q)</annotation>
            </semantics>
          </math>
          の集合にすぎず、次のようになる:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>g</mi>
                <mspace width="0.222em"></mspace>
                <mi>p</mi>
                <mo>=</mo>
                <mi>f</mi>
                <mi>′</mi>
                <mspace width="0.222em"></mspace>
                <mi>q</mi>
              </mrow>
              <annotation encoding="application/x-tex">g\ p = f&#39;\ q</annotation>
            </semantics>
          </math></p>
        <p>同じ終点を共有する2つのスパンの間の射は頂点間の射<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>h</mi>
              <annotation encoding="application/x-tex">h</annotation>
            </semantics>
          </math>として定義され、適切な三角形を可換にする。</p>
        <figure>
          <img src="images/morphspan.png" style="width:35.0%" alt="\mathbf{Span}内の2-セル。" />
          <figcaption aria-hidden="true"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐩</mi>
                  <mi>𝐚</mi>
                  <mi>𝐧</mi>
                </mrow>
                <annotation encoding="application/x-tex">\mathbf{Span}</annotation>
              </semantics>
            </math>内の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mn>2</mn>
                <annotation encoding="application/x-tex">2</annotation>
              </semantics>
            </math>-セル。</figcaption>
        </figure>
        <p>要約すると、双圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐩</mi>
                <mi>𝐚</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Span}</annotation>
            </semantics>
          </math>では、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>-セルは集合、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルはスパン、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セルはスパンの射だ。恒等<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルは、3つの対象すべてが同じで、2つの射が恒等射である退化スパン
          (degenerate span) だ。</p>
        <p>双圏の別の例もすでに見た。それは<a href="#ends-and-coends">プロ関手</a>の双圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐏</mi>
                <mi>𝐫</mi>
                <mi>𝐨</mi>
                <mi>𝐟</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Prof}</annotation>
            </semantics>
          </math>であり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>-セルは圏、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルはプロ関手、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セルは自然変換だ。プロ関手の合成はコエンドによって与えられる。</p>
        <h2 data-number="31.2" id="モナド"><span class="header-section-number">31.2</span> モナド</h2>
        <p>ここまでで、自己関手の圏におけるモノイドとしてのモナドの定義にかなり精通しているはずだ。自己関手の圏は双圏<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>内の自己-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルの1つの小さいhom圏にすぎない、という新たな理解に沿って、この定義を再検討してみよう。それがモノイダル圏であることは知っており、テンソル積は自己関手の合成に由来する。モノイドは、モノイダル圏内のある対象――ここでは自己関手<math
            display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>――と2つの射として定義される。自己関手の間の射は自然変換だ。一方の射はモノイダル単位――恒等自己関手――を<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>に写す:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>η</mi>
                <mo>∷</mo>
                <mi>I</mi>
                <mo>→</mo>
                <mi>T</mi>
              </mrow>
              <annotation encoding="application/x-tex">\eta \Colon I \to T</annotation>
            </semantics>
          </math></p>
        <p>もう一方の射はテンソル積<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>T</mi>
                <mo>⊗</mo>
                <mi>T</mi>
              </mrow>
              <annotation encoding="application/x-tex">T \otimes T</annotation>
            </semantics>
          </math>を<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>に写す。このテンソル積は自己関手の合成によって得られるため、次のようになる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>μ</mi>
                <mo>∷</mo>
                <mi>T</mi>
                <mo>∘</mo>
                <mi>T</mi>
                <mo>→</mo>
                <mi>T</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mu \Colon T \circ T \to T</annotation>
            </semantics>
          </math></p>
        <p><img src="images/monad.png" /></p>
        <p>これらがモナドを定義する2つの操作である
          (Haskellでは<code>return</code>および<code>join</code>と呼ばれる)
          ことと、モノイド則がモナド則に変わったことが分かる。</p>
        <p>さて、この定義から自己関手に関する記述をすべて取り除こう。まず双圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>𝐂</mi>
              <annotation encoding="application/x-tex">\mathbf{C}</annotation>
            </semantics>
          </math>から始めて、その中で<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>a</mi>
              <annotation encoding="application/x-tex">a</annotation>
            </semantics>
          </math>を選ぶ。すでに説明したように、hom圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          はモノイダル圏だ。したがって、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>a</mi>
                  <mo>,</mo>
                  <mi>a</mi>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{C}(a, a)</annotation>
            </semantics>
          </math>
          のモノイドは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セル、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>T</mi>
              <annotation encoding="application/x-tex">T</annotation>
            </semantics>
          </math>、および2つの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セルを、条件:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>η</mi>
                    <mo>∷</mo>
                    <mi>I</mi>
                    <mo>→</mo>
                    <mi>T</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mi>μ</mi>
                    <mo>∷</mo>
                    <mi>T</mi>
                    <mo>∘</mo>
                    <mi>T</mi>
                    <mo>→</mo>
                    <mi>T</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                \eta \Colon I \to T \\
                \mu \Colon T \circ T \to T
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p>がモノイド則を満たすように選ぶことで定義できる。<em>これ</em>をモナドと呼ぶ。</p>
        <p><img src="images/bimonad.png" style="width:30.0%" /></p>
        <p>これは、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>-セルと<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セルと<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セルだけを使って、より一般的にモナドを定義する。これは、双圏<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐂</mi>
                <mi>𝐚</mi>
                <mi>𝐭</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Cat}</annotation>
            </semantics>
          </math>に適用すると、通常のモナドに縮約される。だが、他の双圏では何が起こるか見てみよう。</p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐒</mi>
                <mi>𝐩</mi>
                <mi>𝐚</mi>
                <mi>𝐧</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathbf{Span}</annotation>
            </semantics>
          </math>でモナドを構築しよう。集合である<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>0</mn>
              <annotation encoding="application/x-tex">0</annotation>
            </semantics>
          </math>-セルをここでは選択する。すぐに明らかになる理由から、これを<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑂</mi>
                <mi>𝑏</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ob}</annotation>
            </semantics>
          </math>と呼ぶことにする。次に、自己-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>1</mn>
              <annotation encoding="application/x-tex">1</annotation>
            </semantics>
          </math>-セル
          (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑂</mi>
                <mi>𝑏</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ob}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑂</mi>
                <mi>𝑏</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ob}</annotation>
            </semantics>
          </math>へ戻るスパン)
          を選択する。その頂点には<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐴</mi>
                <mi>𝑟</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ar}</annotation>
            </semantics>
          </math>と呼ばれる集合があり、次の2つの関数を伴う:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mrow>
                      <mi>𝑑</mi>
                      <mi>𝑜</mi>
                      <mi>𝑚</mi>
                    </mrow>
                    <mo>∷</mo>
                    <mrow>
                      <mi>𝐴</mi>
                      <mi>𝑟</mi>
                    </mrow>
                    <mo>→</mo>
                    <mrow>
                      <mi>𝑂</mi>
                      <mi>𝑏</mi>
                    </mrow>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mrow>
                      <mi>𝑐</mi>
                      <mi>𝑜</mi>
                      <mi>𝑑</mi>
                    </mrow>
                    <mo>∷</mo>
                    <mrow>
                      <mi>𝐴</mi>
                      <mi>𝑟</mi>
                    </mrow>
                    <mo>→</mo>
                    <mrow>
                      <mi>𝑂</mi>
                      <mi>𝑏</mi>
                    </mrow>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                \mathit{dom} \Colon \mathit{Ar} \to \mathit{Ob} \\
                \mathit{cod} \Colon \mathit{Ar} \to \mathit{Ob}
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p><img src="images/spanmonad.png" style="width:30.0%" /></p>
        <p>集合<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐴</mi>
                <mi>𝑟</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ar}</annotation>
            </semantics>
          </math>の要素を「矢」と呼ぼう。さらに、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑂</mi>
                <mi>𝑏</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ob}</annotation>
            </semantics>
          </math>の要素を「対象」と呼ぼう、と言えば、目的地の手掛かりになるだろう。2つの関数<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑑</mi>
                <mi>𝑜</mi>
                <mi>𝑚</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{dom}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑐</mi>
                <mi>𝑜</mi>
                <mi>𝑑</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{cod}</annotation>
            </semantics>
          </math>は、始域と終域を「矢」に割り当てる。</p>
        <p>スパンをモナドにするには2つの<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>が必要だ。この場合のモノイダル単位は、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑂</mi>
                <mi>𝑏</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ob}</annotation>
            </semantics>
          </math>から<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑂</mi>
                <mi>𝑏</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ob}</annotation>
            </semantics>
          </math>への自明なスパンであり、頂点は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑂</mi>
                <mi>𝑏</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ob}</annotation>
            </semantics>
          </math>で、2つの恒等関数を伴う。<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>は2つの頂点<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑂</mi>
                <mi>𝑏</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ob}</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐴</mi>
                <mi>𝑟</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ar}</annotation>
            </semantics>
          </math>の間の関数だ。つまり、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>は「矢」をすべての「対象」に割り当てる。<strong>Span</strong>の<math display="inline"
            xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セルは可換条件を満たす必要がある。ここでは次のようになる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mtable>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mrow>
                      <mi>𝑑</mi>
                      <mi>𝑜</mi>
                      <mi>𝑚</mi>
                    </mrow>
                    <mo>∘</mo>
                    <mi>η</mi>
                    <mo>=</mo>
                    <mi>i</mi>
                    <mi>d</mi>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd columnalign="center" style="text-align: center">
                    <mrow>
                      <mi>𝑐</mi>
                      <mi>𝑜</mi>
                      <mi>𝑑</mi>
                    </mrow>
                    <mo>∘</mo>
                    <mi>η</mi>
                    <mo>=</mo>
                    <mi>i</mi>
                    <mi>d</mi>
                  </mtd>
                </mtr>
              </mtable>
              <annotation encoding="application/x-tex">
                \begin{gathered}
                \mathit{dom} \circ \eta = id \\
                \mathit{cod} \circ \eta = id
                \end{gathered}
              </annotation>
            </semantics>
          </math></p>
        <p><img src="images/spanunit.png" style="width:40.0%" /></p>
        <p>これは、コンポーネントでは次のようになる:</p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑑</mi>
                  <mi>𝑜</mi>
                  <mi>𝑚</mi>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>η</mi>
                  <mspace width="0.222em"></mspace>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑏</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
                <mo>=</mo>
                <mrow>
                  <mi>𝑜</mi>
                  <mi>𝑏</mi>
                </mrow>
                <mo>=</mo>
                <mrow>
                  <mi>𝑐</mi>
                  <mi>𝑜</mi>
                  <mi>𝑑</mi>
                </mrow>
                <mspace width="0.222em"></mspace>
                <mrow>
                  <mo stretchy="true" form="prefix">(</mo>
                  <mi>η</mi>
                  <mspace width="0.222em"></mspace>
                  <mrow>
                    <mi>𝑜</mi>
                    <mi>𝑏</mi>
                  </mrow>
                  <mo stretchy="true" form="postfix">)</mo>
                </mrow>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{dom}\ (\eta\ \mathit{ob}) = \mathit{ob} = \mathit{cod}\
                (\eta\ \mathit{ob})</annotation>
            </semantics>
          </math></p>
        <p>ここで、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑜</mi>
                <mi>𝑏</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{ob}</annotation>
            </semantics>
          </math>は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝑂</mi>
                <mi>𝑏</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ob}</annotation>
            </semantics>
          </math>内の「対象」だ。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>η</mi>
              <annotation encoding="application/x-tex">\eta</annotation>
            </semantics>
          </math>が割り当てるのは、すべての「対象」と、「始域」と「終域」がその「対象」であるような「矢」に対してだ。この特別な「矢」を「恒等射」と呼ぶ。</p>
        <p>2番目の<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>は、それ自体とスパン<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐴</mi>
                <mi>𝑟</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ar}</annotation>
            </semantics>
          </math>との合成に作用する。合成は引き戻しとして定義されているため、その要素は<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐴</mi>
                <mi>𝑟</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ar}</annotation>
            </semantics>
          </math>からの要素のペア――「矢」のペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <msub>
                  <mi>a</mi>
                  <mn>1</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>a</mi>
                  <mn>2</mn>
                </msub>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a_1, a_2)</annotation>
            </semantics>
          </math>
          だ。引き戻し条件は次のとおりだ:
        </p>
        <p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mrow>
                  <mi>𝑐</mi>
                  <mi>𝑜</mi>
                  <mi>𝑑</mi>
                </mrow>
                <mspace width="0.222em"></mspace>
                <msub>
                  <mi>a</mi>
                  <mn>1</mn>
                </msub>
                <mo>=</mo>
                <mrow>
                  <mi>𝑑</mi>
                  <mi>𝑜</mi>
                  <mi>𝑚</mi>
                </mrow>
                <mspace width="0.222em"></mspace>
                <msub>
                  <mi>a</mi>
                  <mn>2</mn>
                </msub>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{cod}\ a_1 = \mathit{dom}\ a_2</annotation>
            </semantics>
          </math></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>a</mi>
                <mn>2</mn>
              </msub>
              <annotation encoding="application/x-tex">a_2</annotation>
            </semantics>
          </math>と<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>a</mi>
                <mn>1</mn>
              </msub>
              <annotation encoding="application/x-tex">a_1</annotation>
            </semantics>
          </math>が「合成可能」だと言われるのは、一方の始域が他方の終域だからだ。</p>
        <p><img src="images/spanmul.png" style="width:50.0%" /></p>
        <p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mn>2</mn>
              <annotation encoding="application/x-tex">2</annotation>
            </semantics>
          </math>-セル<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>は、合成可能な矢のペア
          <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mo stretchy="true" form="prefix">(</mo>
                <msub>
                  <mi>a</mi>
                  <mn>1</mn>
                </msub>
                <mo>,</mo>
                <msub>
                  <mi>a</mi>
                  <mn>2</mn>
                </msub>
                <mo stretchy="true" form="postfix">)</mo>
              </mrow>
              <annotation encoding="application/x-tex">(a_1, a_2)</annotation>
            </semantics>
          </math>
          を、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mrow>
                <mi>𝐴</mi>
                <mi>𝑟</mi>
              </mrow>
              <annotation encoding="application/x-tex">\mathit{Ar}</annotation>
            </semantics>
          </math>からの単一の矢<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <msub>
                <mi>a</mi>
                <mn>3</mn>
              </msub>
              <annotation encoding="application/x-tex">a_3</annotation>
            </semantics>
          </math>に写す関数だ。言い換えると、<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
            <semantics>
              <mi>μ</mi>
              <annotation encoding="application/x-tex">\mu</annotation>
            </semantics>
          </math>は矢の合成を定義する。
        </p>
        <p>モナド則が矢の恒等則や結合則に対応していることは簡単に確認できる。以上で圏を定義できた
          (対象と矢が集合を形成する小さい圏であることは忘れないでほしい)。</p>
        <p>つまり、まとめると、圏はスパンの双圏におけるモナドにすぎない。</p>
        <p>
          この結果の驚くべき点は、圏がモナドやモノイドのような他の代数的構造と同じ基盤に置かれていることだ。圏であることは何も特別ではない。ただの2つの集合と4つの関数だ。実際には、対象ごとに個別の集合は必要ない。対象は恒等射と同一視できる
          (それらは1対1で対応している)
          からだ。つまり、実際にはただの集合といくつかの関数だ。圏論がすべての数学において中心的役割を担っていることを考えると、これは非常に謙虚な認識だ。</p>
        <h2 data-number="31.3" id="課題-22"><span class="header-section-number">31.3</span> 課題</h2>
        <ol type="1">
          <li>双圏における自己-<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mn>1</mn>
                <annotation encoding="application/x-tex">1</annotation>
              </semantics>
            </math>-セルの合成として定義されたテンソル積について、単位元則と結合則を導出せよ。</li>
          <li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐩</mi>
                  <mi>𝐚</mi>
                  <mi>𝐧</mi>
                </mrow>
                <annotation encoding="application/x-tex">\mathbf{Span}</annotation>
              </semantics>
            </math>内のモナドについて、モナド則が、結果の圏内での恒等射と結合則に対応していることを確認せよ。</li>
          <li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>𝐏</mi>
                  <mi>𝐫</mi>
                  <mi>𝐨</mi>
                  <mi>𝐟</mi>
                </mrow>
                <annotation encoding="application/x-tex">\mathbf{Prof}</annotation>
              </semantics>
            </math>内のモナドが、対象における恒等射の関手
            (identity-on-objects functor) であることを示せ。</li>
          <li><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML">
              <semantics>
                <mrow>
                  <mi>𝐒</mi>
                  <mi>𝐩</mi>
                  <mi>𝐚</mi>
                  <mi>𝐧</mi>
                </mrow>
                <annotation encoding="application/x-tex">\mathbf{Span}</annotation>
              </semantics>
            </math>内のモナドについてのモナド代数とは何か？</li>
        </ol>
        <h2 data-number="31.4" id="参考文献-6"><span class="header-section-number">31.4</span> 参考文献</h2>
        <ol type="1">
          <li><a
              href="https://graphicallinearalgebra.net/2017/04/16/a-monoid-is-a-category-a-category-is-a-monad-a-monad-is-a-monoid/">Paweł
              Sobocińskiのブログ</a></li>
        </ol>
        <h1 class="unnumbered" id="索引">索引</h1>
        <!-- -->
        <ul>
          <li><span epub:type="index-term"><a href="#basic_product_operations" epub:type="index-locator">basic product
                operations</a></span></li>
          <li><span epub:type="index-term"><a href="#extensional" epub:type="index-locator">extensional</a></span></li>
          <li><span epub:type="index-term"><a href="#factorizer" epub:type="index-locator">factorizer</a></span></li>
          <li>one way - <span epub:type="index-term"><a href="#one_way" epub:type="index-locator">a</a></span>, <span
              epub:type="index-term"><a href="#one_way2" epub:type="index-locator">b</a></span></li>
          <li><span epub:type="index-term"><a href="#one-to-one" epub:type="index-locator">one-to-one</a></span></li>
          <li><span epub:type="index-term"><a href="#point" epub:type="index-locator">points</a></span></li>
          <li>predicate – <span epub:type="index-term"><a href="#predicates" epub:type="index-locator">a</a></span>,
            <span epub:type="index-term"><a href="#predicate" epub:type="index-locator">b</a></span>
          </li>
          <li><span epub:type="index-term"><a href="#proof-relevant_relation" epub:type="index-locator">proof-relevant
                relation</a></span></li>
          <li><span epub:type="index-term"><a href="#total" epub:type="index-locator">total</a></span></li>
        </ul>
        <!-- 英数 -->
        <ul>
          <li><span epub:type="index-term"><a href="#hom-set" epub:type="index-locator">hom集合</a></span></li>
          <li><span epub:type="index-term"><a href="#lawvere_theory" epub:type="index-locator">Lawvere理論</a></span></li>
          <li><span epub:type="index-term"><a href="#modus_ponen" epub:type="index-locator">modus ponens</a></span></li>
          <li><span epub:type="index-term"><a href="#theorems_for_free" epub:type="index-locator">theorems for
                free</a></span></li>
          <li><span epub:type="index-term"><a href="#variant" epub:type="index-locator">variant</a></span></li>
          <li><span epub:type="index-term"><a href="#writer_monad" epub:type="index-locator">writerモナド</a></span></li>
        </ul>
        <!-- あ -->
        <ul>
          <li><span epub:type="index-term"><a href="#ad_hoc_polymorphism" epub:type="index-locator">アドホック多相</a></span>
          </li>
          <li><span epub:type="index-term"><a href="#arity" epub:type="index-locator">アリティ</a></span></li>
          <li>意味論
            <ul>
              <li><span epub:type="index-term"><a href="#operational_semantics"
                    epub:type="index-locator">操作的-</a></span></li>
              <li><span epub:type="index-term"><a href="#denotational_semantics"
                    epub:type="index-locator">表示的-</a></span></li>
            </ul>
          </li>
          <li><span epub:type="index-term"><a href="#instance" epub:type="index-locator">インスタンス</a></span></li>
          <li><span epub:type="index-term"><a href="#onto" epub:type="index-locator">上への</a></span></li>
          <li><span epub:type="index-term"><a href="#embedding" epub:type="index-locator">埋め込み</a></span></li>
        </ul>
        <!-- か -->
        <ul>
          <li><span epub:type="index-term"><a href="#type_inference" epub:type="index-locator">型推論</a></span></li>
          <li><span epub:type="index-term"><a href="#currying" epub:type="index-locator">カリー化</a></span></li>
          <li><span epub:type="index-term"><a href="#Cartesian_closed" epub:type="index-locator">カルテシアン閉</a></span></li>
          <li><span epub:type="index-term"><a href="#Cartesian_product" epub:type="index-locator">カルテシアン積</a></span>
          </li>
          <li><span epub:type="index-term"><a href="#ring" epub:type="index-locator">環</a></span></li>
          <li><span epub:type="index-term"><a href="#function_composition" epub:type="index-locator">関数合成</a></span>
          </li>
          <li><span epub:type="index-term"><a href="#function_application" epub:type="index-locator">関数適用</a></span>
          </li>
          <li>基底集合 - <span epub:type="index-term"><a href="#underlying" epub:type="index-locator">a</a></span>, <span
              epub:type="index-term"><a href="#underlying_set" epub:type="index-locator">b</a></span></li>
          <li><span epub:type="index-term"><a href="#wedge_condition" epub:type="index-locator">くさび条件</a></span></li>
          <li><span epub:type="index-term"><a href="#identity" epub:type="index-locator">恒等射</a></span></li>
          <li><span epub:type="index-term"><a href="#composable" epub:type="index-locator">合成可能</a></span></li>
          <li><span epub:type="index-term"><a href="#component" epub:type="index-locator">コンポーネント</a></span></li>
        </ul>
        <!-- さ -->
        <ul>
          <li><span epub:type="index-term"><a href="#endofunctors" epub:type="index-locator">自己関手</a></span></li>
          <li><span epub:type="index-term"><a href="#natural" epub:type="index-locator">自然</a></span></li>
          <li><span epub:type="index-term"><a href="#natural_isomorphism" epub:type="index-locator">自然同型</a></span></li>
          <li><span epub:type="index-term"><a href="#naturality_condition" epub:type="index-locator">naturality
                condition</a></span></li>
          <li><span epub:type="index-term"><a href="#naturally_isomorphic" epub:type="index-locator">naturally
                isomorphic</a></span></li>
          <li><span epub:type="index-term"><a href="#initial_algebra" epub:type="index-locator">始代数</a></span></li>
          <li><span epub:type="index-term"><a href="#morphism" epub:type="index-locator">射</a></span></li>
          <li>自由
            <ul>
              <li><span epub:type="index-term"><a href="#free_functor" epub:type="index-locator">-関手</a></span></li>
              <li><span epub:type="index-term"><a href="#free_category" epub:type="index-locator">-圏</a></span></li>
              <li><span epub:type="index-term"><a href="#free_monoid" epub:type="index-locator">-モノイド</a></span></li>
            </ul>
          </li>
          <li><span epub:type="index-term"><a href="#pure_function" epub:type="index-locator">純粋関数</a></span></li>
          <li>準同型 – <span epub:type="index-term"><a href="#homomorphisms" epub:type="index-locator">a</a></span>, <span
              epub:type="index-term"><a href="#homomorphism" epub:type="index-locator">b</a></span></li>
          <li><span epub:type="index-term"><a href="#single-sorted" epub:type="index-locator">シングルソート</a></span></li>
          <li><span epub:type="index-term"><a href="#horizontal_composition" epub:type="index-locator">水平合成</a></span>
          </li>
          <li>随伴
            <ul>
              <li><span epub:type="index-term"><a href="#left_adjoint" epub:type="index-locator">左-</a></span></li>
              <li><span epub:type="index-term"><a href="#right_adjoint" epub:type="index-locator">右-</a></span></li>
            </ul>
          </li>
          <li><span epub:type="index-term"><a href="#skeleton" epub:type="index-locator">スケルトン</a></span></li>
          <li><span epub:type="index-term"><a href="#linear_order" epub:type="index-locator">線形順序</a></span></li>
          <li><span epub:type="index-term"><a href="#surjective" epub:type="index-locator">全射</a></span></li>
          <li><span epub:type="index-term"><a href="#preorder" epub:type="index-locator">前順序</a></span></li>
          <li><span epub:type="index-term"><a href="#total_order" epub:type="index-locator">全順序</a></span></li>
          <li><span epub:type="index-term"><a href="#bicartesian_closed" epub:type="index-locator">双カルテシアン閉</a></span>
          </li>
          <li><span epub:type="index-term"><a href="#bifunctor" epub:type="index-locator">双関手</a></span></li>
          <li>双射 – <span epub:type="index-term"><a href="#bijections" epub:type="index-locator">a</a></span>, <span
              epub:type="index-term"><a href="#bijection" epub:type="index-locator">b</a></span></li>
          <li><span epub:type="index-term"><a href="#biclosed" epub:type="index-locator">双閉</a></span></li>
        </ul>
        <!-- た -->
        <ul>
          <li><span epub:type="index-term"><a href="#object" epub:type="index-locator">対象</a></span></li>
          <li><span epub:type="index-term"><a href="#symmetric" epub:type="index-locator">対称</a></span></li>
          <li><span epub:type="index-term"><a href="#injective" epub:type="index-locator">単射</a></span></li>
          <li><span epub:type="index-term"><a href="#chain" epub:type="index-locator">チェイン</a></span></li>
          <li><span epub:type="index-term"><a href="#template_template_parameter"
                epub:type="index-locator">テンプレートテンプレート仮引数</a></span></li>
          <li><span epub:type="index-term"><a href="#tensor_product" epub:type="index-locator">テンソル積</a></span></li>
          <li><span epub:type="index-term"><a href="#isomorphic" epub:type="index-locator">同型</a></span>
            <ul>
              <li><span epub:type="index-term"><a href="#isomorphism" epub:type="index-locator">-射</a></span></li>
              <li><span epub:type="index-term"><a href="#up_to_isomorphism" epub:type="index-locator">-を除いて</a></span>
              </li>
            </ul>
          </li>
          <li><span epub:type="index-term"><a href="#equality" epub:type="index-locator">equality</a></span></li>
          <li><span epub:type="index-term"><a href="#equational_reasoning" epub:type="index-locator">equational
                reasoning</a></span></li>
          <li><span epub:type="index-term"><a href="#equivalence" epub:type="index-locator">equivalence</a></span></li>
          <li><span epub:type="index-term"><a href="#equivalence_relation" epub:type="index-locator">equivalence
                relation</a></span></li>
          <li><span epub:type="index-term"><a href="#topos" epub:type="index-locator">トポス</a></span></li>
        </ul>
        <!-- な -->
        <ul>
          <li><span epub:type="index-term"><a href="#internal" epub:type="index-locator">内部</a></span></li>
        </ul>
        <!-- は -->
        <ul>
          <li><span epub:type="index-term"><a href="#parametric_polymorphism"
                epub:type="index-locator">パラメトリック多相</a></span></li>
          <li><span epub:type="index-term"><a href="#semiring" epub:type="index-locator">半環</a></span></li>
          <li><span epub:type="index-term"><a href="#partial_order" epub:type="index-locator">半順序</a></span></li>
          <li><span epub:type="index-term"><a href="#opposite_category" epub:type="index-locator">反対圏</a></span></li>
          <li><span epub:type="index-term"><a href="#contravariant" epub:type="index-locator">反変</a></span></li>
          <li><span epub:type="index-term"><a href="#evaluation" epub:type="index-locator">評価</a></span></li>
          <li><span epub:type="index-term"><a href="#representation" epub:type="index-locator">表現</a></span></li>
          <li>表現可能 – <span epub:type="index-term"><a href="#representable" epub:type="index-locator">a</a></span>, <span
              epub:type="index-term"><a href="#representable2" epub:type="index-locator">b</a></span>
            <ul>
              <li><span epub:type="index-term"><a href="#representable_presheaf"
                    epub:type="index-locator">-前層</a></span></li>
            </ul>
          </li>
          <li><span epub:type="index-term"><a href="#side_effect" epub:type="index-locator">副作用</a></span></li>
          <li><span epub:type="index-term"><a href="#fixed_point" epub:type="index-locator">不動点</a></span></li>
          <li><span epub:type="index-term"><a href="#universal_construction" epub:type="index-locator">普遍構成</a></span>
          </li>
          <li><span epub:type="index-term"><a href="#profunctor" epub:type="index-locator">プロ関手</a></span></li>
          <li><span epub:type="index-term"><a href="#contextual_computation" epub:type="index-locator">文脈付き計算</a></span>
          </li>
          <li><span epub:type="index-term"><a href="#exponential" epub:type="index-locator">冪乗</a></span></li>
          <li><span epub:type="index-term"><a href="#point-free" epub:type="index-locator">ポイントフリー</a></span></li>
          <li>忘却関手 – <span epub:type="index-term"><a href="#forgetful_functor" epub:type="index-locator">a</a></span>,
            <span epub:type="index-term"><a href="#forgetful_functor2" epub:type="index-locator">b</a></span>
          </li>
          <li><span epub:type="index-term"><a href="#enriched" epub:type="index-locator">enriched</a></span></li>
          <li><span epub:type="index-term"><a href="#enriched_functor" epub:type="index-locator">enriched
                functor</a></span></li>
          <li><span epub:type="index-term"><a href="#poset" epub:type="index-locator">ポセット</a></span></li>
          <li><span epub:type="index-term"><a href="#bottom" epub:type="index-locator">ボトム</a></span></li>
        </ul>
        <!-- ま -->
        <ul>
          <li><span epub:type="index-term"><a href="#monad" epub:type="index-locator">モナド</a></span></li>
          <li><span epub:type="index-term"><a href="#monoidal_category" epub:type="index-locator">モノイダル圏</a></span></li>
        </ul>
        <!-- や -->
        <ul>
          <li><span epub:type="index-term"><a href="#arrow" epub:type="index-locator">矢</a></span></li>
          <li><span epub:type="index-term"><a href="#coequalizer" epub:type="index-locator">余イコライザ</a></span></li>
          <li><span epub:type="index-term"><a href="#Yoneda_embedding" epub:type="index-locator">米田埋め込み</a></span></li>
        </ul>
        <!-- ら -->
        <ul>
          <li><span epub:type="index-term"><a href="#rig" epub:type="index-locator">リグ</a></span></li>
          <li><span epub:type="index-term"><a href="#lifted" epub:type="index-locator">lifted</a></span></li>
          <li><span epub:type="index-term"><a href="#record" epub:type="index-locator">レコード</a></span></li>
        </ul>
        <!-- わ -->
        <h1 class="unnumbered" id="謝辞">謝辞</h1>
        <p>私の計算と論理をチェックしてくれたEdward KmettとGershom
          Bazermanに感謝したい。誤りを訂正し、本書を改善してくれた大勢のボランティアに感謝している。</p>
        <p>Andrew Suttonには、自身とBjarne
          Stroustrupの最新の提案に沿ってC++のモノイドの概念コードを書き直してくれたことに感謝したい。</p>
        <p>Eric
          Nieblerには、草稿を読み、C++14の高度な機能を用いて型推論を進める<code>compose</code>の巧妙な実装を提供してくれたことに感謝している。昔ながらのテンプレート・マジックを使って型トレイトと同じことをしていたセクションをすべてカットできた。
          いい厄介払いだ！</p>
        <p>Gershom
          Bazermanには、有益なコメントのおかげで、いくつかの重要な点を明確にできたことにも感謝したい。</p>
        <h1 class="unnumbered" id="ライセンス">ライセンス</h1>
        <p>この作品は、クリエイティブ・コモンズの 表示 - 継承 4.0 国際
          ライセンスで提供されています。ライセンスの写しをご覧になるには、[http://creativecommons.org/licenses/by-sa/4.0/deed.ja]
          をご覧頂くか、Creative Commons, PO Box 1866, Mountain View, CA 94042,
          USA までお手紙をお送りください。</p>
      </div>
    </div>
  </div>
  <script src="https://vjs.zencdn.net/5.4.4/video.js"></script>

</body>

</html>
